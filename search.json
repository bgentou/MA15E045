[
  {
    "objectID": "slides/SQL_7.html#table-babynames",
    "href": "slides/SQL_7.html#table-babynames",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Table babynames\n",
    "text": "Table babynames\n\n\nstopifnot(\n  require(dplyr),\n  require(tibble),\n  require(babynames),\n  require(gt)\n)\n\n\nbabynames |&gt; \n  glimpse()\n\nRows: 1,924,665\nColumns: 5\n$ year &lt;dbl&gt; 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880,…\n$ sex  &lt;chr&gt; \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", …\n$ name &lt;chr&gt; \"Mary\", \"Anna\", \"Emma\", \"Elizabeth\", \"Minnie\", \"Margaret\", \"Ida\",…\n$ n    &lt;int&gt; 7065, 2604, 2003, 1939, 1746, 1578, 1472, 1414, 1320, 1288, 1258,…\n$ prop &lt;dbl&gt; 0.07238359, 0.02667896, 0.02052149, 0.01986579, 0.01788843, 0.016…"
  },
  {
    "objectID": "slides/SQL_7.html#petit-rappel-sur-lalgèbre-relationnelle",
    "href": "slides/SQL_7.html#petit-rappel-sur-lalgèbre-relationnelle",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Petit rappel sur l’algèbre relationnelle",
    "text": "Petit rappel sur l’algèbre relationnelle\n\n\n\n\n\n\nPrincipe\n\n\nUne opération de l’algèbre relationnelle accepte des opérandes (des relations) et parfois une expression.\nUne opération de l’algèbre relationnelle retourne une relation/table.\n\n\n\n\n\n\n\n\n\n\nEn passant\n\n\nUne relation c’est un schéma (définition des colonnes/attributs) et une instance (une collection de lignes qui obéissent au schéma).\nUne opération de l’algèbre relationnelle définit le schéma de la table résultat à partir des schémas des tables opérandes\nUne opération de l’algèbre relationnelle définit l’instance du schéma résultat à partir des instances des tables opérandes (et peut-être de l’expression)."
  },
  {
    "objectID": "slides/SQL_7.html#opérateurs-de-base",
    "href": "slides/SQL_7.html#opérateurs-de-base",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Opérateurs de base",
    "text": "Opérateurs de base\n\n\n\n\n\n\nListe des opérateurs\n\n\nL’algèbre relationnelle est d’abord un *Langage de Manipulation de Données& (LMD)}.\n\nUnion: \\(\\Large{\\cup}\\)\nIntersection: \\(\\Large{\\cap}\\)\nDifférence: \\(\\Large{\\backslash}\\)\nProjection: \\(\\Large{\\Pi}\\) (avec une expression formée par la liste des attributs de projection)\nSélection: \\(\\Large{\\sigma}\\) (avec une expression qui définit la condition de filtrage)\nProduit cartésien: \\(\\Large{\\times}\\)\nRenommage: \\(\\Large{\\rho}\\) (avec une expression formée par la liste des renommages)\n\ns’appliquent à des relations (les opérandes) pour produire d’autres relations (le résultat)."
  },
  {
    "objectID": "slides/SQL_7.html#union-cup-et-intersection-cap",
    "href": "slides/SQL_7.html#union-cup-et-intersection-cap",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Union \\(\\cup\\) et intersection \\(\\cap\\)\n",
    "text": "Union \\(\\cup\\) et intersection \\(\\cap\\)\n\n\n\n\n\n\n\nDéfinition\n\n\n\nL’union et l’intersection sont des opérations portant sur deux relations \\(R_1\\) et \\(R_2\\) de même schéma\n\\(T=R_1\\cup R_2\\) est constituée des tuples appartenant à \\(R_1\\) ou à \\(R_2\\).\n\\(T=R_1\\cap R_2\\) est constituée des tuples appartenant à \\(R_1\\) et à \\(R_2\\).\nLe schémas de \\(R_1\\cup R_2\\), \\(R_1\\cap R_2\\) sont les mêmess que ceux de \\(R_1\\) et \\(R_2\\)"
  },
  {
    "objectID": "slides/SQL_7.html#union-et-intersection",
    "href": "slides/SQL_7.html#union-et-intersection",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Union et intersection",
    "text": "Union et intersection"
  },
  {
    "objectID": "slides/SQL_7.html#exemple",
    "href": "slides/SQL_7.html#exemple",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Exemple",
    "text": "Exemple\n\n\nTrain 1\n\n\nh-dep\ndest\nnum\n\n\n\n13h15\nLyon\n213\n\n\n13h29\nMarseille\n1024\n\n\n14h15\nLyon\n214\n\n\n\nTrain 2\n\n\nh-dep\ndest\nnum\n\n\n\n13h39\nAvignon\n43\n\n\n14h15\nLyon\n214\n\n\n\n\nTrain 1 \\(\\cup\\) Train 2\n\n\nh-dep\ndest\nnum\n\n\n\n13h15\nLyon\n213\n\n\n13h29\nMarseille\n1024\n\n\n14h15\nLyon\n214\n\n\n13h39\nAvignon\n43\n\n\n\nTrain 1 \\(\\cap\\) Train 2\n\n\nh-dep\ndest\nnum\n\n\n14h15\nLyon\n214"
  },
  {
    "objectID": "slides/SQL_7.html#différence",
    "href": "slides/SQL_7.html#différence",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Différence",
    "text": "Différence\n\n\n\n\n\n\nDéfinition\n\n\n\nLa différence de deux relations \\(R_1\\) et \\(R_2\\) (de même schéma) est une relation \\(T\\)\nde même schéma que \\(R_1\\) et \\(R_2\\)\nconstituée des tuples appartenant à \\(R_1\\) et n’appartenant pas à \\(R_2\\).\nOn note \\(T = R_1 - R_2\\).\n\n\n\n\n\n\n\n\n\n\n\nOpération non commutative !\n\n\nR_1 - R_2R_2 - R_1$ (en général)."
  },
  {
    "objectID": "slides/SQL_7.html#différence-exemple",
    "href": "slides/SQL_7.html#différence-exemple",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Différence : exemple",
    "text": "Différence : exemple"
  },
  {
    "objectID": "slides/SQL_7.html#produit-cartésien",
    "href": "slides/SQL_7.html#produit-cartésien",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Produit Cartésien",
    "text": "Produit Cartésien\n\n\n\n\n\n\nDéfinition\n\n\n\n\nSoient:\n\n\n\\(R_1\\) de schéma \\(R_1(A_1,A_2,...,A_k)\\)\n\n\n\\(R_2\\) de schéma \\(R_2(B_1,B_2,...,B_\\ell)\\)\n\navec \\(A_i\\neq B_j\\), pour tout \\(i=1,...,k\\), \\(j=1,..,\\ell\\)\n\n\n\nDans le contexte “classique” : \\(R_1 \\times R_2= \\{(e_1,e_2): e_1\\in R_1, e_2\\in R_2\\}\\)\n\\(R=R_1 \\times R_2\\) de schéma \\(R(A_1,A_2,...,A_k,B_1,B_2,...,B_\\ell)\\). Le schéma de \\(R\\) est l’union des schémas de \\(R_1\\) et \\(R_2\\)\n\n\n\n\n\n\n\n\n\n\nAttention\n\n\nEn algèbre relationnelle, cette opération est commutative ( \\(R_1\\times R_2 = R_2\\times R_1\\) ) et associative (parce que l’on nomme des attributs/colonnes, on ne les désigne pas par une position)"
  },
  {
    "objectID": "slides/SQL_7.html#produit-cartésien-1",
    "href": "slides/SQL_7.html#produit-cartésien-1",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Produit cartésien :",
    "text": "Produit cartésien :\n\n\n\n\n\n\nDéfinition formelle\n\n\n\\(R=R_1\\times R_2\\) est la relation de schéma \\(R(A_1,A_2,...,A_k,B_1,B_2,...,B_\\ell)\\) vérifiant~:\n\nPour tout \\(t\\in R\\), il existe \\(t_1\\in R_1\\), \\(t_2\\in R_2\\) (\\(\\forall t \\in R, \\exists t_1 \\in R_1, \\exists t_2 \\in R_2, \\ldots\\)) tels que :\n\n\\[t.A_1=t_1.A_1, \\ldots, t.A_k=t_1.A_k,\\quad t.B_1=t_2.B_1, \\ldots, t.B_\\ell=t_2.B_\\ell\\]\n\nRéciproquement, pour tout \\(t_1\\in R_1\\), \\(t_2\\in R_2\\) , il existe \\(t\\in R\\) tels que :\n\n\\[t.A_1=t_1.A_1, \\ldots, t.A_k=t_1.A_k,\\quad \\text{et} \\quad t.B_1=t_2.B_1, \\ldots, t.B_\\ell=t_2.B_\\ell\\]\n\\[\\forall t_1 \\in R_1, \\forall t_2 \\in R_2, \\exists t \\in R, \\qquad  t.A_1=t_1.A_1, \\ldots, t.A_k=t_1.A_k,\\quad \\text{et} \\quad t.B_1=t_2.B_1, \\ldots, t.B_\\ell=t_2.B_\\ell\\]"
  },
  {
    "objectID": "slides/SQL_7.html#produit-cartésien-avec-dplyr-dplyrcross_join",
    "href": "slides/SQL_7.html#produit-cartésien-avec-dplyr-dplyrcross_join",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Produit cartésien avec dplyr: dplyr::cross_join()\n",
    "text": "Produit cartésien avec dplyr: dplyr::cross_join()\n\n\\(R \\times S\\) se traduit en\ncross_join(R, S)"
  },
  {
    "objectID": "slides/SQL_7.html#projection-largepi",
    "href": "slides/SQL_7.html#projection-largepi",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Projection ( \\(\\Large{\\pi}\\) )",
    "text": "Projection ( \\(\\Large{\\pi}\\) )\n\n\n\n\n\n\nDéfinition\n\n\n\nLa projection d’une relation \\(R\\) de schéma \\(R(A_1,\\dots, A_k)\\) sur les attributs \\(A_{i_1}, \\dots, A_{i_p}\\), \\(i_1,..., i_p\\in \\{1,...,k\\}\\), est la relation \\(S\\)\n\nde schéma \\(S(A_{i_1}, \\dots,A_{i_p})\\)\n\ndont les tuples sont obtenus par élimination des attributs non mentionnés dans \\(A_{i_1}, \\dots, A_{i_p}\\) (et par élimination des doublons).\nOn note \\(S = \\pi_{A_{i_1}, \\dots, A_{i_p}} (R)\\).\n\n\nDéfinition formelle :\n\n\\[s\\in S\\quad  \\iff \\quad \\exists t\\in R, \\forall n\\in\\left\\{1,\\dots,p\\right\\}\\qquad s.A_{i_n}=t.A_{i_n}\\]\n\n\n\nImplicitement, on a élimination des doublons car une projection peut produire plusieurs fois le même tuple."
  },
  {
    "objectID": "slides/SQL_7.html#projection-avec-dplyrselect",
    "href": "slides/SQL_7.html#projection-avec-dplyrselect",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Projection avec dplyr::select()\n",
    "text": "Projection avec dplyr::select()\n\n\\(S = \\pi_{A_{i_1}, \\dots, A_{i_p}} (R)\\) se traduit en\nS &lt;- dplyr::select(R, Ai1, Ai2, ..., Aip)"
  },
  {
    "objectID": "slides/SQL_7.html#projection-exemples",
    "href": "slides/SQL_7.html#projection-exemples",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Projection : Exemples",
    "text": "Projection : Exemples"
  },
  {
    "objectID": "slides/SQL_7.html#projection-vitaminée-tidy-selection",
    "href": "slides/SQL_7.html#projection-vitaminée-tidy-selection",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Projection vitaminée (tidy selection)",
    "text": "Projection vitaminée (tidy selection)\nSélection bien tempérée"
  },
  {
    "objectID": "slides/SQL_7.html#sélection-σ",
    "href": "slides/SQL_7.html#sélection-σ",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Sélection (σ)",
    "text": "Sélection (σ)\n\n\n\n\n\n\nDéfinition\n\n\n\n\nLa sélection d’une relation \\(R\\) par une condition \\(C\\) est une relation \\(S\\)\n\nde même schéma que \\(R\\)\ndont les tuples sont ceux de \\(R\\) qui satisfont la condition \\(C\\).\n\n\nOn note \\(S = σ(R, C)\\).\n\nLa condition \\(C\\)\n\ns’exprime à l’aide des noms d’attributs de la relation ou de constantes (pour les opérandes)\non peut utiliser des opérateurs arithmétiques de comparaison ( \\(=, \\neq, \\leq, \\geq, &lt;, &gt;\\) ) ainsi que des connecteurs logiques (¬, ∧, ∨)..\ns’évalue pour chaque ligne de \\(R\\)"
  },
  {
    "objectID": "slides/SQL_7.html#sélection-avec-dplyrfilter",
    "href": "slides/SQL_7.html#sélection-avec-dplyrfilter",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Sélection avec dplyr::filter\n",
    "text": "Sélection avec dplyr::filter\n\n\\(S = σ(R, C)\\) se traduit en\nS &lt;- filter(R, C)"
  },
  {
    "objectID": "slides/SQL_7.html#sélection-exemple",
    "href": "slides/SQL_7.html#sélection-exemple",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Sélection : Exemple",
    "text": "Sélection : Exemple"
  },
  {
    "objectID": "slides/SQL_7.html#renommage",
    "href": "slides/SQL_7.html#renommage",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Renommage",
    "text": "Renommage\n\n\n\n\n\n\nDéfinition\n\n\n\nSoit \\(R\\) de schéma \\(R(A_1,\\dots, A_k)\\), le renommage d’un attribut \\(A_i\\), \\(i\\leq k\\), en \\(B\\) est une relation \\(S\\) :\n\nde même contenu (mêmes lignes)\nde schéma \\(S(A_1,...,A_{i-1},B,A_{i+1},..., A_k)\\)\n\nOn le note \\(S=ρ(R, A_i\\mapsto B)\\)"
  },
  {
    "objectID": "slides/SQL_7.html#renommage-avec-dplyrrename",
    "href": "slides/SQL_7.html#renommage-avec-dplyrrename",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Renommage avec dplyr::rename()\n",
    "text": "Renommage avec dplyr::rename()\n\n\\(S=ρ(R, A_i\\mapsto B)\\) se traduit en\nS &lt;- rename(R, B=Ai)"
  },
  {
    "objectID": "slides/SQL_7.html#exemple-1",
    "href": "slides/SQL_7.html#exemple-1",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Exemple",
    "text": "Exemple\nr$&gt; rename(flights, destination=dest) |&gt; \n    select(flight,tailnum, origin, destination, carrier, time_hour) |&gt;\n    head()\n# A tibble: 6 × 6\n  flight tailnum origin destination carrier time_hour          \n   &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;       &lt;chr&gt;   &lt;dttm&gt;             \n1   1545 N14228  EWR    IAH         UA      2013-01-01 05:00:00\n2   1714 N24211  LGA    IAH         UA      2013-01-01 05:00:00\n3   1141 N619AA  JFK    MIA         AA      2013-01-01 05:00:00\n4    725 N804JB  JFK    BQN         B6      2013-01-01 05:00:00\n5    461 N668DN  LGA    ATL         DL      2013-01-01 06:00:00\n6   1696 N39463  EWR    ORD         UA      2013-01-01 05:00:00\nUtilité Va permettre d’étendre certains opérateurs pour des relations de schémas non-disjoints"
  },
  {
    "objectID": "slides/SQL_7.html#les-opérateurs-comme-fonctions",
    "href": "slides/SQL_7.html#les-opérateurs-comme-fonctions",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Les opérateurs comme fonctions",
    "text": "Les opérateurs comme fonctions\n\\(\\pi_{Ai1, Aip}\\left(\\sigma_C(R)\\right)\\)\nse traduit en\nselect(filter(R, C), Ai1, ..., Aip)\nqui s’avère difficile à lire, surtout si on compose plus d’opérations élémentaires\nLa composition de fonctions se conçoit facilement mais l’expression correspondante est difficile à lire"
  },
  {
    "objectID": "slides/SQL_7.html#réécriture-de-la-composition-avec",
    "href": "slides/SQL_7.html#réécriture-de-la-composition-avec",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Réécriture de la composition avec |>\n",
    "text": "Réécriture de la composition avec |&gt;\n\nS &lt;- select(filter(R, C), Ai1, ..., Aip)\npeut être réécrite en\nS &lt;- R |&gt; \n  filter(C) |&gt;\n  select(Ai1,.., Aip)"
  },
  {
    "objectID": "slides/SQL_7.html#exemple-2",
    "href": "slides/SQL_7.html#exemple-2",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Exemple",
    "text": "Exemple\nLes origines et destinations des vols avec un retard au départ d’au moins 30 minutes e\n\n\nflights |&gt;\n  filter(dep_delay&gt;30) |&gt;\n  select(origin, dest) |&gt;\n  distinct()\n\nou directement\nflights |&gt;\n  filter(dep_delay&gt;30) |&gt;\n  distinct(origin, dest)"
  },
  {
    "objectID": "slides/SQL_7.html#les-jointures",
    "href": "slides/SQL_7.html#les-jointures",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Les jointures",
    "text": "Les jointures\nOn va définir des opérations pratiques pour la manipulation de données~: les jointures\n\nJointure\nJointure naturelle\n\\(\\theta\\)-jointure et équi-jointure"
  },
  {
    "objectID": "slides/SQL_7.html#jointure",
    "href": "slides/SQL_7.html#jointure",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Jointure",
    "text": "Jointure\n\n\n\n\n\n\nDéfinition\n\n\nLa jointure \\(T=R_1\\bowtie_C R_2\\) de deux relations \\(R_1\\) et \\(R_2\\) de schémas disjoints sous la condition \\(C\\) est la relation \\(T\\):\n\nde schéma la concaténation des schémas de \\(R_1\\) et \\(R_2\\)\nformée des tuples du produit cartésien \\(R_1  \\times R_2\\) qui satisfont la condition \\(C\\)\n\nRègles de formation de la condition de jointure : comme pour la sélection\n\n\n\n\n\n\n\n\n\nDéfinition formelle\n\n\n\\[R_1 \\bowtie_C R_2 = \\sigma_C(R_1\\times R_2)\\]"
  },
  {
    "objectID": "slides/SQL_7.html#exemple-3",
    "href": "slides/SQL_7.html#exemple-3",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Exemple",
    "text": "Exemple\nTrDep\n\n\nhdep\ndest\nnumdep\n\n\n\n13h15\nLyon\n213\n\n\n13h29\nMarseille\n1024\n\n\n\nTrArr\n\n\nharr\nprov\nnumarr\n\n\n\n13h39\nAvignon\n43\n\n\n15h15\nParis\n213\n\n\n\n\\(\\texttt{TrDep} \\bowtie_{\\text{numdep} &gt; \\text{numar}} \\texttt{TrArr}\\)\n\n\n\n\n\n\n\n\n\n\nhdep\ndest\nnumdep\nharr\nprov\nnumarr\n\n\n\n13h15\nLyon\n213\n13h39\nAvignon\n43\n\n\n13h29\nMarseille\n1024\n13h39\nAvignon\n43\n\n\n13h29\nMarseille\n1024\n15h15\nParis\n213"
  },
  {
    "objectID": "slides/SQL_7.html#équi-jointure-theta-jointure",
    "href": "slides/SQL_7.html#équi-jointure-theta-jointure",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Équi-jointure, \\(\\theta\\)-jointure",
    "text": "Équi-jointure, \\(\\theta\\)-jointure\n\n\n\n\n\n\nÉqui-jointure\n\n\nJointure avec égalité entre attributs de types comparables\n\n\n\n\\[\\texttt{TrDep} \\bowtie_{\\text{numdep} = \\text{numarr}} \\texttt{TrArr}\\]\n\n\n\n\n\n\n\n\n\n\nhdep\ndest\nnumdep\nharr\nprov\nnumarr\n\n\n13h15\nLyon\n213\n15h15\nParis\n213\n\n\n\n\n\n\n\n\n\n\\(\\theta\\)-jointure\n\n\nCondition de jointure entre attributs de types comparables et avec un opérateur différent de l’égalité, c’est-à-dire dans \\(\\left\\{&lt;,&gt;,\\leq,\\geq, \\neq\\right\\}\\).\n\\[\\text{TrDep} \\bowtie_{\\text{numdep} &gt; \\text{numarr}} \\text{TrArr}\\]"
  },
  {
    "objectID": "slides/SQL_7.html#jointure-naturelle",
    "href": "slides/SQL_7.html#jointure-naturelle",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Jointure naturelle",
    "text": "Jointure naturelle\n\n\n\n\n\n\nDéfinition\n\n\nC’est une équi-jointure concernant les attributs communs (même nom et même type) de deux relations\nOn ne garde dans le résultat qu’une copie des attributs communs \n\n\n\nOn considère\n\n\\(R_1\\) d’attributs \\(A_1,..,A_k,B_1,...,B_h\\)\n\\(R_2\\) d’attributs \\(A_1,..,A_k,B_{h+1},...,B_\\ell\\)\n\\(A_1,..., A_k\\) : attributs communs et \\(\\{B_1,...,B_h\\}\\cap \\{ B_{h+1},...,B_\\ell \\}=\\emptyset\\)\nSoit \\(A'_1, ...., A'_k\\) tels que \\(\\{A_1,..., A_k\\}\\cap \\{ A'_1, ...., A'_k \\}=\\emptyset\\)"
  },
  {
    "objectID": "slides/SQL_7.html#jointure-naturelle-formalisation",
    "href": "slides/SQL_7.html#jointure-naturelle-formalisation",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Jointure naturelle (formalisation)",
    "text": "Jointure naturelle (formalisation)\nConsidérons \\(S\\) d’attributs \\(A_1',..,A_k',B_{h+1},...,B_l\\) définie par :\n\\[S=\\rho_{A_1\\mapsto A_1'}(\\rho_{A_2\\mapsto A_2'}(\\cdots (\\rho_{A_k\\mapsto A_k'}(R_2)\\cdots ))\\]\nLa jointure naturelle sur deux relations \\(R_1\\) et \\(R_2\\) est la relation\n\nd’attributs \\(A_1,..,A_k,B_1,...,B_h, B_{h+1},...,B_\\ell\\)\ndéfinie par :\n\n\\[\\pi_{A_1,..,A_k,B_1,...,B_h, B_{h+1},...,B_\\ell}(R_1\\bowtie_{C} S)\\]\noù \\(C\\) est \\((A_1=A_1') \\wedge (A_2=A'_2) \\wedge \\ldots \\wedge (A_k=A_k')\\)\n on réalise une équi-jointure sur tous les attributs communs et on ne garde qu’un seul “exemplaire” de ces attributs communs par projection.\nOn note cette opération : \\(R_1 \\bowtie R_2\\).\n\nPour éviter le renommage, on peut décider de préfixer les noms des attributs par ceux de la relation. La condition \\(C\\) devient :\n\\[(R_1.A_1=R_2.A_1) \\wedge \\ldots \\wedge (R_1.A_k=R_2.A_k)\\]"
  },
  {
    "objectID": "slides/SQL_7.html#exemple-de-jointure-naturelle",
    "href": "slides/SQL_7.html#exemple-de-jointure-naturelle",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Exemple de Jointure naturelle",
    "text": "Exemple de Jointure naturelle\n\n\nTrDep\n\n\nhdep\ndest\nnum\n\n\n\n13h15\nLyon\n213\n\n\n13h29\nMarseille\n1024\n\n\n\nTrArr\n\n\nharr\nprov\nnum\n\n\n\n13h39\nAvignon\n43\n\n\n15h15\nParis\n213\n\n\n\n\n\\[\\text{TrDep} \\bowtie \\text{TrArr}\\]\n\n\n\n\n\n\n\n\n\nhdep\ndest\nnum\nharr\nprov\n\n\n13h15\nLyon\n213\n15h15\nParis"
  },
  {
    "objectID": "slides/SQL_7.html#exemples-de-requêtes",
    "href": "slides/SQL_7.html#exemples-de-requêtes",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Exemples de requêtes",
    "text": "Exemples de requêtes\nBase constituée des trois tables suivantes:\nfournisseurs(fno, nom, adresse, ville)\nproduits(pno, design, prix, poids, couleur)\ncommandes(cno, fno, pno, qte)"
  },
  {
    "objectID": "slides/SQL_7.html#exemples-de-requêtes-suite",
    "href": "slides/SQL_7.html#exemples-de-requêtes-suite",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Exemples de requêtes (suite)",
    "text": "Exemples de requêtes (suite)\n\ndéterminer les numéros des fournisseurs ayant comme nom “Durand”\n\n\\[\\pi_{\\text{fno}} \\bigl( \\sigma_{\\text{nom}=\\text{'Durand'}} (\\text{fournisseurs})\\bigr)\\]\n\ndéterminer les références, prix et quantités des produits commandés à plus de 10 exemplaires.\n\n\\[\\pi_{\\text{pno,prix,qte}} \\bigl( \\sigma_{\\text{qte}&gt;10} (\\text{commandes} \\bowtie \\text{produits})\\bigr)\\]"
  },
  {
    "objectID": "slides/SQL_7.html#jointure-externe",
    "href": "slides/SQL_7.html#jointure-externe",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Jointure externe",
    "text": "Jointure externe\n\n\n\n\n\n\nPerte d’information dans jointure naturelle\n\n\nLes tuples ne satisfaisant pas la condition (non appariés) disparaissent\n\n\n\n\n\n\n\n\n\nDéfinition\n\n\n\nOn ajoute symboliquement” une ligne dont les valeurs sont vides (ou avec valeur spéciale NULL) pour garder les tuples initiaux “non satisfaisants” après la jointure\nOn note cette opération entre deux relations \\(R\\) et \\(S\\) :\n\\[R \\bowtie^+ S\\]"
  },
  {
    "objectID": "slides/SQL_7.html#jointure-externe-exemple",
    "href": "slides/SQL_7.html#jointure-externe-exemple",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Jointure externe (exemple)",
    "text": "Jointure externe (exemple)\n\n\nTrDep\n\n\nhdep\ndest\nnum\n\n\n\n13h15\nLyon\n213\n\n\n13h29\nMarseille\n1024\n\n\n\nTrArr\n\n\nharr\nprov\nnum\n\n\n\n13h39\nAvignon\n43\n\n\n15h15\nParis\n213\n\n\n\n\n\\[\\text{TrDep} \\bowtie^+ \\text{TrArr}\\]\n\n\n\n\n\n\n\n\n\nhdep\ndest\nnum\nharr\nprov\n\n\n\n13h15\nLyon\n213\n15h15\nParis\n\n\n13h29\nMarseille\n1024\n-\n-\n\n\n-\n-\n43\n13h39\nAvignon"
  },
  {
    "objectID": "slides/SQL_7.html#inner_join",
    "href": "slides/SQL_7.html#inner_join",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "inner_join()",
    "text": "inner_join()"
  },
  {
    "objectID": "slides/SQL_7.html#join_by...",
    "href": "slides/SQL_7.html#join_by...",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "join_by(...)",
    "text": "join_by(...)\n\njoin_by() constructs a specification that describes how to join two tables using a small domain specific language.\n\nArguments\nExpressions specifying the join.\n. . .\nEach expression should consist of one of the following:\n\nEquality condition: ==\nInequality conditions: &gt;=, &gt;, &lt;=, or &lt;\nRolling helper: closest()\nOverlap helpers: between(), within(), or overlaps()\n\n\n\nOther expressions are not supported. If you need to perform a join on a computed variable, e.g. join_by(sales_date - 40 &gt;= promo_date), you’ll need to precompute and store it in a separate column."
  },
  {
    "objectID": "slides/SQL_7.html#left_join",
    "href": "slides/SQL_7.html#left_join",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "left_join()",
    "text": "left_join()"
  },
  {
    "objectID": "slides/SQL_7.html#division",
    "href": "slides/SQL_7.html#division",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Division",
    "text": "Division\n\n\n\n\n\n\nDéfinition\n\n\nLa division ou quotient\n\nd’une relation \\(R\\) de schéma \\(R(A_1,A_2,\\dots,A_k)\\)\npar une relation \\(S\\) de schéma \\(S(A_{p+1},\\dots ,A_k)\\)\n\nest la relation \\(T\\) de schéma \\(T(A_1, \\dots, A_p)\\) formée des tuples qui complétés par chaque tuple de \\(S\\) donnent un tuple de \\(R\\).\nAutrement dit\n\\[\\begin{array}{l} t\\in T(A_1,\\dots,A_p)  \\quad \\Longleftrightarrow \\\\\n\\forall s\\in S(A_{p+1},\\dots ,A_k) \\quad \\exists r\\in R \\quad \\begin{cases}\nt.A_1=r.A_1, \\dots, t.A_p=r.A_p\\\\ s.A_{p+1}=r.A_{p+1},\\dots, s.A_{k}=r.A_{k} \\end{cases} \\end{array}\\]\nOn note \\[T = R \\div S\\]"
  },
  {
    "objectID": "slides/SQL_7.html#division-exemple",
    "href": "slides/SQL_7.html#division-exemple",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Division (exemple)",
    "text": "Division (exemple)\n\n\nVoyage : contient pour chaque numéro de client la ville de départ et d’arrivée des voyages qu’il a effectué\n\n\nnumclient\nvdep\nvarr\n\n\n\n1\nParis\nMarseille\n\n\n3\nMarseille\nLyon\n\n\n1\nParis\nNantes\n\n\n5\nMarseille\nAvignon\n\n\n4\nParis\nNantes\n\n\n3\nParis\nMarseille\n\n\n2\nCaen\nLe Mans\n\n\n3\nParis\nNantes\n\n\n\n\nVilles contient des couples villes de départ/villes d’arrivée\n\n\nvdep\nvarr\n\n\n\nParis\nMarseille\n\n\nParis\nNantes"
  },
  {
    "objectID": "slides/SQL_7.html#division-exemple-suite",
    "href": "slides/SQL_7.html#division-exemple-suite",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Division (exemple, suite)",
    "text": "Division (exemple, suite)\n\\[\\texttt{Voyage} \\div \\texttt{Villes}\\]\n\n\nnumclient\n\n\n\n1\n\n\n3\n\n\n\nRésultat : numéros des clients ayant effectué tous les voyages entre les villes de la table Villes (i.e. à la fois un Paris-Marseille et un Paris-Nantes.)"
  },
  {
    "objectID": "slides/SQL_7.html#interdéfinissabilité-des-opérateurs",
    "href": "slides/SQL_7.html#interdéfinissabilité-des-opérateurs",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Interdéfinissabilité des opérateurs",
    "text": "Interdéfinissabilité des opérateurs\n\nL’union, la différence, le produit cartésien, la sélection et la projection et le renommage sont suffisants pour définir tous les opérateurs que l’on a vu.\nMais avoir un panier plus large d’opérateurs simplifie l’écriture des requêtes.\n\nQuelques définitions\n\nPour la Jointure : \\(R \\bowtie_C S \\equiv \\sigma_C (R \\times S)\\)\nPour l’intersection : \\(A \\cap B = A \\cup B - ((B - A) \\cup (A - B))\\)"
  },
  {
    "objectID": "slides/SQL_7.html#définition-de-la-division",
    "href": "slides/SQL_7.html#définition-de-la-division",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Définition de la division",
    "text": "Définition de la division\n\n\n\n\n\n\nFormalisation\n\n\nSoient \\(R\\) de schéma \\(R(A_1,A_2,\\dots,A_k)\\), \\(S\\) de schéma \\(S(A_{p+1},\\dots ,A_k)\\)\nest la relation \\(T= R \\div S\\) de schéma \\(T(A_1, \\dots, A_p)\\)."
  },
  {
    "objectID": "slides/SQL_7.html#from-wikipedia-smaller",
    "href": "slides/SQL_7.html#from-wikipedia-smaller",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "From Wikipedia {smaller}",
    "text": "From Wikipedia {smaller}\n\nIn the 1960s and 1970s he worked out his theories of data arrangement, issuing his paper “A Relational Model of Data for Large Shared Data Banks”[14] in 1970, after an internal IBM paper one year earlier.[15] To his disappointment, IBM proved slow to exploit his suggestions until commercial rivals started implementing them.[16]\n\n\nInitially, IBM refused to implement the relational model to preserve revenue from IMS/DB.[citation needed] Codd then showed IBM customers the potential of the implementation of its model, and they in turn pressured IBM. Then IBM included in its Future Systems project a System R subproject – but put in charge of it developers who were not thoroughly familiar with Codd’s ideas, and isolated the team from Codd.[citation needed] As a result, they did not use Codd’s own Alpha language but created a non-relational one, SEQUEL. Even so, SEQUEL was so superior to pre-relational systems that it was copied, in 1979, based on pre-launch papers presented at conferences, by Larry Ellison, of Relational Software Inc, in his Oracle Database, which actually reached market before SQL/DS – because of the then-already proprietary status of the original name, SEQUEL had been renamed SQL.\n\n\nCodd continued to develop and extend his relational model, sometimes in collaboration with Christopher J. Date. One of the normalised forms, the Boyce–Codd normal form, is named after him.\n\n\nCodd’s theorem, a result proven in his seminal work on the relational model, equates the expressive power of relational algebra and relational calculus.[14]"
  },
  {
    "objectID": "slides/SQL_7.html#summarizedqta-...-byexpr-dans-dplyr",
    "href": "slides/SQL_7.html#summarizedqta-...-byexpr-dans-dplyr",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "\nsummarize(dqta, ... , by=expr) dans dplyr()\n",
    "text": "summarize(dqta, ... , by=expr) dans dplyr()"
  },
  {
    "objectID": "slides/SQL_7.html#summarize-avec-sélection-bien-tempérée-avec-across...-...",
    "href": "slides/SQL_7.html#summarize-avec-sélection-bien-tempérée-avec-across...-...",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "\nsummarize() avec sélection bien tempérée avec across(..., ...)\n",
    "text": "summarize() avec sélection bien tempérée avec across(..., ...)"
  },
  {
    "objectID": "slides/SQL_7.html#le-problème-group-by-en-sql",
    "href": "slides/SQL_7.html#le-problème-group-by-en-sql",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Le problème GROUP BY en SQL\n",
    "text": "Le problème GROUP BY en SQL"
  },
  {
    "objectID": "slides/SQL_7.html#des-tables-avec-des-domaines-tabulaires",
    "href": "slides/SQL_7.html#des-tables-avec-des-domaines-tabulaires",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Des tables avec des domaines tabulaires",
    "text": "Des tables avec des domaines tabulaires"
  },
  {
    "objectID": "slides/SQL_7.html#group_by-et-les-grouped-tibbles",
    "href": "slides/SQL_7.html#group_by-et-les-grouped-tibbles",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "\ngroup_by() et les grouped tibbles\n",
    "text": "group_by() et les grouped tibbles"
  },
  {
    "objectID": "slides/SQL_7.html#ungroup",
    "href": "slides/SQL_7.html#ungroup",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "ungroup()",
    "text": "ungroup()"
  },
  {
    "objectID": "slides/SQL_7.html#nest-et-unnest",
    "href": "slides/SQL_7.html#nest-et-unnest",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "\nnest() et unnest()\n",
    "text": "nest() et unnest()"
  },
  {
    "objectID": "slides/SQL_7.html#enframe",
    "href": "slides/SQL_7.html#enframe",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "enframe()",
    "text": "enframe()"
  },
  {
    "objectID": "slides/SQL_7.html#références-sur-les-tqbles-partitionnées",
    "href": "slides/SQL_7.html#références-sur-les-tqbles-partitionnées",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Références sur les tqbles partitionnées",
    "text": "Références sur les tqbles partitionnées\ndplyr sur le groupement"
  },
  {
    "objectID": "slides/SQL_7.html#types-de-mises-à-jour-de-tables-en-sql",
    "href": "slides/SQL_7.html#types-de-mises-à-jour-de-tables-en-sql",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Types de mises à jour de tables en SQL\n",
    "text": "Types de mises à jour de tables en SQL\n\n\nmodification du schéma ALTER TABLE ...\n\najout de colonnes\nsuppression de colonnes\nmodification de domaines\n\n\nmodification des lignes\n\nmises à jour d’attributs sur certaines lignes\nsuppression de lignes\ninsertions de lignes"
  },
  {
    "objectID": "slides/SQL_7.html#point-de-vue-fonctionnel",
    "href": "slides/SQL_7.html#point-de-vue-fonctionnel",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Point de vue fonctionnel",
    "text": "Point de vue fonctionnel"
  },
  {
    "objectID": "slides/SQL_7.html#mutate",
    "href": "slides/SQL_7.html#mutate",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "mutate()",
    "text": "mutate()\n\najout de colonnes\nmodification de domaines\nmises à jour d’attributs sur certaines lignes"
  },
  {
    "objectID": "slides/SQL_7.html#ajout-de-lignes",
    "href": "slides/SQL_7.html#ajout-de-lignes",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Ajout de lignes",
    "text": "Ajout de lignes"
  },
  {
    "objectID": "slides/SQL_5.html#trois-objectifs",
    "href": "slides/SQL_5.html#trois-objectifs",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Trois objectifs",
    "text": "Trois objectifs\n\nAutomatisation de taches répétitives (administration)\n\n\nOn veut répéter une même tache sur une collection de schémas\nOn veut traiter une collection de roles\n\n\n\nCalculs impossibles à réaliser en SQL :\n\n\nCalculer la fermeture transitive d’une relation comme film_actors\n\nL’algèbre relationnelle est un modèle de calculabilité restreint·\n\n\nTriggers\n\n\nCertaines contraintes ne peuvent pas être mises en place avec les seules constructions primary key , unique, foreign key, check et exclude (notamment des contraintes d’exclusion qui mettent en jeu plusieurs tables).\nOn peut les maintenir à l’aide de traitements spéciaux : les triggers\n\nLes triggers reposent sur des fonctions spéciales\n\n\nExtensions procédurales de SQL\nplpgsql : Programming Language PostGres SQL"
  },
  {
    "objectID": "slides/SQL_5.html#automatisation-des-tâches-répétitives-deux-outils-nécessaires",
    "href": "slides/SQL_5.html#automatisation-des-tâches-répétitives-deux-outils-nécessaires",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Automatisation des tâches répétitives : deux outils nécessaires",
    "text": "Automatisation des tâches répétitives : deux outils nécessaires\nLorsqu’on administre une base, on doit souvent engendrer des requêtes dynamiques à l’intérieur d’une fonction PL/pgSQL, c’est à dire des commandes qui vont concerner des tables ou des types différents à chaque exécution\nLes requêtes préparées sont alors très utilement combinées avec les structures de contrôle (itérations, alternatives) pour automatiser les tâches !\n\n 2 outils (pour étendre SQL) :\n\nrequêtes dynamiques EXECUTE, PREPARE\n\nstructures de contrôles IF, LOOP, ... Transforment SQL en un langage de programmation"
  },
  {
    "objectID": "slides/SQL_5.html#fonction-inventory_in_stock",
    "href": "slides/SQL_5.html#fonction-inventory_in_stock",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Fonction inventory_in_stock()\n",
    "text": "Fonction inventory_in_stock()\n\nObjectif : calculer si un dvd est en stock ou pas\nUn DVD est en stock\n\ns’il n’a jamais été loué\n\nOU\n\nsi toutes les locations de ce DVD sont déjà terminées (return_date n’est pas nul)\n\n-- AN ITEM IS IN-STOCK IF THERE ARE EITHER NO ROWS IN THE rental TABLE\n-- FOR THE ITEM OR ALL ROWS HAVE return_date POPULATED"
  },
  {
    "objectID": "slides/SQL_5.html#fonction-inventory_in_stock-1",
    "href": "slides/SQL_5.html#fonction-inventory_in_stock-1",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Fonction inventory_in_stock\n",
    "text": "Fonction inventory_in_stock\n\nCREATE OR REPLACE FUNCTION sakila.inventory_in_stock(p_inventory_id integer)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\nDECLARE                 \n    v_rentals INTEGER;  #&lt;&lt;\n    v_out     INTEGER;  #&lt;&lt;\nBEGIN\n    SELECT count(*) INTO v_rentals  #&lt;&lt;\n    FROM rental\n    WHERE inventory_id = p_inventory_id;\n\n    IF v_rentals = 0 THEN   #&lt;&lt;\n      RETURN TRUE;          #&lt;&lt; \n    END IF;                 #&lt;&lt;\n\n    SELECT COUNT(rental_id) INTO v_out     #&lt;&lt; \n    FROM inventory LEFT JOIN rental USING(inventory_id)\n    WHERE inventory.inventory_id = p_inventory_id AND rental.return_date IS NULL;\n\n    IF v_out &gt; 0 THEN\n      RETURN FALSE;\n    ELSE\n      RETURN TRUE;\n    END IF;\nEND $function$ ;"
  },
  {
    "objectID": "slides/SQL_5.html#section",
    "href": "slides/SQL_5.html#section",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "",
    "text": "SELECT ... INTO ...\n\nLe résultat de la requête est ici un entier, il est affecté à une variable locale comme v_rentals, v_out, …\nEn plpgsql, le résultat d’une requête doit être mémorisé ou explicitement négligé en utilisant PERFORM plutôt que SELECT\n\nIF ... THEN ...\n\nAlternative, comme dans un langage de programmation ordinaire\n\nRETURN\n\nRetourne le résultat et termine l’exécution de la fonction"
  },
  {
    "objectID": "slides/SQL_5.html#une-tâche-de-surveillancemaintenance",
    "href": "slides/SQL_5.html#une-tâche-de-surveillancemaintenance",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Une tâche de surveillance/maintenance",
    "text": "Une tâche de surveillance/maintenance\n\nDéterminer pour chaque usager (schéma) le nombre de tuples dans la table ville_pays de cet usager.\nPour chaque schéma schema, on veut évaluer une requête\nSELECT COUNT(*) \nFROM schema.ville_pays ;\nIci schema doit être calculé en interrogeant le SGBD\n\nSituation inédite :\n\ncomment déterminer les schémas pertinents ?"
  },
  {
    "objectID": "slides/SQL_5.html#la-métabase-information_schema-et-pg_catalog",
    "href": "slides/SQL_5.html#la-métabase-information_schema-et-pg_catalog",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "La métabase : information_schema et pg_catalog\n",
    "text": "La métabase : information_schema et pg_catalog\n\nOn va s’aider des tables d’administration du SGBD\nChaque usager correspond à un role et ce rôle correspond dans notre cas à un schema créé à partir du rôle via l’instruction\nCREATE SCHEMA AUTHORIZATION user_name ;\nOn a envie d’écrire une requête comme\nSELECT COUNT(*) FROM username.tournaments ; \noù username est collectée à partir de\nSELECT usename  FROM pg_catalog.pg_user ;"
  },
  {
    "objectID": "slides/SQL_5.html#deux-schémas-pour-ladministration-la-métabase",
    "href": "slides/SQL_5.html#deux-schémas-pour-ladministration-la-métabase",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Deux schémas pour l’administration : la métabase\n",
    "text": "Deux schémas pour l’administration : la métabase\n\n\ninformation_schema\n\nCe schema contient l’information sur les schémas du cluster/catalogue :\n\nles définitions de tables, de vues, de colonnes, les contraintes, …\nil est formé de tables et surtout de (très nombreuses) vues\nles instructions, CREATE, ALTER,  DROP modifient le contenu de ce schéma (une seule instruction ALTER  TABLE peut engendrer plusieurs mises à jours dans les tables de information_schema\n\n\n\npg_catalog\n\nCe schema contient lui aussi beaucoup de tables et de vues utiles au fonctionnement du serveur"
  },
  {
    "objectID": "slides/SQL_5.html#exemple-de-vue-de-pg_catalog-pg_user",
    "href": "slides/SQL_5.html#exemple-de-vue-de-pg_catalog-pg_user",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Exemple de vue de pg_catalog : pg_user\n",
    "text": "Exemple de vue de pg_catalog : pg_user\n\n\n\nSchéma\n+--------------+---------+-------------+\n| Column       | Type    | Modifiers   |\n|--------------+---------+-------------|\n| usename      | name    |             |\n| usesysid     | oid     |             |\n| usecreatedb  | boolean |             |\n| usesuper     | boolean |             |\n| userepl      | boolean |             |\n| usebypassrls | boolean |             |\n| passwd       | text    |             |\n| valuntil     | abstime |             |\n| useconfig    | text[]  |             |\n+--------------+---------+-------------+\n\npg_user nous renseigne sur :\n\n\n les usagers (usename)\n\n leur statut (usesuper : super-utilisateur ou pas)\n\n leurs privilèges (createdb : peut créer une base ou non)"
  },
  {
    "objectID": "slides/SQL_5.html#autre-exemple-dusage-de-la-métabase",
    "href": "slides/SQL_5.html#autre-exemple-dusage-de-la-métabase",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Autre exemple d’usage de la métabase",
    "text": "Autre exemple d’usage de la métabase\nSELECT datname, application_name, client_addr, backend_start, state \nFROM pg_catalog.pg_stat_activity psa \nWHERE datname='bd_2023';                                               \n\n+-----------+-------------------------------------------+---------------+-------------------------------+---------+\n| datname   | application_name                          | client_addr   | backend_start                 | state   |\n|-----------+-------------------------------------------+---------------+-------------------------------+---------|\n| bd_2023   | DBeaver 22.2.0 - Main &lt;bd_2023&gt;           | 127.0.0.1     | 2022-10-04 22:48:59.57231+02  | idle    |\n| bd_2023   | DBeaver 22.2.0 - Metadata &lt;bd_2023&gt;       | 127.0.0.1     | 2022-10-04 22:48:59.693656+02 | idle    |\n| bd_2023   | DBeaver 22.2.0 - SQLEditor &lt;Script-4.sql&gt; | 127.0.0.1     | 2022-10-04 22:48:59.958616+02 | idle    |\n| bd_2023   | pgcli                                     | &lt;null&gt;        | 2022-10-04 23:23:19.739258+02 | active  |\n| bd_2023   | pgcli                                     | &lt;null&gt;        | 2022-10-04 23:23:19.770006+02 | idle    |\n+-----------+-------------------------------------------+---------------+-------------------------------+---------+"
  },
  {
    "objectID": "slides/SQL_5.html#tentative",
    "href": "slides/SQL_5.html#tentative",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Tentative",
    "text": "Tentative\nOn engendre dynamiquement une série de requêtes par une instruction de la forme :\nSELECT \n    'SELECT ' || quote_literal(usename) || ', COUNT(*)  FROM ' || usename || '.ville_pays ;'\nFROM pg_catalog.pg_user  ;\n A quoi sert quote_literal() ?"
  },
  {
    "objectID": "slides/SQL_5.html#le-résultat-est-une-table-de-chaines-de-caractères",
    "href": "slides/SQL_5.html#le-résultat-est-une-table-de-chaines-de-caractères",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Le résultat est une table de chaines de caractères",
    "text": "Le résultat est une table de chaines de caractères\nrqt                                                      |\n---------------------------------------------------------+\nSELECT 'postgres', COUNT(*)  FROM postgres.ville_pays ;  |\nSELECT 'shinken', COUNT(*)  FROM shinken.ville_pays ;    |\nSELECT 'aalahy99', COUNT(*)  FROM aalahy99.ville_pays ;  |\nSELECT 'etemam', COUNT(*)  FROM etemam.ville_pays ;      |\nSELECT 'durand', COUNT(*)  FROM durand.ville_pays ;      |\n...\n\nTel quel, cela ne fonctionnera pas !\n\nIl faut pouvoir confier ces chaines de caractères à l’évaluateur de requêtes\nIl faut pouvoir le faire pour chacune des chaines de caractères produites par la requête (itérer)"
  },
  {
    "objectID": "slides/SQL_5.html#mode-opératoire",
    "href": "slides/SQL_5.html#mode-opératoire",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Mode opératoire",
    "text": "Mode opératoire\nCREATE OR REPLACE FUNCTION taille_ville_pays()\nLANGUAGE plpgsql RETURNS  TEXT AS\n$$\nDECLARE\n  stmt CHARACTER VARYING ;\n  usename CHARACTER VARYING ;\n  result CHARACTER VARYING    := '' ;\n  resp CHARACTER VARYING := '' ;\nBEGIN\nFOR usename IN SELECT u.usename  #&lt;&lt;\n  FROM pg_catalog.pg_user AS u JOIN\n  information_schema.tables t ON\n  (u.usename=t.table_schema and t.table_name ='ville_pays')\nLOOP\n  stmt = 'SELECT CAST(COUNT(*) AS VARCHAR) FROM '|| usename||'.ville_pays #&lt;&lt;\n  result:=result || usename || ': ' ||resp| '; ';   #&lt;&lt; \nEND LOOP ;\nRETURN result ; #&lt;&lt; \nEND;$$ ;"
  },
  {
    "objectID": "slides/SQL_5.html#extension-de-sql",
    "href": "slides/SQL_5.html#extension-de-sql",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Extension de SQL",
    "text": "Extension de SQL\nA travers ces deux exemples, on a vu quelques particularités des extensions possible de SQL en un langage procédural pgplSQL. Le principe est le même dans la plupart des SGBD permettant une telle extension (Oracle, SQL Server, …). Il repose sur la norme SQL.\nOn a besoin :\n\nd’instructions conditionnelles (si … alors … sinon)\nd’instruction itératives (boucles)\nde la capacité à définir des variables\n\nde mécanismes d’articulations entre SQL et son extension procédurale :\n\nPouvoir stocker le résultat d’une requête (avec résultat unique) dans une variable\nPouvoir stocker, les uns après les autres, les résultats d’une requêtes complexes pour traitement, définir un curseur (CURSOR)"
  },
  {
    "objectID": "slides/SQL_5.html#extension-de-sql-1",
    "href": "slides/SQL_5.html#extension-de-sql-1",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Extension de SQL",
    "text": "Extension de SQL\nOn doit avoir un mécanisme qui permet conserver les programmes écrits pour les utiliser lors de sessions futures\nLe langage plpgsql permet :\n\nde définir des fonctions et procédures stockées…\nqui vont avoir la même persistence que les tables, vues, etc\nL’existence de ces fonctions, leurs codes, etc, seront conservés dans des tables et vue d’administration (information_schema.routines)."
  },
  {
    "objectID": "slides/SQL_5.html#exemple",
    "href": "slides/SQL_5.html#exemple",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Exemple",
    "text": "Exemple\nSELECT routine_catalog, routine_schema, routine_name, data_type, security_type\nFROM information_schema.routines    #&lt;&lt; \nWHERE routine_type='FUNCTION' AND specific_schema='sakila'   #&lt;&lt; \n\nroutine_catalog|routine_schema|routine_name              |data_type   |security_type|\n---------------+--------------+--------------------------+------------+-------------+\nbd_2023        |sakila        |_group_concat             |text        |INVOKER      |\nbd_2023        |sakila        |film_in_stock             |integer     |INVOKER      |\nbd_2023        |sakila        |film_not_in_stock         |integer     |INVOKER      |\nbd_2023        |sakila        |get_customer_balance      |numeric     |INVOKER      |\nbd_2023        |sakila        |inventory_held_by_customer|integer     |INVOKER      |\nbd_2023        |sakila        |inventory_in_stock        |boolean     |INVOKER      |\nbd_2023        |sakila        |last_day                  |date        |INVOKER      |\nbd_2023        |sakila        |last_updated              |trigger     |INVOKER      |\nbd_2023        |sakila        |rewards_report            |USER-DEFINED|DEFINER      |"
  },
  {
    "objectID": "slides/SQL_5.html#rewards_report-signature",
    "href": "slides/SQL_5.html#rewards_report-signature",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "\nrewards_report signature",
    "text": "rewards_report signature\nCREATE OR REPLACE FUNCTION \n    sakila.rewards_report(min_monthly_purchases integer, \n                          min_dollar_amount_purchased numeric)\n RETURNS SETOF sakila.customer\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    last_month_start DATE;\n    last_month_end DATE;\nrr RECORD;\ntmpSQL TEXT;\nBEGIN\n...\nEND $$ ;\nDétermine la liste des bons clients qui beaucoup consommé durant le dernier mois écoulé"
  },
  {
    "objectID": "slides/SQL_5.html#section-1",
    "href": "slides/SQL_5.html#section-1",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "",
    "text": "la signature comporte une déclaration de type originale\nla déclaration des variables locales mentionne un type fourre-tout\n\nSETOF customer\nTable de même schéma que customer (mêmes colonnes)\nConstruction très très utile : SETOF nom_de_table\nRECORD\nUn type générique (fourre-tout) pour désigner les types composés (en particulier comme les types définis à partir des tables)"
  },
  {
    "objectID": "slides/SQL_5.html#rewards_report-corps-i",
    "href": "slides/SQL_5.html#rewards_report-corps-i",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "\nrewards_report corps (I)",
    "text": "rewards_report corps (I)\nBEGIN\n    /* Some sanity checks... */\n    IF min_monthly_purchases = 0 THEN\n        RAISE EXCEPTION 'Minimum monthly purchases parameter must be &gt; 0';\n    END IF;\n    IF min_dollar_amount_purchased = 0.00 THEN\n        RAISE EXCEPTION 'Minimum monthly dollar amount purchased parameter must be &gt; $0.00';  #&lt;&lt; \n    END IF;\n\n    last_month_start := CURRENT_DATE - '3 month'::interval;\n    last_month_start := to_date((extract(YEAR FROM last_month_start) || '-' || extract(MONTH FROM last_month_start) || '-01'),'YYYY-MM-DD');\n    last_month_end := LAST_DAY(last_month_start);\n...\n\n RAISE EXCEPTION 'msg'\ntermine (en erreur) l’exécution de la fonction envoie un message d’erreur"
  },
  {
    "objectID": "slides/SQL_5.html#rewards_report-corps-ii",
    "href": "slides/SQL_5.html#rewards_report-corps-ii",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "\nrewards_report corps (II)",
    "text": "rewards_report corps (II)\n/*\n    Create a temporary storage area for Customer IDs.\n    */\n    CREATE TEMPORARY TABLE tmpCustomer (customer_id INTEGER NOT NULL PRIMARY KEY);\n\n    /*\n    Find all customers meeting the monthly purchase requirements\n    */\n\n    tmpSQL := 'INSERT INTO tmpCustomer (customer_id)\n        SELECT p.customer_id\n        FROM payment AS p\n        WHERE DATE(p.payment_date) BETWEEN '|| quote_literal(last_month_start) ||' AND '|| quote_literal(last_month_end) || '\n        GROUP BY customer_id\n        HAVING SUM(p.amount) &gt; ' || min_dollar_amount_purchased || \n        'AND COUNT(customer_id) &gt; ' || \n        min_monthly_purchases ;\n\n    EXECUTE tmpSQL;  #&lt;&lt;"
  },
  {
    "objectID": "slides/SQL_5.html#create-temporary-table-...",
    "href": "slides/SQL_5.html#create-temporary-table-...",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "\n CREATE TEMPORARY TABLE ...\n",
    "text": "CREATE TEMPORARY TABLE ...\n\nCrée une table (très simple ici) qui sera détruite avant la fin de l’exécution de la fonction.\nSi l’exécution de la fonction devait être interrompue, cette table ne survivrait pas à la session qui a invoqué la fonction"
  },
  {
    "objectID": "slides/SQL_5.html#pourquoi-utiliser-une-requête-créée-dynamiquement",
    "href": "slides/SQL_5.html#pourquoi-utiliser-une-requête-créée-dynamiquement",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Pourquoi utiliser une requête créée dynamiquement ?",
    "text": "Pourquoi utiliser une requête créée dynamiquement ?\n\nEst ce une nécessité ici ?\nSi non, quel est l’intérêt ?"
  },
  {
    "objectID": "slides/SQL_5.html#rewards_report-corps-iii",
    "href": "slides/SQL_5.html#rewards_report-corps-iii",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "\nrewards_report corps III",
    "text": "rewards_report corps III\n/*\n    Output ALL customer information of matching rewardees.\n    Customize output as needed.\n    */\n    FOR rr IN EXECUTE 'SELECT c.* FROM tmpCustomer AS t INNER JOIN customer AS c ON t.customer_id = c.customer_id' LOOP\n        RETURN NEXT rr;   #&lt;&lt;\n    END LOOP;\n\n    /* Clean up */\n    tmpSQL := 'DROP TABLE tmpCustomer';\n    EXECUTE tmpSQL;\n\nRETURN;   #&lt;&lt;\nEND\n$function$ ;"
  },
  {
    "objectID": "slides/SQL_3.html#limite-de-lalgèbre-relationnelle-pure",
    "href": "slides/SQL_3.html#limite-de-lalgèbre-relationnelle-pure",
    "title": "BD IV: SQL III",
    "section": "Limite de l’algèbre relationnelle pure",
    "text": "Limite de l’algèbre relationnelle pure\nL’algèbre relationnelle pure (σ, π, ⋈) ne sait pas tout calculer.\nCertains problèmes aisément solubles par un langage de programmation complet (Python, C, R, …) ne sont pas solubles dans l’algèbre relationnelle pure :\n\ncompter. Exemple simple : calculer le nombre de lignes d’une table.\ndans une table décrivant une arborescence (une organisation hiérarchisée), déterminer tous les descendants d’un enregistrement."
  },
  {
    "objectID": "slides/SQL_3.html#fonctions-dagrégation-1",
    "href": "slides/SQL_3.html#fonctions-dagrégation-1",
    "title": "BD IV: SQL III",
    "section": "Fonctions d’agrégation ?",
    "text": "Fonctions d’agrégation ?\nPossibilité de compter, de faire des moyennes, de trouver un maximum, … en SQL (contrairement à l’algèbre relationnelle “classique”)."
  },
  {
    "objectID": "slides/SQL_3.html#extension-possible-de-lalgèbre-relationnelle",
    "href": "slides/SQL_3.html#extension-possible-de-lalgèbre-relationnelle",
    "title": "BD IV: SQL III",
    "section": "Extension possible de l’algèbre relationnelle",
    "text": "Extension possible de l’algèbre relationnelle\n\n\n\n\n\n\nIdée\n\n\nIntroduire un opérateur \\(Résume()\\) qui admet comme arguments une table \\(T\\) et une suite d’expressions susceptibles de calculer des agrégats : moyenne, somme, comptage, etc.\nProposition de syntaxe :\n\\(Résume(T, expr_1, ..., expr_k)\\) retourne une table \\(S\\) à une ligne et \\(k\\) colonnes.\nLa colonne \\(i\\) de \\(S\\) contient l’évaluation de \\(expr_i\\) sur la table \\(T\\).\n\n\n\n\n\n\n\n\n\nAvertissement\n\n\nIl n’est pas évident de définir ce que peut être une fonction d’agrégation et un agrégat.\nNous travaillerons à partir d’exemples."
  },
  {
    "objectID": "slides/SQL_3.html#fonctions-dagrégation-sum-et-avg",
    "href": "slides/SQL_3.html#fonctions-dagrégation-sum-et-avg",
    "title": "BD IV: SQL III",
    "section": "Fonctions d’agrégation SUM et AVG\n",
    "text": "Fonctions d’agrégation SUM et AVG\n\n\nSomme des valeurs prises par nomattribut\n\n\nRésume(T, SOMME(nomattribut))\nse traduit en\nSELECT \n  SUM ([DISTINCT|ALL] &lt;nomattribut&gt;)  \nFROM T\n\n\nMoyenne des valeurs prises par nomattribut\n\n\nRésume(T, MOYENNE(nomattribut))\nse traduit en\nSELECT \n  AVG ([DISTINCT|ALL] &lt;nom_attribut&gt;) \nFROM T\n\n\n\n\n\n\nAvertissement\n\n\nLe type de l’attribut doit correspondre à un nombre (cf. spécifications de chaque fonction dans la documentation)."
  },
  {
    "objectID": "slides/SQL_3.html#options-all-et-distinct-des-fonctions-dagrégats",
    "href": "slides/SQL_3.html#options-all-et-distinct-des-fonctions-dagrégats",
    "title": "BD IV: SQL III",
    "section": "Options ALL et DISTINCT des fonctions d’agrégats",
    "text": "Options ALL et DISTINCT des fonctions d’agrégats\nCes options sont disponibles pour toutes les fonctions\nmais sont surtout utiles pour COUNT :\n\nALL, option par défaut : toutes les valeurs de la colonne sont utilisées,\nDISTINCT : les valeurs doublons ne sont utilisées qu’une fois."
  },
  {
    "objectID": "slides/SQL_3.html#exemples-avec-sum-et-avg",
    "href": "slides/SQL_3.html#exemples-avec-sum-et-avg",
    "title": "BD IV: SQL III",
    "section": "Exemples avec SUM et AVG\n",
    "text": "Exemples avec SUM et AVG\n\n\nSomme des populations des villes du pays de code FRA (dans le schéma world).\n\nSELECT SUM(population)  \nFROM city \nWHERE countrycode = 'FRA';\nTraduction de\n\nR1 = σ(city, countrycode = 'FRA')\nR = Résume(R1, SOMME(population))\n\n\n\nMoyenne des populations des villes du continent Europe et Afrique.\n\nSELECT AVG(ci.population)  \nFROM city ci join country co on ci.countrycode = co.countrycode\nWHERE co.continent in ('Afrique','Europe');\nTraduction de\n\nR1 = ⋈(city, country, city.countrycode = country.countrycode)\nR2 = σ(R1, continent in ('Afrique','Europe'))\nR = Résume(R1, avg(population))"
  },
  {
    "objectID": "slides/SQL_3.html#fonctions-de-calcul-max-min",
    "href": "slides/SQL_3.html#fonctions-de-calcul-max-min",
    "title": "BD IV: SQL III",
    "section": "Fonctions de calcul MAX, MIN\n",
    "text": "Fonctions de calcul MAX, MIN\n\n\nmaximum des valeurs prises par &lt;nomattribut&gt; dans T :\n\nSELECT \n  MAX (&lt;nomattribut&gt;)  \nFROM T ;\n\n\nminimum des valeurs prises par &lt;nomattribut&gt; dans T :\n\nSELECT \n  MIN (&lt;nomattribut&gt;)  \nFROM T \n\n\nExemple :\nSELECT max(gnp)   \nFROM country \nWHERE region = 'Caribbean';"
  },
  {
    "objectID": "slides/SQL_3.html#gestion-des-données-manquantes-null",
    "href": "slides/SQL_3.html#gestion-des-données-manquantes-null",
    "title": "BD IV: SQL III",
    "section": "Gestion des données manquantes (NULL)",
    "text": "Gestion des données manquantes (NULL)\n\nEn statistique : données manquantes prises en compte dans les fonctions d’agrégation.\n\nEn SQL : données manquantes ignorées dans les fonctions d’agrégation,\nà l’exception de COUNT(*).\n\n\n\nSELECT name_country, gnpold, gnp\nFROM country\nWHERE continent = 'Europe' AND (gnp IS NULL OR gnpold IS NULL)\nRésultat : 10 lignes.\n\n\nPourtant, ces données manquantes n’empèchent pas le calcul du maximum sur ces colonnes.\nSELECT max(gnpold) AS max_gnpold, max(gnp) AS max_gnp   \nFROM country \nWHERE continent  = 'Europe';\n+-------------+------------+\n|  max_gnpold |  max_gnp   |\n+-------------+------------+\n|  2102826.00 | 2133367.00 |\n+-------------+------------+"
  },
  {
    "objectID": "slides/SQL_3.html#fonction-dagrégat-sur-des-valeurs-toutes-null",
    "href": "slides/SQL_3.html#fonction-dagrégat-sur-des-valeurs-toutes-null",
    "title": "BD IV: SQL III",
    "section": "Fonction d’agrégat sur des valeurs toutes NULL\n",
    "text": "Fonction d’agrégat sur des valeurs toutes NULL\n\n\n\n\n\n\n\nAvertissement\n\n\nQue se passe-t-il si, après une éventuelle sélection, toutes les valeurs de l’agrégat sont NULL ?\nLa valeur calculée est alors NULL, ce qui signifie “pas de valeur”.\nEssayez SELECT MIN(gnpold) FROM country WHERE gnpold IS NULL; !"
  },
  {
    "objectID": "slides/SQL_3.html#fonction-dagrégats-sur-une-table-vide",
    "href": "slides/SQL_3.html#fonction-dagrégats-sur-une-table-vide",
    "title": "BD IV: SQL III",
    "section": "Fonction d’agrégats sur une table vide",
    "text": "Fonction d’agrégats sur une table vide\n\n\n\n\n\n\nAvertissement\n\n\nLes fonctions d’agrégats renvoie un scalaire même sur une table vide.\nPour une table vide, la valeur calculée est NULL.\n\n\n\n\nSELECT \n  SUM(population) AS urban_pop\nFROM city  ci\nWHERE ci.countrycode = 'zzz' ;\n\n\n+-----------+\n| urban_pop |\n|-----------|\n| &lt;null&gt;    |\n+-----------+\nEst-ce cohérent?\nLe résultat signifie : “Pour le pays de code ‘zzz’, pas de données”"
  },
  {
    "objectID": "slides/SQL_3.html#fonctions-de-calcul-count",
    "href": "slides/SQL_3.html#fonctions-de-calcul-count",
    "title": "BD IV: SQL III",
    "section": "Fonctions de calcul : COUNT\n",
    "text": "Fonctions de calcul : COUNT\n\nOn peut aussi compter le nombre de tuples d’une table :\nSELECT \n  COUNT(* |[ALL | DISTINCT] &lt;nomattribut&gt;)  \nFROM T\n-- | pour indiquer une alternative, [ ] pour une option.\n\n\n\n\n\n\nNote\n\n\nOptions de la fonction COUNT :\n\n\n* : compte le nombre de lignes dans la table ou la sous-requête, en incluant les valeurs NULL.\n\nDISTINCT : sans les doublons et sans les valeurs NULL,\n\nALL : avec les doublons mais sans les valeurs NULL,\n\nSi la table est vide, COUNT renvoie 0.\n\n\n\n\nNombre de pays dans la région Carribean\nSELECT COUNT(*)  \nFROM country\nWHERE region = 'Caribbean';"
  },
  {
    "objectID": "slides/SQL_3.html#exemples-dutilisation-des-options-de-la-fonction-count",
    "href": "slides/SQL_3.html#exemples-dutilisation-des-options-de-la-fonction-count",
    "title": "BD IV: SQL III",
    "section": "Exemples d’utilisation des options de la fonction COUNT\n",
    "text": "Exemples d’utilisation des options de la fonction COUNT\n\nSELECT COUNT(*) FROM country;\nretourne 239, le nombre de lignes de la table country.\n\n \nSELECT COUNT (indepyear) FROM country;\nSELECT COUNT (ALL indepyear) FROM country;\nretournent 192, le nombre de valeurs non NULL de la colonne indepyear.\n\n\n \nSELECT COUNT (DISTINCT indepyear) FROM country;\nretourne 88, le nombre de valeurs disctintes et non NULL de la colonne indepyear.\n\n\n \nSELECT COUNT(*) FROM (SELECT indepyear FROM country) as T;\nretourne 239 car T contient une seule colonne avec 239 lignes, les 47 lignes NULL sont comptées comme les autres."
  },
  {
    "objectID": "slides/SQL_3.html#opérations-sur-des-fonctions-dagrégats",
    "href": "slides/SQL_3.html#opérations-sur-des-fonctions-dagrégats",
    "title": "BD IV: SQL III",
    "section": "Opérations sur des fonctions d’agrégats",
    "text": "Opérations sur des fonctions d’agrégats\nPNB moyen par habitant du continent South America\nSELECT \n  ROUND(SUM(1e6*gnp)/SUM(population_country),2) as pnb_avg\nFROM \n  country \nWHERE \n  continent = 'South America';\nRésultat : 4372,36\n\n\n\n\n\n\nNote\n\n\n\\(10^6\\) s’écrit 1e6. On a écrit 1e6*gnp car gnp est exprimé en millions de USD.\nROUND(x,s) effectue un arrondi de x avec s chiffres après la virgule. s négatif accepté.\nDocumentation des fonctions mathématiques"
  },
  {
    "objectID": "slides/SQL_3.html#fonctions-dagrégats-sur-des-opérations",
    "href": "slides/SQL_3.html#fonctions-dagrégats-sur-des-opérations",
    "title": "BD IV: SQL III",
    "section": "Fonctions d’agrégats sur des opérations",
    "text": "Fonctions d’agrégats sur des opérations\n\n\n\n\n\n\nNote\n\n\nLes fonctions d’agrégats peuvent s’appliquer à des opérations arithmétiques entre les différents attributs d’un même tuple…\n\n\n\n\nMoyenne des PNB/habitant des pays du continent ‘South America’. A ne pas confondre avec la requête précédente !\nSELECT \n  ROUND(AVG(1e6*gnp/population_country),2) as pnb_country_avg\nFROM country \nWHERE \n  continent = 'South America' AND population_country &gt; 0 ;\n-- Le test population_country &gt; 0 évite les divisions par 0\nRésultat : 3176,44"
  },
  {
    "objectID": "slides/SQL_3.html#utilisation-de-case-when-...then-...-else-...",
    "href": "slides/SQL_3.html#utilisation-de-case-when-...then-...-else-...",
    "title": "BD IV: SQL III",
    "section": "Utilisation de CASE WHEN ...THEN ... ELSE ...\n",
    "text": "Utilisation de CASE WHEN ...THEN ... ELSE ...\n\nSELECT \n  SUM(\n    CASE \n      WHEN countrycode='GBR' THEN population \n      ELSE 0 \n    END) AS urban_pop \n FROM city ;\n+-----------+\n| urban_pop |\n|-----------|\n| 22436673  |\n+-----------+"
  },
  {
    "objectID": "slides/SQL_3.html#gestion-des-valeurs-manquantes-avec-case-when-...then-...-else-...",
    "href": "slides/SQL_3.html#gestion-des-valeurs-manquantes-avec-case-when-...then-...-else-...",
    "title": "BD IV: SQL III",
    "section": "Gestion des valeurs manquantes avec CASE WHEN ...THEN ... ELSE ...\n",
    "text": "Gestion des valeurs manquantes avec CASE WHEN ...THEN ... ELSE ...\n\nSELECT \n  AVG(\n    CASE \n      WHEN gnpold IS NOT NULL THEN gnpold \n      ELSE 0 \n    END)::NUMERIC(8,2) AS avg_gnpold \n FROM world.country \n WHERE continent = 'Europe';\nRetourne 203956,54\nSELECT \n  AVG(gnpold)::NUMERIC(8,2) AS avg_gnpold \n FROM world.country \n WHERE continent = 'Europe';\nRetourne 260611,14"
  },
  {
    "objectID": "slides/SQL_3.html#autres-possibilités-avec-case-when-...then-...-else-...",
    "href": "slides/SQL_3.html#autres-possibilités-avec-case-when-...then-...-else-...",
    "title": "BD IV: SQL III",
    "section": "Autres possibilités avec CASE WHEN ...THEN ... ELSE ...\n",
    "text": "Autres possibilités avec CASE WHEN ...THEN ... ELSE ...\n\nSELECT \n  SUM(CASE \n    WHEN governmentform LIKE '%Monarchy%' THEN population_COUNTRY \n    ELSE 0    -- résultat identique si on enlève cette ligne\n  END) AS pop_monarch,  \n  SUM(CASE \n    WHEN governmentform LIKE '%Republic%' THEN population_COUNTRY \n    ELSE 0   -- résultat identique si on enlève cette ligne\n  END) AS pop_repu \nFROM country ;\n+-------------+------------+\n| pop_monarch | pop_repu   |\n|-------------+------------|\n| 519485000   | 5502453700 |\n+-------------+------------+"
  },
  {
    "objectID": "slides/SQL_3.html#agrégats-sur-des-données-filtrées-filter-where-condition",
    "href": "slides/SQL_3.html#agrégats-sur-des-données-filtrées-filter-where-condition",
    "title": "BD IV: SQL III",
    "section": "Agrégats sur des données filtrées FILTER (WHERE condition)\n",
    "text": "Agrégats sur des données filtrées FILTER (WHERE condition)\n\nAvec une clause FILTER, la fonction d’agrégation n’utilise que les tuples vérifiant la condition.\n\n\nSELECT \n  SUM(population_country) FILTER  \n    (WHERE governmentform LIKE '%Monarchy%') AS pop_monarch,  \n  SUM(population_country) FILTER \n    (WHERE governmentform LIKE '%Republic%') AS pop_repu \nFROM country ;\n\n+-------------+------------+\n| pop_monarch | pop_repu   |\n|-------------+------------|\n| 519485000   | 5502453700 |\n+-------------+------------+\n\n\n\n\n\n\n\n\nMise en garde\n\n\nIl est plus conforme à l’algèbre relationnelle et au SQL d’organiser les données en lignes.\n\n\n\n\n\nSELECT 'Monarchy' as governmentform, SUM(population_country) as population    \nFROM world.country c\nWHERE c.governmentform LIKE '%Monarchy%'\nUNION\nSELECT 'Republic' as governmentform, SUM(population_country) as population    \nFROM world.country c\nWHERE c.governmentform LIKE '%Republic%';\n\n+----------------+------------+\n| governmentform | population |\n|----------------+------------|\n| Monarchy       |  519485000 |\n|----------------+------------|\n| Republic       | 5502453700 |\n+----------------+------------+"
  },
  {
    "objectID": "slides/SQL_3.html#problèmes-defficacité",
    "href": "slides/SQL_3.html#problèmes-defficacité",
    "title": "BD IV: SQL III",
    "section": "Problèmes d’efficacité",
    "text": "Problèmes d’efficacité\nNom des régions comportant plus de \\(15\\) pays.\n\nLa requête suivante est à éviter :\nSELECT DISTINCT c.region \nFROM country c \nWHERE (\n  SELECT COUNT (*)     \n  FROM country co     \n  WHERE co.region = c.region\n) &gt;= 15\nORDER BY c.region;  \n5 lignes.\n\n\n\n\n\n\nMise en garde\n\n\nY-a-t-il des calculs effectués plusieurs fois sur les mêmes données ?"
  },
  {
    "objectID": "slides/SQL_3.html#efficacité",
    "href": "slides/SQL_3.html#efficacité",
    "title": "BD IV: SQL III",
    "section": "Efficacité",
    "text": "Efficacité\n On peut faire plus efficace, gràce à la suite du cours :\nSELECT region    \nFROM country     \nGROUP BY region\nHAVING COUNT(*) &gt;= 15\nORDER BY region;"
  },
  {
    "objectID": "slides/SQL_3.html#pour-en-savoir-plus",
    "href": "slides/SQL_3.html#pour-en-savoir-plus",
    "title": "BD IV: SQL III",
    "section": "Pour en savoir plus ?",
    "text": "Pour en savoir plus ?\nDocumentation PostgreSQL"
  },
  {
    "objectID": "slides/SQL_3.html#partition-de-résultats-de-requêtes",
    "href": "slides/SQL_3.html#partition-de-résultats-de-requêtes",
    "title": "BD IV: SQL III",
    "section": "Partition de résultats de requêtes",
    "text": "Partition de résultats de requêtes\nGROUP BY &lt;nomattribut1&gt;, ..., &lt;nomattributn&gt;\n\nGROUP BY permet de regrouper l’ensemble des résultats d’une requête selon la valeur de certains attributs,\nForme des sous-relations auxquelles on peut appliquer des fonctions d’agrégation (SUM, MAX, …) renvoyant un résultat par sous-relation.\n\n\n\n\n\n\n\n\nAvertissement\n\n\nGestion des valeurs manquantes : les valeurs NULLd’un attribut forment un groupe dans la partition selon celui-ci."
  },
  {
    "objectID": "slides/SQL_3.html#utilisation-group-by",
    "href": "slides/SQL_3.html#utilisation-group-by",
    "title": "BD IV: SQL III",
    "section": "Utilisation GROUP BY\n",
    "text": "Utilisation GROUP BY\n\nCalculer la population de chaque continent.\nSELECT continent, SUM(population_country) as population_continent\nFROM country \nGROUP BY continent;    \n+--------------+----------------------+\n| continent    | population_continent |\n+--------------+----------------------+\n|Asia          |          3705025700  |\n|South America |           345780000  |\n|North America |           482993000  |\n|Oceania       |            30401150  |\n|Antarctica    |                   0  |\n|Africa        |           784475000  |\n|Europe        |           730074600  |\n+--------------+----------------------+\n\n\n\n\n\n\n\nImportant\n\n\nOn peut afficher continent pour chaque groupe parce qu’on a groupé selon cet attribut"
  },
  {
    "objectID": "slides/SQL_3.html#exemple-avec-group-by",
    "href": "slides/SQL_3.html#exemple-avec-group-by",
    "title": "BD IV: SQL III",
    "section": "Exemple avec GROUP BY\n",
    "text": "Exemple avec GROUP BY\n\nQuel est le gnp moyen, le gnp maximum et le gnp minimum par region sur le continent Europe en milliers de USD par habitant ?\n\nSELECT region, \n     ROUND(1000 * SUM(gnp)/SUM(population_country),2) AS avg_gnp,  \n     ROUND(MAX(1000* gnp/population_country),2) AS max_gnp, \n     ROUND(MIN(1000* gnp/population_country),2) AS min_gnp,\nFROM country \nWHERE continent = 'Europe' \nGROUP BY region \nORDER BY avg_gnp DESC;\n+----------------+---------+---------+---------+\n| region         | avg_gnp | max_gnp | min_gnp |\n+----------------+---------+---------+---------+\n|Nordic Countries|   28.00 |   32.66 |    0.00 |\n|Western Europe  |   25.50 |   37.46 |   22.82 | \n|British Islands |   22.94 |   23.12 |   20.11 | \n|Southern Europe |   13.91 |   20.90 |    0.72 | \n|Baltic Countries|    2.96 |    3.70 |    2.64 |\n|Eastern Europe  |    2.15 |    5.35 |    0.36 |\n+----------------+---------+---------+---------+"
  },
  {
    "objectID": "slides/SQL_3.html#précautions-avec-group-by",
    "href": "slides/SQL_3.html#précautions-avec-group-by",
    "title": "BD IV: SQL III",
    "section": "Précautions avec GROUP BY\n",
    "text": "Précautions avec GROUP BY\n\nPour chaque région, indiquer le continent, la région et la population du pays le plus peuplé.\nLa requête suivante n’est pas correcte\nSELECT continent, region, MAX(population_country) \nFROM country \nGROUP BY region;\n\n\n\n\n\n\n\nImportant\n\n\nLes attributs présents dans le SELECT doivent impérativement être présents dans le GROUP BY pour s’assurer qu’ils sont communs à tous les tuples de chaque groupe."
  },
  {
    "objectID": "slides/SQL_3.html#comment-afficher-un-attribut-absent-de-group-by",
    "href": "slides/SQL_3.html#comment-afficher-un-attribut-absent-de-group-by",
    "title": "BD IV: SQL III",
    "section": "Comment afficher un attribut absent de GROUP BY ?",
    "text": "Comment afficher un attribut absent de GROUP BY ?\nPour chaque continent, indiquer le nom et la population du (des) pays le(s) plus peuplé(s).\n\n\n\n\n\n\n\nMise en garde\n\n\nOn ne peut pas utiliser une seule requête puisqu’on veut afficher les pays sans grouper selon les pays. Il faut donc faire les calculs d’agrégats dans une sous-requête.\nPréférez les CTEs (ou éventuellement les requêtes imbriquées dans FROM), plus efficaces que les requêtes imbriquées dans WHERE qui sont ré-exécutées inutilement."
  },
  {
    "objectID": "slides/SQL_3.html#solution",
    "href": "slides/SQL_3.html#solution",
    "title": "BD IV: SQL III",
    "section": "Solution",
    "text": "Solution\nWITH pmc AS\n  (SELECT continent, MAX(population_country) AS pop_max\n  FROM country\n  GROUP BY continent)\nSELECT c.continent, c.name_country AS country_max_pop, c.population_country AS population\nFROM country c JOIN pmc ON c.continent = pmc.continent\nWHERE c.population_country = pmc.pop_max\nORDER BY pmc.pop_max DESC;\n+---------------+----------------------------------------------+------------+\n| continent     | country_max_pop                              | population |\n+---------------+----------------------------------------------+------------+\n| Asia          | China                                        | 1277558000 |\n| North America | United States                                |  278357000 |\n| South America | Brazil                                       |  170115000 |\n| Europe        | Russian Federation                           |  146934000 |\n| Africa        | Nigeria                                      |  111506000 |\n| Oceania       | Australia                                    |   18886000 |\n| Antarctica    | Antarctica                                   |          0 |\n| Antarctica    | Bouvet Island                                |          0 |\n| Antarctica    | South Georgia and the South Sandwich Islands |          0 |\n| Antarctica    | Heard Island and McDonald Islands            |          0 |\n| Antarctica    | French Southern territories                  |          0 |\n+---------------+----------------------------------------------+------------+"
  },
  {
    "objectID": "slides/SQL_3.html#sous-partitionnements",
    "href": "slides/SQL_3.html#sous-partitionnements",
    "title": "BD IV: SQL III",
    "section": "Sous-partitionnements",
    "text": "Sous-partitionnements\nQue fait cette requête ?\nWITH \n  co_urb_rate AS\n  (\n    SELECT co.countrycode, co.name_country, co.continent, SUM(ci.population)/(co.population_country::numeric) AS urb_rate\n    FROM world.country co JOIN world.city ci ON co.countrycode = ci.countrycode\n    WHERE co.population_country &gt; 0\n    GROUP BY co.countrycode, co.name_country, co.continent\n  ),\n  cont_max_ur AS \n  (\n    SELECT continent, MAX(urb_rate) AS max_ur\n    FROM co_urb_rate\n    GROUP BY continent\n  )\nSELECT \n  co.continent, \n  co.name_country, \n  round(co.urb_rate,2)\nFROM co_urb_rate co JOIN cont_max_ur ct ON co.urb_rate = ct.max_ur;"
  },
  {
    "objectID": "slides/SQL_3.html#aller-plus-loin-que-group-by",
    "href": "slides/SQL_3.html#aller-plus-loin-que-group-by",
    "title": "BD IV: SQL III",
    "section": "Aller plus loin que GROUP BY ?",
    "text": "Aller plus loin que GROUP BY ?\n\n\n\n\n\n\nNote\n\n\nL’opération GROUP BY ne renvoie pas une table mais (implicitement) une collection de sous-tables indicées/étiquetées par les valeurs des attributs de groupement.\nL’opération GROUP BY ne peut pas s’intégrer dans une algèbre relationnelle, même étendue.\n\n\n\n\n\n\n\n\n\nMise en garde\n\n\nSQL n’offre pas de moyen d’utiliser le partitionnement effectué par GROUP BY autrement que pour effectuer des calculs d’agrégats et/ou une projection sur les attributs de groupement.\n\n\n\nCette requête n’est pas valide :\n\nSELECT *  \nFROM country \nGROUP BY continent ;\n\nCette requête est valide :\nSELECT continent  \nFROM country \nGROUP BY continent ;"
  },
  {
    "objectID": "slides/SQL_3.html#sélection-sur-les-groupes-having",
    "href": "slides/SQL_3.html#sélection-sur-les-groupes-having",
    "title": "BD IV: SQL III",
    "section": "Sélection sur les groupes HAVING\n",
    "text": "Sélection sur les groupes HAVING\n\n\nLa clause HAVING permet de poser une condition portant sur chacune des sous-relations générées par le GROUP BY,\nLes sous-relations ne vérifiant pas la condition sont écartées du résultat.\n\nListe des continents comportant au moins cinq régions.\nSELECT continent \nFROM country \nGROUP BY continent    \nHAVING COUNT(DISTINCT region) &gt;= 5;"
  },
  {
    "objectID": "slides/SQL_3.html#tri-de-résultats-order-by",
    "href": "slides/SQL_3.html#tri-de-résultats-order-by",
    "title": "BD IV: SQL III",
    "section": "Tri de résultats ORDER BY\n",
    "text": "Tri de résultats ORDER BY\n\nLa clause ORDER BY permet de trier le résultat de la requête, en fournissant la liste des attributs sur lesquels effectuer le tri et en spécifiant le sens du tri pour chacun d’eux (ASC ou DESC).\n\n\n\n\n\n\nMise en garde\n\n\nL’ordre par défaut est ASC.\n\n\n\nListe des pays triés par ordre décroissant de population\nSELECT * \nFROM country \nORDER BY population_country DESC;  \n\n\n\n\n\n\nAvertissement\n\n\nQue se passe-t-il avec les valeurs nulles ?\nLe comportement dépend du serveur. PostgreSQL et Oracle les classent comme plus grandes que toutes les autres. SQL Server (Microsoft), MySQL, SQLite font l’inverse."
  },
  {
    "objectID": "slides/SQL_3.html#ordre-des-opérations-where-group-by-having-order-by",
    "href": "slides/SQL_3.html#ordre-des-opérations-where-group-by-having-order-by",
    "title": "BD IV: SQL III",
    "section": "Ordre des opérations WHERE, GROUP BY, HAVING, ORDER BY\n",
    "text": "Ordre des opérations WHERE, GROUP BY, HAVING, ORDER BY\n\n\n\n\n\n\n\nImportant\n\n\n\nla sélection des tuples (WHERE),\npuis le partitionnement (GROUP BY),\npuis la sélection sur les groupes (HAVING),\nenfin le tri des résultats (ORDER BY) .\n\n\n\n\nQue fait cette requête ?\nSELECT continent, COUNT(*) \nFROM country \nWHERE countrycode IN (\n  SELECT countrycode \n  FROM countrylanguage \n  WHERE language='English' AND percentage &gt; 10 \n) \nGROUP BY continent \nHAVING AVG(1e6*gnpold/population_country) &gt;= 1000 \nORDER BY continent;"
  },
  {
    "objectID": "slides/SQL_3.html#principe-des-fonctions-fenêtres",
    "href": "slides/SQL_3.html#principe-des-fonctions-fenêtres",
    "title": "BD IV: SQL III",
    "section": "Principe des fonctions fenêtres",
    "text": "Principe des fonctions fenêtres\nUne fonction fenêtre effectue une partition puis un calcul sur le groupe de lignes (“une fenêtre”) auquel la ligne courante appartient.\nDocumentation PostgreSQL\n\n\n\n\n\n\n\nNote\n\n\nC’est comparable au type de calcul effectué avec une fonction d’agrégation.\n\n\n\n\n\nMais les fonctions de fenêtre permettent de faire des calculs différents de ceux réalisés avec GROUP BY.\n\nAvec GROUP BY, le résultat rassemble les lignes d’un même groupe en une seule.\nAvec les fonctions fenêtres, chaque ligne de la table reste présente dans le résultat."
  },
  {
    "objectID": "slides/SQL_3.html#fonctions-fenêtres",
    "href": "slides/SQL_3.html#fonctions-fenêtres",
    "title": "BD IV: SQL III",
    "section": "Fonctions fenêtres",
    "text": "Fonctions fenêtres\nSoit f est une fonction d’agrégation (SUM, AVG, MAX, MIN, COUNT, etc.)\n\nf(...) OVER (PARTITION BY attribut),  \n\neffectue le calcul sur le groupe de lignes auquel appartient la ligne courante après un partitionnement selon attribut (la “fenêtre” de la ligne courante)."
  },
  {
    "objectID": "slides/SQL_3.html#exemple-de-fonctions-fenêtres",
    "href": "slides/SQL_3.html#exemple-de-fonctions-fenêtres",
    "title": "BD IV: SQL III",
    "section": "Exemple de fonctions fenêtres",
    "text": "Exemple de fonctions fenêtres\nPrésenter pour chaque pays dont la région comprend le motif Countries, l’espérance de vie du pays et les espérance de vie maximale et minimale des pays de la région.\n\n\nSELECT region, name_country, lifeexpectancy, \n     min(lifeexpectancy) OVER (PARTITION BY region),  \n     max(lifeexpectancy) OVER (PARTITION BY region)   \nFROM country \nWHERE region LIKE '%Countries'\nORDER BY region, lifeexpectancy  \nLIMIT 6 ;\n\n+------------------+-----------------+---------------+-----+-----+\n| Region           | Name of country |Life expectancy| min | max |\n+------------------+-----------------+---------------+-----+-----+\n| Baltic Countries | Latvia          |          68.4 | 68.4| 69.5|\n| Baltic Countries | Lithuania       |          69.1 | 68.4| 69.5|\n| Baltic Countries | Estonia         |          69.5 | 68.4| 69.5|\n| Nordic Countries | Denmark         |          76.5 | 76.5| 79.6|\n| Nordic Countries | Finland         |          77.4 | 76.5| 79.6|\n| Nordic Countries | Faroe Islands   |          78.4 | 76.5| 79.6|\n+------------------+-----------------+---------------+-----+-----+\n\n\n\n\n\n\nNote\n\n\nAvec des fonctions d’agrégation sur un partitionnement par GROUP BY region, il n’était pas possible d’afficher une ligne par pays."
  },
  {
    "objectID": "slides/SQL_3.html#sans-utiliser-over-...",
    "href": "slides/SQL_3.html#sans-utiliser-over-...",
    "title": "BD IV: SQL III",
    "section": "Sans utiliser OVER (...)\n",
    "text": "Sans utiliser OVER (...)\n\nPour calculer ce résultat sans fonctions fenêtres :\n\nOn effectue une partition selon la region, une aggrégation par groupe pour calculer min(lifeexpectancy) et max(lifeexpectancy). On obtient une table à trois colonnes.\nOn calcule une (équi)-jointure avec la table country originelle sur la colonne commune region.\nOn projette le résultat sur les cinq colonnes pertinentes.\n\n\n\nWITH R AS (\n  SELECT region, min(lifeexpectancy) AS minlex, max(lifeexpectancy) AS maxlex\n  FROM country\n  WHERE region LIKE '%Countries' AND lifeexpectancy IS NOT NULL \n  GROUP BY region\n)\n\nSELECT region, name_country, lifeexpectancy, minlex, maxlex\nFROM country co NATURAL JOIN R"
  },
  {
    "objectID": "slides/SQL_3.html#fonctions-fenêtres-avec-une-clause-order-by",
    "href": "slides/SQL_3.html#fonctions-fenêtres-avec-une-clause-order-by",
    "title": "BD IV: SQL III",
    "section": "Fonctions fenêtres avec une clause ORDER BY\n",
    "text": "Fonctions fenêtres avec une clause ORDER BY\n\n\n\n\n\n\n\nImportant\n\n\nAvec une clause ORDER BY, la fenêtre est restreinte aux lignes qui précèdent la ligne courante (selon l’ordre indiqué dans ORDER BY), après partitionnement.\nLa ligne courante est incluse dans le calcul.\n\n\n\n\n\n\nOn ajoute ORDER BY lifeexpectancy à l’exemple précédent :\nSELECT region, name_country, lifeexpectancy, \n     min(lifeexpectancy) OVER (PARTITION BY region ORDER BY lifeexpectancy),  \n     max(lifeexpectancy) OVER (PARTITION BY region ORDER BY lifeexpectancy)   \nFROM world.country \nWHERE region LIKE '%Countries'\nORDER BY region, lifeexpectancy ;\n\nLes 3 premières lignes :\n|name_country |lifeexpecta|min |max |\n|-------------|-----------|----|----|\n|Latvia       |68,4       |68,4|68,4|\n|Lithuania    |69,1       |68,4|69,1|\n|Estonia      |69,5       |68,4|69,5|\n...\n\n\n\n\n\n\n\n\n\nNote\n\n\nLa colonne min n’a pas changé car la première ligne de la fenêtre contient la valeur minimale de la fenêtre puisqu’on a fait ORDER BY lifeexpectancy.\nLa colonne max a changé. Elle est maintenant identique à la colonne lifeexpectancy car la ligne courante contient la valeur maximale parmi les lignes qui la précèdent dans “la fenêtre” selon l’ordre lifeexpectancy."
  },
  {
    "objectID": "slides/SQL_3.html#exemple-de-fonction-fenêtre-avec-une-clause-order-by",
    "href": "slides/SQL_3.html#exemple-de-fonction-fenêtre-avec-une-clause-order-by",
    "title": "BD IV: SQL III",
    "section": "Exemple de fonction fenêtre avec une clause ORDER BY\n",
    "text": "Exemple de fonction fenêtre avec une clause ORDER BY\n\nrow_number() : fonction d’agrégation qui retourne le numéro de la ligne dans la fenêtre.\n\nPour les pays d’Asie, lister la région, le nom du pays, le rang du pays dans sa région pour l’espérance de vie et le rang du pays dans sa région pour le PNB par habitant.\n\n\nSELECT region, name_country, \n  row_number() OVER (\n    PARTITION BY region   \n    ORDER BY lifeexpectancy DESC\n  ) AS rk_lifeexpectancy,\n  row_number() OVER (\n    PARTITION BY region   \n    ORDER BY gnp / population_country DESC\n  ) AS rk_gnp \nFROM world.country \nWHERE continent LIKE 'Asi%' and lifeexpectancy IS NOT NULL and gnp IS NOT NULL\nORDER BY region, lifeexpectancy DESC;\n\n\n\n\n\n\nAvertissement\n\n\nDans cette requête, il faut rejeter les valeurs NULL sinon le rang n’aurait pas de sens (ces lignes seraient en tête)."
  },
  {
    "objectID": "slides/SQL_3.html#sommes-cumulées-par-groupes-selon-un-ordre",
    "href": "slides/SQL_3.html#sommes-cumulées-par-groupes-selon-un-ordre",
    "title": "BD IV: SQL III",
    "section": "Sommes cumulées par groupes selon un ordre",
    "text": "Sommes cumulées par groupes selon un ordre\nAvec une clause ORDER BY, une fonction fenêtre SUM() effectue une somme cumulée selon l’ordre choisi.\n\nCalculer, pour chaque pays d’Europe, le pourcentage des PNB supérieur ou égal à celui du pays parmi ceux de sa région.\n\n\nSELECT \n  region, name_country,  \n  ROUND(SUM(gnp) OVER (\n    PARTITION BY region  \n  ORDER BY gnp DESC) \n  / sum(gnp) OVER (\n    PARTITION BY region), 4)*100  \n  AS pc_sum_GNP    \nFROM world.country c \nWHERE continent = 'Europe'\norder by region, gnp DESC;"
  },
  {
    "objectID": "slides/SQL_3.html#limites-dutilisation-des-fonctions-fenêtres",
    "href": "slides/SQL_3.html#limites-dutilisation-des-fonctions-fenêtres",
    "title": "BD IV: SQL III",
    "section": "Limites d’utilisation des fonctions fenêtres",
    "text": "Limites d’utilisation des fonctions fenêtres\n\n\n\n\n\n\nAvertissement\n\n\nLes fonctions de fenêtre ne sont autorisées que dans les clauses SELECT et ORDER BY de la requête.\nElles sont interdites ailleurs, par exemple dans les clauses GROUP BY, HAVING et WHERE.\nEn effet, elles s’exécutent logiquement après le traitement de ces clauses.\n\n\n\n\n\n\n\n\n\n\nMise en garde\n\n\nDe même, les fonctions de fenêtre s’exécutent après les fonctions d’agrégation habituelles.\nCela signifie qu’il est pertinent d’inclure un appel de fonction d’agrégation dans les arguments d’une fonction de fenêtre, mais pas l’inverse."
  },
  {
    "objectID": "slides/SQL_3.html#sous-requête-avec-des-fonctions-fenêtres",
    "href": "slides/SQL_3.html#sous-requête-avec-des-fonctions-fenêtres",
    "title": "BD IV: SQL III",
    "section": "Sous-requête avec des fonctions fenêtres",
    "text": "Sous-requête avec des fonctions fenêtres\nPour chaque continent, afficher les trois pays ayant l’espérance de vie à la naissance la plus élevée.\n\nSELECT continent, \n  name_country, \n  lifeexpectancy, \n  pos\nFROM\n  (SELECT continent, \n    name_country, \n    lifeexpectancy,\n    rank() OVER (\n      PARTITION BY continent \n      ORDER BY lifeexpectancy DESC) AS pos\n  FROM country\n  WHERE lifeexpectancy IS NOT NULL\n  ) AS ws\nWHERE pos &lt;= 3;"
  },
  {
    "objectID": "slides/SQL_3.html#autre-écriture-avec-with-...-et-les-ctes",
    "href": "slides/SQL_3.html#autre-écriture-avec-with-...-et-les-ctes",
    "title": "BD IV: SQL III",
    "section": "Autre écriture avec WITH ... et les CTEs",
    "text": "Autre écriture avec WITH ... et les CTEs\nWITH ws AS (\n  SELECT continent, \n    name_country, \n    lifeexpectancy,\n    rank() OVER (\n      PARTITION BY continent \n      ORDER BY lifeexpectancy DESC) AS pos\n  FROM country\n  WHERE lifeexpectancy IS NOT NULL\n) \nSELECT continent, \n  name_country, \n  lifeexpectancy, \n  pos\nFROM ws   \nWHERE pos &lt;= 3;"
  },
  {
    "objectID": "slides/SQL_3.html#autre-exemple-de-sous-requête-avec-des-fonctions-fenêtres",
    "href": "slides/SQL_3.html#autre-exemple-de-sous-requête-avec-des-fonctions-fenêtres",
    "title": "BD IV: SQL III",
    "section": "Autre exemple de sous-requête avec des fonctions fenêtres",
    "text": "Autre exemple de sous-requête avec des fonctions fenêtres\nAfficher les 10 pays les plus peuplés\n\nWITH S AS (        \n  SELECT c.*, rank() \n    OVER (ORDER BY population_country DESC) AS rpc  \n  FROM world.country c\n)\n\nSELECT name_country, continent, population_country\nFROM S   \nWHERE rpc &lt;= 10 \nORDER BY rpc DESC;\n\n\n------------------+-------------+------------------+\nname_country      |continent    |population_country|\n------------------+-------------+------------------+\nChina             |Asia         |        1277558000|\nIndia             |Asia         |        1013662000|\nUnited States     |North America|         278357000|\nIndonesia         |Asia         |         212107000|\nBrazil            |South America|         170115000|\nPakistan          |Asia         |         156483000|\nRussian Federation|Europe       |         146934000|\nBangladesh        |Asia         |         129155000|\nJapan             |Asia         |         126714000|\nNigeria           |Africa       |         111506000|"
  },
  {
    "objectID": "slides/SQL_3.html#différentes-alternatives-pour-une-même-requête",
    "href": "slides/SQL_3.html#différentes-alternatives-pour-une-même-requête",
    "title": "BD IV: SQL III",
    "section": "Différentes alternatives pour une même requête",
    "text": "Différentes alternatives pour une même requête\nAfficher le pays le plus peuplé\n\n\n\nSELECT S.name_country, \n  S.continent, \n  S.population_country\nFROM (\n  SELECT max(population_country) AS mpc \n  FROM country c\n  ) AS R \n  JOIN LATERAL (    \n    SELECT * \n    FROM country c2 \n    WHERE c2.population_country &gt;= R.mpc\n    ) AS S \n  ON (TRUE) ;\n\nSELECT c.name_country, \n       c.continent, \n       c.population_country\nFROM (\n  SELECT max(population_country) AS mpc \n  FROM country c2\n  ) AS S\n  JOIN country c \n  ON (c.population_country &gt;= S.mpc)    \n;\n\nname_country|continent|population_country|\n------------+---------+------------------+\nChina       |Asia     |        1277558000|"
  },
  {
    "objectID": "slides/SQL_3.html#différentes-alternatives-suite",
    "href": "slides/SQL_3.html#différentes-alternatives-suite",
    "title": "BD IV: SQL III",
    "section": "Différentes alternatives (suite)",
    "text": "Différentes alternatives (suite)\nAfficher le pays le plus peuplé\n\n\nSELECT * \nFROM world.country c  \nWHERE population_country &gt;= ALL(\n  SELECT cc.population_country  \n  FROM world.country  cc\n) ;     \n\nWITH S AS (        \n  SELECT c.*, max(population_country) \n         OVER () AS mpc  \n  FROM world.country c\n)\nSELECT * \nFROM S   \nWHERE population_country &gt;= mpc ;\n\nname_country|continent|population_country|\n------------+---------+------------------+\nChina       |Asia     |        1277558000|"
  },
  {
    "objectID": "slides/SQL_3.html#introduction",
    "href": "slides/SQL_3.html#introduction",
    "title": "BD IV: SQL III",
    "section": "Introduction",
    "text": "Introduction\nIntroduits dans SQL avec la mode du Data mining (Fouille de données) dans les années 1990.\nPermet de réaliser de facon apparemment simultanée des aggrégations de régularités emboîtées.\nDans le monde des statistiques, lorsqu’on aggrège des comptages de grains différents, on parle de tables de contingences (contingency tables).\nDocumentation PostgreSQL"
  },
  {
    "objectID": "slides/SQL_3.html#rollup",
    "href": "slides/SQL_3.html#rollup",
    "title": "BD IV: SQL III",
    "section": "ROLLUP",
    "text": "ROLLUP\nROLLUP ( a, b, c, ... )\nest un raccourci pour\nGROUPING SETS (\n    ( a, b, c, ... ),\n    ...\n    ( a, b ),\n    ( a ),\n    ( )\n)"
  },
  {
    "objectID": "slides/SQL_3.html#exemple-avec-rollup",
    "href": "slides/SQL_3.html#exemple-avec-rollup",
    "title": "BD IV: SQL III",
    "section": "Exemple avec ROLLUP\n",
    "text": "Exemple avec ROLLUP\n\n\nSELECT continent, region, max(lifeexpectancy)\nFROM country c \nWHERE continent LIKE '%America'\nGROUP BY ROLLUP  (continent, region)  \nORDER BY continent, region ;\n\n+-------------+---------------+----+\n|Continent    |Region         |max |\n+-------------+---------------+----+\n|North America|Caribbean      |78.9|\n|North America|Central America|75.8|\n|North America|North America  |79.4|\n|North America|               |79.4|\n|South America|South America  |76.1|\n|South America|               |76.1|\n|             |               |79.4|"
  },
  {
    "objectID": "slides/SQL_3.html#grouping-sets",
    "href": "slides/SQL_3.html#grouping-sets",
    "title": "BD IV: SQL III",
    "section": "GROUPING SETS",
    "text": "GROUPING SETS\nUn GROUPING SETS permet d’effectuer simultanément des calculs d’agrégats pour différentes partitions de la table.\nIl s’écrit dans la clause GROUP BY avec une liste d’ensemble d’attributs de la forme ((c1,c2), (c1), (c2)).\nGROUP BY GROUPING SETS ((c1,c2), (c1), ())\nsignifie que l’on fera les calculs d’agrégats successivement pour les regroupements selon c1,c2, puis pour les regroupements selon c1, puis sans regroupement.\nDans le résultat, lorsque le partitionnement selon c1 est effectué, la colonne c2 a la valeur NULL (i.e. pas de valeur), ce qui cohérent avec le fonctionnement de GROUP BY."
  },
  {
    "objectID": "slides/SQL_3.html#exemple-avec-grouping-sets",
    "href": "slides/SQL_3.html#exemple-avec-grouping-sets",
    "title": "BD IV: SQL III",
    "section": "Exemple avec GROUPING SETS\n",
    "text": "Exemple avec GROUPING SETS\n\nSELECT continent, region, max(lifeexpectancy)\nFROM country c \nWHERE continent LIKE '%America'\nGROUP BY GROUPING SETS  ((continent, region), (continent), ())  \nORDER BY continent, region ;\n|continent    |region         |max |\n|-------------|---------------|----|\n|North America|Caribbean      |78,9|\n|North America|Central America|75,8|\n|North America|North America  |79,4|\n|North America|               |79,4|\n|South America|South America  |76,1|\n|South America|               |76,1|\n|             |               |79,4|"
  },
  {
    "objectID": "slides/SQL_3.html#cube",
    "href": "slides/SQL_3.html#cube",
    "title": "BD IV: SQL III",
    "section": "CUBE",
    "text": "CUBE\nCUBE (a, b, c) est un raccourci pour un GROUPING SETS contenant toutes les parties de (a, b, c), c.a.d\nGROUPING SETS (\n    (         )\n    ( a, b, c ),\n    ( a, b    ),\n    ( a       ),\n    (    b, c ),\n    (    b    ),\n    ( a,    c ),\n    (       c ),\n)"
  },
  {
    "objectID": "slides/SQL_3.html#exemple-1-avec-cube",
    "href": "slides/SQL_3.html#exemple-1-avec-cube",
    "title": "BD IV: SQL III",
    "section": "Exemple 1 avec CUBE\n",
    "text": "Exemple 1 avec CUBE\n\n\n\n\nSELECT continent, region, governmentform, \n       count(*) AS cnt, \n       max(lifeexpectancy)\nFROM country c \nWHERE continent LIKE '%America'\nGROUP BY CUBE (continent, region, governmentform)   \nHAVING COUNT(*) &gt; 5;\n\n\n+-------------+---------------+-----------------------------+---+----+\n|continent    |region         |Governmentform               |cnt|max |\n+-------------+---------------+-----------------------------+---+----+\n|             |               |                             | 51|79.4|\n|South America|South America  |Republic                     |  9|75.7|\n|North America|Central America|Republic                     |  6|75.8|\n|North America|Caribbean      |Constitutional Monarchy      |  8|75.2|\n|North America|Caribbean      |                             | 24|78.9|\n|South America|South America  |                             | 14|76.1|\n|North America|Central America|                             |  8|75.8|\n|South America|               |                             | 14|76.1|\n|North America|               |                             | 37|79.4|\n|             |Caribbean      |Constitutional Monarchy      |  8|75.2|\n|             |South America  |Republic                     |  9|75.7|\n|             |Central America|Republic                     |  6|75.8|\n|             |South America  |                             | 14|76.1|\n|             |Central America|                             |  8|75.8|\n|             |Caribbean      |                             | 24|78.9|\n|North America|               |Constitutional Monarchy      |  9|75.2|\n|North America|               |Republic                     | 10|75.8|\n|South America|               |Republic                     |  9|75.7|\n|North America|               |Dependent Territory of the UK|  6|78.9|\n|             |               |Republic                     | 19|75.8|\n|             |               |Constitutional Monarchy      |  9|75.2|\n|             |               |Dependent Territory of the UK|  7|78.9|"
  },
  {
    "objectID": "slides/SQL_3.html#exemple-2-avec-cube",
    "href": "slides/SQL_3.html#exemple-2-avec-cube",
    "title": "BD IV: SQL III",
    "section": "Exemple 2 avec CUBE\n",
    "text": "Exemple 2 avec CUBE\n\nCompter les formes de gouvernement et les région dans les Amériques.\n\n\n\nSELECT  \n     region, \n     governmentform, \n     count(*) AS cnt, \n     max(lifeexpectancy)\nFROM country c \nWHERE continent LIKE '%America'\nGROUP BY CUBE   (region, governmentform)   \nHAVING COUNT(*) &gt; 0\nORDER BY region, cnt DESC;\n\n\n---------------+--------------------------------------------+---+----+\nregion         |governmentform                              |cnt|max |\n---------------+--------------------------------------------+---+----+\nCaribbean      |                                            | 24|78.9|\nCaribbean      |Constitutional Monarchy                     |  8|75.2|\nCaribbean      |Dependent Territory of the UK               |  5|78.9|\nCaribbean      |Republic                                    |  4|73.4|\n...            |                                            |   |    |\n               |Republic                                    | 19|75.8|\n               |Constitutional Monarchy                     |  9|75.2|\n               |Dependent Territory of the UK               |  7|78.9|\n               |Federal Republic                            |  5|77.1|\n               |Overseas Department of France               |  3|78.3|\n..."
  },
  {
    "objectID": "slides/SQL_3.html#portrait-robot-dune-requête",
    "href": "slides/SQL_3.html#portrait-robot-dune-requête",
    "title": "BD IV: SQL III",
    "section": "Portrait robot d’une requête",
    "text": "Portrait robot d’une requête\nSELECT &lt;attributs&gt;           -- les colonnes de la table résultat\n\nFROM &lt;relations&gt;             -- la/les table/s qui émettent les données\n\n[WHERE &lt;condition&gt; ]         -- filtre\n\n[GROUP BY &lt;attributs de partitionnement&gt;   -- découpage en groupes\n\n[HAVING &lt;condition&gt;]]      -- filtrage des groupes\n\n[ORDER BY &lt;critere&gt;]       -- trier \n\n\nSELECT : attributs du résultat (avec agrégations éventuelles)\n\nWHERE : condition de sélection indépendante du GROUP BY\n\n\nHAVING : condition de sélection portant sur les groupes"
  },
  {
    "objectID": "slides/SQL_3.html#ordre-dexécution-des-éléments-dune-requête",
    "href": "slides/SQL_3.html#ordre-dexécution-des-éléments-dune-requête",
    "title": "BD IV: SQL III",
    "section": "Ordre d’exécution des éléments d’une requête",
    "text": "Ordre d’exécution des éléments d’une requête\n\nRassembler les données mentionnées dans la clause FROM\nFilter les lignes selon la clause WHERE\nRegrouper les lignes selon la clause GROUP BY\nFiltrer les groupes selon la clause HAVING\nSpecifier les colonnes du résultat selon la clause SELECT\nTrier le résultat final selon la clause ORDER BY"
  },
  {
    "objectID": "slides/SQL_1.html#sql-structured-query-language",
    "href": "slides/SQL_1.html#sql-structured-query-language",
    "title": "BD II: SQL I",
    "section": "SQL : Structured Query Language",
    "text": "SQL : Structured Query Language\nLe SQL est un langage permettant :\n\ninterrogation des données (requêtes)\ndéfinition des données et des contraintes structurelles sur celles-ci\nmanipulation des données (insertion, suppression, mise à jour)\ndéfinition des vues et des index\nadministration des bases de données"
  },
  {
    "objectID": "slides/SQL_1.html#plusieurs-fois-normalisés-par-liso",
    "href": "slides/SQL_1.html#plusieurs-fois-normalisés-par-liso",
    "title": "BD II: SQL I",
    "section": "Plusieurs fois normalisés par l’ISO …",
    "text": "Plusieurs fois normalisés par l’ISO …\n\nSQL-86, SQL-89, SQL-92, SQL-99,\n…\nSQL-2003, SQL-2008, SQL-2011, SQL-2016,\n…\n\nNous utiliserons le dialecte PostgreSQL (https://www.postgresql.org){target=“_blank”}\nLa norme est révisée environ tous les 5 ans, acutellement ISO/IEC 9075-1:2023 de l’ISO (https://www.iso.org/){target=“_blank”}"
  },
  {
    "objectID": "slides/SQL_1.html#un-langage-de-requête",
    "href": "slides/SQL_1.html#un-langage-de-requête",
    "title": "BD II: SQL I",
    "section": "Un langage de requête",
    "text": "Un langage de requête\n\nAvec SQL, on envoit au serveur des requêtes composées d’instructions,\nLes opérations de l’Algèbre relationnel ne sont pas directement disponibles.\n\n\nLa principale instruction est SELECT. Elle permet de combiner :\n\nrestriction/filtrage (sélection) \\(\\sigma\\)\nprojection \\(\\pi\\)\nrenommage \\(\\rho\\)\net bien d’autres choses.\n\nD’autres instructions pour définir et manipuler les données, administrer une BDD."
  },
  {
    "objectID": "slides/SQL_1.html#format-de-linstruction-select",
    "href": "slides/SQL_1.html#format-de-linstruction-select",
    "title": "BD II: SQL I",
    "section": "Format de l’instruction SELECT\n",
    "text": "Format de l’instruction SELECT\n\nSELECT &lt;liste attribut&gt;\n\nFROM &lt;table&gt;\n\nWHERE &lt;condition&gt; ;\ntraduit l’expression\n\\(\\Pi\\left(\\sigma \\left(\\text{&lt;table&gt;}, \\text{&lt;condition&gt;}\\right), \\text{&lt;liste attribut&gt;}\\right)\\)"
  },
  {
    "objectID": "slides/SQL_1.html#autres-langages-autres-choix",
    "href": "slides/SQL_1.html#autres-langages-autres-choix",
    "title": "BD II: SQL I",
    "section": "Autres langages, autres choix",
    "text": "Autres langages, autres choix\nOn peut faire autrement : dans les extensions du langage R, notamment celles qui relèvent de tidyverse, on associe des fonctions à chaque opérateur de l’algèbre relationnelle. Pour les opérateurs qui portent sur une seule table, le premier argument de chaque fonction est toujours la table sur laquelle on opère. Les autres arguments sont soit les attributs de projection, soit la spécification d’une condition de sélection, soit …\nL’usage d’un opérateur pipe (comme dans Unix) permet de composer de facon lisible les opérations.\n&lt;table&gt; |&gt;\n  filter(&lt;condition&gt; ) |&gt;\n  select(&lt;liste attribut&gt;) |&gt; \n  ..."
  },
  {
    "objectID": "slides/SQL_1.html#syntaxe---requêtes-simples",
    "href": "slides/SQL_1.html#syntaxe---requêtes-simples",
    "title": "BD II: SQL I",
    "section": "Syntaxe - requêtes simples",
    "text": "Syntaxe - requêtes simples\nSELECT [DISTINCT] * | &lt;liste attribut&gt;\n\nFROM &lt;liste de tables&gt;\n\n[WHERE &lt;condition&gt;] ;\n\n* : sélection de tous les attributs (pas de projection)\n[...] : clause, expression facultative.\nDISTINCT : supprime les doublons."
  },
  {
    "objectID": "slides/SQL_1.html#exemples-de-requête",
    "href": "slides/SQL_1.html#exemples-de-requête",
    "title": "BD II: SQL I",
    "section": "Exemples de requête",
    "text": "Exemples de requête\n\n\nSchémas des tables :\n\nEmploye(Nu, NomE, Annee, Tel, Nudept)\nFournisseur (NomF, Ville, Adresse)\nPiece(NomP, Prix, Couleur)\n\nLa requête\nSELECT *\n\nFROM Fournisseur ;\n\nest équivalente à : \\(\\quad Fournisseur\\)\n\n\nLa requête\nSELECT NomF\n\nFROM Fournisseur\n\nWHERE Ville='Paris' ;\n\n\nest équivalente à : \\(\\quad \\pi((\\sigma(\\texttt{Fournisseur}, \\texttt{Ville}=\\texttt{'Paris'})), \\texttt{NomF})\\)"
  },
  {
    "objectID": "slides/SQL_1.html#structure-de-base",
    "href": "slides/SQL_1.html#structure-de-base",
    "title": "BD II: SQL I",
    "section": "Structure de base",
    "text": "Structure de base\nLa structure de base d’une requête s’appuie sur les trois mots clés suivants :\n\nSELECT correspond à l’opérateur de projection sur la liste d’attributs demandée, il peut aussi être suivi de fonctions d’attributs\nFROM indique la ou les relations concernées\nWHERE précise une condition et correspond à l’opération de restriction/sélection en algèbre relationnelle."
  },
  {
    "objectID": "slides/SQL_1.html#syntaxe-de-la-condition-de-sélection-where-...",
    "href": "slides/SQL_1.html#syntaxe-de-la-condition-de-sélection-where-...",
    "title": "BD II: SQL I",
    "section": "Syntaxe de la condition de sélection (WHERE ...)",
    "text": "Syntaxe de la condition de sélection (WHERE ...)\nUne condition se construit à l’aide des opérations suivantes :\n\n\nComparaison avec opérateurs : =, &lt;&gt;, &gt;,&lt;, &gt;=, &lt;=\n\n\nSELECT *\n\nFROM Employe\n\nWHERE NomE &lt;&gt;'Durand'  ;  \n\n\n\n\n\n\nMise en garde\n\n\nUtiliser * en production n’est pas une bonne idée car une modification du schéma de la table Employe modifiera le schéma du résultat."
  },
  {
    "objectID": "slides/SQL_1.html#syntaxe-de-la-condition-de-sélection-where-...---suite",
    "href": "slides/SQL_1.html#syntaxe-de-la-condition-de-sélection-where-...---suite",
    "title": "BD II: SQL I",
    "section": "Syntaxe de la condition de sélection (WHERE ...) - suite",
    "text": "Syntaxe de la condition de sélection (WHERE ...) - suite\nCombinaison de conditions à l’aide des opérateurs logiques: AND, OR, NOT\nSELECT DISTINCT NomF\n\nFROM Fournisseur\n\nWHERE (Ville='Londres') OR (Ville='Paris');  \n Attention aux priorités dans l’évaluation des expressions logiques\n\n\n\n\n\n\n\nAvertissement\n\n\nAND est prioritaire sur OR. Il est utile de parenthéser !\n\n\n\n\n\n Attention aux valeurs NULL c.a.d. manquantes/indéterminées."
  },
  {
    "objectID": "slides/SQL_1.html#logique-trivalente",
    "href": "slides/SQL_1.html#logique-trivalente",
    "title": "BD II: SQL I",
    "section": "Logique trivalente",
    "text": "Logique trivalente\nWHERE C ne sélectionne que les tuples vérifiant C = TRUE.\nUne comparaison sur un attribut NULL renvoie UNKNOWN, à l’exception de IS [NOT] NULL.\n\nLes opérateurs logiques sont trivalents : TRUE, FALSE, UNKNOWN\nOn compléte les règles habituelles :\n\nNOT NULL = NOT UNKNOWN = UNKNOWN car résultat incertain\nTRUE AND UNKNOWN = UNKNOWN car résultat incertain\nFALSE AND UNKNOWN = FALSE car résultat certain\nTRUE OR UNKNOWN = TRUE car résultat certain\nFALSE OR UNKNOWN = UNKNOWN car résultat incertain"
  },
  {
    "objectID": "slides/SQL_1.html#test-between",
    "href": "slides/SQL_1.html#test-between",
    "title": "BD II: SQL I",
    "section": "Test BETWEEN\n",
    "text": "Test BETWEEN\n\nPermet de vérifier si la valeur d’un attribut est comprise entre deux constantes\nSELECT NomE\n\nFROM Employe\n\nWHERE Annee BETWEEN 2022 AND 2025;   \n\n\n\n\n\n\nMise en garde\n\n\nÉviter de manipuler les dates et heures comme des chaînes de caractères"
  },
  {
    "objectID": "slides/SQL_1.html#test-is-null",
    "href": "slides/SQL_1.html#test-is-null",
    "title": "BD II: SQL I",
    "section": "Test IS NULL\n",
    "text": "Test IS NULL\n\nVérifie si une valeur est égale à NULL (c-à-d est inconnue).\nSELECT *\n\nFROM Employe\n\nWHERE Tel IS NULL;    \n\n\n\n\n\n\nMise en garde\n\n\n Attention à la gestion des valeurs manquantes."
  },
  {
    "objectID": "slides/SQL_1.html#test-in",
    "href": "slides/SQL_1.html#test-in",
    "title": "BD II: SQL I",
    "section": "Test IN\n",
    "text": "Test IN\n\ntest appartenance : permet de vérifier si la valeur d’un attribut appartient à une liste de constantes.\nSELECT *\n\nFROM Fournisseur\n\nWHERE Ville IN ('Paris', 'Londres');"
  },
  {
    "objectID": "slides/SQL_1.html#test-like",
    "href": "slides/SQL_1.html#test-like",
    "title": "BD II: SQL I",
    "section": "Test LIKE\n",
    "text": "Test LIKE\n\nPermet de vérifier si un attribut de type chaîne de caractères contient une ou plusieurs sous-chaînes.\n\\(\\_\\) : remplace n’importe quel caractère,\n\\(\\%\\) : remplace n’importe quelle chaîne de caractères.\nSELECT Ville\n\nFROM Fournisseur\n\nWHERE Ville LIKE 'Saint%';\nCette requête sélectionne les noms de ville commençant par ‘Saint’.\n\n\n\n\n\n\nAvertissement\n\n\n\nLIKE est sensible à la casse,\nILIKE est insensible à la casse."
  },
  {
    "objectID": "slides/SQL_1.html#requêtes-multi-relations-1",
    "href": "slides/SQL_1.html#requêtes-multi-relations-1",
    "title": "BD II: SQL I",
    "section": "Requêtes multi-relations",
    "text": "Requêtes multi-relations\nQuand l’information est dispersée sur plusieurs tables, on utilise des jointures\n\nOn peut :\n\nUtiliser plusieurs tables dans la clause FROM,\nFaire intervenir des conditions complexes impliquant ces tables dans la clause WHERE."
  },
  {
    "objectID": "slides/SQL_1.html#détails-du-schema-world",
    "href": "slides/SQL_1.html#détails-du-schema-world",
    "title": "BD II: SQL I",
    "section": "Détails du schema World\n",
    "text": "Détails du schema World\n\nImages et tables créées grâce à DbSchema (https://dbschema.com){target=“_blank”}"
  },
  {
    "objectID": "slides/SQL_1.html#diagramme-en-pattes-de-corbeau",
    "href": "slides/SQL_1.html#diagramme-en-pattes-de-corbeau",
    "title": "BD II: SQL I",
    "section": "Diagramme en pattes de corbeau",
    "text": "Diagramme en pattes de corbeau\n\nimg"
  },
  {
    "objectID": "slides/SQL_1.html#table-world.city",
    "href": "slides/SQL_1.html#table-world.city",
    "title": "BD II: SQL I",
    "section": "Table world.city",
    "text": "Table world.city\n\n\n* 🔑 ⬋\nid\ninteger\n\n\n*\nname\ntext\n\n\n*\ncountrycode\nchar(3)\n\n\n*\ndistrict\ntext\n\n\n*\npopulation\ninteger"
  },
  {
    "objectID": "slides/SQL_1.html#table-world.country",
    "href": "slides/SQL_1.html#table-world.country",
    "title": "BD II: SQL I",
    "section": "Table world.country",
    "text": "Table world.country\n\n\n\n\n* 🔑 ⬋\ncode\nchar(3)\n\n\n*\nname\ntext\n\n\n*\ncontinent\ntext\n\n\n*\nregion\ntext\n\n\n*\nsurfacearea\nreal\n\n\n\nindepyear\nsmallint\n\n\n*\npopulation\ninteger\n\n\n\nlifeexpectancy\nreal\n\n\n\ngnp\nnumeric(10,2)\n\n\n\ngnpold\nnumeric(10,2)\n\n\n*\nlocalname\ntext\n\n\n*\ngovernmentform\ntext\n\n\n\nheadofstate\ntext\n\n\n⬈\ncapital\ninteger\n\n\n*\ncode2\nchar(2)\n\n\n\nForeign Keys\n\n\ncountry_capital_fkey\n( capital ) ref world.city (id)\n\nConstraints\n\n\n\n\n\n\ncountry_continent_check\n((continent = ‘Asia’::text) OR (continent = ‘Europe’::text) OR (continent = ‘North America’::text) OR (continent = ‘Africa’::text) OR (continent = ‘Oceania’::text) OR (continent = ‘Antarctica’::text) OR (continent = ‘South America’::text))"
  },
  {
    "objectID": "slides/SQL_1.html#table-world.countrylanguage",
    "href": "slides/SQL_1.html#table-world.countrylanguage",
    "title": "BD II: SQL I",
    "section": "Table world.countrylanguage",
    "text": "Table world.countrylanguage\n\n\n* 🔑 ⬈\ncountrycode\nchar(3)\n\n\n* 🔑\nlanguage\ntext\n\n\n*\nisofficial\nboolean\n\n\n*\npercentage\nreal\n\n\nForeign Keys\n\n\ncountrylanguage_countrycode_fkey\n( countrycode ) ref world.country (code)"
  },
  {
    "objectID": "slides/SQL_1.html#première-jointure-sur-schéma-world",
    "href": "slides/SQL_1.html#première-jointure-sur-schéma-world",
    "title": "BD II: SQL I",
    "section": "Première jointure sur schéma world\n",
    "text": "Première jointure sur schéma world\n\nQuels sont les pays qui portent le même nom que leur capitale ?\n\nSELECT name_country\nFROM country co, city ci   \nWHERE co.capital=ci.id AND co.name_country=ci.name;\n\n\nqui correspond à\n\\(\\pi_{\\text{name\\_country}}(\\sigma_{\\text{capital}=\\text{id} \\wedge \\text{name\\_country}=\\text{name}}(\\text{country}\\times \\text{city}))\\)\nautrement dit à\n\\(\\pi_{\\text{name\\_country}}(\\text{country} \\bowtie_{\\text{capital}=\\text{id} \\wedge  \\text{name\\_country}=\\text{name}} \\text{city}))\\)"
  },
  {
    "objectID": "slides/SQL_1.html#syntaxe-normalisée-pour-les-jointures-join-et-on",
    "href": "slides/SQL_1.html#syntaxe-normalisée-pour-les-jointures-join-et-on",
    "title": "BD II: SQL I",
    "section": "Syntaxe normalisée pour les jointures : JOIN et ON\n",
    "text": "Syntaxe normalisée pour les jointures : JOIN et ON\n\nQuels sont les pays qui portent le même nom que leur capitale ?\n\nSELECT name_country\nFROM country co join city ci \nON co.capital=ci.id  \nWHERE co.name_country = ci.name;\nqui correspond à\n\\(\\pi_{\\text{name\\_country}}(\\sigma_{\\text{capital}=id \\wedge  \\text{name\\_country}=\\text{name}}(\\text{country} \\times \\text{city}))\\)"
  },
  {
    "objectID": "slides/SQL_1.html#renommage",
    "href": "slides/SQL_1.html#renommage",
    "title": "BD II: SQL I",
    "section": "Renommage",
    "text": "Renommage\nSi on veut faire une jointure d’une table avec elle-même, on utilise AS pour obtenir deux tables de noms différents\n\nQuels sont les noms de ville qui apparaissent dans deux pays différents?\n\n\nSELECT DISTINCT c1.name, c1.countrycode, c2.countrycode\nFROM city AS c1 JOIN city AS c2   \nON c1.countrycode != c2.countrycode AND c1.name=c2.name  \nORDER BY c1.name;\n\n\n\n\n\n\nNote\n\n\nLe mot AS est optionnel."
  },
  {
    "objectID": "slides/SQL_1.html#jointure-naturelle",
    "href": "slides/SQL_1.html#jointure-naturelle",
    "title": "BD II: SQL I",
    "section": "Jointure naturelle",
    "text": "Jointure naturelle\nQuels sont les noms des pays où le français est parlé ?\n\nSELECT co.name_country, cl.language\nFROM country co, countrylanguage cl\nWHERE co.countrycode=cl.countrycode AND cl.language='French';\nC’est une jointure naturelle.\n\n\nSyntaxe normalisée : NATURAL JOIN\nSELECT co.name_country, cl.language\nFROM country co NATURAL JOIN countrylanguage cl\nWHERE cl.language='French';"
  },
  {
    "objectID": "slides/SQL_1.html#jointure-naturelle-suite",
    "href": "slides/SQL_1.html#jointure-naturelle-suite",
    "title": "BD II: SQL I",
    "section": "Jointure naturelle (suite)",
    "text": "Jointure naturelle (suite)\nQuels sont les pays dont une ville a le même nom qu’une langue parlée dans ce pays?\nSELECT DISTINCT co.name_country, ci.name, language\nFROM country co NATURAL JOIN  \n     city ci NATURAL JOIN     \n     countrylanguage cl     \nWHERE cl.language = ci.name;\n\n\n\n\n\n\nAvertissement\n\n\n\nla syntaxe nom_table.nom_attribut améliore la lisibilité d’une requète multi-table.\nOn peut utiliser des alias très systématiquement pour alléger les notations."
  },
  {
    "objectID": "slides/SQL_1.html#schéma-world-pour-mémoire",
    "href": "slides/SQL_1.html#schéma-world-pour-mémoire",
    "title": "BD II: SQL I",
    "section": "Schéma world pour mémoire",
    "text": "Schéma world pour mémoire"
  },
  {
    "objectID": "slides/SQL_1.html#jointure-externe",
    "href": "slides/SQL_1.html#jointure-externe",
    "title": "BD II: SQL I",
    "section": "Jointure externe",
    "text": "Jointure externe\n\nLEFT OUTER JOIN : jointure externe gauche. On garde les tuples de la table de gauche qui n’ont pas de correspondant dans l’autre table.\nRIGHT OUTER JOIN : jointure externe droite. Idem à droite.\nFULL OUTER JOIN : on garde les tuples de chacune des tables qui n’ont pas de correspondant.\nOn complète les valeurs non renseignées par NULL."
  },
  {
    "objectID": "slides/SQL_1.html#exemple-de-jointure-externe",
    "href": "slides/SQL_1.html#exemple-de-jointure-externe",
    "title": "BD II: SQL I",
    "section": "Exemple de jointure externe",
    "text": "Exemple de jointure externe\n\nCertains pays n’ont pas de capitale.\n\n\nSELECT name_country\nFROM country\nWHERE capital IS NULL;\nLe résultat contient 8 lignes.\n\n\n\nQuels sont les pays qui n’ont pas de capitale ou portent le même nom que leur capitale ?\n\n\n\nSELECT co.name_country, ci.name\nFROM country co LEFT OUTER JOIN city ci   \n     ON co.capital=ci.id                  \nWHERE ci.name IS NULL OR co.name_country=ci.name ;"
  },
  {
    "objectID": "slides/Modelisation_2.html#entre-modèle-ea-et-modèle-relationnel",
    "href": "slides/Modelisation_2.html#entre-modèle-ea-et-modèle-relationnel",
    "title": "Modélisation II :",
    "section": "Entre modèle EA et modèle relationnel",
    "text": "Entre modèle EA et modèle relationnel\nDans le modèle EA\n\nPlusieurs types de briques de bases : Entités (noms) et Associations (verbes)\nPas a priori de moyen de représenter les schémas EA dans le formatlisme EA\nUn formalisme accessible (en principe) aux usagers du système d’information\n\nDans le modèles relationnel\n\nUne seule brique de base : les tables\nUn schéma est décrit par des tuples insérés dans les tables de la métabase"
  },
  {
    "objectID": "slides/Modelisation_2.html#objectifs",
    "href": "slides/Modelisation_2.html#objectifs",
    "title": "Modélisation II :",
    "section": "Objectifs",
    "text": "Objectifs\nUne technique de traduction du formalisme EA vers le formalisme relationnel\nTraduction des associations selon l’arité et les cardinalités\nVisualisation des contraintes référentielles via les pattes de corbeaux\nUn formalisme graphique très proche du modèle relationnel\nUn formalisme graphique utilisé en rétro-ingénierie\nUn formalisme graphique utilisé pour documenter les bases de données relationnelles"
  },
  {
    "objectID": "slides/Modelisation_2.html#origines",
    "href": "slides/Modelisation_2.html#origines",
    "title": "Modélisation II :",
    "section": "Origines",
    "text": "Origines\nCréé par Gordon Everest (fin des années 1970)\nNormalisé par Finkelstein et Martin"
  },
  {
    "objectID": "slides/Modelisation_2.html#diagrammes",
    "href": "slides/Modelisation_2.html#diagrammes",
    "title": "Modélisation II :",
    "section": "Diagrammes",
    "text": "Diagrammes\n\n\n\n\n\n\nDeux briques de base\n\n\nLes diagrammes en pattes de corbeau sont formés de tables et de liens entre tables.\n\n\n\n\n\n\n\n\n\nLes tables \n\n\nreprésentent :\n\ndes entités fortes\ndes entités faibles issues de la traduction d’associations \\(n\\)-aires et/ou d’associations plusieurs-vers-plusieurs\n\n\n\n\n\n\n\n\n\n\nLes liens \n\n\nreprésentent des associations binaires un-un, ou un-vers-plusieurs\nLes cardinalités sont visualisées par les extrémités des liens"
  },
  {
    "objectID": "slides/Modelisation_2.html#les-cardinalités",
    "href": "slides/Modelisation_2.html#les-cardinalités",
    "title": "Modélisation II :",
    "section": "Les cardinalités",
    "text": "Les cardinalités\n\n\n\n\nSymbole (gauche)\n\n\nSymbole (droite)\n\n\nInterprétation\n\n\n\n\n\n\n|o\n\n\no|\n\n\nZero ou un\n\n\n\n\n||\n\n\n||\n\n\nExactement un\n\n\n\n\n}o\n\n\no{\n\n\nZero ou plus (pas de borne supérieure)\n\n\n\n\n}|\n\n\n|{\n\n\nun ou plus (pas de borne supérieure)"
  },
  {
    "objectID": "slides/Modelisation_2.html#aliases",
    "href": "slides/Modelisation_2.html#aliases",
    "title": "Modélisation II :",
    "section": "Aliases",
    "text": "Aliases\n\n\n\n\nSymbole (gauche)\n\n\nSymbole (droite)\n\n\nAlias for\n\n\n\n\n\n\nun or zero\n\n\nun or zero\n\n\nZero ou un\n\n\n\n\nzero ou un\n\n\nzero ou un\n\n\nZero ou un\n\n\n\n\nun ou plus\n\n\nun ou plus\n\n\nun ou plus\n\n\n\n\nun or plusieurs\n\n\nun or plusieurs\n\n\nun ou plus\n\n\n\n\nplusieurs(1)\n\n\nplusieurs(1)\n\n\nun ou plus\n\n\n\n\n1+\n\n\n1+\n\n\nun ou plus\n\n\n\n\nzero ou plus\n\n\nzero ou plus\n\n\nZero ou plus\n\n\n\n\nzero or plusieurs\n\n\nzero or plusieurs\n\n\nZero ou plus\n\n\n\n\nplusieurs(0)\n\n\nplusieurs(0)\n\n\nZero ou plus\n\n\n\n\n0+\n\n\n0+\n\n\nZero ou plus\n\n\n\n\nonly un\n\n\nonly un\n\n\nExactement un\n\n\n\n\n1\n\n\n1\n\n\nExactement un"
  },
  {
    "objectID": "slides/Modelisation_2.html#liens-non-identifiants-exemples",
    "href": "slides/Modelisation_2.html#liens-non-identifiants-exemples",
    "title": "Modélisation II :",
    "section": "Liens non-identifiants : exemples",
    "text": "Liens non-identifiants : exemples\n\n\n\n\n\n\n\nerDiagram\n    COUNTRY ||..o{ CITY : contains\n    COUNTRY {\n      string(3) countrycode PK\n      string name_country\n      numeric population_country\n      integer capital  FK\n    }\n    CITY {\n      integer id PK\n      string(3) countrycode FK\n      string name\n      numeric population\n    }\n    CITY |o..o| COUNTRY : is-capital\n\n\n\n\n\n\n\n\nUne instance de COUNTRY contient entre \\(0\\) et un nombre non borné d’instances de CITY (patte de corbeau côté CITY)\nUne instance de CITY est toujours située sur une et une seule instance de COUNTRY\nUne instance de CITY est la capitale de \\(0\\) ou \\(1\\) intance de COUNTRY\nUne instance de COUNTRY possède \\(0\\) ou \\(1\\) capitale"
  },
  {
    "objectID": "slides/Modelisation_2.html#liens-identifiants",
    "href": "slides/Modelisation_2.html#liens-identifiants",
    "title": "Modélisation II :",
    "section": "Liens identifiants",
    "text": "Liens identifiants\n\n\n\n\n\n\nNote\n\n\nUn lien est identifiant si la clé primaire de l’émetteur contient une référence à la clé primaire de la table destinataire.\n\n\n\n\n\n\n\nExemple\n\nDans le schéma world le lien entre countrylanguage et country est identifiant : la clé primaire de countrylanguage est formée par (countrycode, language). L’attribut countrycode de countrylanguage fait référence à l’attribut countrycode de country (clé primaire de country)\n\n\n\n\n\n\n\n\nerDiagram\n    COUNTRY ||--|{ COUNTRYLANGUAGE : speaks\n    COUNTRY {\n      string countrycode\n      string name_country\n      numeric population_country\n    }\n    COUNTRYLANGUAGE {\n      string countrycode\n      string language\n      boolean isofficial\n      numeric percentage\n    }"
  },
  {
    "objectID": "slides/Modelisation_2.html#les-pattes-de-corbeau-comme-variante-du-modèle-entité-association",
    "href": "slides/Modelisation_2.html#les-pattes-de-corbeau-comme-variante-du-modèle-entité-association",
    "title": "Modélisation II :",
    "section": "Les pattes de corbeau comme variante du modèle Entité-Association ?",
    "text": "Les pattes de corbeau comme variante du modèle Entité-Association ?\n\n\n\n\n\n\nRemarque\n\n\nLa notation en pattes de corbeau est parfois/souvent présentée comme un variante de la modélisation Entité-Association (de Chen)\nC’est le cas dans l’outil de dessin mermaid\n\n\n\n\n\n\n\n\n\n\nObjection I :\n\n\nUn lien en notation pattes de corbeau définit une relation entre deux tables. Un lien en pattes de corbeau ne peut pas représenter directement un association d’arité supérieure à 2\n\n\n\n\n\n\n\n\n\n\n\nObjection II :\n\n\nUn lien en notation pattes de corbeau ne porte pas d’attributs propres\n\n\n\n\n\n\n\n\n\n\n\nConvention\n\n\nDans ce cours, la notation en pattes de corbeau est utilisée pour visualiser le modèle relationnel. Les liens permettent de souligner/visualiser les contraintes référentielles"
  },
  {
    "objectID": "slides/Modelisation_2.html#exemple-association-binaire-plusieurs-un-dans-schéma-world",
    "href": "slides/Modelisation_2.html#exemple-association-binaire-plusieurs-un-dans-schéma-world",
    "title": "Modélisation II :",
    "section": "Exemple association binaire plusieurs-un dans schéma world",
    "text": "Exemple association binaire plusieurs-un dans schéma world\n\n\n\n\n\n\nER\n\n\n\ncountry\n\ncountry\n\n\n\niso\n\niso3\n\n\n\ncountry--iso\n\n\n\n\ncity\n\ncity\n\n\n\nname1\n\nname\n\n\n\ncity--name1\n\n\n\n\nid\n\nid\n\n\n\ncity--id\n\n\n\n\nis-in\n\nis-in\n\n\n\ncity--is-in\n\n1:1\n\n\n\nname0\n\nname\n\n\n\nname0--country\n\n\n\n\npopulation\n\npopulation\n\n\n\npopulation--country\n\n\n\n\ngovernmentForm\n\ngovernmentForm\n\n\n\ngovernmentForm--country\n\n\n\n\nheadOfState\n\nheadOfState\n\n\n\nheadOfState--country\n\n\n\n\nis-in--country\n\n0:n"
  },
  {
    "objectID": "slides/Modelisation_2.html#traduction",
    "href": "slides/Modelisation_2.html#traduction",
    "title": "Modélisation II :",
    "section": "Traduction",
    "text": "Traduction\n\n\n\n\n\n\n\nerDiagram\n    COUNTRY ||..o{ CITY : contains\n    COUNTRY {\n      string(3) iso3 PK\n      string name_country\n      numeric population_country\n      string governmentForm\n      string headOfState\n    }\n    CITY {\n      integer id PK\n      string(3) iso3 FK\n      string name\n      numeric population\n    }\n\n\n\n\n\n\n\nUn lien non-identifiant depuis la table représentant l’entité de cardinalité \\(0:1\\) (CITY) vers la table représentant la cardinalité \\(0:n\\) (COUNTRY)\nLes éventuels attributs propres de l’association sont représentés par des attributs de la table représentant l’entité de cardinalité \\(0:1\\)\n\n\n\n\n\n\nMise en garde\n\n\nLa patte de corbeau 0{ est placée du côté de la table représentant l’entité de cardinalité \\(0:1\\) (CITY)"
  },
  {
    "objectID": "slides/Modelisation_2.html#une-association-plusieurs-plusieurs",
    "href": "slides/Modelisation_2.html#une-association-plusieurs-plusieurs",
    "title": "Modélisation II :",
    "section": "Une association plusieurs-plusieurs",
    "text": "Une association plusieurs-plusieurs\n\n\n\n\n\n\nER\n\n\n\ncountry\n\ncountry\n\n\n\niso\n\niso3\n\n\n\ncountry--iso\n\n\n\n\nlanguage\n\nlanguage\n\n\n\nname2\n\nname\n\n\n\nlanguage--name2\n\n\n\n\nisol\n\niso\n\n\n\nlanguage--isol\n\n\n\n\nis-spoken-in\n\nis-spoken-in\n\n\n\nlanguage--is-spoken-in\n\n0:n\n\n\n\nname0\n\nname\n\n\n\nname0--country\n\n\n\n\npopulation\n\npopulation\n\n\n\npopulation--country\n\n\n\n\ngovernmentForm\n\ngovernmentForm\n\n\n\ngovernmentForm--country\n\n\n\n\nheadOfState\n\nheadOfState\n\n\n\nheadOfState--country\n\n\n\n\npercentage\n\npercentage\n\n\n\nisofficial\n\nisofficial\n\n\n\nis-spoken-in--country\n\n0:n\n\n\n\nis-spoken-in--percentage\n\n\n\n\nis-spoken-in--isofficial"
  },
  {
    "objectID": "slides/Modelisation_2.html#transformation-préalable-à-laide-dune-entité-faible",
    "href": "slides/Modelisation_2.html#transformation-préalable-à-laide-dune-entité-faible",
    "title": "Modélisation II :",
    "section": "Transformation préalable à l’aide d’une entité faible",
    "text": "Transformation préalable à l’aide d’une entité faible\n\n\n\n\n\n\nER\n\n\n\ncountry\n\ncountry\n\n\n\niso\n\niso3\n\n\n\ncountry--iso\n\n\n\n\nspeaks\n\n\nspeaks\n\n\n\ncountry--speaks\n\n0:n\n\n\n\nlanguage\n\nlanguage\n\n\n\nname2\n\nname\n\n\n\nlanguage--name2\n\n\n\n\nisol\n\niso\n\n\n\nlanguage--isol\n\n\n\n\nis-spoken\n\n\nis-spoken\n\n\n\nlanguage--is-spoken\n\n0:n\n\n\n\nname0\n\nname\n\n\n\nname0--country\n\n\n\n\npopulation\n\npopulation\n\n\n\npopulation--country\n\n\n\n\ngovernmentForm\n\ngovernmentForm\n\n\n\ngovernmentForm--country\n\n\n\n\nheadOfState\n\nheadOfState\n\n\n\nheadOfState--country\n\n\n\n\npercentage\n\npercentage\n\n\n\nisofficial\n\nisofficial\n\n\n\ncountrylanguage\n\n\ncountrylanguage\n\n\n\ncountrylanguage--percentage\n\n\n\n\ncountrylanguage--isofficial\n\n\n\n\nspeaks--countrylanguage\n\n1:1\n\n\n\nis-spoken--countrylanguage\n\n1:1"
  },
  {
    "objectID": "slides/Modelisation_2.html#traduction-1",
    "href": "slides/Modelisation_2.html#traduction-1",
    "title": "Modélisation II :",
    "section": "Traduction",
    "text": "Traduction\n\n\n\n\n\n\n\nerDiagram\n    COUNTRY ||--o{ COUNTRYLANGUAGE : speaks\n    COUNTRY {\n      string(3) iso3 PK\n      string name_country\n      numeric population_country\n      string governmentForm\n      string headOfState\n    }\n    LANGUAGE ||--o{ COUNTRYLANGUAGE : is-spoken\n    LANGUAGE {\n      string(3) iso PK\n      string name\n    }\n    COUNTRYLANGUAGE {\n      string(3) iso PK, FK\n      string(3) iso3 PK, FK\n      boolean isofficial\n      numeric percentage\n    }\n\n\n\n\n\n\n\nLa table obtenue par traduction de l’entité faible est appelée table intermédiaire\nLa table intermédiaire COUNTRYLANGUAGE comporte les attributs propres (percentage, isofficial) de l’association originelle (qui sont aussi ceux de l’entité faible)\nLes deux associations faibles issues de l’entité faible sont traduites en liens identifiants entre l’entité intermédiaire et les tables traduisant les entités (ici COUNTRY et LANGUAGE)"
  },
  {
    "objectID": "slides/Modelisation_2.html#liens-identifiants-1",
    "href": "slides/Modelisation_2.html#liens-identifiants-1",
    "title": "Modélisation II :",
    "section": "Liens identifiants",
    "text": "Liens identifiants\nLes liens identifiants correspondent à des contraintes référentielles (comme les liens non-identifiants).\nLes liens identifiants témoignent du fait que les constituants de la clé primaire de la table intermédiaire (ici iso3 et isol) font référence aux clés primaires des tables COUNTRY (iso3) et LANGUAGE (isol)."
  },
  {
    "objectID": "slides/Modelisation_2.html#table-intermédiaire",
    "href": "slides/Modelisation_2.html#table-intermédiaire",
    "title": "Modélisation II :",
    "section": "Table intermédiaire",
    "text": "Table intermédiaire\n\n\n\n\n\n\n\n\n\nCaractérisation\n\n\nLes tables intermédiaires sont caractérisées par le fait que certaines composantes de leur clé primaire sont la source de contraintes référentielles vers la clé primaire d’une autre table.\n\n\n\n\n\n\n\n\n\n\n\n\nUsages\n\n\n\ntraduction des associations plusieurs-plusieurs\ntraduction des associations d’arité supérieure ou égale à 3\ntraduction des entités faibles\ntraduction des spécialisations"
  },
  {
    "objectID": "slides/Modelisation_2.html#exemple-de-lassociation-flight",
    "href": "slides/Modelisation_2.html#exemple-de-lassociation-flight",
    "title": "Modélisation II :",
    "section": "Exemple de l’association flight",
    "text": "Exemple de l’association flight\n\n\n\n\n\n\n\n\n\nER\n\n\n\nairport\n\nairport\n\n\n\nflight\n\nflight\n\n\n\nairport--flight\n\norig\n0:n\n\n\n\nplane\n\nplane\n\n\n\nairline\n\nairline\n\n\n\nflight--airport\n\ndest\n0:n\n\n\n\nflight--plane\n\n0:n\n\n\n\nflight--airline\n\n0:n"
  },
  {
    "objectID": "slides/Modelisation_2.html#transformation-de-lassociation-quarternaire-en-quatre-associations-binaires-faibles",
    "href": "slides/Modelisation_2.html#transformation-de-lassociation-quarternaire-en-quatre-associations-binaires-faibles",
    "title": "Modélisation II :",
    "section": "Transformation de l’association quarternaire en quatre associations binaires (faibles)",
    "text": "Transformation de l’association quarternaire en quatre associations binaires (faibles)\n\n\n\n\n\n\n\n\n\nER\n\n\n\nairport\n\nairport\n\n\n\norig\n\n\norig\n\n\n\nairport--orig\n\n0:n\n\n\n\ndest\n\n\ndest\n\n\n\nairport--dest\n\n0:n\n\n\n\nplane\n\nplane\n\n\n\nairline\n\nairline\n\n\n\nflight\n\n\nflight\n\n\n\noperates\n\n\noperates\n\n\n\nflight--operates\n\n1:1\n\n\n\nuses\n\n\nuses\n\n\n\nflight--uses\n\n1:1\n\n\n\norig--flight\n\n1:1\n\n\n\ndest--flight\n\n1:1\n\n\n\noperates--airline\n\n0:n\n\n\n\nuses--plane\n\n0:n\n\n\n\n\n\n\n\n\n\nL’association quarternaire est transformée en\n\nune entité faible. Chaque instance de cette entité faible représente une instance de l’association quaternaire\nquatre associations binaires faibles. Une instance de l’association binaire faible relie une instance de l’entité faible (association quaternaire) à l’instance de entité participante concernée\n\nEntre l’entité faible et une association faible, la cardinalité est toujours 1:1"
  },
  {
    "objectID": "slides/Modelisation_2.html#traduction-en-pattes-de-corbeau",
    "href": "slides/Modelisation_2.html#traduction-en-pattes-de-corbeau",
    "title": "Modélisation II :",
    "section": "Traduction en pattes de corbeau",
    "text": "Traduction en pattes de corbeau\n\n\n\n\n\n\n\n\nerDiagram\n    AIRPORT ||--o{ FLIGHT : takes-off\n    AIRPORT ||--o{ FLIGHT : lands-at\n    AIRLINE ||--o{ FLIGHT : operates\n    PLANE   ||--o{ FLIGHT : uses\n    AIRPORT {\n      string(3) faa PK\n      string name \n      numeric lat\n      numeric lon\n    }\n    AIRLINE {\n      string(3) faa PK\n      string name \n    }\n    PLANE {\n      string(3) tailnum PK \n      string model\n      string manufacturer\n      int year\n    }\n    FLIGHT {\n      string(3) origin  PK, FK\n      string(3) dest PK, FK\n      string tailnum PK, FK\n      string carrier PK, FK\n      int num PK\n      datetime dep_time PK\n    }\n\n\n\n\n\n\n\n\n\nUne fois la transformation de l’association quaternaire en une entité faible et quatre associations binaires un-plusieurs, la traduction ressemble à la traduction des associations binaires un-plusieurs\nL’entité faible est traduite en une table intermédiaire\nLes associations faibles sont traduites en liens identifiants"
  },
  {
    "objectID": "slides/Modelisation_2.html#un-traduction-immédiate",
    "href": "slides/Modelisation_2.html#un-traduction-immédiate",
    "title": "Modélisation II :",
    "section": "Un traduction immédiate ",
    "text": "Un traduction immédiate \nChaque table du modèle en pattes de corbeau correspond à une table/relation du modèle relationnel.\nLes liens du modèle en pattes de corbeau se traduisent en contraintes référentielles\n\n La proximité entre le modèle relationnel et les diagrammes en pattes de corbeau ouvrent la voie à la rétro-ingénierie"
  },
  {
    "objectID": "slides/Modelisation_2.html#rétro-ingénierie-reverse-engineering",
    "href": "slides/Modelisation_2.html#rétro-ingénierie-reverse-engineering",
    "title": "Modélisation II :",
    "section": "Rétro-ingénierie (reverse engineering)",
    "text": "Rétro-ingénierie (reverse engineering)\nL’ingénierie directe est normalement le processus de création d’un nouveau système (d’information) à partir de rien.\nLa rétro-ingénierie est le processus d’analyse d’un système existant pour comprendre sa conception et ses usages.\n\nUn SGBD mémorise la définition des schémas comme world dans un schéma particulier la métabase (information_schema + pg_catalog)\nLa rétro-ingénierie consiste à construire un diagramme en pattes de corbeau à partir des données de la métabase\nDe nombreux outils (plus ou moins payants) sont disponibles"
  },
  {
    "objectID": "slides/Modelisation_2.html#schéma-world",
    "href": "slides/Modelisation_2.html#schéma-world",
    "title": "Modélisation II :",
    "section": "Schéma world",
    "text": "Schéma world\n\nschema world"
  },
  {
    "objectID": "slides/Modelisation_2.html#ldd-create-schema-if-not-exists-world",
    "href": "slides/Modelisation_2.html#ldd-create-schema-if-not-exists-world",
    "title": "Modélisation II :",
    "section": "LDD CREATE SCHEMA IF NOT EXISTS world;",
    "text": "LDD CREATE SCHEMA IF NOT EXISTS world;\nCREATE  TABLE world.region_continent ( \n    region               text  NOT NULL  ,\n    continent            text    ,\n    CONSTRAINT pk_region_continent PRIMARY KEY ( region )\n );\n\nCREATE  TABLE world.city ( \n    id                   integer  NOT NULL  ,\n    name                 text  NOT NULL  ,\n    countrycode          char(3)  NOT NULL  ,\n    district             text  ,\n    population           integer ,\n    CONSTRAINT city_pkey PRIMARY KEY ( id )\n );"
  },
  {
    "objectID": "slides/Modelisation_2.html#créations-de-tables-suite",
    "href": "slides/Modelisation_2.html#créations-de-tables-suite",
    "title": "Modélisation II :",
    "section": "Créations de tables (suite)",
    "text": "Créations de tables (suite)\nCREATE  TABLE world.country ( \n    countrycode          char(3)  NOT NULL  ,\n    name_country         text  NOT NULL  ,\n    region               text  ,  \n    surfacearea          real   ,\n    indepyear            smallint    ,\n    population_country   integer     ,\n    lifeexpectancy       real    ,\n    gnp                  numeric(10,2)    ,\n    gnpold               numeric(10,2)    ,\n    localname            text  NOT NULL  ,\n    governmentform       text  NOT NULL  ,\n    headofstate          text    ,\n    capital              integer    ,\n    code2                char(2)  NOT NULL  ,\n    CONSTRAINT country_pkey PRIMARY KEY ( countrycode )\n );\n\n\nCREATE  TABLE world.countrylanguage ( \n    countrycode          char(3)  NOT NULL  ,\n    \"language\"           text  NOT NULL  ,\n    isofficial           boolean  NOT NULL  ,\n    percentage           real  NOT NULL  ,\n    CONSTRAINT countrylanguage_pkey PRIMARY KEY ( countrycode, \"language\" )\n );"
  },
  {
    "objectID": "slides/Modelisation_2.html#les-contraintes-référentielles",
    "href": "slides/Modelisation_2.html#les-contraintes-référentielles",
    "title": "Modélisation II :",
    "section": "Les contraintes référentielles",
    "text": "Les contraintes référentielles\nALTER TABLE world.city \n  ADD CONSTRAINT city_country_fk \n  FOREIGN KEY ( countrycode ) \n  REFERENCES world.country( countrycode ) \n  ON DELETE SET NULL ON UPDATE CASCADE DEFERRABLE;\n\nALTER TABLE world.country \n  ADD CONSTRAINT country_capital_fkey \n  FOREIGN KEY ( capital ) REFERENCES world.city( id ) \n  ON DELETE SET NULL ON UPDATE CASCADE;\n\nALTER TABLE world.country \n  ADD CONSTRAINT country_region_fk \n  FOREIGN KEY ( region ) REFERENCES world.region_continent( region ) \n  ON DELETE SET NULL ON UPDATE CASCADE DEFERRABLE;\n\nALTER TABLE world.countrylanguage \n  ADD CONSTRAINT countrylanguage_countrycode_fkey \n  FOREIGN KEY ( countrycode ) \n  REFERENCES world.country( countrycode );"
  },
  {
    "objectID": "slides/Modelisation_2.html#la-modélisation-un-exercice-très-général",
    "href": "slides/Modelisation_2.html#la-modélisation-un-exercice-très-général",
    "title": "Modélisation II :",
    "section": "La modélisation : un exercice très général",
    "text": "La modélisation : un exercice très général\nEn Informatique, la modélisation concerne aussi la conception des interfaces humains-machines, des sites WWW, des traitements divers, des entrepots de données, des lacs de données, ….\nChaque situation a suscité une méthode apropriée\n\nQuelques exemples :\n\nModèles Relation-Objet (Object Relational Model ORM)\nUML (Universal Modeling Language)\n\n\n\nLes modèles EA et pattes de corbeau ne sont que la partie émergée d’un iceberg"
  },
  {
    "objectID": "slides/LDD_2.html#schema-de-world",
    "href": "slides/LDD_2.html#schema-de-world",
    "title": "BD VII: Corriger le schéma World",
    "section": "Schema de world",
    "text": "Schema de world\n\nSchema World en pattes de corbeau"
  },
  {
    "objectID": "slides/LDD_2.html#conraintes-sur-la-table-country",
    "href": "slides/LDD_2.html#conraintes-sur-la-table-country",
    "title": "BD VII: Corriger le schéma World",
    "section": "Conraintes sur la table country",
    "text": "Conraintes sur la table country\n\nUn pays est identifié par son countrycode\nDeux pays ne devraient pas avoir le même nom\nUne région ne devrait appartenir qu’à un seul continent\nLa capitale d’un pays devrait être une ville connue dans city\nLa capitale d’un pays devrait être une ville de ce pays\nLes capitales de deux pays différents devraient être des villes différentes\n…\n\n Ce ne sont pas les seules contraintes possibles"
  },
  {
    "objectID": "slides/LDD_2.html#mise-en-œuvre-des-contraintes",
    "href": "slides/LDD_2.html#mise-en-œuvre-des-contraintes",
    "title": "BD VII: Corriger le schéma World",
    "section": "Mise en œuvre des contraintes",
    "text": "Mise en œuvre des contraintes\n\nUn pays est identifié par son countrycode : PRIMARY KEY\nDeux pays ne devraient pas avoir le même nom : UNIQUE\nUne région ne devrait appartenir qu’à un seul continent : ???\nLa capitale d’un pays devrait être une ville connue dans city : REFERENCES\nLa capitale d’un pays devrait être une ville de ce pays : ???\nLes capitales de deux pays différents devraient être des villes différentes : UNIQUE\nDeux pays différents ne peuvent avoir le même code2 : UNIQUE"
  },
  {
    "objectID": "slides/LDD_2.html#examen-du-schema-de-country",
    "href": "slides/LDD_2.html#examen-du-schema-de-country",
    "title": "BD VII: Corriger le schéma World",
    "section": "Examen du schema de country",
    "text": "Examen du schema de country\n+--------------------+---------------+-----------+----------+--------------+-------------+\n| Column             | Type          | Modifiers | Storage  | Stats target | Description |\n|--------------------+---------------+-----------+----------+--------------+-------------|\n| countrycode        | character(3)  |  not null | extended | &lt;null&gt;       | &lt;null&gt;      |\n| name_country       | text          |  not null | extended | &lt;null&gt;       | &lt;null&gt;      |\n| continent          | text          |  not null | extended | &lt;null&gt;       | &lt;null&gt;      |\n| region             | text          |  not null | extended | &lt;null&gt;       | &lt;null&gt;      |\n| surfacearea        | real          |  not null | plain    | &lt;null&gt;       | &lt;null&gt;      |\n| indepyear          | smallint      |           | plain    | &lt;null&gt;       | &lt;null&gt;      |\n| population_country | integer       |  not null | plain    | &lt;null&gt;       | &lt;null&gt;      |\n| lifeexpectancy     | real          |           | plain    | &lt;null&gt;       | &lt;null&gt;      |\n| gnp                | numeric(10,2) |           | main     | &lt;null&gt;       | &lt;null&gt;      |\n| gnpold             | numeric(10,2) |           | main     | &lt;null&gt;       | &lt;null&gt;      |\n| localname          | text          |  not null | extended | &lt;null&gt;       | &lt;null&gt;      |\n| governmentform     | text          |  not null | extended | &lt;null&gt;       | &lt;null&gt;      |\n| headofstate        | text          |           | extended | &lt;null&gt;       | &lt;null&gt;      |\n| capital            | integer       |           | plain    | &lt;null&gt;       | &lt;null&gt;      |\n| code2              | character(2)  |  not null | extended | &lt;null&gt;       | &lt;null&gt;      |\n+--------------------+---------------+-----------+----------+--------------+-------------+\n Un schéma de table ne se réduit pas à la données des noms et domaines des colonnes"
  },
  {
    "objectID": "slides/LDD_2.html#continued",
    "href": "slides/LDD_2.html#continued",
    "title": "BD VII: Corriger le schéma World",
    "section": "(continued)",
    "text": "(continued)\nIndexes:\n    \"country_pkey\" PRIMARY KEY, btree (countrycode)\nCheck constraints:\n    \"country_continent_check\" CHECK (continent = 'Asia'::text OR \n                                     continent = 'Europe'::text OR \n                                     continent = 'North America'::text OR \n                                     continent = 'Africa'::text OR\n                                     continent = 'Oceania'::text OR\n                                     continent = 'Antarctica'::text OR\n                                     continent = 'South America'::text),\nForeign-key constraints:\n    \"country_capital_fkey\" FOREIGN KEY (capital) REFERENCES city(id)\n    \"country_fk\" FOREIGN KEY (continent) REFERENCES code_continent(continent)"
  },
  {
    "objectID": "slides/LDD_2.html#ddl-pour-country",
    "href": "slides/LDD_2.html#ddl-pour-country",
    "title": "BD VII: Corriger le schéma World",
    "section": "DDL pour country",
    "text": "DDL pour country\nCREATE TABLE world.country (\n    countrycode bpchar(3) NOT NULL,\n    name_country text NOT NULL,\n    continent text NOT NULL,\n    region text NOT NULL,\n    surfacearea float4 NOT NULL,\n    indepyear int2 NULL,\n    population_country int4 NOT NULL,\n    lifeexpectancy float4 NULL,\n    gnp numeric(10, 2) NULL,\n    gnpold numeric(10, 2) NULL,\n    localname text NOT NULL,\n    governmentform text NOT NULL,\n    headofstate text NULL,\n    capital int4 NULL,\n    code2 bpchar(2) NOT NULL,\n    CONSTRAINT country_continent_check CHECK (((continent = 'Asia'::text) \n    OR (continent = 'Europe'::text) \n    OR (continent = 'North America'::text) \n    OR (continent = 'Africa'::text) \n    OR (continent = 'Oceania'::text)\n    OR (continent = 'Antarctica'::text) \n    OR (continent = 'South America'::text))),\n    CONSTRAINT country_pkey PRIMARY KEY (countrycode)\n);"
  },
  {
    "objectID": "slides/LDD_2.html#ajout-de-contraintes-référentielles",
    "href": "slides/LDD_2.html#ajout-de-contraintes-référentielles",
    "title": "BD VII: Corriger le schéma World",
    "section": "Ajout de contraintes référentielles",
    "text": "Ajout de contraintes référentielles\n-- world.country foreign keys\n\nALTER TABLE world.country ADD CONSTRAINT \n  country_capital_fkey FOREIGN KEY (capital) REFERENCES world.city(id);\n\nALTER TABLE world.country ADD CONSTRAINT \n  country_fk FOREIGN KEY (continent) REFERENCES world.code_continent(continent);\n Les contraintes country_capital_fkey et country_fk sont émises par la table country"
  },
  {
    "objectID": "slides/LDD_2.html#contraintes-ajoutées",
    "href": "slides/LDD_2.html#contraintes-ajoutées",
    "title": "BD VII: Corriger le schéma World",
    "section": "Contraintes ajoutées",
    "text": "Contraintes ajoutées\n-- world.country foreign keys\n\nALTER TABLE world.country ADD CONSTRAINT \n  country_capital_fkey FOREIGN KEY (capital) REFERENCES world.city(id);\n\nALTER TABLE world.country ADD CONSTRAINT \n  country_fk FOREIGN KEY (continent) REFERENCES world.code_continent(continent);\n La contrainte country_fk sur continent remplit la même fonction que la contrainte country_continent_check\n\n Conseil:\n\nSi le domaine est de grande cardinalité, utiliser une table pour représenter le domaine, et une contrainte référentielle\nSi le domaine est de petite cardinalité, une contrainte CHECK est aussi pratique (et sans doute plus efficace)\n\n\n\n Comment procéder pour mettre en œuvre une contrainte de domaine sur region ?"
  },
  {
    "objectID": "slides/LDD_2.html#une-région-nappartient-quà-un-seul-continent",
    "href": "slides/LDD_2.html#une-région-nappartient-quà-un-seul-continent",
    "title": "BD VII: Corriger le schéma World",
    "section": "Une région n’appartient qu’à un seul continent",
    "text": "Une région n’appartient qu’à un seul continent\nCette contrainte signifie que le résultat de la requête suivante est vide :\nSELECT *\nFROM \n  world.country c1 \nJOIN \n  world.country c2 ON (c1.continent&lt;&gt; c2.continent AND c1.region=c2.region);\n\nOn exclut l’existence de deux lignes qui coïncideraient sur region mais pas sur continent\nNous postulons l’existence d’une dépendance fonctionnelle\n\\[\\texttt{region} \\longrightarrow \\texttt{continent}\\]"
  },
  {
    "objectID": "slides/LDD_2.html#deux-attitudes",
    "href": "slides/LDD_2.html#deux-attitudes",
    "title": "BD VII: Corriger le schéma World",
    "section": "Deux attitudes",
    "text": "Deux attitudes\nDans sa forme actuelle, la table country de world contient des informations redondantes: on répète plusieurs fois que la région Western Europe est située dans le continent Europe\nCes redondances représentent un gaspillage de mémoire (très modeste ici) et un risque pour le maintien de la cohérence de la base : chaque insertion, mise-à-jour est susceptible de mettre en défaut la dépendance fonctionnelle\nOn peut considérer qu’il s’agit d’une anomalie de schéma et normaliser le schéma.\nLa normalisation suppose une révision du schéma. Si le schéma est muni de vues et de fonctions, il faudra éventuellement réécrire ces vues et ces fonctions.\n\n On peut mettre en place une contrainte d’exclusion avec EXCLUDE.\nDe cette façon, on ne touchera pas au schéma, les vues et les fonctions resteront utilisables. La contrainte d’exclusion permettra de maintenir la dépendance fonctionnelle."
  },
  {
    "objectID": "slides/LDD_2.html#les-contraintes-dexclusion",
    "href": "slides/LDD_2.html#les-contraintes-dexclusion",
    "title": "BD VII: Corriger le schéma World",
    "section": "Les contraintes d’exclusion",
    "text": "Les contraintes d’exclusion\n\n\n\n\n\n\nObjectifs\n\n\n\nMise en place des dépendances fonctionnelles\nMise en place de contraintes de non-recouvrement (données spatiales ou temporelles)\nMise en place de contraintes très diverses\n\n\n\n\n\n\n\n\n\n\nComment ?\n\n\nL’ajout d’une contrainte d’exclusion crée automatiquement un index du type spécifié dans déclaration de constrainte\n\n\n\nDocumentation"
  },
  {
    "objectID": "slides/LDD_2.html#détails-syntaxiques",
    "href": "slides/LDD_2.html#détails-syntaxiques",
    "title": "BD VII: Corriger le schéma World",
    "section": "Détails syntaxiques",
    "text": "Détails syntaxiques\nEXCLUDE \n  [ USING index_method ] \n  ( exclude_element WITH operator [, ... ] ) \n  index_parameters \n  [ WHERE ( predicate ) ] \n\n\n\n\n\n\nNote\n\n\nLa clause EXCLUDE définit une contrainte d’exclusion qui garantit que si deux lignes sont comparées sur la ou les colonnes spécifiées ou des expressions utilisant le ou les opérateurs spécifiés, seulement certaines de ces comparaisons, mais pas toutes, renverront TRUE."
  },
  {
    "objectID": "slides/LDD_2.html#remarques",
    "href": "slides/LDD_2.html#remarques",
    "title": "BD VII: Corriger le schéma World",
    "section": "Remarques",
    "text": "Remarques\nSi tous les opérateurs spécifiés testent une égalité, ceci est équivalent à une contrainte UNIQUE bien qu’une contrainte unique ordinaire sera plus rapide.\nNéanmoins, ces contraintes d’exclusion peuvent spécifier des contraintes qui sont plus générales qu’une simple égalité.\nVous pouvez spécifier qu’il n’y a pas deux lignes/tuples dans la table contenant des cercles se recouvrant surcharge en utilisant l’opérateur &&.\n Le(s) opérateur(s) doivent être commutatif(s)."
  },
  {
    "objectID": "slides/LDD_2.html#mise-en-œuvre",
    "href": "slides/LDD_2.html#mise-en-œuvre",
    "title": "BD VII: Corriger le schéma World",
    "section": "Mise en œuvre",
    "text": "Mise en œuvre\nLes contraintes d’exclusion sont implantées en utilisant un index qui a le même nom que la contrainte, donc chaque opérateur précisé doit être associé avec une classe d’opérateurs appropriée pour la méthode d’accès par index, nommée méthode_index.\nChaque élément_exclusion définit une colonne de l’index, donc il peut spécifier en option une collation, une classe d’opérateur, des paramètres pour la classe d’opérateurs, et/ou des options de tri\nEn pratique, la méthode d’accès sera toujours GiST ou SP-GiST (GIST est un acronyme qui renvoie à Generalized Search Tree)."
  },
  {
    "objectID": "slides/LDD_2.html#zoologie-des-index-b-tree-hash-gin",
    "href": "slides/LDD_2.html#zoologie-des-index-b-tree-hash-gin",
    "title": "BD VII: Corriger le schéma World",
    "section": "Zoologie des index B-tree, hash, GIN",
    "text": "Zoologie des index B-tree, hash, GIN\nUne stratégie d’indexation permet de gérer efficacement des conditions de la forme\n&lt;colonne indexée&gt; &lt;opérateur&gt; &lt;valeur de comparaison&gt;\nLes index de type B-tree sont appropriés pour les types ordonnés et les opérateurs =, &lt;=, =&gt;\nLes index de type B-tree sont souvent utilisés pour réaliser les équi-jointures."
  },
  {
    "objectID": "slides/LDD_2.html#méthodes-daccès-index-gist",
    "href": "slides/LDD_2.html#méthodes-daccès-index-gist",
    "title": "BD VII: Corriger le schéma World",
    "section": "Méthodes d’accès (Index) GiST",
    "text": "Méthodes d’accès (Index) GiST\nGiST: une infrastructure qui permet la mise en œuvre de différentes stratégies d’indexation.\nLes opérateurs susceptibles d’utiliser un index GiST peuvent varier selon la stratégie d’indexation\n\nLa distribution standard de PostgreSQL comprend des classes d’opérateurs GiST pour plusieurs types de données géométriques (bidimensionnelles), qui permettent d’effectuer des requêtes indexées à l’aide de ces opérateurs\n&lt;&lt;   &&lt;   &&gt;   &gt;&gt;   &lt;&lt;|   &&lt;|   |&&gt;   |&gt;&gt;   @&gt;   &lt;@   ~=   &&"
  },
  {
    "objectID": "slides/LDD_2.html#dans-world.country",
    "href": "slides/LDD_2.html#dans-world.country",
    "title": "BD VII: Corriger le schéma World",
    "section": "Dans world.country",
    "text": "Dans world.country\nALTER TABLE world.country\nADD CONSTRAINT xcl_country_region_continent \nEXCLUDE  USING GIST  (\n    region WITH =, \n    continent with &lt;&gt;\n) ;\nAvec cette contrainte d’exclusion, on interdit la présence de deux tuples dand la table country, coïncidant sur la colonne region mais pas sur la colonne continent."
  },
  {
    "objectID": "slides/LDD_2.html#autre-exemple",
    "href": "slides/LDD_2.html#autre-exemple",
    "title": "BD VII: Corriger le schéma World",
    "section": "Autre exemple",
    "text": "Autre exemple\nCREATE TABLE public.zoo (\n  zoo_id INTEGER DEFAULT nextval('public.zoo_zoo_id_seq'::regclass) NOT NULL,\n  PRIMARY KEY, \n  cage   INTEGER,\n  animal TEXT,\n  CONSTRAINT zoo_pkey PRIMARY KEY ( zoo_id )\n  EXCLUDE USING GIST (\n    cage WITH =, \n    animal WITH &lt;&gt;)\n);"
  },
  {
    "objectID": "slides/LDD_2.html#question",
    "href": "slides/LDD_2.html#question",
    "title": "BD VII: Corriger le schéma World",
    "section": "Question",
    "text": "Question\n Comment utiliser les contraintes d’exclusion pour préciser que deux colonnes sont liées par une relation de monotonie ?"
  },
  {
    "objectID": "slides/LDD_2.html#section",
    "href": "slides/LDD_2.html#section",
    "title": "BD VII: Corriger le schéma World",
    "section": "",
    "text": "La normalisation des bases de données relationnelles est une activité en soi, guidée par des principes codifiés et des algorithmes établis (voir Normalisation I, Normalisation II)\nIci, nous profitons de la simplicité du schéma world pour normaliser country à la main."
  },
  {
    "objectID": "slides/LDD_2.html#éclatement-de-la-table-country",
    "href": "slides/LDD_2.html#éclatement-de-la-table-country",
    "title": "BD VII: Corriger le schéma World",
    "section": "Éclatement de la table country",
    "text": "Éclatement de la table country\n\nMise en place d’une table region_continent(region, continent)\nÉmission d’une contrainte référentielle de country vers region_continent"
  },
  {
    "objectID": "slides/LDD_2.html#préparation",
    "href": "slides/LDD_2.html#préparation",
    "title": "BD VII: Corriger le schéma World",
    "section": "Préparation",
    "text": "Préparation\nCREATE SCHEMA monde AUTHORIZATION superdupont ;\n\nGRANT ALL ON SCHEMA monde TO superdupont ;\n\nCREATE TABLE monde.code_continent AS \n       TABLE world.code_continent ;\n\nALTER TABLE monde.code_continent ADD CONSTRAINT \n  code_continent_pk PRIMARY KEY (codecontinent);\nALTER TABLE monde.code_continent ADD CONSTRAINT \n  code_continent_un UNIQUE (continent);"
  },
  {
    "objectID": "slides/LDD_2.html#création-de-region_continent",
    "href": "slides/LDD_2.html#création-de-region_continent",
    "title": "BD VII: Corriger le schéma World",
    "section": "Création de region_continent",
    "text": "Création de region_continent\nCREATE TABLE monde.region_continent AS \n  SELECT DISTINCT \n    region, continent \n  FROM \n    world.country c ;\nLa requête suivante renvoie une table vide:\nSELECT * \nFROM \n  monde.region_continent rc1 \nJOIN \n  monde.region_continent rc2 \nON (\n    rc1.region=rc2.region AND \n  rc1.continent&lt;&gt; rc2.continent\n) ;\nALTER TABLE monde.region_continent ADD CONSTRAINT \n    region_continent_pk PRIMARY KEY (region);\n\nALTER TABLE mode.region_continent ADD CONSTRAINT \n  region_continent_fk FOREIGN KEY (continent) \n  REFERENCES monde.code_continent(continent);"
  },
  {
    "objectID": "slides/LDD_2.html#création-de-la-table-monde.country",
    "href": "slides/LDD_2.html#création-de-la-table-monde.country",
    "title": "BD VII: Corriger le schéma World",
    "section": "Création de la table monde.country",
    "text": "Création de la table monde.country\nCREATE TABLE monde.country AS  \n  SELECT  \n    countrycode, name_country, region, surfacearea, \n    indepyear, population_country, \n    lifeexpectancy, gnp, gnpold, localname,\n    governmentform, headofstate, capital,  code2            \n  FROM \n    world.country ;\n sans colonne continent"
  },
  {
    "objectID": "slides/LDD_2.html#mise-en-place-des-contraintes-sur-monde.country",
    "href": "slides/LDD_2.html#mise-en-place-des-contraintes-sur-monde.country",
    "title": "BD VII: Corriger le schéma World",
    "section": "Mise en place des contraintes sur monde.country",
    "text": "Mise en place des contraintes sur monde.country\nALTER TABLE monde.country ADD CONSTRAINT \n  country_pk PRIMARY KEY (countrycode);\n\nALTER TABLE monde.country ADD CONSTRAINT \n  country_un_name UNIQUE (name_country);\n\nALTER TABLE monde.country ADD CONSTRAINT \n  country_un_code2 UNIQUE (code2);\n\nALTER TABLE monde.country ADD CONSTRAINT \n  country_un_capital UNIQUE (capital);\n\nALTER TABLE monde.country ADD CONSTRAINT country_fk \n  FOREIGN KEY (region) REFERENCES monde.region_continent(region) \n  ON DELETE SET NULL \n  ON UPDATE CASCADE;"
  },
  {
    "objectID": "slides/LDD_2.html#copie-de-city",
    "href": "slides/LDD_2.html#copie-de-city",
    "title": "BD VII: Corriger le schéma World",
    "section": "Copie de city",
    "text": "Copie de city\nCREATE TABLE monde.city AS \n  TABLE world.city;\n On a copié le schéma a minima (sans les contraintes)"
  },
  {
    "objectID": "slides/LDD_2.html#dans-un-pays-plusieurs-villes-peuvent-elles-porter-le-même-nom",
    "href": "slides/LDD_2.html#dans-un-pays-plusieurs-villes-peuvent-elles-porter-le-même-nom",
    "title": "BD VII: Corriger le schéma World",
    "section": "Dans un pays plusieurs villes peuvent elles porter le même nom ?",
    "text": "Dans un pays plusieurs villes peuvent elles porter le même nom ?\nSELECT *\nFROM \n  monde.city c \nJOIN \n  monde.city c2 \nON (c.name = c2.name AND \n    c.countrycode = c2.countrycode  AND \n    c.id &lt;&gt; c2.id) ;\nrenvoie 48 lignes\n\nSELECT *\nFROM \n  monde.city c \nJOIN \n  monde.city c2 \nON (c.name = c2.name AND \n    c.countrycode = c2.countrycode  AND\n    c.district = c2.district  AND\n    c.id &lt;&gt; c2.id) ;\nrenvoie 2 lignes"
  },
  {
    "objectID": "slides/LDD_2.html#existe-t-il-un-pays-dont-la-capitale-est-dans-un-autre-pays",
    "href": "slides/LDD_2.html#existe-t-il-un-pays-dont-la-capitale-est-dans-un-autre-pays",
    "title": "BD VII: Corriger le schéma World",
    "section": "Existe-t-il un pays dont la capitale est dans un autre pays ?",
    "text": "Existe-t-il un pays dont la capitale est dans un autre pays ?\nSELECT c. countrycode, c.name_country, cc.name, cc.countrycode\nFROM \n  world.country c \nJOIN \n  world.city cc \nON (c.capital = cc.id  AND \n    cc.countrycode &lt;&gt; c.countrycode) ;\nrenvoie 0 lignes"
  },
  {
    "objectID": "slides/LDD_2.html#blocages-possibles",
    "href": "slides/LDD_2.html#blocages-possibles",
    "title": "BD VII: Corriger le schéma World",
    "section": " Blocages possibles",
    "text": "Blocages possibles\nSi\n\ncity emet une contrainte référentielle sur country (countrycode)\ncountry emet une contrainte référentielle sur city (capital \\(\\rightarrow\\) id)\n\nRisque de blocage : qui précède la capitale ou le pays ?"
  },
  {
    "objectID": "slides/LDD_2.html#émission-de-la-contrainte-de-city-vers-country",
    "href": "slides/LDD_2.html#émission-de-la-contrainte-de-city-vers-country",
    "title": "BD VII: Corriger le schéma World",
    "section": "Émission de la contrainte de city vers country",
    "text": "Émission de la contrainte de city vers country\nALTER TABLE monde.city \n  ADD CONSTRAINT city_fk FOREIGN KEY (countrycode) \n      REFERENCES monde.country(countrycode) \n  ON DELETE SET NULL ON UPDATE CASCADE;"
  },
  {
    "objectID": "slides/LDD_2.html#table-countrylanguage",
    "href": "slides/LDD_2.html#table-countrylanguage",
    "title": "BD VII: Corriger le schéma World",
    "section": "Table countrylanguage",
    "text": "Table countrylanguage\nCREATE TABLE monde.countrylanguage  AS \n  TABLE world.countrylanguage ;\n\nALTER TABLE monde.countrylanguage \n  ADD CONSTRAINT countrylanguage_fk \n        FOREIGN KEY (countrycode) REFERENCES monde.country(countrycode) \n        ON DELETE CASCADE \n      ON UPDATE CASCADE;\n\nALTER TABLE monde.countrylanguage \n  ADD CONSTRAINT countrylanguage_pk \n    PRIMARY KEY (\"language\",countrycode);\n\nALTER TABLE monde.countrylanguage \n  ADD CONSTRAINT countrylanguage_check \n    CHECK (percentage &lt;= 100.0 AND percentage &gt;=0.0 );"
  },
  {
    "objectID": "slides/LDD_2.html#synthèse-régionale",
    "href": "slides/LDD_2.html#synthèse-régionale",
    "title": "BD VII: Corriger le schéma World",
    "section": "Synthèse régionale",
    "text": "Synthèse régionale\nCREATE OR REPLACE VIEW monde.regionale AS (\nSELECT C.region, \n       SUM(c.population_country) AS population_region,\n       SUM(COALESCE(c.surfacearea, 0)) AS surfacearea_region,\n       SUM(c.gnp) AS gnp_region,\n       SUM(c.gnpold) AS gnpold_region\nFROM monde.country c \nGROUP BY c.region ) ;"
  },
  {
    "objectID": "slides/LDD_2.html#synthèse-continentale",
    "href": "slides/LDD_2.html#synthèse-continentale",
    "title": "BD VII: Corriger le schéma World",
    "section": "Synthèse continentale",
    "text": "Synthèse continentale\nSELECT r.* \nFROM \n  monde.regionale r \nJOIN \n  monde.region_continent rc \nON (r.region=rc.region AND rc.continent='Europe') ;\n\nSELECT r.* \nFROM \n  monde.regionale r \nWHERE \n  r.region IN (\n    SELECT \n      region\n    FROM \n      monde.region_continent\n    WHERE \n      continent='Europe'\n  ) ;\n\n\n+----------------+-----------------+------------------+----------+-------------+\n|region          |population_region|surfacearea_region|gnp_region|gnpold_region|\n+----------------+-----------------+------------------+----------+-------------+\n|Western Europe  |        183247600|         1108456.5|4673272.00|   4578420.00|\n|Southern Europe |        144674200|         1316392.4|2012289.00|   1944737.00|\n|Baltic Countries|          7561900|          175117.0|  22418.00|     18595.00|\n|Nordic Countries|         24166400|         1321901.0| 676655.00|    677698.00|\n|British Islands |         63398500|          313173.0|1454251.00|   1369962.00|\n|Eastern Europe  |        307026000|          18814094| 659980.00|    792589.00|"
  },
  {
    "objectID": "slides/LDD_2.html#synthèse-continentale-1",
    "href": "slides/LDD_2.html#synthèse-continentale-1",
    "title": "BD VII: Corriger le schéma World",
    "section": "Synthèse continentale",
    "text": "Synthèse continentale\nCREATE OR REPLACE VIEW monde.continentale AS (\nSELECT rc.continent, \n       SUM(r.population_region) AS population,\n       SUM(r.surfacearea_region) AS surfacearea,\n       SUM(r.gnp_region) AS gcp,\n       SUM(r.gnpold_region) AS gcpold\nFROM monde.regionale r JOIN monde.region_continent rc \n     ON (r.region=rc.region) \nGROUP BY rc.continent;) ;\n\n+-------------+----------+-----------+----------+----------+\n|continent    |population|surfacearea|gcp       |gcpold    |\n+-------------+----------+-----------+----------+----------+\n|South America| 345780000|   17864926|1511874.00|1520641.00|\n|North America| 482993000|   24214472|9688627.20|9288175.00|\n|Oceania      |  30401150|  8564294.0| 419774.70| 469058.00|\n|Antarctica   |         0|   13132101|      0.00|          |\n|Africa       | 784475000|   30250376| 580375.00| 553264.00|\n|Europe       | 730074600|   23049132|9498865.00|9382001.00|\n|Asia         |3705025700|   31881006|7655392.00|8251969.00|"
  },
  {
    "objectID": "slides/LDD_0.html#définition-de-données",
    "href": "slides/LDD_0.html#définition-de-données",
    "title": "BD II: SQL LDD",
    "section": "Définition de données",
    "text": "Définition de données\nSQL est un monde à part entière\nOn peut :\n\nInterroger des données par des requêtes (déjà vu en partie)\n\nAdministrer les bases de données :\n\nCréer celles-ci : définition des tables (schémas, etc), contraintes..\nCréer de nouvelles données, en insérer, supprimer, mettre à jour, etc\nCréer et gérer les utilisateurs, leurs droits sur les objets de la base,\n…\n\n\n\n\nDans ce cours : création des tables (version simplifiée) et des données"
  },
  {
    "objectID": "slides/LDD_0.html#création-de-tables-1",
    "href": "slides/LDD_0.html#création-de-tables-1",
    "title": "BD II: SQL LDD",
    "section": "Création de tables",
    "text": "Création de tables\n\nInstruction : CREATE TABLE ...\n\n\nPermet de définir :\n\n\nLes noms et les domaines (type) des attributs ainsi que des contraintes d’intégrité comme :\n\nContraintes de clés primaires (PRIMARY KEY)\nContraintes référentielles (clés étrangères FOREIGN KEY, par exemple)\n\n\nDes contraintes assez générales (de contrôle des données)\nDes index (pour la recherche et l’exécution efficaces)"
  },
  {
    "objectID": "slides/LDD_0.html#création-de-tables-noms-et-domaines-dattributs",
    "href": "slides/LDD_0.html#création-de-tables-noms-et-domaines-dattributs",
    "title": "BD II: SQL LDD",
    "section": "Création de tables : noms et domaines d’attributs",
    "text": "Création de tables : noms et domaines d’attributs\nChaque relation est définie par un nom de relation et une liste d’attributs\nCREATE TABLE &lt;nom_relation&gt; (\n  &lt;element de relation&gt;\n  &lt;,element de relation&gt;*\n  &lt;,contrainte de relation&gt;* );\n\nChaque attribut est défini par un nom d’attribut et un type de données\n&lt;element de relation&gt; ::= &lt;nom_attrib&gt;&lt;type_donnees&gt;[&lt;contrainte_attrib&gt;*]\n\n\n\n\n\n\n\n\nExemples de types\n\n\n&lt;type_donnees&gt; ::=  VARCHAR &lt;longueur&gt;| INT | REAL | DATE"
  },
  {
    "objectID": "slides/LDD_0.html#exemple",
    "href": "slides/LDD_0.html#exemple",
    "title": "BD II: SQL LDD",
    "section": "Exemple",
    "text": "Exemple\nSchéma:\nfournisseur(nomf, villef),\npiece(nomp, prix, couleur),\nlivraison(numliv, nomf, nomp, dateliv, quantite)\n\nCREATE TABLE fournisseur(\n    nomf VARCHAR(20),\n    villef VARCHAR(20)\n);\n\nCREATE TABLE piece(\n    nomp VARCHAR(20),\n    prix REAL,\n    couleur VARCHAR(15)\n);"
  },
  {
    "objectID": "slides/LDD_0.html#exemple-avec-valeurs-par-défaut",
    "href": "slides/LDD_0.html#exemple-avec-valeurs-par-défaut",
    "title": "BD II: SQL LDD",
    "section": "Exemple avec valeurs par défaut",
    "text": "Exemple avec valeurs par défaut\n\nCREATE TABLE livraison(\n    numLiv INT,\n    nomf VARCHAR(20),\n    nomp VARCHAR(20),\n    dateliv DATE DEFAULT NOW(),\n    quantite INT DEFAULT 1\n);\n\n\n\n\n\n\n\n\nValeurs par défaut\n\n\n\nPour dateliv, c’est la date courante lors de l’insertion de la ligne dans la table\nPour quantite, c’est une constante"
  },
  {
    "objectID": "slides/LDD_0.html#exemple-schéma-world",
    "href": "slides/LDD_0.html#exemple-schéma-world",
    "title": "BD II: SQL LDD",
    "section": "Exemple : schéma world\n",
    "text": "Exemple : schéma world\n\n\nCREATE TABLE world.city (\n    id int4 NOT NULL,\n    name text NOT NULL,\n    countrycode bpchar(3) NOT NULL,\n    district text NOT NULL,\n    population int4 NOT NULL,\n    CONSTRAINT city_pkey\n        PRIMARY KEY (id)\n);\n\n\nCREATE TABLE world.code_continent (\n    continent name NOT NULL,\n    codecontinent int4 NOT NULL,\n    CONSTRAINT code_continent_pk\n        PRIMARY KEY (codecontinent)\n);"
  },
  {
    "objectID": "slides/LDD_0.html#exemple-schéma-world-avec-clé-primaire-composée",
    "href": "slides/LDD_0.html#exemple-schéma-world-avec-clé-primaire-composée",
    "title": "BD II: SQL LDD",
    "section": "Exemple : schéma world avec clé primaire composée",
    "text": "Exemple : schéma world avec clé primaire composée\n\nCREATE TABLE world.countrylanguage (\n    countrycode bpchar(3) NOT NULL,\n    \"language\" text NOT NULL,\n    isofficial bool NOT NULL,\n    percentage float4 NOT NULL,\n    CONSTRAINT countrylanguage_pkey\n        PRIMARY KEY (countrycode, language)\n);\n\n\n\n\n\n\n\n\nAttention\n\n\nUne clé peut être composée de plusieurs attributs"
  },
  {
    "objectID": "slides/LDD_0.html#exemple-schéma-world-suite",
    "href": "slides/LDD_0.html#exemple-schéma-world-suite",
    "title": "BD II: SQL LDD",
    "section": "Exemple: schéma world (suite)",
    "text": "Exemple: schéma world (suite)\n\nCREATE TABLE world.country (\n    countrycode bpchar(3) NOT NULL,\n    name_country text NOT NULL,\n    continent text NOT NULL,\n    region text NOT NULL,\n    surfacearea float4 NOT NULL,\n    indepyear int2 NULL,\n    population_country int4 NOT NULL,\n    lifeexpectancy float4 NULL,\n    gnp numeric(10, 2) NULL,\n    gnpold numeric(10, 2) NULL,\n    localname text NOT NULL,\n    governmentform text NOT NULL,\n    headofstate text NULL,\n    capital int4 NULL,\n    code2 bpchar(2) NOT NULL,\n    CONSTRAINT country_continent_check CHECK (\n        ((continent = 'Asia'::text) OR (\n            continent = 'Europe'::text) OR\n            (continent = 'North America'::text) OR\n            (continent = 'Africa'::text) OR\n            (continent = 'Oceania'::text) OR\n            (continent = 'Antarctica'::text) OR\n            (continent = 'South America'::text))),\n    CONSTRAINT country_pkey PRIMARY KEY (countrycode)\n);"
  },
  {
    "objectID": "slides/LDD_0.html#suppression-dune-table",
    "href": "slides/LDD_0.html#suppression-dune-table",
    "title": "BD II: SQL LDD",
    "section": "Suppression d’une table",
    "text": "Suppression d’une table\nDROP TABLE fournisseur;\nDROP TABLE piece;\nDROP TABLE livraison;\n\n\n\n\n\n\nSuppression n’est pas vidange\n\n\nSupprimer une table, c’est supprimer son contenu (vidange) mais aussi son schéma"
  },
  {
    "objectID": "slides/LDD_0.html#contenu-des-relations",
    "href": "slides/LDD_0.html#contenu-des-relations",
    "title": "BD II: SQL LDD",
    "section": "Contenu des relations",
    "text": "Contenu des relations\nOn peut gérer le contenu des tables directement dans le langage SQL.\nOn peut donc :\n\nAjouter des tuples à une table : INSERT INTO ...\nMettre à jour des tuples d’une relation : UPDATE ...\nSupprimer des tuples : DELETE FROM ..."
  },
  {
    "objectID": "slides/LDD_0.html#insertion-de-tuples-syntaxe",
    "href": "slides/LDD_0.html#insertion-de-tuples-syntaxe",
    "title": "BD II: SQL LDD",
    "section": "Insertion de tuples : syntaxe",
    "text": "Insertion de tuples : syntaxe\n\nINSERT INTO &lt;nom_relation&gt;\n    [(nom_attrib [, nom_attrib]*)]\n    VALUES (valeur [, valeur]*);\n\n\n\nINSERT INTO piece VALUES('x21', 1.51, 'rouge');\n\nINSERT INTO piece (nomp,couleur) VALUES('x22', 'vert');\n\n+--------+--------+-----------+\n| nomp   | prix   | couleur   |\n|--------+--------+-----------|\n| x21    | 1.51   | rouge     |\n| x22    | &lt;null&gt; | vert      |\n+--------+--------+-----------+\n\n\n\n\n\n\n\nAttention\n\n\n\nLes valeurs doivent être fournies dans l’ordre de déclaration des attributs\nLes valeurs non spécifiées sont affectées à NULL"
  },
  {
    "objectID": "slides/LDD_0.html#insertion-exemple-suite",
    "href": "slides/LDD_0.html#insertion-exemple-suite",
    "title": "BD II: SQL LDD",
    "section": "Insertion, exemple (suite)",
    "text": "Insertion, exemple (suite)\nINSERT INTO world.Country\n  (countrycode, name_country, continent,\n   region, surfacearea, indepyear, population_country,\n   lifeexpectancy, gnp, gnpold,\n   localname, governmentform, headofstate, capital, code2)\nVALUES(\n    'SYL', 'Syldavia', 'Europe',\n    'Eastern Europe', 200000, 1918, 21345717, 81.2, 25213, 24878,\n    'Syldavie', 'Constitutional Monarchy', 'Ottokar II', 0, 'SY'\n);"
  },
  {
    "objectID": "slides/LDD_0.html#remarques",
    "href": "slides/LDD_0.html#remarques",
    "title": "BD II: SQL LDD",
    "section": "Remarques",
    "text": "Remarques\nLa dernière partie du constructeur multiligne, qui commence avec VALUES est souvent appelée la liste de valeurs.\n\nUne liste de valeurs peut être définie sans référene à une table existante et définir à la volée une nouvelle table virtuelle/éphémère.\n\n\n\nSELECT *\nFROM (\n  VALUES\n    ('robe', 'logged in', '2011-01-10 10:15 AM EST'::timestamptz),\n    ('lhsu', 'logged out', '2011-01-11 10:20 AM EST'::timestamptz)\n) AS l (user_name, description, log_ts);\n\n\n\n\nQuand on utilise VALUES pour définir une table virtuelle, il faut spécifier le nom des colonnes.\nPar défaut, les types des colonnes sont inférés. Si l’inférence de type n’est pas possible, il faut effectuer explicitement des conversions de type comme ici avec ::timestamptz."
  },
  {
    "objectID": "slides/LDD_0.html#exemple-insertion-de-tuples-suite",
    "href": "slides/LDD_0.html#exemple-insertion-de-tuples-suite",
    "title": "BD II: SQL LDD",
    "section": "Exemple : Insertion de tuples (suite)",
    "text": "Exemple : Insertion de tuples (suite)\nINSERT INTO livraison\n    VALUES\n    (1, 'fournisseur1', 'x21', '2019-07-13', 2);\n\n-- Avec des colonnes pas renseignées\n\nINSERT INTO livraison\n   (numliv, dateliv, quantite)\n    VALUES\n   (2, '2018-07-29', 10);\n\n\n+----------+--------------+--------+------------+------------+\n| numliv   | nomf         | nomp   | dateliv    | quantite   |\n|----------+--------------+--------+------------+------------|\n| 1        | fournisseur1 | x21    | 2019-07-13 | 2          |\n| 2        | &lt;null&gt;       | &lt;null&gt; | 2018-07-29 | 10         |\n+----------+--------------+--------+------------+------------+\n\n\n\n\n\n\nRappel\n\n\n\nLes valeurs doivent être fournies dans l’ordre de déclaration des attributs\nLes valeurs non spécifiées sont affectées à NULL."
  },
  {
    "objectID": "slides/LDD_0.html#insertion-de-tuples-par-requête",
    "href": "slides/LDD_0.html#insertion-de-tuples-par-requête",
    "title": "BD II: SQL LDD",
    "section": "Insertion de tuples par requête",
    "text": "Insertion de tuples par requête\n\nOn peut faire une insertion par le biais d’une requête\nLa clause VALUES est remplacée par une requête\nLes résultats de la requête sont insérés comme valeurs dans la table\n\n\n\n\n\n\n\n\nAlimentation d’une nouvelle table à l’aide des données d’une autre\n\n\nINSERT INTO FournisseursParisiens (\n  SELECT *\n  FROM Fournisseur\n  WHERE VilleF='Paris'\n);"
  },
  {
    "objectID": "slides/LDD_0.html#exemple-1",
    "href": "slides/LDD_0.html#exemple-1",
    "title": "BD II: SQL LDD",
    "section": "Exemple",
    "text": "Exemple\nCREATE TABLE chaprot.city () \n  INHERITS (world.city) ;\n\nCREATE TABLE chaprot.country () \n  INHERITS (world.country) ;\n\nINSERT INTO chaprot.country (\n    SELECT * \n    FROM world.country\n    WHERE continent = 'Europe' \n);\n\nINSERT INTO chaprot.city (\n    SELECT ci.*  \n    FROM world.city ci NATURAL JOIN \n      world.country co\n    WHERE co.continent = 'Europe'\n) ;"
  },
  {
    "objectID": "slides/LDD_0.html#mise-à-jour-de-colonnes-ed-cellules",
    "href": "slides/LDD_0.html#mise-à-jour-de-colonnes-ed-cellules",
    "title": "BD II: SQL LDD",
    "section": "Mise à jour de colonnes, ed cellules",
    "text": "Mise à jour de colonnes, ed cellules\n\n\nOn peut mettre à jour des tuples existants par le biais d’une requête\n\nSoit tous les tuples de la table,\nSoit l’ensemble des tuples vérifiants une condition donnée\n\n\n\n\nUPDATE nom_relation\nSET nom_attribut = &lt;expression de valeur&gt; \n    [ , nom_attribut = &lt;expression de valeur&gt; ]*\n[WHERE &lt;condition de recherche&gt; ];"
  },
  {
    "objectID": "slides/LDD_0.html#mise-à-jour-conditionnelle-de-tuples",
    "href": "slides/LDD_0.html#mise-à-jour-conditionnelle-de-tuples",
    "title": "BD II: SQL LDD",
    "section": "Mise à jour conditionnelle de tuples",
    "text": "Mise à jour conditionnelle de tuples\nLe WHERE permet de sélectionner les tuples à mettre à jour\nUPDATE Fournisseur\nSET VilleF='St.Petersburg'\nWHERE VilleF='Leningrad';\nOn peut aussi effectuer des opérations sur les tuples à mettre à jour.\n\n\n\n\n\n\nLa clause &lt;expression de valeur&gt; peut être :\n\n\n\nNULL\nUne constante (explicite ou via une requête)\nUne expression arithmétique sur les attributs de la table à modifier"
  },
  {
    "objectID": "slides/LDD_0.html#mise-à-jour-de-tuples-exemple",
    "href": "slides/LDD_0.html#mise-à-jour-de-tuples-exemple",
    "title": "BD II: SQL LDD",
    "section": "Mise à jour de tuples (exemple)",
    "text": "Mise à jour de tuples (exemple)\nAugmentation du prix d’une pièce\nUPDATE Piece\nSET Prix = Prix * 1.05\nWHERE NomP = 'x21';"
  },
  {
    "objectID": "slides/LDD_0.html#mise-à-jour-par-requête",
    "href": "slides/LDD_0.html#mise-à-jour-par-requête",
    "title": "BD II: SQL LDD",
    "section": "Mise à jour par requête",
    "text": "Mise à jour par requête\nUPDATE Piece\nSET Prix = (\n    SELECT Prix\n    FROM Piece\n    WHERE NomP = 'x21'\n)\nWHERE Prix &lt;= 1000;"
  },
  {
    "objectID": "slides/LDD_0.html#suppression-de-tuples-syntaxe",
    "href": "slides/LDD_0.html#suppression-de-tuples-syntaxe",
    "title": "BD II: SQL LDD",
    "section": "Suppression de tuples : syntaxe",
    "text": "Suppression de tuples : syntaxe\nDELETE FROM &lt;nom_relation&gt;\n[WHERE &lt;condition de recherche&gt;];\n\nExemple\nDELETE FROM Fournisseur\nWHERE NomF = 'FastDelivery';\nOn supprime dans Fournisseur les tuples correspondant au fournisseur nommé 'FastDelivery'"
  },
  {
    "objectID": "slides/LDD_0.html#suppression-de-tuples-avec-requête-imbriquée",
    "href": "slides/LDD_0.html#suppression-de-tuples-avec-requête-imbriquée",
    "title": "BD II: SQL LDD",
    "section": "Suppression de tuples avec requête imbriquée",
    "text": "Suppression de tuples avec requête imbriquée\nDELETE FROM Livraison\nWHERE NomP IN (\n    SELECT NomP\n    FROM Piece\n    WHERE Couleur='Rouge'\n);"
  },
  {
    "objectID": "slides/LDD_0.html#delete-from-table-using-t-where-...",
    "href": "slides/LDD_0.html#delete-from-table-using-t-where-...",
    "title": "BD II: SQL LDD",
    "section": "DELETE FROM <table> USING <t> WHERE ...",
    "text": "DELETE FROM &lt;table&gt; USING &lt;t&gt; WHERE ...\n\n\n\n\n\n\nNote\n\n\nSouvent, lorsque vous supprimez des données d’une table, vous souhaitez supprimer ces données en fonction de leur présence dans un autre ensemble de données.\nSpécifiez cet ensemble supplémentaire avec le prédicat USING"
  },
  {
    "objectID": "slides/LDD_0.html#delete-from-table-using-t-where-...-1",
    "href": "slides/LDD_0.html#delete-from-table-using-t-where-...-1",
    "title": "BD II: SQL LDD",
    "section": "DELETE FROM <table> USING <t> WHERE ...",
    "text": "DELETE FROM &lt;table&gt; USING &lt;t&gt; WHERE ...\n\n\n\n\n\n\nAstuce\n\n\nSouvent, lorsque vous supprimez des données d’une table, vous souhaitez supprimer ces données en fonction de leur présence dans un autre ensemble de données.\nSpécifiez cet ensemble supplémentaire avec le prédicat USING\n\n\n\n\nDELETE FROM chaprot.city \nUSING chaprot.country AS co\nWHERE \n  city.countrycode = co.countrycode AND \n  co.region= 'Eastern Europe' AND \n  co.indepyear = 1991 ;"
  },
  {
    "objectID": "slides/DF_norm_1.html#conception-du-modèle-relationnel",
    "href": "slides/DF_norm_1.html#conception-du-modèle-relationnel",
    "title": "Normalisation I",
    "section": "Conception du modèle relationnel",
    "text": "Conception du modèle relationnel\nUne première approche pour concevoir un modèle relationnel (l’ensemble des schémas de tables d’une bd) consiste à :\n\nIdentifier les attributs d’intérêt\nRépartir les attributs dans plusieurs relations\n\n\n\nComment savoir si le modèle relationnel est bon ?\n\n\n\n\nSi ce n’est pas le cas : y a-t-il des techniques pour le transformer en un bon modèle?"
  },
  {
    "objectID": "slides/DF_norm_1.html#qualité-dun-schéma",
    "href": "slides/DF_norm_1.html#qualité-dun-schéma",
    "title": "Normalisation I",
    "section": "Qualité d’un schéma",
    "text": "Qualité d’un schéma\nQuelles sont de bonnes propriétés d’un schéma ?\nExemple\nAttributs relatifs à des vendeurs, produits et livraisons\n\n\nAttribut\nUsage\n\n\n\nV#\nnuméro du vendeur\n\n\nVnom\nnom du vendeur\n\n\nVville\nville du vendeur\n\n\nP#\nnuméro du produit\n\n\nPnom\nnom du produit\n\n\nPville\nville où le produit est stocké\n\n\nQte\nquantité de produit livrée au vendeur"
  },
  {
    "objectID": "slides/DF_norm_1.html#qualité-dun-schéma-1",
    "href": "slides/DF_norm_1.html#qualité-dun-schéma-1",
    "title": "Normalisation I",
    "section": "Qualité d’un schéma",
    "text": "Qualité d’un schéma\nUn schéma relationnel possible : une seule relation R avec tous les attributs\nR(V#, Vnom, Vville, P#, Pnom, Pville, Qte)\n\n\n C’est une mauvaise modélisation.\n Pourquoi ?"
  },
  {
    "objectID": "slides/DF_norm_1.html#qualité-dun-schéma-relationnel",
    "href": "slides/DF_norm_1.html#qualité-dun-schéma-relationnel",
    "title": "Normalisation I",
    "section": "Qualité d’un schéma relationnel",
    "text": "Qualité d’un schéma relationnel\n\n\n\n\n\n\nRedondance\n\n\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\n3\nMagicV\nParis\n…\n…\n…\n…\n\n\n3\nMagicV\nParis\n…\n…\n…\n…\n\n\n2\nIdealB\nLyon\n…\n…\n…\n…\n\n\n2\nIdealB\nLyon\n…\n…\n…\n…\n\n\n\nVnom et Vville sont déterminés parV# :\nsi deux livraisons ont le même V#, elles ont aussi le même Vville et le même Vnom"
  },
  {
    "objectID": "slides/DF_norm_1.html#section",
    "href": "slides/DF_norm_1.html#section",
    "title": "Normalisation I",
    "section": "",
    "text": "Anomalies de mise à jour\n\nVnom ou Vville pourrait être mis à jour dans une livraison et pas dans une autre, ce qui donnerait une incohérence. Les mesures pour éviter cela rendent la mise à jour est coûteuse\n\n\nAnomalies d’insertion\n\nOn ne peut pas enregistrer un vendeur s’il ne reçoit pas de livraison\n\n\n\nAnomalies de suppression\n\nSi on supprime toutes les livraisons à un vendeur, on perd toute l’information sur ce vendeur"
  },
  {
    "objectID": "slides/DF_norm_1.html#qualité-dun-schéma-relationnel-1",
    "href": "slides/DF_norm_1.html#qualité-dun-schéma-relationnel-1",
    "title": "Normalisation I",
    "section": "Qualité d’un schéma relationnel",
    "text": "Qualité d’un schéma relationnel\n\nUn bon schéma\n\nVendeur(V#, Vnom, Vville)    Clef : V#\nProduit(P#, Pnom, Pville)    Clef : P#\nLivraison(V#, P#, Qte)       Clef : (V#,P#)\n\nPlus d’anomalie ! Comment y arriver?\n\n\nLa théorie de la normalisation des BD relationnelles fournit\n\nla notion de forme normale : propriétés d’un schéma qui garantissent l’absence de redondance et des anomalies qui en dérivent. Ces propriétés sont définies par rapport à un ensemble de contraintes\ndes techniques de normalisation : passage d’un schéma arbitraire (mauvais) à un schéma en forme normale (obtenu typiquement par décomposition)"
  },
  {
    "objectID": "slides/DF_norm_1.html#df-exemple-suite",
    "href": "slides/DF_norm_1.html#df-exemple-suite",
    "title": "Normalisation I",
    "section": "DF exemple (suite)",
    "text": "DF exemple (suite)\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\n3\nMagicV\nParis\n322\nmanteau\nLille\n2\n\n\n1\nStarV\nRome\n546\nveste\nRome\n1\n\n\n3\nMagicV\nParis\n322\nmanteau\nLille\n5\n\n\n2\nIdealB\nLyon\n145\njupe\nParis\n7\n\n\n2\nIdealB\nLyon\n234\njupe\nLille\n1\n\n\n\n\n\nR satisfait V# ⟶ Vnom Vville et P# ⟶ Pnom Pville\nR viole V# P# ⟶ Qte"
  },
  {
    "objectID": "slides/DF_norm_1.html#autre-exemple",
    "href": "slides/DF_norm_1.html#autre-exemple",
    "title": "Normalisation I",
    "section": "Autre Exemple",
    "text": "Autre Exemple\nSchéma Films(titre, année, durée, genre, producteur, acteur)\n\n\n\n\n\n\n\n\n\n\ntitre\nannée\ndurée\ngenre\nproducteur\nacteur\n\n\n\nStar Wars\n1977\n124\nSciFi\nFox\nCarrie Fisher\n\n\nStar Wars\n1977\n124\nSciFi\nFox\nMark Hamill\n\n\nStar Wars\n1977\n124\nSciFi\nFox\nHarrison Ford\n\n\nGone With The Wind\n1939\n231\ndrame\nMGM\nVivien Leigh\n\n\nWayne’s World\n1992\n95\ncomédie\nParamount\nDana Carvey\n\n\nWayne’s World\n1992\n95\ncomédie\nParamount\nMike Meyers\n\n\n…"
  },
  {
    "objectID": "slides/DF_norm_1.html#définition-dune-dépendance-fonctionnelle",
    "href": "slides/DF_norm_1.html#définition-dune-dépendance-fonctionnelle",
    "title": "Normalisation I",
    "section": "Définition d’une dépendance fonctionnelle",
    "text": "Définition d’une dépendance fonctionnelle\n\n\n\n\n\n\nDéfinition : Dépendance fonctionnelle\n\n\nSoit \\(\\mathcal{A}\\) un schéma de relation (\\(\\mathcal{A}\\) est un ensemble d’attributs)\nUne dépendance fonctionnelle sur \\(\\mathcal{A}\\) est une expression de la forme\n\\[X → Y\\]\noù \\(X ⊆ \\mathcal{A}\\) et \\(Y ⊆ \\mathcal{A}\\)\nUne relation \\(R\\) de schéma \\(\\mathcal{A}\\) satisfait \\(X → Y\\) si pour tous tuples \\(s,t ∈ R\\) on a\n\\[\\bigl(∀ A∈ X\\ s.A=t.A\\bigr) ⟹ \\bigl(\\forall A∈ Y\\ s.A=t.A\\bigr)\\]\n(si \\(s\\) et \\(t\\) coïncident sur \\(X\\) alors \\(s\\) et \\(t\\) coïncident sur \\(Y\\))\nUne relation \\(R\\), de schéma \\(\\mathcal{A}\\), satisfait un ensemble \\(\\Sigma\\) de DF si \\(R\\) satisfait chaque DF de \\(\\Sigma\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#exemples",
    "href": "slides/DF_norm_1.html#exemples",
    "title": "Normalisation I",
    "section": "Exemples",
    "text": "Exemples\nDans la base Pagila, relation Actor :\n\nActor_id ⟶ last_name, first_name\ncar Actor_id est une clé…"
  },
  {
    "objectID": "slides/DF_norm_1.html#dépendance-fonctionnelle-triviale",
    "href": "slides/DF_norm_1.html#dépendance-fonctionnelle-triviale",
    "title": "Normalisation I",
    "section": "Dépendance fonctionnelle triviale",
    "text": "Dépendance fonctionnelle triviale\nUne DF triviale est une DF satisfaite par toute relation\n\n\n\n\n\n\nDéfinition (dépendance triviale)\n\n\nSoient \\(X,Y⊂ \\mathcal{A}\\)\n\\(X\\rightarrow Y\\) est une dépendance triviale si \\(Y ⊂ X\\)\n\n\n\n\n\n\n\n\n\n\nExemple\n\n\nNo_insee ⟶ No_insee est triviale"
  },
  {
    "objectID": "slides/DF_norm_1.html#implication-pour-les-df",
    "href": "slides/DF_norm_1.html#implication-pour-les-df",
    "title": "Normalisation I",
    "section": "Implication pour les DF",
    "text": "Implication pour les DF\n\nSoit \\(\\mathcal{A}\\) un schéma de relation ( \\(\\mathcal{A}\\) est un ensemble d’attributs) et \\(\\Sigma\\) un ensemble de DF sur \\(\\mathcal{A}\\)\nExemple : \\(\\mathcal{A}=\\{A,B,C\\}\\) et \\(\\Sigma=\\{A\\rightarrow B, B\\rightarrow C\\}\\)\nLes DF données impliquent d’autres DF additionnelles\n\n\n\n\n\n\n\n\nExemple I\n\n\n\\(A\\rightarrow B\\) et \\(B\\rightarrow C\\) impliquent \\(A\\rightarrow C\\)\nc’est-à-dire : toute relation de schéma \\(\\mathcal{A}\\) qui satisfait \\(A\\rightarrow B\\) et \\(B\\rightarrow C\\) satisfait également \\(A\\rightarrow C\\)\n\n\n\n\n\n\n\n\n\n\n\nExemple II\n\n\n\\(A\\rightarrow C\\), \\(BC\\rightarrow D\\), \\(AD\\rightarrow E\\) impliquent \\(AB\\rightarrow E\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#implication-entre-df",
    "href": "slides/DF_norm_1.html#implication-entre-df",
    "title": "Normalisation I",
    "section": "Implication entre DF",
    "text": "Implication entre DF\n\n\n\n\n\n\nDéfinition\n\n\nUn ensemble \\(\\Sigma\\) de DF implique une autre DF \\(X\\rightarrow Y\\) si toute relation (instance) qui satisfait \\(\\Sigma\\) satisfait également \\(X\\rightarrow Y\\).\nNotation pour \\(\\Sigma\\) implique \\(X\\rightarrow Y\\) :\n\\[\\Sigma \\models X \\rightarrow Y\\]\n\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\\(\\Sigma=\\{A\\rightarrow B, B\\rightarrow C\\}\\) implique\n\\(A\\rightarrow B\\), \\(B\\rightarrow C\\), \\(A\\rightarrow C\\), \\(A,B\\rightarrow C\\), …\nmais aussi les DF triviales \\(A\\rightarrow A\\), \\(AB\\rightarrow A\\), …"
  },
  {
    "objectID": "slides/DF_norm_1.html#vérification-de-la-transitivité",
    "href": "slides/DF_norm_1.html#vérification-de-la-transitivité",
    "title": "Normalisation I",
    "section": "Vérification de la transitivité",
    "text": "Vérification de la transitivité\nOn se rammène à vérifier une règle du calcul propositionnel :\nsi p ⇒ q et q ⇒ r alors p ⇒ r\nSoit une instance \\(\\mathcal{R}\\) telle que :\\[\\forall s,t \\in \\mathcal{R} \\qquad\n  \\begin{cases}  \\text{si } s.X =t.X & \\text{alors } s.Y= t.Y \\\\\n   \\text{si } s.Y =t.Y &  \\text{alors } s.Z= t.Z\n\\end{cases}\n\\] On a alors aussi \\(\\forall s,t \\in \\mathcal{R}\\), si \\(s.X =t.X\\) alors \\(s.Z= t.Z\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#tables-de-vérité",
    "href": "slides/DF_norm_1.html#tables-de-vérité",
    "title": "Normalisation I",
    "section": "Tables de vérité",
    "text": "Tables de vérité\n\n\np\nq\nr\np ⇒ q\nq ⇒ r\np ⇒ r\n\n\n\nTRUE\nTRUE\nTRUE\nTRUE\nTRUE\nTRUE\n\n\nFALSE\nTRUE\nTRUE\nTRUE\nTRUE\nTRUE\n\n\nTRUE\nFALSE\nTRUE\nFALSE\nTRUE\nTRUE\n\n\nFALSE\nFALSE\nTRUE\nTRUE\nTRUE\nTRUE\n\n\nTRUE\nTRUE\nFALSE\nTRUE\nFALSE\nFALSE\n\n\nFALSE\nTRUE\nFALSE\nTRUE\nFALSE\nTRUE\n\n\nTRUE\nFALSE\nFALSE\nFALSE\nTRUE\nFALSE\n\n\nFALSE\nFALSE\nFALSE\nTRUE\nTRUE\nTRUE"
  },
  {
    "objectID": "slides/DF_norm_1.html#preuve",
    "href": "slides/DF_norm_1.html#preuve",
    "title": "Normalisation I",
    "section": "Preuve",
    "text": "Preuve"
  },
  {
    "objectID": "slides/DF_norm_1.html#exemples-1",
    "href": "slides/DF_norm_1.html#exemples-1",
    "title": "Normalisation I",
    "section": "Exemples",
    "text": "Exemples\n\\(\\mathcal{A}=\\{A,B,C,D\\}\\),\n\\(\\Sigma= \\{AB\\rightarrow C, C\\rightarrow A, BC\\rightarrow D\\}\\)|\n\\(\\Sigma'=\\{AB\\rightarrow D\\}\\)\n\\(\\Sigma\\models\\Sigma'\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#question-principale",
    "href": "slides/DF_norm_1.html#question-principale",
    "title": "Normalisation I",
    "section": "Question principale",
    "text": "Question principale\n\nComment vérifier si un ensemble \\(\\Sigma\\) de DF implique une DF \\(X\\rightarrow Y\\)~?\n\n\n\nPar les équivalences présentées précédemment, la question se ramène à :\n\nComment vérifier si un ensemble \\(\\Sigma\\) de DF implique une DF \\(X\\rightarrow A\\) où \\(A\\) est un attribut~?"
  },
  {
    "objectID": "slides/DF_norm_1.html#fermeture-dun-ensemble-dattributs-1",
    "href": "slides/DF_norm_1.html#fermeture-dun-ensemble-dattributs-1",
    "title": "Normalisation I",
    "section": "Fermeture d’un ensemble d’attributs",
    "text": "Fermeture d’un ensemble d’attributs\nSoit \\(X \\subset\\mathcal{A}\\) un sous-ensemble d’attributs et \\(\\Sigma\\) un ensemble de DF sur \\(\\mathcal{A}\\)\n\n\n\n\n\n\nDéfinition\n\n\nLa fermeture de \\(X\\) par rapport à \\(\\Sigma\\) est\n\\[X^+=\\{ A\\in\\mathcal{A} \\mid \\Sigma\\models X\\rightarrow A \\}\\]\n\n\n\n\n\nAutrement dit \\(X^+\\) est l’ensemble des attributs déterminés par \\(X\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#exemple-de-fermeture",
    "href": "slides/DF_norm_1.html#exemple-de-fermeture",
    "title": "Normalisation I",
    "section": "Exemple de fermeture",
    "text": "Exemple de fermeture\n\n\\(R(ABCDE)\\)\n\\(\\Sigma=\\{AB\\rightarrow C, C\\rightarrow D, E\\rightarrow D\\}\\)\n\\(\\{A,B\\}^+=\\{A,B,C,D\\}\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#section-2",
    "href": "slides/DF_norm_1.html#section-2",
    "title": "Normalisation I",
    "section": "",
    "text": "Soit \\(\\Sigma\\) un ensemble de DF sur un schéma \\(\\mathcal{A}\\) et \\(X\\subset\\mathcal{A}\\)\n\n\n\n\n\\begin{algorithm} \\caption{Fermeture} \\begin{algorithmic} \\Procedure{Fermeture}{$X, Σ$} \\State $X^c ← X$ \\Repeat \\State stop ← \\True \\Comment{Arrêt si Point Fixe atteint} \\For{$(Y → Z) ∈ Σ$} \\If{$Y ⊆ X^c ∧ ¬ Z ⊆ X^c$} \\State $X^c ← X^c ∪ Z$ \\State stop ← \\False \\Comment{Point Fixe pas atteint} \\Break \\EndIf \\EndFor \\Until{stop} \\Return $X^c$ \\EndProcedure \\end{algorithmic} \\end{algorithm}\n\n\n\nXc &lt;-  X\n\nwhile (exists Y -&gt; Z in Σ with Y ⊂ Xc and not Z ⊂ Xc) {\n  Xc &lt;- Xc ∪ Z\n}\n\nreturn Xc"
  },
  {
    "objectID": "slides/DF_norm_1.html#exemple-de-calcul-de-fermeture",
    "href": "slides/DF_norm_1.html#exemple-de-calcul-de-fermeture",
    "title": "Normalisation I",
    "section": "Exemple de calcul de fermeture",
    "text": "Exemple de calcul de fermeture\n\\(\\mathcal{A}=\\{ABCDEF\\}\\) \\(\\Sigma=\\{A\\rightarrow C, BC\\rightarrow D, AD\\rightarrow E\\}\\) \\(X=\\{A,B\\}\\)\n\n\\(X_c=\\{A,B\\}\\)\n\\(A\\rightarrow C\\) donc on obtient \\(X^cc=\\{A,B,C\\}\\)\n\\(BC\\rightarrow D\\) donc on obtient \\(X^c=\\{A,B,C,D\\}\\)\n\\(AD\\rightarrow E\\) donc on obtient \\(X^c=\\{A,B,C,D, E\\}\\)\nOn obtient \\(X^+=\\{A,B,C,D, E\\}\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#terminaison-de-lalgorithme",
    "href": "slides/DF_norm_1.html#terminaison-de-lalgorithme",
    "title": "Normalisation I",
    "section": "Terminaison de l’algorithme",
    "text": "Terminaison de l’algorithme\n \\(X^c\\) grandit à chaque itération\nComme \\(\\mathcal{A}\\) est fini, l’algorithme se termine en au plus \\(|\\mathcal{A}|\\) itérations"
  },
  {
    "objectID": "slides/DF_norm_1.html#correction-de-lalgorithme-de-fermeture",
    "href": "slides/DF_norm_1.html#correction-de-lalgorithme-de-fermeture",
    "title": "Normalisation I",
    "section": "Correction de l’algorithme de fermeture \n",
    "text": "Correction de l’algorithme de fermeture \n\n\nL’algorithme calcule uniquement des attributs dans la fermeture car on a toujours \\(X^c \\subset X^+\\) (récurrence sur le nombre d’itérations de la boucle repeat)\nL’algorithme calcule tous les attributs dans la fermeture: \\(X_c=X^+\\) quand l’algorithme se termine\n\n\n\nLe dernier point est le plus délicat. Que peut signifier le fait qu’il existe au moins un attribut \\(Y\\in X^+\\) qui n’appartienn pas à valeur terminale de \\(X^c\\) ?"
  },
  {
    "objectID": "slides/DF_norm_1.html#calcul-de-la-fermeture-transitive-exemple",
    "href": "slides/DF_norm_1.html#calcul-de-la-fermeture-transitive-exemple",
    "title": "Normalisation I",
    "section": "Calcul de la fermeture transitive : exemple",
    "text": "Calcul de la fermeture transitive : exemple\n\n\nSoit \\(R\\) d’ensemble d’attributs\n\\[\\mathcal{A} =\\{A,B,C,D,E,F,G\\}\\]\nSoit \\(X=\\{B,D\\} \\subset \\mathcal{A}\\)\nEt \\(Σ\\) l’ensemble de dépendances fonctionnelles ci-contre\n\n\n\n\\(\\Sigma\\)\n\n\n\n\\(A,B \\rightarrow C\\)\n\n\n\\(C \\rightarrow A\\)\n\n\n\\(B,C \\rightarrow D\\)\n\n\n\\(A,C,D \\rightarrow B\\)\n\n\n\\(F\\rightarrow A,C\\)\n\n\n\\(D \\rightarrow E,G\\)\n\n\n\\(B,E \\rightarrow C\\)\n\n\n\\(C,G \\rightarrow B,D\\)\n\n\n\\(C,E \\rightarrow A,G\\)\n\n\n\n\n\nMontrer que \\(X^+=\\{A,B,C,D,E,G\\}\\)\nDonner une clef de \\(R\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#forme-normale-de-boyce-codd-fnbc",
    "href": "slides/DF_norm_1.html#forme-normale-de-boyce-codd-fnbc",
    "title": "Normalisation I",
    "section": "Forme normale de Boyce-Codd (FNBC)",
    "text": "Forme normale de Boyce-Codd (FNBC)\n\n\n\n\n\n\nDéfinition\n\n\nUn schéma \\(\\mathcal{A}\\) est en FNBC par rapport à un ensemble de dépendances fonctionnelles \\(\\Sigma\\) sur \\(\\mathcal{A}\\)\nsi\npour toute DF non triviale \\(X\\rightarrow Y\\) impliquée par \\(\\Sigma\\) (Σ ⊧ X → Y avec \\(¬ Y ⊂ X\\)), \\(X\\) est une super-clef\n\n\n\n\n\n\n \\((\\mathcal{A},\\Sigma)\\) est en FNBC si pour toute DF non triviale impliquée par \\(\\Sigma\\), le membre de gauche (le déterminant) est une super-clef"
  },
  {
    "objectID": "slides/DF_norm_1.html#fnbc-exemple-1",
    "href": "slides/DF_norm_1.html#fnbc-exemple-1",
    "title": "Normalisation I",
    "section": "FNBC : exemple 1",
    "text": "FNBC : exemple 1\n\nSchéma \\(\\mathcal{A}=\\{\\texttt{V\\#, Vnom, Vville, P\\#, Pnom, Pville, Qte}\\}\\)\n\n\nEnsemble de dépendances fonctionnelles \\(\\Sigma\\) :\nV# ⟶ Vnom Vville\nP# ⟶ Pnom Pville\nV# P# ⟶ Qte\n\n\\(\\mathcal{A}\\) n’est pas en FNBC par rapport \\(\\Sigma\\).\nEn effet ni V# ni P# ne sont des super-clefs"
  },
  {
    "objectID": "slides/DF_norm_1.html#fnbc-exemple-2",
    "href": "slides/DF_norm_1.html#fnbc-exemple-2",
    "title": "Normalisation I",
    "section": "FNBC : exemple 2",
    "text": "FNBC : exemple 2\nSchéma Films(titre, année, durée, genre, producteur, acteur)\n\nOn a la dépendance suivante titre, année ⟶ durée, genre, producteur\ntitre, année, acteur est la seule clef\nLa DF titre, année ⟶ durée, genre, producteur} viole la condition de FNBC"
  },
  {
    "objectID": "slides/DF_norm_1.html#fnbc-exemple-3",
    "href": "slides/DF_norm_1.html#fnbc-exemple-3",
    "title": "Normalisation I",
    "section": "FNBC : exemple 3",
    "text": "FNBC : exemple 3\nTrois schémas en FNBC :\n\n\nRelation\nClef\n\n\n\nVendeur(V#, Vnom, Vville)\nV#\n\n\nProduit(P#, Pnom, Pville)\nP#\n\n\nLivraison(V#, P#, Qte)\n(V#,P#)"
  },
  {
    "objectID": "slides/DF_norm_1.html#schéma-avec-deux-attributs",
    "href": "slides/DF_norm_1.html#schéma-avec-deux-attributs",
    "title": "Normalisation I",
    "section": "Schéma avec deux attributs",
    "text": "Schéma avec deux attributs\n\n\n\n\n\n\nProposition\n\n\nSoit \\(\\mathcal{A}=\\{A,B\\}\\) un schéma avec deux attributs et \\(\\Sigma\\) un ensemble de DF non triviales.\n\\(\\mathcal{A}\\) est toujours en FNBC par rapport à \\(\\Sigma\\)\n\n\n\n\n\nPreuve. On distingue 4 cas\n\n\\(\\Sigma=\\emptyset\\)\n\\(\\Sigma=\\{A\\rightarrow B\\}\\)\n\\(\\Sigma=\\{B\\rightarrow A\\}\\)\n\\(\\Sigma=\\{A\\rightarrow B, B\\rightarrow A\\}\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#décomposition-dun-schéma-de-relation",
    "href": "slides/DF_norm_1.html#décomposition-dun-schéma-de-relation",
    "title": "Normalisation I",
    "section": "Décomposition d’un schéma de relation",
    "text": "Décomposition d’un schéma de relation\n\n\n\n\n\n\nDéfinition\n\n\nSoit \\(\\mathcal{A}\\) un schéma de relation\nUn décomposition de \\(\\mathcal{A}\\) est un ensemble \\(\\{\\mathcal{A}_1,..., \\mathcal{A}_k\\}\\) de sous-ensembles de \\(\\mathcal{A}\\) tel que\n\\[\\mathcal{A}_i\\not=\\emptyset, 1\\le i\\le k, \\quad \\text{ et } \\quad \\mathcal{A} = \\bigcup_{i=1}^k \\mathcal{A}_i\\]\n\n\n\n\n Une décomposition n’est pas nécessairement une partition. On n’impose pas que les \\(\\mathcal{A}_i\\) soient deux à deux disjoints."
  },
  {
    "objectID": "slides/DF_norm_1.html#exemple-de-décomposition-i",
    "href": "slides/DF_norm_1.html#exemple-de-décomposition-i",
    "title": "Normalisation I",
    "section": "Exemple de décomposition I",
    "text": "Exemple de décomposition I\nVendeur(V#, Vnom, Vville)\nProduit(P#, Pnom, Pville)\nLivraison(V#, P#, Qte)\nest une décomposition du schéma\nR(V#, Vnom, Vville, P#, Pnom, Pville, Qte)"
  },
  {
    "objectID": "slides/DF_norm_1.html#exemple-de-décomposition-ii",
    "href": "slides/DF_norm_1.html#exemple-de-décomposition-ii",
    "title": "Normalisation I",
    "section": "Exemple de décomposition II",
    "text": "Exemple de décomposition II\nSchéma :\nFilms(titre, année, durée, genre, producteur, acteur)\n\nUne décomposition :\nFilms1(titre, année, durée, genre, producteur)\nFilms2(titre, année, acteur)\n\n\nFilms1 est FNBC par rapport à \\(\\Sigma_1=\\{\\texttt{titre, année ⟶ durée, genre, producteur}\\}\\)\n\n\nFilms2 est en FNBC par rapport à \\(\\Sigma_2=\\emptyset\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#propriétés-dune-décomposition",
    "href": "slides/DF_norm_1.html#propriétés-dune-décomposition",
    "title": "Normalisation I",
    "section": "Propriétés d’une décomposition",
    "text": "Propriétés d’une décomposition\nOn ne peut pas décomposer arbitrairement\nToutes les décompositions ne sont pas intéressantes\n\n\n\n\n\n\n\nConditions pour une décomposition raisonnable :\n\n\n\nDécomposition sans perte d’information\nDécomposition sans perte de dépendance fonctionnelle"
  },
  {
    "objectID": "slides/DF_norm_1.html#décomposition-sans-perte-dinformation-1",
    "href": "slides/DF_norm_1.html#décomposition-sans-perte-dinformation-1",
    "title": "Normalisation I",
    "section": "Décomposition sans perte d’information",
    "text": "Décomposition sans perte d’information\nIdée : Si on remplace le schéma\n(V#, Vnom, Vville, P#, Pnom, Pville, Qte)\npar les trois schémas\nVendeur(V#, Vnom, Vville)\nProduit(P#, Pnom, Pville)\nLivraison(V#, P#, Qte)\nalors au lieu de stocker une relation R(V#, Vnom, Vville, P#, Pnom, Pville, Qte), on stockera ses projections:\n\\[\\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R}) \\qquad \\pi_{\\texttt{P\\#,Pnom,Pville}}(\\texttt{R}) \\qquad \\pi_{\\texttt{V\\#,P\\#,Qte}}(\\texttt{R})\\]\n Peut-on retrouver R à partir de ces trois projections ?"
  },
  {
    "objectID": "slides/DF_norm_1.html#décomposition-sans-perte-dinformation-2",
    "href": "slides/DF_norm_1.html#décomposition-sans-perte-dinformation-2",
    "title": "Normalisation I",
    "section": "Décomposition sans perte d’information",
    "text": "Décomposition sans perte d’information\n\nLa décomposition doit garantir que pour toute relation R, ses projections contiennent la même information que R au sens que l’on doit pouvoir reconstruire R à partir de ses projections\nComment tenter de reconstruire R à partir de ses projections ?\n\nOn considère la jointure naturelle\n\\[\\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{P\\#,Pnom,Pville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{V\\#,P\\#,Qte}}(\\texttt{R})\\]"
  },
  {
    "objectID": "slides/DF_norm_1.html#décomposition-sans-perte-dinformation-3",
    "href": "slides/DF_norm_1.html#décomposition-sans-perte-dinformation-3",
    "title": "Normalisation I",
    "section": "Décomposition sans perte d’information",
    "text": "Décomposition sans perte d’information\nLa propriété souhaitée s’écrit donc\n\\[R = \\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{P\\#,Pnom,Pville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{V\\#,P\\#,Qte}}(\\texttt{R})\\]\npour toute relation R(V#, Vnom, Vville, P#, Pnom, Pville, Qte) satisfaisant les DF\n\n\nEst ce vrai?\nIntuitivement, oui : à partir d’un tuple de Livraison(V#,P#,Qte)\nV# permet de récupérer toutes les informations sur le vendeur (V# ⟶ Vnom Vville)\nP# permet de récupérer toutes les informations sur le produit (P# ⟶ Pnom Pville)\n La propriété d’être sans perte d’information est liée à l’ensemble de DF considéré"
  },
  {
    "objectID": "slides/DF_norm_1.html#décomposition-sans-perte-dinformation-lossless-join",
    "href": "slides/DF_norm_1.html#décomposition-sans-perte-dinformation-lossless-join",
    "title": "Normalisation I",
    "section": "Décomposition sans perte d’information (lossless join)",
    "text": "Décomposition sans perte d’information (lossless join)\n\n\n\n\n\n\nDéfinition\n\n\nSoit \\(\\mathcal{A}\\) un schéma de relation et \\(\\Sigma\\) un ensemble de DF sur \\(\\mathcal{A}\\).\nUne décomposition \\(\\{\\mathcal{A}_1,..., \\mathcal{A}_k\\}\\) est sans perte d’information par rapport à \\(\\Sigma\\) si pour toute relation \\(R\\) de schéma \\(\\mathcal{A}\\) satisfaisant \\(\\Sigma\\) on a\n\\[R= \\pi_{\\mathcal{A}_1}(R) \\bowtie \\pi_{\\mathcal{A}_2}(R) \\bowtie...\\bowtie\\pi_{\\mathcal{A}_k}(R)\\]"
  },
  {
    "objectID": "slides/DF_norm_1.html#exemple-de-décomposition-avec-perte-dinformation",
    "href": "slides/DF_norm_1.html#exemple-de-décomposition-avec-perte-dinformation",
    "title": "Normalisation I",
    "section": "Exemple de décomposition avec perte d’information",
    "text": "Exemple de décomposition avec perte d’information\n\\(\\mathcal{A}=\\{A,B,C\\} \\quad  \\Sigma=\\{AB\\rightarrow C\\}\\)\nDécomposition \\(\\mathcal{A}_1=\\{A,B\\}  \\quad  \\mathcal{A}_2=\\{B,C\\}\\)\n\n\nSoit \\(R\\) la relation\n\n\nA\nB\nC\n\n\n\n1\n2\n3\n\n\n4\n2\n5\n\n\n\n\n\\(\\pi_{AB}(R)=\\)\n\n\nA\nB\n\n\n\n1\n2\n\n\n4\n2\n\n\n\n\n\\(\\pi_{BC}(R)=\\)\n\n\nB\nC\n\n\n\n2\n3\n\n\n2\n5\n\n\n\n\n\\(\\pi_{AB}(R) \\bowtie \\pi_{BC}(R)=\\)\n\n\nA\nB\nC\n\n\n\n1\n2\n3\n\n\n4\n2\n5\n\n\n1\n2\n5\n\n\n4\n2\n3"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite-chase-algorithm",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite-chase-algorithm",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite (chase algorithm)",
    "text": "Algorithme de poursuite (chase algorithm)\n\nComment déterminer si une décomposition est sans perte d’information?\nSi \\(R\\) est une relation de schéma \\(\\mathcal{A}\\) on a toujours que\n\n\\[R ⊆ \\pi_{\\mathcal{A}_1}(R) \\bowtie \\pi_{\\mathcal{A}_2}(R) \\bowtie...\\bowtie\\pi_{\\mathcal{A}_k}(R)\\]\npar définition de la jointure naturelle et de la projection\n\nLe seul problème est que les jointures peuvent générer des tuples supplémentaires\nMais comme \\(R\\) est supposée vérifier les DF de \\(\\Sigma\\), l’inclusion inverse est garantie dans certains cas\n\nPour le savoir, un algorithme simple existe appelé algorithme de poursuite"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite : exemple",
    "text": "Algorithme de poursuite : exemple\nSi on remplace le schéma (V#, Vnom, Vville, P#, Pnom, Pville, Qte) par\nVendeur(V#, Vnom, Vville)}\nProduit(P#, Pnom, Pville)}\nLivraison(V#, P#, Qte)\nA-t-on\n\\[\\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{P\\#,Pnom,Pville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{V\\#,P\\#,Qte}}(R) \\subset \\texttt{R} \\quad ?\\]"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-1",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-1",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite : exemple",
    "text": "Algorithme de poursuite : exemple\nSoit \\(t\\) un tuple dans la jointure\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d\\)\n\\(e\\)\n\\(f\\)\n\\(g\\)\n\n\n\n\\((a, b, c)\\in \\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R})\\) donc il existe \\(e_1, f_1, g_1\\) tels que \\((a, b, c, d_1, e_1, f_1, g_1) \\in \\texttt{R}\\)\n\\((d,e,f) \\in \\pi_{\\texttt{P\\#,Pnom,Pville}}(\\texttt{R})\\) donc il existe \\(a_2, b_2, c_2, g_2\\) tels que \\((a_2, b_2, c_2, d, e, f, g_2)\\in \\texttt{R}\\)\n\\((a,d,g)\\in \\pi_{\\texttt{V\\#,P\\#,Qte}}(R)\\) donc il existe \\(b_3,c_3,e_3,f_3\\) tels que \\((a,b_3,c_3,d,e_3,f_3,g)\\in \\texttt{R}\\)\nOn peut le représenter comme ceci :\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\nVendeur\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d_1\\)\n\\(e_1\\)\n\\(f_1\\)\n\\(g_1\\)\n\n\nProduit\n\\(a_2\\)\n\\(b_2\\)\n\\(c_2\\)\n\\(d\\)\n\\(e\\)\n\\(f\\)\n\\(g_2\\)\n\n\nLivraison\n\\(a\\)\n\\(b_3\\)\n\\(c_3\\)\n\\(d\\)\n\\(e_3\\)\n\\(f_3\\)\n\\(g\\)\n\n\n\n\n\nVendeur (resp. Produit, Livraison) désigne l’ensemble des tuples de \\(R\\) qui se projettent sur \\(a,b,c\\) (resp. \\(d,e,f\\) et \\(a,d,g\\)) lorsque on projette \\(R\\) sur V#,Vnom,Vville (resp. P#, Pnom, Pville et V#, P#, Qte)"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-2",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-2",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite : exemple",
    "text": "Algorithme de poursuite : exemple\n\n\n\n\n\n\n\n\n\n\n\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\nVendeur\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d_1\\)\n\\(e_1\\)\n\\(f_1\\)\n\\(g_1\\)\n\n\nProduit\n\\(a_2\\)\n\\(b_2\\)\n\\(c_2\\)\n\\(d\\)\n\\(e\\)\n\\(f\\)\n\\(g_2\\)\n\n\nLivraison\n\\(a\\)\n\\(b_3\\)\n\\(c_3\\)\n\\(d\\)\n\\(e_3\\)\n\\(f_3\\)\n\\(g\\)\n\n\n\nV# ⟶ Vnom, Vville donc \\(b_3=b\\) et \\(c_3=c\\)\n\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\nVendeur\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d_1\\)\n\\(e_1\\)\n\\(f_1\\)\n\\(g_1\\)\n\n\nProduit\n\\(a_2\\)\n\\(b_2\\)\n\\(c_2\\)\n\\(d\\)\n\\(e\\)\n\\(f\\)\n\\(g_2\\)\n\n\nLivraison\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d\\)\n\\(e_3\\)\n\\(f_3\\)\n\\(g\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-suite",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-suite",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite : exemple (suite)",
    "text": "Algorithme de poursuite : exemple (suite)\nP#⟶ Pnom, Pville donc \\(e_3=e\\) et \\(f_3=f\\)\n\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\nVendeur\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d_1\\)\n\\(e_1\\)\n\\(f_1\\)\n\\(g_1\\)\n\n\nProduit\n\\(a_2\\)\n\\(b_2\\)\n\\(c_2\\)\n\\(d\\)\n\\(e\\)\n\\(f\\)\n\\(g_2\\)\n\n\nLivraison\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d\\)\n\\(e\\)\n\\(f\\)\n\\(g\\)\n\n\n\nOn a obtenu une ligne égale au tuple \\(t=(a,b,c,d,e,f,g)\\) donc \\(t\\in \\texttt{R}\\) (tous les tuples qui se projettent sur \\(a,f,g\\) coïncident avec \\(t\\))\nOn en déduit que la décomposition est Sans Perte d’Information (SPI)"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite-cas-général",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite-cas-général",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite : cas général",
    "text": "Algorithme de poursuite : cas général\n\nEntrée : un schéma \\(\\mathcal{A}\\), une décomposition \\(\\{\\mathcal{A}_1,...,\\mathcal{A}_k\\}\\) et un ensemble \\(\\Sigma\\) de DF\nPour chaque attribut de \\(\\mathcal{A}\\), choisir un symbole (par exemple \\(a\\), \\(b\\), \\(c\\),…). La correspondance doit être injective.\nConstruire un tableau dont les colonnes sont les attributs de \\(\\mathcal{A}\\)\n\nLe tableau a une ligne pour chaque \\(\\mathcal{A}_i\\)\nSur la ligne associée à \\(\\mathcal{A}_i\\), les positions correspondant à \\(\\mathcal{A}_i\\) sont remplies avec les symboles choisis.\nLes autres positions sont remplies avec les symboles indicés par \\(i\\)\n\nRépéter tant que possible : s’il existe une DF \\(X\\rightarrow Y\\) dans \\(\\Sigma\\) et deux lignes du tableau en accord sur \\(X\\), égaliser ces deux lignes sur \\(Y\\)\nSortie : Si on obtient une ligne sans valeur indicée, la décomposition est sans perte d’information, sinon il y a perte d’information"
  },
  {
    "objectID": "slides/DF_norm_1.html#commentaires-sur-lalgorithme-de-poursuite",
    "href": "slides/DF_norm_1.html#commentaires-sur-lalgorithme-de-poursuite",
    "title": "Normalisation I",
    "section": "Commentaires sur l’algorithme de poursuite",
    "text": "Commentaires sur l’algorithme de poursuite\nL’objectif de l’algorithme de poursuite est de vérifier que tout tuple de \\(\\pi_{\\mathcal{A}_1}(R) \\bowtie \\pi_{\\mathcal{A}_2}(R) \\bowtie...\\bowtie\\pi_{\\mathcal{A}_k}(R)\\) est aussi un tuple de \\(R\\)\nÀ l’initialisation, on part d’un tuple de \\(\\pi_{\\mathcal{A}_1}(R) \\bowtie \\pi_{\\mathcal{A}_2}(R) \\bowtie...\\bowtie\\pi_{\\mathcal{A}_k}(R)\\) qu’on note symboliquement \\((a, b, c, \\ldots)\\) avec des symboles non indicés\nPour chaque \\(i \\leq k\\), on utilise le fait que pour chaque tuple de \\(\\pi_{\\mathcal{A}_i}(R)\\) il existe un ensemble de tuples de \\(R\\) qui coïncident avec \\((a, b, c, \\ldots)\\) sur \\(\\mathcal{A}_i\\). On note génériquement ces tuples de \\(R\\) en indiçant les noms de variables par \\(i\\) pour toutes les variables qui ne sont pas dans \\(\\mathcal{A}_i\\)\nChacun des sous-ensembles de tuples indicés par \\(i \\leq k\\) définit un sous-ensemble de tuples de \\(R\\)\nOn veut se convaincre que \\((a, b, c, \\ldots)\\) appartient à l’un de ces sous-ensembles\n\nL’algorithme de poursuite utilise les DF de Σ, pour restreindre les \\(k\\) sous-ensembles"
  },
  {
    "objectID": "slides/DF_norm_1.html#commentaires-suite",
    "href": "slides/DF_norm_1.html#commentaires-suite",
    "title": "Normalisation I",
    "section": "Commentaires (suite)",
    "text": "Commentaires (suite)\nL’algorithme de poursuite est un algorithme de réécriture\n\nL’algorithme de poursuite est non-déterministe : à chaque étape, il est parfois possible d’invoquer plusieurs DFs pour réécrire une ou plusieurs lignes\n\n\nUn point important de l’analyse de l’algorithme de poursuite consiste à vérifier que ce non-déterminisme n’est pas un problème : l’algorithme de poursuite termine par un succès ou un échec (blocage) quelle que soit la suite des choix effectués\n\nPreuve ()."
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-2-1",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-2-1",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite : exemple 2",
    "text": "Algorithme de poursuite : exemple 2\nConsidérons l’exemple : \\(\\mathcal{A}=\\{A,B,C,D\\}\\) avec \\(\\mathcal{A}_1=\\{A,B\\}\\), \\(\\mathcal{A}_2=\\{B,C\\}\\) et \\(\\mathcal{A}_3=\\{C,D\\}\\)\nSoit \\(\\Sigma=\\{{C}\\rightarrow{D}; {B}\\rightarrow{A}\\}\\).\nSoit \\(t=(a,b,c,d)\\). Soit \\(t_1,t_2,t_3\\) les tuples de \\(R\\) suivants:\n\n\n\nA\nB\nC\nD\n\n\n\n\\(t_2\\)\n\\(a_2\\)\nb\nc\n\\(d_2\\)\n\n\n\\(t_3\\)\n\\(a_3\\)\n\\(b_3\\)\nc\nd\n\n\n\nOn a pris \\(c_1,d_1, a_2,d_2, a_3,b_3\\) comme valeurs variables et a,b,c,d comme constantes"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite---exemple-2",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite---exemple-2",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite - exemple 2",
    "text": "Algorithme de poursuite - exemple 2\n\n\n\nA\nB\nC\nD\n\n\n\n\\(t_1\\)\na\nb\n\\(c_1\\)\n\\(d_1\\)\n\n\n\\(t_2\\)\n\\(a_2\\)\nb\nc\n\\(d_2\\)\n\n\n\\(t_3\\)\n\\(a_3\\)\n\\(b_3\\)\nc\nd\n\n\n\nPar la dépendance \\({B}\\rightarrow{A}\\), il vient :\n\n\n\nA\nB\nC\nD\n\n\n\n\\(t_1\\)\na\nb\n\\(c_1\\)\n\\(d_1\\)\n\n\n\\(t_2\\)\na\nb\nc\n\\(d_2\\)\n\n\n\\(t_3\\)\n\\(a_3\\)\n\\(b_3\\)\nc\nd"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-2-2",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-2-2",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite : exemple 2",
    "text": "Algorithme de poursuite : exemple 2\nPar la dépendance \\({C}\\rightarrow{D}\\), il vient :\n\n\n\nA\nB\nC\nD\n\n\n\n\\(t_1\\)\na\nb\n\\(c_1\\)\n\\(d_1\\)\n\n\n\\(t_2\\)\na\nb\nc\nd\n\n\n\\(t_3\\)\n\\(a_3\\)\n\\(b_3\\)\nc\nd\n\n\n\nOn a bien fait apparaître \\(t\\) qui appartient donc à \\(R\\)."
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite---exemple-3",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite---exemple-3",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite - exemple 3",
    "text": "Algorithme de poursuite - exemple 3\nConsidérons toujours l’exemple : \\(\\mathcal{A}=\\{A,B,C,D\\}\\) avec\n\\(\\mathcal{A}_1=\\{A,B\\}\\), \\(\\mathcal{A}_2=\\{B,C\\}\\) et \\(\\mathcal{A}_3=\\{C,D\\}\\)\nMais avec \\(\\Sigma=\\{{B}\\rightarrow{AD}\\}\\).\n\n\nA\nB\nC\nD\n\n\n\na\nb\n\\(c_1\\)\n\\(d_1\\)\n\n\n\\(a_2\\)\nb\nc\n\\(d_2\\)\n\n\n\\(a_3\\)\n\\(b_3\\)\nc\nd\n\n\n\nDans ce cas, en utilisant la seule DF \\({B}\\rightarrow{AD}\\), on obtient \\(a_2=a\\) et \\(d_1=d_2\\) :\n\n\nA\nB\nC\nD\n\n\n\na\nb\n\\(c_1\\)\n\\(d_1\\)\n\n\na\nb\nc\n\\(d_1\\)\n\n\n\\(a_3\\)\n\\(b_3\\)\nc\nd\n\n\n\n\n\n\n\n\n\nNote\n\n\nMais on ne peut aller plus loin : la jointure des projections contient des tuples qui ne sont pas dans la relation originelle"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme",
    "href": "slides/DF_norm_1.html#algorithme",
    "title": "Normalisation I",
    "section": "Algorithme",
    "text": "Algorithme\n\n\n\\begin{algorithm} \\caption{Décomposition FNBC} \\begin{algorithmic} \\Procedure{DecompositionFNBC}{$\\mathcal{A}, Σ$} \\State \\Comment{Initialisation de la décomposition} \\State $D ← \\{\\mathcal{A}\\}$ \\State \\While{$\\exists \\mathcal{B} \\in D$ not in BCNF w.r.t. $\\Sigma \\models X → X^+ \\cap \\mathcal{B}$, $X \\subsetneq \\mathcal{B}$} \\State $Y \\leftarrow X^+ \\cap \\mathcal{B} \\setminus X\\qquad$ \\Comment{DF non triviale! $Y \\neq \\emptyset$} \\State $D \\leftarrow D \\setminus \\{\\mathcal{B}\\} \\cup \\{ X \\cup Y, \\mathcal{B} \\setminus Y \\}$ \\EndWhile \\State \\Return $D$ \\EndProcedure \\end{algorithmic} \\end{algorithm}"
  },
  {
    "objectID": "slides/DF_norm_1.html#remarques",
    "href": "slides/DF_norm_1.html#remarques",
    "title": "Normalisation I",
    "section": "Remarques",
    "text": "Remarques\n\n\n\n\n\n\n\nProposition\n\n\n\nL’algorithme termine\nLes éléments de la décomposition finale sont en FNBC\nLa décomposition est Sans Perte d’Information (SPI)"
  },
  {
    "objectID": "slides/DF_norm_1.html#preuves",
    "href": "slides/DF_norm_1.html#preuves",
    "title": "Normalisation I",
    "section": "Preuves \n",
    "text": "Preuves \n\n\nLa terminaison est triviale : à chaque itération le nombre de parties de \\(\\mathcal{A}\\) dans \\(D\\) augmente de \\(1\\) et ce nombre ne peut dépasser \\(\\# \\mathcal{A}\\)\nLa seconde propriété est triviale aussi\nLa propriété SPI se vérifie avec l’algorithme de poursuite (et son analyse): chaque itération de la boucle While est SPI."
  },
  {
    "objectID": "slides/BD_admin_2.html#les-lois-des-tables",
    "href": "slides/BD_admin_2.html#les-lois-des-tables",
    "title": "BD VII: Administration et Droits",
    "section": "Les lois des tables",
    "text": "Les lois des tables\n\n\n\n\n\n\nNote\n\n\n\n\n\n\n\n\nCodd’s Twelve Principles\n\n\n\nInformation is represented logically in tables\n\nData must be logically accessible by table, primary key, and column.\n\nNull values must be uniformly treated as “missing information,” not as empty strings, blanks, or zeros.\nMetadata (data about the database) must be stored in the database just as regular data is\nA single language must be able to define data, views, integrity constraints, authorization, transactions, and data manipulation\n\nViews must show the updates of their base tables and vice versa\nA single operation must be available to do each of the following operations: retrieve data, insert data, update data, or delete data\nBatch and end-user operations are logically separate from physical storage and access methods\nBatch and end-user operations can change the database schema without having to recreate it or the applications built upon it\n\nIntegrity constraints must be available and stored in the metadata, not in an application program\nThe data manipulation language of the relational system should not care where or how the physical data is distributed and should not require alteration if the physical data is centralized or distributed\nAny row processing done in the system must obey the same integrity rules and constraints that set-processing operations do"
  },
  {
    "objectID": "slides/BD_admin_2.html#problème",
    "href": "slides/BD_admin_2.html#problème",
    "title": "BD VII: Administration et Droits",
    "section": "Problème",
    "text": "Problème\nUn serveur de BD met à la disposition d’une collectivité d’usagers un multitude de bases formées d’une collection de tables, de vues, de routines…\n\nLes usagers ne sont pas tous égaux…\n\n–\nCertains utilisateurs doivent pouvoir créer des bases, d’autres les mettre à jour, d’autres les consulter\n–\n\n\n Le contrôle de l’accès…\n\nPeut être motivé par un désir de maintenir l’intégrité ou la confidentialité des données.\nLe niveau de contrôle (granularité) désirable peut varier : base, schema, table, colonne, ligne…."
  },
  {
    "objectID": "slides/BD_admin_2.html#confidentialité-et-sécurité",
    "href": "slides/BD_admin_2.html#confidentialité-et-sécurité",
    "title": "BD VII: Administration et Droits",
    "section": "Confidentialité et sécurité",
    "text": "Confidentialité et sécurité\nObjectif :\nProtéger les données gérées contre tout accès (malveillant ou accidentel) non autorisé\n\n\nQuels outils ?\n\nUn système de privilèges implémenté dans SQL pour définir l’accès des usagers et plus généralement des rôles aux différents objets"
  },
  {
    "objectID": "slides/BD_admin_2.html#commandes",
    "href": "slides/BD_admin_2.html#commandes",
    "title": "BD VII: Administration et Droits",
    "section": "Commandes",
    "text": "Commandes\nPour octroyer ou retirer des droits d’accès (par exemple sur une relation ou une vue) :\nGRANT et REVOKE\nLes droits d’accès donnent la possibilité d’exécuter des requêtes SQL\n Le propriétaire (créateur) d’une relation à tous les droits sur cette relation et on ne peut lui les retirer"
  },
  {
    "objectID": "slides/BD_admin_2.html#les-commandes",
    "href": "slides/BD_admin_2.html#les-commandes",
    "title": "BD VII: Administration et Droits",
    "section": "Les commandes",
    "text": "Les commandes\nDépendent du type d’objet auquel on s’intéresse.\nPour une table ou une vue :\n\n\nSyntaxe :\nGRANT {ALL PRIVILEGES |\n   privilege {,privilege*}\nON {[TABLE] table_name [, ...]\n    | ALL TABLES IN SCHEMA schema_name}\nTO role-specification [, ...]\n[WITH GRANT OPTION]\n\nrole-specification :\nrole_name, PUBLIC, ...\n\nprivilege :\nSELECT, DELETE, INSERT,\nUPDATE [(nom-attribut\n    {, nom-attribut})],\nREFERENCES [(nom-attribut\n     {, nom-attribut})]\n\n *WITH GRANT OPTION:] si spécifié, donne le droit de transmettre les droits obtenus\n voir : https://www.postgresql.org/docs/current/sql-grant.html"
  },
  {
    "objectID": "slides/BD_admin_2.html#les-commandes-suite-granularité",
    "href": "slides/BD_admin_2.html#les-commandes-suite-granularité",
    "title": "BD VII: Administration et Droits",
    "section": "Les commandes (suite) : granularité",
    "text": "Les commandes (suite) : granularité\nOn peut aller plus loin et spécifier le droit d’accès à seulement une ou plusieurs colonnes d’une table\nPour d’autres objets, comme les domaines, fonction, bases de données, schémas ou rôles d’autres types de droits sont pertinents:\n\nle droit de créer une BD ou un schéma dans une BD existante\nle droit de se connecter à une BD existante\nle droit d’exécuter une fonction\nle droit d’usage d’un schéma (i.e. d’en voir les objets existants)\nle droit d’attribuer des rôles à des utilisateurs"
  },
  {
    "objectID": "slides/BD_admin_2.html#révoquer-des-droits",
    "href": "slides/BD_admin_2.html#révoquer-des-droits",
    "title": "BD VII: Administration et Droits",
    "section": "Révoquer des droits",
    "text": "Révoquer des droits\nvia le mot clé REVOKE\nSyntaxe (simplifiée) :\nREVOKE [ GRANT OPTION FOR ]\n{ { SELECT | INSERT | UPDATE | DELETE }\n| ALL [ PRIVILEGES ] }\n\nON { [ TABLE ] table_name [, ...]\n      | ALL TABLES IN SCHEMA schema_name }\n\nFROM role_spec [, ...]\n[ GRANTED BY role_spec ]\n[ CASCADE | RESTRICT ]\n *syntaxe complète:] voir https://www.postgresql.org/docs/current/sql-revoke.html\nCommentaire\n\nGRANT OPTION FOR\nCASCADE\nRESTRICT"
  },
  {
    "objectID": "slides/BD_admin_2.html#exemples",
    "href": "slides/BD_admin_2.html#exemples",
    "title": "BD VII: Administration et Droits",
    "section": "Exemples",
    "text": "Exemples\nGRANT USAGE\nON SCHEMA durand\nTO thomas007\n\nGRANT SELECT\nON ALL TABLES IN SCHEMA durand\nTO thomas007\n\n\nOn peut se mettre “à la place” de l’utilisateur thomas007 par la commande :\nset role thomas007\n\n\nREVOKE SELECT\nON ALL TABLES IN SCHEMA durand\nFROM thomas007\nREVOKE USAGE\nON SCHEMA durand\nFROM thomas007\nOn pouvait donner directement les mêmes droits à tous les utilisateurs d’un même rôle etudiant par exemple plutôt qu’un seul utilisateur\n\nUSAGE\nSELECT\nEXECUTE"
  },
  {
    "objectID": "slides/BD_admin_2.html#exemples-suite",
    "href": "slides/BD_admin_2.html#exemples-suite",
    "title": "BD VII: Administration et Droits",
    "section": "Exemples (suite)",
    "text": "Exemples (suite)\nSupposons que le schema durand contiennent une table resultat dont une des colonnes se nomme identifiant.\nQue peut faire (et ne pas faire) l’utilisateur thomas007 après ces trois commandes ?\n\nGRANT INSERT (identifiant) ON TABLE durand.resultat TO thomas007;\nGRANT USAGE ON SCHEMA durand  TO thomas007\nGRANT SELECT ON TABLE durand.resultat TO thomas007;\n\n\nIl peut selectionner les infos de la table resultat, inserer un tuple avec une valeur pour l’attribut identifiant et null pour les autres attributs\nIl ne peut pas effacer son insertion…"
  },
  {
    "objectID": "slides/BD_admin_2.html#politique-de-droits",
    "href": "slides/BD_admin_2.html#politique-de-droits",
    "title": "BD VII: Administration et Droits",
    "section": "Politique de droits",
    "text": "Politique de droits\n\nLors de la conception d’une base de données, on anticipe le fait que tous les utilisateurs ne vont pas avoir les mêmes droits\nIl peut y avoir plusieurs niveaux d’administrateurs aussi\nL’architecture des droits doit être pensée le plus finement possible pour éviter les problèmes de sécurité\nSQL permet d’implémenter directement cela (et ne pas le laisser à la couche applicative au dessus)\n\nRenvoyer aux principes de Codd"
  },
  {
    "objectID": "slides/BD_admin_2.html#administrer-utilisation-dune-métabase",
    "href": "slides/BD_admin_2.html#administrer-utilisation-dune-métabase",
    "title": "BD VII: Administration et Droits",
    "section": "Administrer : utilisation d’une “métabase”",
    "text": "Administrer : utilisation d’une “métabase”\n\n\nLes SGBD relationnels contiennent des schémas particuliers qui décrivent totalement l’état des bases :\n\nschéma existants,\ntables,\ncolonnes,\nutilisateurs,\nfonction stockées,\ncontraintes,\netc\n\n\nCes schémas constituent une métabase\nOn peut utiliser SQL pour interroger ces tables et donc (presque) tout savoir de l’état du SGBD sans faire appel à un langage extérieur\nOn peut aussi apporter des modifications en utilisant les instructions SQL classiques INSERT, UPDATE, DELETE, etc"
  },
  {
    "objectID": "slides/BD_admin_2.html#administrer-utilisation-dune-méta-base",
    "href": "slides/BD_admin_2.html#administrer-utilisation-dune-méta-base",
    "title": "BD VII: Administration et Droits",
    "section": "Administrer : utilisation d’une “méta-base”",
    "text": "Administrer : utilisation d’une “méta-base”\nDeux schémas jouent un rôle essentiel dans l’administration de Postgres (situation similaire dans tous les SGBD)\ninformation_schema\n\nles définitions de tables, de vues, de colonnes, les contraintes, …\nil est formé de tables et surtout de (très nombreuses) vues\ncomme pour les autres tables, les instructions, CREATE, ALTER, DROP modifient le contenu de ce schéma (une seule instruction ALTER TABLE peut engendrer en cascade plusieurs mises à jours dans les tables de information_schema)\ncontient, en théorie, des informations compatibles avec le standard SQL (identique sur tout SGBD respectant la norme)\n\npg_catalog\n\nContient des informations de nature similaire à information_schema mais spécifiques à l’organisation de Postgres"
  },
  {
    "objectID": "slides/BD_admin_2.html#quelques-tables-et-vues-de-information_schema",
    "href": "slides/BD_admin_2.html#quelques-tables-et-vues-de-information_schema",
    "title": "BD VII: Administration et Droits",
    "section": "Quelques tables et vues de information_schema\n",
    "text": "Quelques tables et vues de information_schema\n\n Une liste complète des tables et vues de information_schema se trouve ici :\nhttps://www.postgresql.org/docs/current/information-schema.html\nQuelques exemples:\n\nschemata contient la liste des schémas, leurs propriétaires, leurs catalogue d’appartenance, etc\ntables contient la liste des noms de toutes les tables et vues et, entre autres, leurs BD et schémas d’appartenance\ncolumns contient les noms de colonnes, les tables (et donc schémas et BD) auxquels elles appartiennent.\nrole_table_grants contient la liste de tous les droits alloués, à qui, par qui etc"
  },
  {
    "objectID": "slides/BD_admin_2.html#quelques-tables-et-vues-de-pg_catalog",
    "href": "slides/BD_admin_2.html#quelques-tables-et-vues-de-pg_catalog",
    "title": "BD VII: Administration et Droits",
    "section": "Quelques tables et vues de pg_catalog\n",
    "text": "Quelques tables et vues de pg_catalog\n\nUne liste complète des tables et vues de pg_catalog se trouve ici :\n https://www.postgresql.org/docs/current/catalogs.html\nQuelques exemples:\n\npg_user contient la liste des utilisateurs, leur id système\npg_tables contient des informations similaires à information_schema.tables\npg_views contient la liste des vues\npg_roles contient la liste des roles\npg_auth_members met en relation les rôles entre eux (quel rôle est contenu dans tel autre)"
  },
  {
    "objectID": "slides/BD_admin_2.html#exemples-1",
    "href": "slides/BD_admin_2.html#exemples-1",
    "title": "BD VII: Administration et Droits",
    "section": "Exemples",
    "text": "Exemples\nSELECT *\nFROM information_schema.tables;\nSELECT table_name\nFROM information_schema.tables\nWHERE table_type='VIEW' AND table_schema='durand';\n    +------------------+\n    | table_name       |\n    |------------------|\n    | listevuecc1      |\n    | notescc1         |\n    | listevuecc1_isif |\n    | q4               |\n    | q5               |\n    | q6               |\n    | defi1            |\n    | q1               |\n    | q2               |\n    | q3               |\n    +------------------+"
  },
  {
    "objectID": "slides/BD_admin_2.html#exemple-représentation-des-droits-dans-la-metabase",
    "href": "slides/BD_admin_2.html#exemple-représentation-des-droits-dans-la-metabase",
    "title": "BD VII: Administration et Droits",
    "section": "Exemple : Représentation des droits dans la metabase",
    "text": "Exemple : Représentation des droits dans la metabase\nSELECT table_schema, table_name, privilege_type\nFROM information_schema.role_table_grants\nWHERE grantee='durand'\n +----------------+--------------------+------------------+\n | table_schema   | table_name         | privilege_type   |\n |----------------+--------------------+------------------|\n | gestion_2022   | etudiantsmiashs    | INSERT           |\n | gestion_2022   | etudiantsmiashs    | SELECT           |\n | gestion_2022   | etudiantsmiashs    | UPDATE           |\n | gestion_2022   | etudiantsmiashs    | DELETE           |\n | gestion_2022   | etudiantsmiashs    | TRUNCATE         |\n | gestion_2022   | etudiantsmiashs    | REFERENCES       |\n | gestion_2022   | etudiantsmiashs    | TRIGGER          |"
  },
  {
    "objectID": "slides/BD_admin_2.html#information_schema.table_privileges",
    "href": "slides/BD_admin_2.html#information_schema.table_privileges",
    "title": "BD VII: Administration et Droits",
    "section": "information_schema.table_privileges",
    "text": "information_schema.table_privileges\nThe view table_privileges identifies all privileges granted on tables or views to a currently enabled role or by a currently enabled role.\nThere is one row for each combination of table, grantor, and grantee.\n\nLe role PUBLIC dispose du privilège de SELECT sur les tables de pg_catalog et de information_schema"
  },
  {
    "objectID": "slides-listings.html",
    "href": "slides-listings.html",
    "title": "Diapositives",
    "section": "",
    "text": "Les diapositives fournissent le canevas du cours. Vous pouvez les utiliser pour vous familiariser avec le matériel du prochain cours, pour revoir les cours passés et, pour réviser.\nLes diapositives marquées par l’image  renvoient à des développements effectués en classes.\n\n\n   \n    \n    \n      Order By\n      Default\n      \n        Titre\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Description\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\n\nTitre\n\n\n\nDescription\n\n\n\n\n\n\n\n\nSep 15, 2025\n\n\nIntroduction aux Bases de Données\n\n\nBases de données, Systèmes d’information, Modèle relationnel, OLTP, OLAP\n\n\n\n\n\n\nSep 15, 2025\n\n\nAlgèbre relationnelle\n\n\nAlgèbre relationnelle, Sélection, Projection, Jointure\n\n\n\n\n\n\nSep 22, 2025\n\n\nSQL : requêtes simples\n\n\nAlgèbre relationnelle, SQL, Sélection, Projection, Jointure\n\n\n\n\n\n\nSep 29, 2025\n\n\nSQL : requêtes imbriquées\n\n\nRequêtes imbriquées, CTE\n\n\n\n\n\n\nOct 6, 2025\n\n\nSQL : Agrégations, Partitions, Fenêtres\n\n\nAggrégations, Partitions, Fenêtres\n\n\n\n\n\n\nOct 13, 2025\n\n\nSQL : Définition de données\n\n\nCréation de tables, Insertion, Suppression, Mises à jour\n\n\n\n\n\n\nOct 20, 2025\n\n\nSQL : Définition de données, Contraintes simples\n\n\nContraintes, Check, Primary Key, Foreign Key\n\n\n\n\n\n\nNov 3, 2025\n\n\nSQL : Définition de données, Contraintes d’exclusion\n\n\nContraintes, Étude de cas, Exclude, Contraintes multitables\n\n\n\n\n\n\nNov 10, 2025\n\n\nModélisation : Entité-Association\n\n\nModélisation, Entité-Association, Cardinalités, Spécialisation/Généralisation\n\n\n\n\n\n\nNov 17, 2025\n\n\nModélisation : Pattes de corbeaux\n\n\nModélisation, Pattes de corbeaux, Rétro-ingénierie\n\n\n\n\n\n\nNov 24, 2025\n\n\nNormalisation : Dépendances fonctionnelles, Fermetures\n\n\nNormalisation, Dépendances fonctionnelles, Implication, Fermeture, Clés\n\n\n\n\n\n\nDec 1, 2025\n\n\nNormalisation: FNBC, Décomposition SPI, Poursuite\n\n\nNormalisation, Dépendances fonctionnelles, Implication, Fermeture, Clés\n\n\n\n\n\n\nDec 8, 2025\n\n\nNormalisation: FN3, Décomposition SPI et sans perte de DF\n\n\nNormalisation, FN3, Dépendances projetés, Perte de DF, Couverture irréductible\n\n\n\n\n\n\nNo matching items\n\n\n\n\n\n\n\nNoteMode d’emploi\n\n\n\nLes diapositives utilisent la bibliothèque revealjs de . Elles s’affichent dans votre navigateur. Vous pouvez accéder au mode d’emploi en tappant",
    "crumbs": [
      "Diapositives"
    ]
  },
  {
    "objectID": "slides/BD_intro.html#situation-du-cours-bases-de-données-ma15e045-dans-la-licence-miashs",
    "href": "slides/BD_intro.html#situation-du-cours-bases-de-données-ma15e045-dans-la-licence-miashs",
    "title": "BD I: Introduction aux SGBD",
    "section": "Situation du cours Bases de Données (MA15E045) dans la Licence MIASHS",
    "text": "Situation du cours Bases de Données (MA15E045) dans la Licence MIASHS\n\nTroisième cours tourné vers l’informatique\n\nInitiation (L1, S1)\nAlgorithmes et Programmation (L2, S3)\n\nUn cours tourné vers les données avant Science des Données (L3, S6)"
  },
  {
    "objectID": "slides/BD_intro.html#le-déluge-des-données-une-mode",
    "href": "slides/BD_intro.html#le-déluge-des-données-une-mode",
    "title": "BD I: Introduction aux SGBD",
    "section": "Le déluge des données : une mode ?",
    "text": "Le déluge des données : une mode ?"
  },
  {
    "objectID": "slides/BD_intro.html#rien-de-neuf-sous-le-soleil",
    "href": "slides/BD_intro.html#rien-de-neuf-sous-le-soleil",
    "title": "BD I: Introduction aux SGBD",
    "section": "Rien de neuf sous le soleil …",
    "text": "Rien de neuf sous le soleil …\n\n De qui sont ces lignes ? Quand furent-elles écrites ?\n\n\nJe croyais que le goût de la statistique était particulier aux administrateurs de nos jours ; mais je me trompais. Vers la fin de l’ancien régime, on envoie souvent à l’intendant de petits tableaux tout imprimés qu’il n’a plus qu’à faire remplir par ses subdélégués et par les syndics des paroisses. Le contrôleur-général se fait faire des rapports sur la nature des terres, sur leur culture, l’espèce et la quantité des produits, le nombre des bestiaux, l’industrie et les mœurs des habitants. Les renseignements ainsi obtenus ne sont guère moins circonstanciés ni plus certains que ceux que fournissent en pareils cas de nos jours les sous-préfets et les maires. Le jugement que les subdélégués portent, à cette occasion, sur le caractère de leurs administrés, est en général peu favorable. Ils reviennent souvent sur cette opinion que « le paysan est naturellement paresseux, et ne travaillerait pas s’il n’y était obligé pour vivre. »\n\n\nC’est là une doctrine économique qui paraît fort répandue chez ces administrateurs."
  },
  {
    "objectID": "slides/BD_intro.html#les-données-intéressent",
    "href": "slides/BD_intro.html#les-données-intéressent",
    "title": "BD I: Introduction aux SGBD",
    "section": "Les données intéressent",
    "text": "Les données intéressent\n\nles sciences\nles administrations\nles entreprises\nles citoyennes (et les citoyens)\n…"
  },
  {
    "objectID": "slides/BD_intro.html#les-données-en-sciences-sociales",
    "href": "slides/BD_intro.html#les-données-en-sciences-sociales",
    "title": "BD I: Introduction aux SGBD",
    "section": "Les données en Sciences Sociales",
    "text": "Les données en Sciences Sociales\n\n\n\nPourquoi ?\nDe quoi sont faites les données ?\nComment les accumuler ?\nComment les interroger ?\nComment les conserver ? les éditer ?\n\n\n\n\n\nBN Salle ovale"
  },
  {
    "objectID": "slides/BD_intro.html#sources-et-usages-des-données",
    "href": "slides/BD_intro.html#sources-et-usages-des-données",
    "title": "BD I: Introduction aux SGBD",
    "section": "Sources et usages des données",
    "text": "Sources et usages des données\n\n\nQuelques références\n\n\n\nData humanities with R. Arnold and Tilton\n\n\nQuantitative tour at social sciences edited by Gelman and Cortina, 2009\n Relational databses on slideshare\n\nQuelques problèmes\n\nConstitution (archivage, etc)\nAcquisition/organisation\nUsage(s)\nMaintenance"
  },
  {
    "objectID": "slides/BD_intro.html#les-données-de-lentreprisedes-administrations",
    "href": "slides/BD_intro.html#les-données-de-lentreprisedes-administrations",
    "title": "BD I: Introduction aux SGBD",
    "section": "Les données de l’entreprise/des administrations",
    "text": "Les données de l’entreprise/des administrations\n\n\n\nLa comptabilité\nLes stocks (ERP)\nLa clientèle (CRM)\n…"
  },
  {
    "objectID": "slides/BD_intro.html#la-vie-des-données-en-résumé",
    "href": "slides/BD_intro.html#la-vie-des-données-en-résumé",
    "title": "BD I: Introduction aux SGBD",
    "section": "La vie des données (en résumé)",
    "text": "La vie des données (en résumé)\n\n\n\n Saisie/Alimentation\n Traitement(s)\n Usage(s)\n Archivage\n Maintenance\n\n\n\n\n\npipelines"
  },
  {
    "objectID": "slides/BD_intro.html#avant-hier",
    "href": "slides/BD_intro.html#avant-hier",
    "title": "BD I: Introduction aux SGBD",
    "section": "Avant-hier",
    "text": "Avant-hier\n\n\nLes entreprises et les administrations ont toujours cultivé une mémoire sous forme de fichiers plus ou moins mécanisés et formattés.\nCes collections de fichiers mécanisées répondaient à des exigences de fiabilité, de convenance (facilité de la recherche, de la maintenance)\n\n\n\n\nFrom https://www.ibm.com/history/punched-card"
  },
  {
    "objectID": "slides/BD_intro.html#aujourdhui",
    "href": "slides/BD_intro.html#aujourdhui",
    "title": "BD I: Introduction aux SGBD",
    "section": "Aujourd’hui",
    "text": "Aujourd’hui\n\n\n\nExplosion des volumes\nExplosion des débits\nUsages (très) divers"
  },
  {
    "objectID": "slides/BD_intro.html#systèmes-dinformation-1",
    "href": "slides/BD_intro.html#systèmes-dinformation-1",
    "title": "BD I: Introduction aux SGBD",
    "section": "Systèmes d’information",
    "text": "Systèmes d’information\n\nUn système d’information (SI) est un ensemble de composants qui fonctionnent ensemble pour collecter, traiter, stocker et diffuser des informations.\n\n\n\nLes systèmes d’information ont des objectifs (très) divers.\n\n\nPar exemple : les systèmes de traitement des transactions (TPS), les systèmes d’information de gestion (MIS), les systèmes d’aide à la décision (DSS) et les systèmes de planification des ressources de l’entreprise (ERP)."
  },
  {
    "objectID": "slides/BD_intro.html#décomposition-des-si",
    "href": "slides/BD_intro.html#décomposition-des-si",
    "title": "BD I: Introduction aux SGBD",
    "section": "Décomposition des SI",
    "text": "Décomposition des SI\nUn système d’information comprend en général les éléments suivants:\n\nMatériel informatique (ou pas) : dispositifs physiques utilisés pour collecter, stocker et traiter l’information (ordinateurs, serveurs, stockage, réseau, …).\nLogiciels : Les programmes exécutés sur le matériel pour gérer les données et effectuer des tâches spécifiques (OS, SGBD, Logiciels applicatifs).\nDonnées\nPersonnes : Les usagers du système d’information\nProcessus : Les flux de travail et les règles régissant la manière dont les données sont collectées, traitées et distribuées, conformément aux objectifs."
  },
  {
    "objectID": "slides/BD_intro.html#systèmes-dinformation-si-et-bases-de-données-bd-sgbd-sgbdr",
    "href": "slides/BD_intro.html#systèmes-dinformation-si-et-bases-de-données-bd-sgbd-sgbdr",
    "title": "BD I: Introduction aux SGBD",
    "section": "Systèmes d’information (SI) et Bases de Données (BD, SGBD, SGBDR)",
    "text": "Systèmes d’information (SI) et Bases de Données (BD, SGBD, SGBDR)\nAu coeur des systèmes d’information (modernes) on trouve (presque toujours) les bases de données\n\n\n\n\n\n\nMise en garde\n\n\nToutes les bases de données ne sont pas relationnelles"
  },
  {
    "objectID": "slides/BD_intro.html#des-propriétés-désirables-acid",
    "href": "slides/BD_intro.html#des-propriétés-désirables-acid",
    "title": "BD I: Introduction aux SGBD",
    "section": "Des propriétés désirables (ACID)",
    "text": "Des propriétés désirables (ACID)\n\n\n\n\n\n\nAtomicité\n\n\nChaque ajout/modification d’information doit former un tout cohérent\nSi tout se passe correctement, les actions de la transaction sont toutes validées, sinon on retourne à l’état initial\n\n\n\n\n\n\n\n\n\n\nCohérence\n\n\nLe contenu de la base de données doit rester conforme à des contraintes définies lors de la conception\n\n\n\n\n\n\n\n\n\n\n\nIsolation\n\n\nLa bases de données doit pouvoir être utilisée concurremment par plusieurs usagers\n\n\n\n\n\n\n\n\n\n\n\nDurabilité\n\n\nLa vie d’une base de données s’étale sur plusieurs dizaines d’années"
  },
  {
    "objectID": "slides/BD_intro.html#bases-de-données",
    "href": "slides/BD_intro.html#bases-de-données",
    "title": "BD I: Introduction aux SGBD",
    "section": " Bases de données",
    "text": "Bases de données\n\nQu’est-ce que c’est (plus précisément) ?\n\n\nCe sont des logiciels intermédiaires (middleware) entre :\n\nSystèmes de gestion de fichiers/Systèmes d’exploitation   …\nApplications (CRM, ERP, CMS, …)    …\n\n\n\nLes bases de données ne sont pas (simplement) un langage (comme JAVA, , )"
  },
  {
    "objectID": "slides/BD_intro.html#collection-de-tablesdata-frames",
    "href": "slides/BD_intro.html#collection-de-tablesdata-frames",
    "title": "BD I: Introduction aux SGBD",
    "section": " Collection de tables/data frames",
    "text": "Collection de tables/data frames\nCaricaturalement :\n\nUne base de données relationnelle est une collection de tables\n\n\nLes tables s’incarnent de plusieurs façons en informatique\nR, Pandas, les tableurs (Excel …), offrent un environnement interactif de manipulation de données et un environnement de définition de données"
  },
  {
    "objectID": "slides/BD_intro.html#data-frame",
    "href": "slides/BD_intro.html#data-frame",
    "title": "BD I: Introduction aux SGBD",
    "section": " Data frame",
    "text": "Data frame\n\n\nUn dataframe est une liste de vecteurs (colonnes)\nLes vecteurs (colonnes) d’un dataframe sont tous de même longueur\nLes éléments d’un vecteur sont d’un même type de base\nChaque vecteur a un nom et son propre type"
  },
  {
    "objectID": "slides/BD_intro.html#autres-environments-excel-java-python",
    "href": "slides/BD_intro.html#autres-environments-excel-java-python",
    "title": "BD I: Introduction aux SGBD",
    "section": "Autres environments (Excel, JAVA, Python)",
    "text": "Autres environments (Excel, JAVA, Python)\n\n\nLes spreadsheet des tableurs \nLes Dataframes de Pandas  \nLes tableaux d’objets en JAVA\n\npermettent de représenter ce que les dataframes représentent en R"
  },
  {
    "objectID": "slides/BD_intro.html#les-sgbd-vont-au-delà",
    "href": "slides/BD_intro.html#les-sgbd-vont-au-delà",
    "title": "BD I: Introduction aux SGBD",
    "section": "Les SGBD vont au delà :",
    "text": "Les SGBD vont au delà :\nIls offrent:\n\n\n\n\n\n\nPersistance\n\n\nEntre deux sessions, les données sont confiées au système de fichiers de l’ordinateur\n\n\n\n\n\n\n\n\n\n\nIntégrité\n\n\nLes données confiées au système de fichiers ne peuvent pas être altérées par d’autres logiciels\n\n\n\n\n\n\n\n\n\n\n\nConcurrence\n\n\nLes données peuvent être manipulées/consultées/mises à jour de manière concurrente par plusieurs voire par une grande quantité d’ utilisateurs."
  },
  {
    "objectID": "slides/BD_intro.html#usages",
    "href": "slides/BD_intro.html#usages",
    "title": "BD I: Introduction aux SGBD",
    "section": "Usages",
    "text": "Usages\n\nSites web dynamiques  \nLogiciels personnels\n\nDerrière certaines applications (gestion de photos, de carnet d’adresses, …), on trouve des bases de données légères (SQLITE)\n\nPartout\n\nsmartphones, tablettes, …\nweb, réseaux sociaux\nadministrations (APOGEE, …)\nentreprises (Stocks Supply Chain, Customer Relationship Management, …)\nNSA"
  },
  {
    "objectID": "slides/BD_intro.html#lidée-clé-codd-1970",
    "href": "slides/BD_intro.html#lidée-clé-codd-1970",
    "title": "BD I: Introduction aux SGBD",
    "section": "L’idée clé (Codd, 1970)",
    "text": "L’idée clé (Codd, 1970)\nOrganiser les informations en tables ou relations\nDévelopper et formaliser un langage de manipulation de tables : l’algèbre relationnelle (langage SQL, Structured Query Language)\n\nL’usager peut définir l’organisation des données\nIl peut interroger celles-ci (par des requêtes)\nLe langage est déclaratif :\n\nOn décrit ce que l’on veut obtenir (quoi mais pas comment)\nLe système fait le reste…\n\nL’évaluation de toutes les requêtes s’arrête (au moins en théorie : si on y met les moyens…)\nL’algèbre relationnelle/SQL n’est pas un langage complet (différence avec JAVA, C, Python, etc)"
  },
  {
    "objectID": "slides/BD_intro.html#quelques-acteurs",
    "href": "slides/BD_intro.html#quelques-acteurs",
    "title": "BD I: Introduction aux SGBD",
    "section": "Quelques acteurs",
    "text": "Quelques acteurs\n\n\nServeurs\n\nORACLE (commercial)\nDB2 (IBM commercial)\nSQLSERVER (Microsoft commercial)\nMySQL (open source)\nPostGres (open source)\nHana (commercial)\n\n\nClients\n\npsql\npgcli\ndbeaver\nPgAdmin\n…"
  },
  {
    "objectID": "slides/BD_intro.html#postgres-postgresql",
    "href": "slides/BD_intro.html#postgres-postgresql",
    "title": "BD I: Introduction aux SGBD",
    "section": "PostGres (PostgreSQL)",
    "text": "PostGres (PostgreSQL)\n\nUn serveur : etu-pgsql\nUn catalogue : bd_2023-24\nDes schémas: world, pagila, nycflights13, ..."
  },
  {
    "objectID": "slides/BD_intro.html#un-exemple-de-schéma-world",
    "href": "slides/BD_intro.html#un-exemple-de-schéma-world",
    "title": "BD I: Introduction aux SGBD",
    "section": "Un exemple de schéma world",
    "text": "Un exemple de schéma world\nUn schema\nDes schémas de table\n\ncontinent : association nom de continent (texte)-code de continent (entier)\ncountry : chaque tuple porte sur un état/territoire\ncity : chaque tuple porte sur une ville (déisgnée par id) qui appartient à un état/territoire désigné par countrycode\ncountrylanguage : chaque tuple indique la part de la population d’un état/territoire (désigné par countrycode) qui parle/connaît une langue (désignée par language) et précise si la langue est officielle dans cet état/territoire."
  },
  {
    "objectID": "slides/BD_intro.html#détails-du-schema-world",
    "href": "slides/BD_intro.html#détails-du-schema-world",
    "title": "BD I: Introduction aux SGBD",
    "section": "Détails du schema world",
    "text": "Détails du schema world\n\n\n\nImage World\n\n\n\n\nUn schéma de table : la donnée des noms des colonnes et des types des colonnes"
  },
  {
    "objectID": "slides/BD_intro.html#quelques-questions-et-propriétés-typiques",
    "href": "slides/BD_intro.html#quelques-questions-et-propriétés-typiques",
    "title": "BD I: Introduction aux SGBD",
    "section": "Quelques questions et propriétés typiques",
    "text": "Quelques questions et propriétés typiques\n\nExtraire de l’information\nAssurer de la cohérence après modification\n\nFaire en sorte que chaque état/territoire soit identifié par un numéro unique\nFaire en sorte que chaque ville soit identifiée par un numéro unique\nNe pas proposer de données sur des villes/territoires/états qui n’existent pas\n\n\n\n\nPropager l’information\n\nHistoriciser le schéma"
  },
  {
    "objectID": "slides/BD_intro.html#objectifs-du-cours",
    "href": "slides/BD_intro.html#objectifs-du-cours",
    "title": "BD I: Introduction aux SGBD",
    "section": "Objectifs du cours",
    "text": "Objectifs du cours\n\nCompétences d’un usager de BD relationnelles\nExprimer des requêtes en algèbre relationnelle et en SQL\nSQL Définition, manipulation et contrôle des données\nConcevoir un Modèle Conceptuel de Données (Entités/Associations)\nDéterminer les dépendances fonctionnelles et normaliser une relation"
  },
  {
    "objectID": "slides/BD_intro.html#plan-du-cours",
    "href": "slides/BD_intro.html#plan-du-cours",
    "title": "BD I: Introduction aux SGBD",
    "section": "Plan du cours",
    "text": "Plan du cours\n\nAlgèbre et calcul relationnels\nSQL (algèbre relationnelle stricte)\nSQL sous-requêtes\nSQL agrégation\nSQL requêtes paramétrées\nDéfinition de données/Conception\nNormalisation"
  },
  {
    "objectID": "slides/BD_intro.html#entrepôts-de-données-fin-des-années-1980",
    "href": "slides/BD_intro.html#entrepôts-de-données-fin-des-années-1980",
    "title": "BD I: Introduction aux SGBD",
    "section": "Entrepôts de données (Fin des années 1980)",
    "text": "Entrepôts de données (Fin des années 1980)\n\n\n\n\n\n\nDatawarehouse\n\n\n\nUn Data Warehouse est une technologie qui regroupe des données structurées provenant d’une ou de plusieurs sources afin qu’elles puissent être comparées et analysées.\n\n\n\n\n\n“Entrepôt de données” sur Wikipedia"
  },
  {
    "objectID": "slides/BD_intro.html#lacs-de-données-2010",
    "href": "slides/BD_intro.html#lacs-de-données-2010",
    "title": "BD I: Introduction aux SGBD",
    "section": "Lacs de données (2010)",
    "text": "Lacs de données (2010)\n\n\n\n\n\n\nDatalake\n\n\nLe concept de Data Lake a été évoqué pour la première fois, en 2010, par James Dixon, comme une solution pour le stockage de données sans pré-traitement et sans connaître précisément l’usage futur qui en sera fait. L’image du lac, permettant d’expliquer, que différentes sources peuvent l’alimenter de manière naturelle et brute, et que les utilisateurs peuvent y plonger pour l’explorer et en rapporter des échantillons à examiner"
  },
  {
    "objectID": "slides/BD_intro.html#au-delà-du-relationnel-no-sql",
    "href": "slides/BD_intro.html#au-delà-du-relationnel-no-sql",
    "title": "BD I: Introduction aux SGBD",
    "section": "Au delà du relationnel: No SQL",
    "text": "Au delà du relationnel: No SQL\nCe sont les grandes entreprises du web qui ont été les premières confrontées aux limitations intrinsèques des SGBD relationnels traditionnels. Ces systèmes fondés sur une application stricte des propriétés ACID et généralement conçus pour fonctionner sur des ordinateurs uniques ont rapidement posé des problèmes d’extensibilité.\n\nAfin de répondre à ces limites, ces entreprises ont commencé à développer leurs propres systèmes de gestion de bases de données pouvant fonctionner sur des architectures matérielles distribuées et permettant de traiter des volumes de données importants.\n\n\nLes systèmes propriétaires qui en ont résulté, Google (BigTable), Amazon (Dynamo (en)), LinkedIn (Voldemort), Facebook (Cassandra puis HBase), SourceForge.net (MongoDB), Ubuntu One (CouchDB), Baidu (Hypertable) ont été les précurseurs du modèle NoSQL."
  },
  {
    "objectID": "slides/BD_intro.html#lire-plus",
    "href": "slides/BD_intro.html#lire-plus",
    "title": "BD I: Introduction aux SGBD",
    "section": "Lire plus",
    "text": "Lire plus\nGuy Harrison. Next Generation Databases. NoSQL, NewSQL, Big Data"
  },
  {
    "objectID": "slides/DF_norm_3.html#résultat-de-la-séance-précédente",
    "href": "slides/DF_norm_3.html#résultat-de-la-séance-précédente",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Résultat de la séance précédente\n",
    "text": "Résultat de la séance précédente\n\n\n\n\n\n\n\nImportant\n\n\nOn peut décomposer une relation \\(\\mathcal{A}\\) relativement à un ensemble de DF \\(\\Sigma\\) de façon à obtenir une décomposition :\n\ndont tous les membres sont en FNBC relativement à \\(\\Sigma\\)\nSPI\n\n\n\n\n\n Ce résultat ne fournit pas toujours une solution complètement satisfaisante"
  },
  {
    "objectID": "slides/DF_norm_3.html#projection-dun-ensemble-de-df",
    "href": "slides/DF_norm_3.html#projection-dun-ensemble-de-df",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Projection d’un ensemble de DF",
    "text": "Projection d’un ensemble de DF\nSoientt \\(\\mathcal{A}\\) un schéma de relation (\\(\\mathcal{A}\\) est un ensemble d’attributs) et \\(\\Sigma\\) un ensemble de DF sur \\(\\mathcal{A}\\)\nSoit \\(\\mathcal{A}_1\\subset  \\mathcal{A}\\) un sous-ensemble d’attributs\n\n\n\n\n\n\nDéfinition\n\n\n\\[\\pi_{\\mathcal{A}_1}(\\Sigma)=\\left\\{ X\\to Y \\mid \\Sigma\\models X\\to Y \\text{ et } X,Y\\subset \\mathcal{A}_1\\right\\}\\]\n\n\n\n\n\n\n\n\n\n\nCaractérisation\n\n\nSi \\(X\\subset {\\mathcal{A}}_1\\) on a l’équivalence \\[X\\to Y \\in \\pi_{{\\mathcal{A}}_1}(\\Sigma) \\iff Y\\subset\\left\\{X\\right\\}^+∩{\\mathcal{A}}_1\\]\n\n\n\n\n\\(\\pi_{\\mathcal{A}_1}(\\Sigma)\\) est l’ensemble des DF de la forme \\(X\\to Y\\) impliquées par \\(\\Sigma\\) et telles que \\(X\\subset \\mathcal{A}_1\\) et \\(Y\\subset \\mathcal{A}_1\\)"
  },
  {
    "objectID": "slides/DF_norm_3.html#exemple",
    "href": "slides/DF_norm_3.html#exemple",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Exemple",
    "text": "Exemple\n\n\\({\\mathcal{A}}=\\left\\{A,B,C\\right\\}\\) et \\(\\Sigma=\\left\\{A\\to B, B\\to C, C\\to A\\right\\}\\)\n\\(\\pi^{}_{\\left\\{A,B\\right\\}}(\\Sigma)\\) est équivalent à \\(\\left\\{A\\to B, B\\to A\\right\\}\\)"
  },
  {
    "objectID": "slides/DF_norm_3.html#calcul-de-pi_mathcala_1sigma",
    "href": "slides/DF_norm_3.html#calcul-de-pi_mathcala_1sigma",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Calcul de \\(\\pi_{{\\mathcal{A}}_1}(\\Sigma)\\)\n",
    "text": "Calcul de \\(\\pi_{{\\mathcal{A}}_1}(\\Sigma)\\)\n\nOn calcule un ensemble de DF équivalent à \\(\\pi_{\\mathcal{A}_1}(\\Sigma)\\)\n\n\n\\begin{algorithm} \\caption{Projection de DF} \\begin{algorithmic} \\Procedure{Projection}{$\\mathcal{A}_1, Σ$} \\State P ← ∅ \\For{$X ⊂ \\mathcal{A}_1$, $X ≠ ∅$, $X ≠ \\mathcal{A}_1$} \\State Y ← $X^+ ∩ \\mathcal{A}_1$ \\State P ← P ∪ $\\{ X → Y\\}$ \\EndFor \\Return P \\EndProcedure \\end{algorithmic} \\end{algorithm}\n\n\n\n\nL’ensemble de DF obtenu est équivalent à \\(\\pi_{{\\mathcal{A}}_1}(\\Sigma)\\)Très coûteux ! Le nombre de sous-ensembles \\(X\\) considérés est \\(2^{\\#{\\mathcal{A}}_1}-2\\)"
  },
  {
    "objectID": "slides/DF_norm_3.html#exemple-1",
    "href": "slides/DF_norm_3.html#exemple-1",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Exemple",
    "text": "Exemple\n\n\n\\({\\mathcal{A}}=\\left\\{A,B,C,D,E\\right\\}\\) et \\(\\Sigma=\\left\\{A\\to C, BC\\to D, AD\\to E\\right\\}\\)\n\n\n\n\n\n\\(\\pi_{AC}(\\Sigma)\\) est équivalent à \\(\\left\\{A\\to C\\right\\}\\) car\\(\\left\\{A\\right\\}^+=\\left\\{A,C\\right\\}\\) et \\(\\left\\{C\\right\\}^+=\\left\\{C\\right\\}\\)\n\n\n\n\n\n\n\\(\\pi_{ABD}(\\Sigma)\\) est équivalent à \\(\\left\\{AB\\to D\\right\\}\\) car\\(\\left\\{A\\right\\}^+=\\left\\{A,C\\right\\}\\), \\(\\left\\{B\\right\\}^+=\\left\\{D\\right\\}\\), \\(\\left\\{D\\right\\}^+=\\left\\{D\\right\\}\\),\\(\\left\\{A,B\\right\\}^+=\\left\\{A,B,C,D,E\\right\\}\\), \\(\\left\\{A,D\\right\\}^+=\\left\\{A,D,C,E\\right\\}\\), \\(\\left\\{B,D\\right\\}^+=\\left\\{B,D\\right\\}\\)\n\n\n\n\n\n\n\\(\\pi_{ABCE}(\\Sigma)\\) est équivalent à \\(\\left\\{A\\to C, AB \\to CE, AE\\to C, ABC\\to E, ABE\\to C\\right\\}\\)\\(A^+=AC \\quad B^+=B \\quad C^+=C \\quad E^+=E\\)\\(AB^+=ABCDE \\quad AC^+=AC \\quad AE^+=AEC\\)\\(BC^+=BCD \\quad BE^+=BE \\quad CE^+=CE\\)\\(ABC^+=ABCDE \\quad ABE^+=ABECD\\)\\(BCE^+=BCED \\quad ACE^+=ACE\\)\n\n\n\n\n\nSimplification : \\(\\pi_{ABCE}(\\Sigma)\\) équivaut à \\(\\left\\{A\\to C, AB\\to E\\right\\}\\)"
  },
  {
    "objectID": "slides/DF_norm_3.html#préservation-de-dépendances-fonctionnelles",
    "href": "slides/DF_norm_3.html#préservation-de-dépendances-fonctionnelles",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Préservation de dépendances fonctionnelles",
    "text": "Préservation de dépendances fonctionnelles\n\n\n\n\n\n\nDéfinition\n\n\nSoit \\(\\mathcal{A}\\) un schéma de relation et \\(\\Sigma\\) un ensemble de DF sur \\(\\mathcal{A}\\).\nSoit \\(\\left\\{ \\mathcal{A}_1,\\dots, \\mathcal{A}_k\\right\\}\\) une décomposition du schéma \\(\\mathcal{A}\\) (\\(\\mathcal{A}_i\\neq \\emptyset, 1\\leq i\\leq k\\) et \\(\\mathcal{A}= \\bigcup_{i=1}^k \\mathcal{A}_i\\))\nLa décomposition \\(\\left\\{\\mathcal{A}_1,\\dots, \\mathcal{A}_k\\right\\}\\) préserve \\(\\Sigma\\) si l’ensemble des dépendances fonctionnelles locales \\(\\bigcup_{i=1}^k \\pi_{\\mathcal{A}_i}(\\Sigma)\\) est équivalent à \\(\\Sigma\\)\n\n\n\n\n\nPuisque \\(\\Sigma ⊧ \\bigcup_{i=1}^k \\pi_{\\mathcal{A}_i}(\\Sigma)\\), la décomposition préserve \\(\\Sigma\\) si et seulement si toutes les DF de \\(\\Sigma\\) sont impliquées par les DF locales"
  },
  {
    "objectID": "slides/DF_norm_3.html#algorithme-pour-tester-si-bigcup_i1k-pi_mathcala_isigma-models-x-rightarrow-y",
    "href": "slides/DF_norm_3.html#algorithme-pour-tester-si-bigcup_i1k-pi_mathcala_isigma-models-x-rightarrow-y",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Algorithme pour tester si \\(\\bigcup_{i=1}^k \\pi_{\\mathcal{A}_i}(\\Sigma) \\models X \\rightarrow Y\\)\n",
    "text": "Algorithme pour tester si \\(\\bigcup_{i=1}^k \\pi_{\\mathcal{A}_i}(\\Sigma) \\models X \\rightarrow Y\\)\n\n\n\n\\begin{algorithm} \\caption{X → Y est-elle impliquée par les dépendances projetées?} \\begin{algorithmic} \\Procedure{Implique}{$\\left\\{ \\mathcal{A}_1,\\dots, \\mathcal{A}_k\\right\\}, Σ, X, Y$} \\State Z ← X \\State continuer ← \\True \\While{continuer} \\State $W ← Z$ \\For{i ∈ 1, ..., k} \\State $W ← W ∪ \\bigl((W ∩ \\mathcal{A}_i)^+ ∩ \\mathcal{A}_i\\bigr)$ \\EndFor \\If{W ≠ Z} \\State Z ← W \\Else \\State continuer ← \\False \\EndIf \\EndWhile \\If{Y ⊆ Z} \\Return \\True \\Else \\Return \\False \\EndIf \\EndProcedure \\end{algorithmic} \\end{algorithm}"
  },
  {
    "objectID": "slides/DF_norm_3.html#exemple-i",
    "href": "slides/DF_norm_3.html#exemple-i",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Exemple I",
    "text": "Exemple I\n\n\\(\\mathcal{A}=\\left\\{A,B,C,D\\right\\}\\),\n\\(\\mathcal{A}_1=\\left\\{A,B\\right\\}\\), \\(\\mathcal{A}_2=\\left\\{B,C\\right\\}\\), \\(\\mathcal{A}_3=\\left\\{C,D\\right\\}\\)\n\\(\\Sigma=\\left\\{A\\to B, B\\to C, C\\to D, D\\to A\\right\\}\\)\nEst-ce que la décomposition \\(\\left\\{\\mathcal{A}_1,\\mathcal{A}_2,\\mathcal{A}_3\\right\\}\\) préserve \\(\\Sigma\\) ?\n\n\n\nLes DF locales impliquent \\(A\\to B\\), \\(B\\to C\\), \\(C\\to D\\) (ce sont DF locales)\n\n\n\n\nEst-ce que les DF locales impliquent \\(D\\to A\\) ?\n\n\n\nCommencer avec \\(Z ← \\{D\\}\\)\n\n\\((\\{D\\}∩\\{CD\\})^+ ∩ \\{CD\\}=\\{D\\}^+ ∩\\{CD\\}=\\{DABC\\} ∩ \\{CD\\}=\\{CD\\}\\), ajouter \\(C\\)\n\\((\\{DC\\}∩ \\{BC\\})^+ ∩ \\{BC\\}=\\{C\\}^+ ∩ \\{BC\\}=\\{CDAB\\}∩ \\{BC=B\\}\\), ajouter \\(B\\)\n\\((\\{DCB\\}∩ \\{AB\\})^+ ∩ \\{AB\\}=\\{B\\}^+ ∩ \\{AB\\}=\\{BCDA\\} ∩ \\{AB\\}\\), ajouter \\(A\\)\n\\(\\{DCBA\\}\\) contient \\(A\\) donc \\(D\\to A\\) est préservée"
  },
  {
    "objectID": "slides/DF_norm_3.html#exemple-ii",
    "href": "slides/DF_norm_3.html#exemple-ii",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Exemple II",
    "text": "Exemple II\n\n\\(\\mathcal{A}=\\) {Ville, CP, Rue, Numero}\n\\(\\Sigma=\\) { CP →  Ville, {Ville, Rue, Numero} → CP}\n\\(\\mathcal{A}_1=\\) {Ville, CP} \\(\\mathcal{A}_2=\\) {Rue, Numero, CP}\nEst-ce que la décomposition \\(\\{\\mathcal{A}_1, \\mathcal{A}_2 \\}\\) préserve \\(\\Sigma\\) ?\n\n\n\n\nCP →  Ville est préservée car elle est locale à \\(\\mathcal{A}_1\\)\n\n\n\n\n\nEst-ce que {Ville, Rue, Numero} → CP est préservée par \\(\\mathcal{A}_1, \\mathcal{A}_2\\) ?\n\n\n\nZ ← {Ville, Rue, Numero}\n\n\\((\\texttt{Z} ∩ \\texttt{{Ville, CP}})^+\\) ∩ {Ville, CP} = {Ville} rien à ajouter\n\\((\\texttt{Z} ∩ \\texttt{{Rue, Numero, CP}})^+\\) ∩ {Rue, Numero, CP} = {Rue, Numero}, rien à ajouter\n\n\n\nDonc Ville, Rue, Numero → CP n’est pas préservée"
  },
  {
    "objectID": "slides/DF_norm_3.html#rappels-séance-précédente-bis",
    "href": "slides/DF_norm_3.html#rappels-séance-précédente-bis",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Rappels séance précédente (bis)",
    "text": "Rappels séance précédente (bis)\n\n\n\n\n\n\nDéfinition\n\n\nUn schéma \\(\\mathcal{A}\\) est en FNBC par rapport à un ensemble de dépendances fonctionnelles \\(\\Sigma\\) sur \\(\\mathcal{A}\\)\nsi\npour toute DF \\(X\\rightarrow Y\\) impliquée par \\(\\Sigma\\) avec \\(Y\\not\\subset X\\), \\(X\\) est une super-clef"
  },
  {
    "objectID": "slides/DF_norm_3.html#algorithme",
    "href": "slides/DF_norm_3.html#algorithme",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Algorithme",
    "text": "Algorithme\n\n\n\\begin{algorithm} \\caption{Décomposition FNBC} \\begin{algorithmic} \\Procedure{DecompositionFNBC}{$\\mathcal{A}, Σ$} \\State \\Comment{Initialisation de la décomposition} \\State $D ← \\{\\mathcal{A}\\}$ \\State \\While{Exists some $\\mathcal{B} \\in D$ which is not in BCNF w.r.t. $\\Sigma \\models X → X^+ \\cap \\mathcal{B}$, $X \\subsetneq \\mathcal{B}$} \\State $Y \\leftarrow X^+ \\cap \\mathcal{B} \\setminus X$ \\State $D \\leftarrow D \\setminus \\{\\mathcal{B}\\} \\cup \\{ X \\cup Y, \\mathcal{B} \\setminus Y \\}$ \\EndWhile \\State \\Return $D$ \\EndProcedure \\end{algorithmic} \\end{algorithm}"
  },
  {
    "objectID": "slides/DF_norm_3.html#limites-de-la-décomposition-fnbc",
    "href": "slides/DF_norm_3.html#limites-de-la-décomposition-fnbc",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Limites de la décomposition FNBC",
    "text": "Limites de la décomposition FNBC\n\n\n\n\n\n\nNote\n\n\nIl existe des couples schéma/Ensemble de DFs (\\(\\mathcal{A}, \\Sigma\\)) pour lesquels toute décomposition FNBC entraine une perte de dépendances fonctionnelles"
  },
  {
    "objectID": "slides/DF_norm_3.html#section",
    "href": "slides/DF_norm_3.html#section",
    "title": "Normalisation II : Décomposition FN3",
    "section": "",
    "text": "\\(\\mathcal{A} =\\) {Ville, Rue, Numéro, #Bureau_vote}\nΣ = { Ville, Nom, Rue → #Bureau_vote,  #Bureau_vote  →  Ville }\n\nDeux clés Ville, Nom, Rue et #Bureau_vote, Nom, Rue\n\n\n#Bureau_vote  →  Ville ne satisfait pas le critère FNBC\n\n\nL’algorithme de décomposition en FNBC conduit à la décomposition {#Bureau_vote,Ville} et {#Bureau_vote, Nom, Rue}\nLa DF Ville, Nom, Rue → #Bureau_vote n’est pas préservée\nLa décomposition préserve l’information (SPI) mais pas les dépendances fonctionnelles."
  },
  {
    "objectID": "slides/DF_norm_3.html#limites-de-la-décomposition-fnbc-suite",
    "href": "slides/DF_norm_3.html#limites-de-la-décomposition-fnbc-suite",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Limites de la décomposition FNBC (suite)",
    "text": "Limites de la décomposition FNBC (suite)\n\n\n\n\n\n\n\nÀ noter\n\n\nOn peut vérifier qu’aucune décomposition FNBC de \\(\\mathcal{A}\\) ne préserve toutes les dépendances fonctionnelles."
  },
  {
    "objectID": "slides/DF_norm_3.html#un-nouvel-objectif",
    "href": "slides/DF_norm_3.html#un-nouvel-objectif",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Un nouvel objectif",
    "text": "Un nouvel objectif\n\n\n\n\n\n\n\nConstruire\n\n\nUne décomposition :\n\nSans Perte d’Information (SPI)\nSans perte de Dépendances Fonctionnelles\nDont les éléments sont en FN3 par rapports aux dépendances projetées"
  },
  {
    "objectID": "slides/DF_norm_3.html#pour-réaliser-cet-objectif",
    "href": "slides/DF_norm_3.html#pour-réaliser-cet-objectif",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Pour réaliser cet objectif",
    "text": "Pour réaliser cet objectif\nUne étape cruciale : réécrire l’ensemble de DFs"
  },
  {
    "objectID": "slides/DF_norm_3.html#algorithme-de-construction-de-couverture-irredondante",
    "href": "slides/DF_norm_3.html#algorithme-de-construction-de-couverture-irredondante",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Algorithme de construction de couverture irredondante",
    "text": "Algorithme de construction de couverture irredondante\n\n\n\\begin{algorithm} \\caption{Couverture irredondante} \\begin{algorithmic} \\Procedure{MinCover}{$Σ$} \\State Σ' ← ∅ \\State \\Comment{Normaliser les éléments de Σ} \\For{$(X → Y) ∈ Σ$} \\For{$y ∈ Y$} \\State Σ' ← Σ' ∪ {X → y} \\EndFor \\EndFor \\State \\Comment{Éliminer les dépendances redondantes dans Σ'} \\State \\Comment{Miniser les dépendances dans Σ'} \\Return Σ' \\EndProcedure \\end{algorithmic} \\end{algorithm}"
  },
  {
    "objectID": "slides/DF_norm_3.html#détails",
    "href": "slides/DF_norm_3.html#détails",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Détails",
    "text": "Détails\n\n\n\n\n\\begin{algorithm} \\caption{Éliminer les dépendances redondantes dans Σ' (détail)} \\begin{algorithmic} \\Repeat \\State s ← \\True \\For{$(X → y) ∈ Σ'$} \\If{$Σ' \\setminus {X → y} ⊧ X → y$} \\State $Σ' ← Σ' \\setminus {X → y}$ \\State s ← \\False \\EndIf \\EndFor \\Until{s} \\end{algorithmic} \\end{algorithm}\n\n\n\n\n\n\\begin{algorithm} \\caption{Miniser les dépendances dans Σ' (détail)} \\begin{algorithmic} \\Repeat \\State s ← \\True \\For{$(X → y) ∈ Σ'$} \\For{$x ∈ X$} \\If{$Σ' \\setminus {X → y} ⊧ X \\setminus {x} → y$} \\State $Σ' ← (Σ' \\setminus {X → y}) ∪ X \\setminus {x} → y$ \\State s ← \\False \\Break \\EndIf \\EndFor \\EndFor \\Until{s} \\end{algorithmic} \\end{algorithm}"
  },
  {
    "objectID": "slides/DF_norm_3.html#définition-forme-normale-3-fn3",
    "href": "slides/DF_norm_3.html#définition-forme-normale-3-fn3",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Définition : forme normale 3 (FN3)",
    "text": "Définition : forme normale 3 (FN3)\n\n\n\n\n\n\nImportant\n\n\nUn schéma relationnel \\(\\mathcal{A}\\) est en forme normale 3 (FN3) relativement à un ensemble de DF Σ ssi pour toute dépendance non triviale X → Yde Σ, on a\n\nle membre gauche X est une super-clé ou\n\nle membre droit Y fait partie d’une clé\n\n\n\n\n\n\nLe schéma \\(\\mathcal{A} =\\) {Ville, Rue, Numéro, #Bureau_vote} est en FN3 relativement à Σ = { Ville, Nom, Rue → #Bureau_vote,  #Bureau_vote  →  Ville }\nMais ce schéma n’est pas en FNBC."
  },
  {
    "objectID": "slides/DF_norm_3.html#pourquoi-deux-notions-de-forme-normale",
    "href": "slides/DF_norm_3.html#pourquoi-deux-notions-de-forme-normale",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Pourquoi deux notions de forme normale ?",
    "text": "Pourquoi deux notions de forme normale ?\n\n\n\n\n\n\nProposition\n\n\nSi un schéma \\(\\mathcal{A}\\) est en forme normale Boyce-Codd (FNBC) relativement à un ensemble de DF Σ, alors \\(\\mathcal{A}\\) est en forme normale 3 (FN3) relativement à Σ\n\n\n\n\n\nLa réciproque est fausse"
  },
  {
    "objectID": "slides/DF_norm_3.html#exercice",
    "href": "slides/DF_norm_3.html#exercice",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Exercice",
    "text": "Exercice\n\\(\\mathcal{A}=\\) (A, B, C, D, E) et Σ={A → C, BC → D, AD → E}\n\nQuelles sont les clés ?\nLe schéma est-il en FNBC ?\nSi non, propopsez une décomposition SPI en FNBC. Est-elle sans perte de DF?\nLe schéma est-il en FN3 ?"
  },
  {
    "objectID": "slides/DF_norm_3.html#intérêt-de-la-forme-normale-3-fn3",
    "href": "slides/DF_norm_3.html#intérêt-de-la-forme-normale-3-fn3",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Intérêt de la forme normale 3 (FN3)",
    "text": "Intérêt de la forme normale 3 (FN3)\nRedondance limitée\n\nPossibilité de décomposition SPI et sans perte de Dépendances Fonctionnelles"
  },
  {
    "objectID": "slides/DF_norm_3.html#algorithme-1",
    "href": "slides/DF_norm_3.html#algorithme-1",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Algorithme",
    "text": "Algorithme\n\n\n\\begin{algorithm} \\caption{Decomposition FN3} \\begin{algorithmic} \\Procedure{DecompositionFN3}{$\\mathcal{A}, Σ$} \\State \\Comment{Initialisation de la décomposition} \\State $D ← ∅$ \\State \\Comment{Mise en forme des courverture minimale de Σ} \\State Σ' ← \\Call{MinCover}{$Σ$} \\State \\For{Each distinct determinant $X$ amongst FDs in Σ'} \\State $Y ← \\{y : X → y ∈ Σ'\\}$ \\State $D ← D \\cup \\{X \\cup Y\\}$ \\Comment{ Ajouter $X \\cup Y$ à $D$} \\EndFor \\State \\State $\\mathcal{B} ← $ Attributes in $\\mathcal{A}$ that do not occur in $D$ \\State $D ← D \\cup \\{\\mathcal{B}\\}$ \\State \\If{No component of $D$ includes a key for $\\mathcal{A}, Σ$} \\State $D ← D \\cup $ some key for $\\mathcal{A}, Σ$ \\EndIf \\State \\Return $D$ \\EndProcedure \\end{algorithmic} \\end{algorithm}"
  },
  {
    "objectID": "slides/DF_norm_3.html#preuves",
    "href": "slides/DF_norm_3.html#preuves",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Preuves",
    "text": "Preuves\nTerminaison \n\nFN3 \n\nSPI \n\nSPDF"
  },
  {
    "objectID": "slides/LDD_1.html#problème",
    "href": "slides/LDD_1.html#problème",
    "title": "BD : Contraintes",
    "section": "Problème",
    "text": "Problème\n\nLa définition d’un schéma de base ne s’arrête pas à la définition des tables, des colonnes et des types des colonnes\n\n\n\nLes contraintes décrivent des propriétés que devront vérifier toutes les mises en oeuvre (instances) du schéma durant toute sa durée de vie\n\n\n La définition d’un schéma de base ne s’arrête pas à la définition des tables, des colonnes et des types des colonnes\nLes contraintes décrivent des propriétés que devront vérifier toutes les mises en oeuvre (instances) du schémas durant toute leur durée de vie\n Pour spécifier une contrainte, il suffit de préciser que le résultat d’une certaine requête doit toujours être vide"
  },
  {
    "objectID": "slides/LDD_1.html#famille-de-contraintes",
    "href": "slides/LDD_1.html#famille-de-contraintes",
    "title": "BD : Contraintes",
    "section": "Famille de contraintes",
    "text": "Famille de contraintes\n\n\nContraintes d’attribut\n\nContrainte de type\n\nContrainte de non-nullité\n\n\n\n\n\n\n\nContraintes de tupe\n\nContrainte de vérification\n\n\n\n\n\n\n\n\nContraintes de table\n\nContrainte de clé primaire\n\nContrainte d’unicité\n\nContrainte d’unicité avancée\n\nContraintes d’exclusion\n\n\n\n\n\n\n\nContraintes multi-tables\n\nContraintes de clé étrangère"
  },
  {
    "objectID": "slides/LDD_1.html#contrainte-de-type",
    "href": "slides/LDD_1.html#contrainte-de-type",
    "title": "BD : Contraintes",
    "section": "Contrainte de type",
    "text": "Contrainte de type\nUne contrainte de type spécifie le type/domaine d’une colonne\nLes contrainte de type sont les plus simples à mettre en oeuvre.\n\nAu delà des types de base varchar, integer, ... PostgreSQL propose des types sophistiqués pour :\n\n\ndates,\n\nles estampilles avec ou sans fuseau horaire,\ndes types intervalles (rangetype),\n\ndes types énumérés,\n\ndes types tableaux,\netc"
  },
  {
    "objectID": "slides/LDD_1.html#consulter-la-liste-des-types",
    "href": "slides/LDD_1.html#consulter-la-liste-des-types",
    "title": "BD : Contraintes",
    "section": "Consulter la liste des types",
    "text": "Consulter la liste des types\nhttps://docs.postgresql.fr/docs/current/datatype.html\nIl faut essayer d’utiliser ces types pour préciser les contenus des colonnes\n\n\n\n\n\n\nConseil\n\n\nIl faut essayer d’utiliser autant que possible ces types pour préciser les contenus des colonnes\nCela permet de contraindre les contenus\nCela permet d’utiliser une foule de fonctions de manipulation très pratiques, notamment pour l’arithmétique du temps\n\n\n\n\n\n\n\n\n\n\nMise en garde\n\n\nLes types disponibles diffèrent d’un SGBD à l’autre (Mysql, Postgres, Oracle, SQL Server, …)"
  },
  {
    "objectID": "slides/LDD_1.html#contraintes-de-tuple",
    "href": "slides/LDD_1.html#contraintes-de-tuple",
    "title": "BD : Contraintes",
    "section": "Contraintes de tuple",
    "text": "Contraintes de tuple\nUne contrainte de tuple peut être vérifiée tuple par tuple (ligne par ligne)\n\nLors d’une insertion ou d’une modification de tuple, il suffit de vérifier que la contrainte est respectée par le nouveau tuple"
  },
  {
    "objectID": "slides/LDD_1.html#exemple",
    "href": "slides/LDD_1.html#exemple",
    "title": "BD : Contraintes",
    "section": "Exemple",
    "text": "Exemple\nDans un tuple de Piece, on devrait toujours avoir une valeur du prix positive.\nOn peut imposer cela en ajoutant au schéma de la table Piece une contrainte de type CHECK"
  },
  {
    "objectID": "slides/LDD_1.html#exemple-suite",
    "href": "slides/LDD_1.html#exemple-suite",
    "title": "BD : Contraintes",
    "section": "Exemple (suite)",
    "text": "Exemple (suite)\nCREATE TABLE piece(\n    nomp VARCHAR(20),\n    prix MONEY CHECK (prix&gt;= 0::money), \n    couleur VARCHAR(15)\n);\n\n\n\n\n\n\n\nNote\n\n\nHave a look at PostGres Monetary type"
  },
  {
    "objectID": "slides/LDD_1.html#exemple-world.country",
    "href": "slides/LDD_1.html#exemple-world.country",
    "title": "BD : Contraintes",
    "section": "Exemple world.country\n",
    "text": "Exemple world.country\n\nDans un tuple de country, les colonnes numériques ne devraient pas prendre de valeur négative\n\n\nCREATE TABLE world.country (\n    countrycode BPCHAR(3) NOT NULL,\n    name_country TEXT NOT NULL,\n    continent TEXT NOT NULL,\n    region TEXT NOT NULL,\n    surfacearea FLOAT4 CHECK (surfacearea&gt;= 0) NOT NULL, \n    indepyear INT2 NULL,\n    population_country INT4 NOT NULL,\n    lifeexpectancy FLOAT4 CHECK (lifeexpectancy&gt;= 0) NULL, \n    gnp NUMERIC(10, 2) NULL,    \n    gnpold NUMERIC(10, 2) NULL,  \n    localname TEXT NOT NULL,\n    governmentform TEXT NOT NULL,\n    headofstate TEXT NULL,\n    capital INT4 NULL,\n    code2 BPCHAR(2) NOT NULL,\n    CONSTRAINT country_continent_check CHECK (\n        ((continent = 'Asia'::text) OR (continent = 'Europe'::text) OR \n         (continent = 'North America'::text) OR (continent = 'Africa'::text) OR \n         (continent = 'Oceania'::text) OR (continent = 'Antarctica'::text) OR \n         (continent = 'South America'::text))),\n    CONSTRAINT country_pkey PRIMARY KEY (countrycode)\n);"
  },
  {
    "objectID": "slides/LDD_1.html#contrainte-de-vérification---exemple-suite",
    "href": "slides/LDD_1.html#contrainte-de-vérification---exemple-suite",
    "title": "BD : Contraintes",
    "section": "Contrainte de vérification - Exemple (suite)",
    "text": "Contrainte de vérification - Exemple (suite)\n\nCREATE TABLE piece(\n    nomp VARCHAR(20),\n    prix moNey CHECK (prix&gt;= 0::money),  \n    prix_promo MONEY CHECK (prix_promo &gt;= 0::MONEY), \n    couleur VARCHAR(15),\n    CHECK(prix &gt; prix_promo) \n); \n\n\nINSERT INTO piece \n  VALUES\n  ('x21', 1.51, 1.61,'rouge');\nERROR:  new row for relation \"piece\" violates check constraint piece_check \n\n\nINSERT INTO piece VALUES('x21', 1.51, null,'rouge');\nest accepté"
  },
  {
    "objectID": "slides/LDD_1.html#valeurs-nulles-et-contraintes-de-tuple",
    "href": "slides/LDD_1.html#valeurs-nulles-et-contraintes-de-tuple",
    "title": "BD : Contraintes",
    "section": "\n Valeurs nulles et contraintes de tuple",
    "text": "Valeurs nulles et contraintes de tuple\nLes contraintes CHECK sont satisfaites si l’expression associée vaut TRUE ou NULL\n\nComme une expression composée vaut parfois NULL si l’un des opérandes vaut lui-même NULL, les contraintes CHECK ne suffisent pas à prévenir l’insertion de valeurs nulles\n\n\n\n\n\n\n\n\nAstuce\n\n\nIl faut compléter les contraintes de tuple avec des contraintes de non-nullité"
  },
  {
    "objectID": "slides/LDD_1.html#pourquoi-imposer-quune-colonne-soit-toujours-renseignée",
    "href": "slides/LDD_1.html#pourquoi-imposer-quune-colonne-soit-toujours-renseignée",
    "title": "BD : Contraintes",
    "section": "Pourquoi imposer qu’une colonne soit toujours renseignée ?",
    "text": "Pourquoi imposer qu’une colonne soit toujours renseignée ?\n\n\n\n\n\n\nImportant\n\n\nLa présence possible des valeurs nulles rend beaucoup d’opérations complexes\nIl faut avoir en tête que en SQL,\n\nles booléens peuvent avoir trois valeurs : TRUE, FALSE et NULL et que\nle fait qu’une expression ne vaille pas FALSE ne veut pas dire qu’elle vaut TRUE …\n\n\n\n\n\nPour imposer qu’une colonne soit renseignée :\n\npréciser après le type : NOT NULL"
  },
  {
    "objectID": "slides/LDD_1.html#contrainte-de-non-nullité-exemple",
    "href": "slides/LDD_1.html#contrainte-de-non-nullité-exemple",
    "title": "BD : Contraintes",
    "section": "Contrainte de non-nullité (Exemple)",
    "text": "Contrainte de non-nullité (Exemple)\n\nCREATE TABLE piece(\n    nomp VARCHAR(20) NOT NULL,\n    prix MONEY CHECK (prix&gt;= 0::MONEY),  \n    prix_promo MONEY CHECK (prix_promo &gt;= 0::MONEY),  \n    couleur VARCHAR(15),\n    CHECK (prix &gt; prix_promo)   \n);"
  },
  {
    "objectID": "slides/LDD_1.html#contrainte-dunicité-1",
    "href": "slides/LDD_1.html#contrainte-dunicité-1",
    "title": "BD : Contraintes",
    "section": "Contrainte d’unicité",
    "text": "Contrainte d’unicité\n\nLes contraintes d’unicité garantissent l’unicité des données contenues dans une colonne ou un groupe de colonnes par rapport à toutes les lignes de la table\nC’est une contrainte de table puisqu’elle fait intervenir tous les tuples de la table"
  },
  {
    "objectID": "slides/LDD_1.html#contrainte-dunicité-2",
    "href": "slides/LDD_1.html#contrainte-dunicité-2",
    "title": "BD : Contraintes",
    "section": "Contrainte d’unicité",
    "text": "Contrainte d’unicité\n\n\n\n\n\n\nNote\n\n\nLa contrainte d’unicité peut porter sur un groupe de colonnes\n\n\n\n\nCREATE TABLE fournisseur(\n    nomf VARCHAR(20) NOT NULL,\n    villef VARCHAR(20) NOT NULL,\n    UNIQUE(nomf, villef)  \n);\n\n\n\n Il ne peut pas y avoir deux lignes identiques dans la table fournisseur"
  },
  {
    "objectID": "slides/LDD_1.html#clef-primaire-primary-key",
    "href": "slides/LDD_1.html#clef-primaire-primary-key",
    "title": "BD : Contraintes",
    "section": "Clef primaire : PRIMARY KEY\n",
    "text": "Clef primaire : PRIMARY KEY\n\n\n\n\n\n\n\nDéfinition\n\n\nUne contrainte de type clef primaire indique qu’une colonne, ou un groupe de colonnes, peuvent être utilisée comme un identifiant unique de ligne pour cette table.\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nCeci nécessite que les valeurs soient à la fois uniques et NON NULL.\n\n\n\n\n\nLes définitions de table suivantes acceptent de ce fait les mêmes données\n\n\nCREATE TABLE fournisseur(\n    nomf VARCHAR(20) NOT NULL,\n    villef VARCHAR(20) NOT NULL,\n    UNIQUE(nomf, villef)  \n);\n\nCREATE TABLE fournisseur(\n    nomf VARCHAR(20),\n    villef VARCHAR(20),\n    PRIMARY KEY (nomf, villef)  \n);\n\n\n\n\n Une table a au plus une clef primaire"
  },
  {
    "objectID": "slides/LDD_1.html#clef-étrangère-1",
    "href": "slides/LDD_1.html#clef-étrangère-1",
    "title": "BD : Contraintes",
    "section": "Clef étrangère",
    "text": "Clef étrangère\n\nUne contrainte de clef étrangère stipule que les valeurs d’une colonne (ou d’un groupe de colonnes) doivent correspondre aux valeurs qui apparaissent dans les lignes d’une autre table.\nOn dit que cela maintient l’intégrité référentielle entre les deux tables\nSoit les deux tables suivantes\n\n\n\nCREATE TABLE fournisseur(\n    idf INT PRIMARY KEY,\n    nomf VARCHAR(20),\n    villef VARCHAR(20)\n);\n\nCREATE TABLE piece(\n    nomp VARCHAR(20) PRIMARY KEY,\n    prix MONEY CHECK \n        (prix&gt;= 0::MONEY),\n    prix_promo MONEY CHECK \n        (prix_promo &gt;= 0::MONEY),\n    couleur VARCHAR(15),\n    CHECK (prix &gt; prix_promo)\n);"
  },
  {
    "objectID": "slides/LDD_1.html#clef-étrangère-references",
    "href": "slides/LDD_1.html#clef-étrangère-references",
    "title": "BD : Contraintes",
    "section": "Clef étrangère : REFERENCES",
    "text": "Clef étrangère : REFERENCES\n\nSoit également une table livraison qui stocke les livraisons de ces pièces\nIl est intéressant de s’assurer que la table livraison ne contient que des références de pièces et de fournisseurs qui existent dans la base\n\nPour cela, deux contraintes de clef étrangère sont émises par la table des livraisons\n\nUne contrainte référence piece\n\nUne contrainte référence fournisseur\n\n\n\nCREATE TABLE livraison(\n    numliv INT PRIMARY KEY,\n    idf INT REFERENCES fournisseur,   \n    nomp VARCHAR(20) REFERENCES piece,  \n    dateLiv DATE DEFAULT NOW(),\n    quantite INT DEFAULT 1 CHECK (quantite&gt;=0)\n);\n \n\n\n\n\n\n\nIl est désormais impossible de créer des livraisons pour lesquelles les valeurs non NULL de nomp n’apparaissent pas dans la table piece et les valeurs non NULL de idf n’apparaissent pas dans la table fournisseur\nOn dit que la table des livraisons est la table qui référence et la table des pièces est la table référencée"
  },
  {
    "objectID": "slides/LDD_1.html#définition-de-world.countrylanguage",
    "href": "slides/LDD_1.html#définition-de-world.countrylanguage",
    "title": "BD : Contraintes",
    "section": "Définition de world.countrylanguage\n",
    "text": "Définition de world.countrylanguage\n\n+-------------+--------------+-------------+\n| Column      | Type         | Modifiers   |\n|-------------+--------------+-------------|\n| countrycode | character(3) |  not null   |\n| language    | text         |  not null   |\n| isofficial  | boolean      |  not null   |\n| percentage  | real         |  not null   |\n+-------------+--------------+-------------+\nIndexes:\n    \"countrylanguage_pkey\" PRIMARY KEY, btree (countrycode, language)"
  },
  {
    "objectID": "slides/LDD_1.html#définition-de-world.country",
    "href": "slides/LDD_1.html#définition-de-world.country",
    "title": "BD : Contraintes",
    "section": "Définition de world.country\n",
    "text": "Définition de world.country\n\n\n\n+--------------------+---------------+-------------+\n| Column             | Type          | Modifiers   |\n|--------------------+---------------+-------------|\n| countrycode        | character(3)  |  not null   |\n| name_country       | text          |  not null   |\n| continent          | text          |  not null   |\n| region             | text          |  not null   |\n| surfacearea        | real          |  not null   |\n| indepyear          | smallint      |             |\n| population_country | integer       |  not null   |\n| lifeexpectancy     | real          |             |\n| gnp                | numeric(10,2) |             |\n| gnpold             | numeric(10,2) |             |\n| localname          | text          |  not null   |\n| governmentform     | text          |  not null   |\n| headofstate        | text          |             |\n| capital            | integer       |             |\n| code2              | character(2)  |  not null   |\n+--------------------+---------------+-------------+\n\nIndexes:\n    \"country_pkey\" PRIMARY KEY, btree (countrycode)\nCheck constraints:\n    \"country_continent_check\" CHECK\n    (continent = 'Asia'::text OR \n      continent = 'Europe'::text OR \n      continent = 'North America'::text OR \n      continent = 'Africa'::text OR \n      continent = 'Oceania'::text OR \n      continent = 'Antarctica'::text OR \n      continent = 'South America'::text)\nForeign-key constraints:\n    \"country_capital_fkey\" \n        FOREIGN KEY (capital) \n        REFERENCES world.city(id)  \nReferenced by:\n    TABLE \"world.countrylanguage\"\n    CONSTRAINT \"countrylanguage_countrycode_fkey\" \n        FOREIGN KEY (countrycode)\n        REFERENCES country(countrycode)"
  },
  {
    "objectID": "slides/LDD_1.html#foreign-keys-emitted-by-world.country",
    "href": "slides/LDD_1.html#foreign-keys-emitted-by-world.country",
    "title": "BD : Contraintes",
    "section": "Foreign keys emitted by world.country\n",
    "text": "Foreign keys emitted by world.country\n\nALTER TABLE world.country ADD \n    CONSTRAINT country_capital_fkey \n        FOREIGN KEY (capital)   \n        REFERENCES world.city(id);  \n\nALTER TABLE world.country \n    ADD CONSTRAINT country_fk \n        FOREIGN KEY (continent)   \n        REFERENCES world.code_continent(continent);"
  },
  {
    "objectID": "slides/Modelisation_1.html#pourquoi",
    "href": "slides/Modelisation_1.html#pourquoi",
    "title": "Modélisation I : Entité/Association",
    "section": "Pourquoi ?",
    "text": "Pourquoi ?\nPour construire/concevoir des bases de données utiles, il n’est pas facile d’utiliser immédiatement le Langage de Définition de Données (partie de SQL)\n\nIl est plus raisonnable de s’appuyer sur\n\n\n\nUn formalisme pour décrire les informations à intégrer dqns une base\nUn formalisme pour décrire les liens entre ses informations\nUn formalisme lisible par les humains\nUn formalisme traduisible dans un Langage de Définition de Données, c’est-à-dire dans un langage où tout doit se décrire à l’aide de tables et de contraintes"
  },
  {
    "objectID": "slides/Modelisation_1.html#comment",
    "href": "slides/Modelisation_1.html#comment",
    "title": "Modélisation I : Entité/Association",
    "section": "Comment ?",
    "text": "Comment ?\nDepuis les temps originels des Bases de Données, on a multiplié les formalismes, les méthodes de conception\nLes différents formalismes sont presque toujours des variations autour du modèle dit Entité-Association proposé par Chen en 1976"
  },
  {
    "objectID": "slides/Modelisation_1.html#modèle-entité-association-eaer",
    "href": "slides/Modelisation_1.html#modèle-entité-association-eaer",
    "title": "Modélisation I : Entité/Association",
    "section": "Modèle Entité-Association (EA/ER)",
    "text": "Modèle Entité-Association (EA/ER)\nPeter Chen, the father of ER modeling écrivait dans le texte fondateur:\n\nThe entity-relationship model adopts the more natural view that the real world consists of entities and relationships. It incorporates some of the important semantic information about the real world.\n\nDans l’article de 1976, Chen distingue explicitement les diagrammes entité–associations des techniques de modélisation par record:\n\nThe data structure diagram is a representation of the organization of records and is not an exact representation of entities and relationships.\n\n\n\nVoir La Sémantique selon wikipedia"
  },
  {
    "objectID": "slides/Modelisation_1.html#exemple-dentités-world",
    "href": "slides/Modelisation_1.html#exemple-dentités-world",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemple d’entités : world",
    "text": "Exemple d’entités : world\nPour la constitution de la base de données de géographie politique world, la modélisation choisirait les entités :\n\ncountry: les pays/territoires\ncity: les villes de population urbaine supérieure à un seuil donné lors de la constitution de la base\nlanguage: les langues parlées lors de la constitution de la base"
  },
  {
    "objectID": "slides/Modelisation_1.html#exemple-dentités-nycflights",
    "href": "slides/Modelisation_1.html#exemple-dentités-nycflights",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemple d’entités (nycflights)",
    "text": "Exemple d’entités (nycflights)\nPour la modélisation du traffic aérien civil aux États-Unis, on peut considérer les entités suivantes\n\nairports: les aéroports (civils, sur le sol des États-Unis)\nairlines: les compagnies aériennes\nplanes : les avions (aéronefs)"
  },
  {
    "objectID": "slides/Modelisation_1.html#les-noms-et-les-notations-graphiques",
    "href": "slides/Modelisation_1.html#les-noms-et-les-notations-graphiques",
    "title": "Modélisation I : Entité/Association",
    "section": "Les noms et les notations graphiques",
    "text": "Les noms et les notations graphiques\nLes entités sont généralement associées à des noms (substantifs). Une entité est en effet une collection d’objets apparentés (avec des caractériques communes)\n\nDans les diagrammes EA, les entités sont représentées par des rectangles. Le nom de l’entité est inscrit au centre du rectangle."
  },
  {
    "objectID": "slides/Modelisation_1.html#instances-et-entités",
    "href": "slides/Modelisation_1.html#instances-et-entités",
    "title": "Modélisation I : Entité/Association",
    "section": "Instances et Entités",
    "text": "Instances et Entités\n\n\n\n\n\n\nDéfinition\n\n\nUne instance est un élément d’une entité.\n\n\n\n\nDans word, le pays Luxemburg est une instance de country.\nLes instances d’une entité sont discernables (pas d’éléments dupliqués)\n\n\n\nLe jargon de la modélisation EA nomme des notions qui sont déjà présentes dans la théorie naïve des ensembles (le langage des mathématiciens)"
  },
  {
    "objectID": "slides/Modelisation_1.html#attributs",
    "href": "slides/Modelisation_1.html#attributs",
    "title": "Modélisation I : Entité/Association",
    "section": "Attributs",
    "text": "Attributs\n\n\n\n\n\n\nDéfinition\n\n\nUn attribut est une fonction qui envoie une entité dans un domaine (ensemble de valeurs, type)\n\n\n\n\nDans world, l’attribut name envoie country vers l’ensemble des chaînes de caractères. Dans l’égalité name(Luxemburg) = \"Luxemburg\", à gauche Luxemburg désigne le pays, à droite, \"Luxemburg\" est une chaîne de caractères\nL’attribut population envoie country vers les entiers (positifs)\n\n\nDans les diagrammes EA, les attributs sont représentés par des ellipses. Le nom de l’attribut est placé au centre de l’ellipse\nUn arête relie l’ellipse attribut au rectangle entité."
  },
  {
    "objectID": "slides/Modelisation_1.html#attributs-notation-graphique",
    "href": "slides/Modelisation_1.html#attributs-notation-graphique",
    "title": "Modélisation I : Entité/Association",
    "section": "Attributs (notation graphique)",
    "text": "Attributs (notation graphique)\n\n\n\n\n\n\nER\n\n\n\ncountry\n\ncountry\n\n\n\ncity\n\ncity\n\n\n\nname1\n\nname\n\n\n\ncity--name1\n\n\n\n\nlanguage\n\nlanguage\n\n\n\nname2\n\nname\n\n\n\nlanguage--name2\n\n\n\n\nname0\n\nname\n\n\n\nname0--country\n\n\n\n\npopulation\n\npopulation\n\n\n\npopulation--country\n\n\n\n\ngovernmentForm\n\ngovernmentForm\n\n\n\ngovernmentForm--country\n\n\n\n\nheadOfState\n\nheadOfState\n\n\n\nheadOfState--country"
  },
  {
    "objectID": "slides/Modelisation_1.html#identifiant",
    "href": "slides/Modelisation_1.html#identifiant",
    "title": "Modélisation I : Entité/Association",
    "section": "Identifiant",
    "text": "Identifiant\n\n\n\n\n\n\nDéfinition\n\n\nPour une entité, un identifiant est un attribut qui envoie deux instances distinctes vers deux valeurs distinctes du domaine.\n\n\n\n\n\n\n\n\n\nAstuce\n\n\nUn identifiant est un attribut (une fonction) injectif(ve)\nDans un schéma EA, on choisit un attribut injectif et on le désigne comme identifiant en soulignant le nom de l’attribut.\n L’identifiant d’une entité n’est pas le nom de l’entité"
  },
  {
    "objectID": "slides/Modelisation_1.html#identifiant-exemple",
    "href": "slides/Modelisation_1.html#identifiant-exemple",
    "title": "Modélisation I : Entité/Association",
    "section": "Identifiant (exemple)",
    "text": "Identifiant (exemple)\nLa norme ISO-3166 associe à chaque pays un code en deux lettres (alpha-2). Pour le Luxemburg, il s’agit de LU\nLa norme ISO-3166 associe à chaque pays un code en trois lettres (alpha-3). Pour le Luxemburg, il s’agit de LUX\n\n\nNorme ISO 3166 selon Wikipedia"
  },
  {
    "objectID": "slides/Modelisation_1.html#identifiant-représentation",
    "href": "slides/Modelisation_1.html#identifiant-représentation",
    "title": "Modélisation I : Entité/Association",
    "section": "Identifiant (représentation)",
    "text": "Identifiant (représentation)\n\n\n\n\n\n\nER\n\n\n\ncountry\n\ncountry\n\n\n\niso\n\niso3\n\n\n\ncountry--iso\n\n\n\n\ncity\n\ncity\n\n\n\nname1\n\nname\n\n\n\ncity--name1\n\n\n\n\nlanguage\n\nlanguage\n\n\n\nname2\n\nname\n\n\n\nlanguage--name2\n\n\n\n\nname0\n\nname\n\n\n\nname0--country\n\n\n\n\npopulation\n\npopulation\n\n\n\npopulation--country\n\n\n\n\ngovernmentForm\n\ngovernmentForm\n\n\n\ngovernmentForm--country\n\n\n\n\nheadOfState\n\nheadOfState\n\n\n\nheadOfState--country\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nOn singularise les identifiants en les soulignant."
  },
  {
    "objectID": "slides/Modelisation_1.html#association-exemple",
    "href": "slides/Modelisation_1.html#association-exemple",
    "title": "Modélisation I : Entité/Association",
    "section": "Association (exemple)",
    "text": "Association (exemple)\nDans world, on peut définir une association is-in entre les entités city et country."
  },
  {
    "objectID": "slides/Modelisation_1.html#graphique",
    "href": "slides/Modelisation_1.html#graphique",
    "title": "Modélisation I : Entité/Association",
    "section": "Graphique",
    "text": "Graphique\n\n\n\n\n\n\nER\n\n\n\ncountry\n\ncountry\n\n\n\niso\n\niso3\n\n\n\ncountry--iso\n\n\n\n\ncity\n\ncity\n\n\n\nname1\n\nname\n\n\n\ncity--name1\n\n\n\n\nid\n\nid\n\n\n\ncity--id\n\n\n\n\nis-in\n\nis-in\n\n\n\ncity--is-in\n\n\n\n\nis-capital\n\nis-capital\n\n\n\ncity--is-capital\n\n\n\n\nlanguage\n\nlanguage\n\n\n\nname2\n\nname\n\n\n\nlanguage--name2\n\n\n\n\nisol\n\niso\n\n\n\nlanguage--isol\n\n\n\n\nis-spoken-in\n\nis-spoken-in\n\n\n\nlanguage--is-spoken-in\n\n\n\n\nname0\n\nname\n\n\n\nname0--country\n\n\n\n\npopulation\n\npopulation\n\n\n\npopulation--country\n\n\n\n\ngovernmentForm\n\ngovernmentForm\n\n\n\ngovernmentForm--country\n\n\n\n\nheadOfState\n\nheadOfState\n\n\n\nheadOfState--country\n\n\n\n\nis-in--country\n\n\n\n\nis-spoken-in--country\n\n\n\n\nis-capital--country"
  },
  {
    "objectID": "slides/Modelisation_1.html#remarques-suite",
    "href": "slides/Modelisation_1.html#remarques-suite",
    "title": "Modélisation I : Entité/Association",
    "section": "Remarques (suite)",
    "text": "Remarques (suite)\n\n\n\n\n\n\nNote\n\n\nUne association est représentée par un losange, elle est nommée.\nLe losange est relié aux dfférentes entités participantes par une arête\nLe nom d’une association reflète (en principe) la signification de cette association.\nLe nom d’une association renvoie souvent à un verbe, pas forcémment d’action\n\n\n\n\n\n\n\n\n\nAvertissement\n\n\nIl n’est pas toujours évident de lire sur le graphique le rôle joué par les différentes entités participantes dans une association. Bien nommer aide."
  },
  {
    "objectID": "slides/Modelisation_1.html#attributs-dassociation",
    "href": "slides/Modelisation_1.html#attributs-dassociation",
    "title": "Modélisation I : Entité/Association",
    "section": "Attributs d’association",
    "text": "Attributs d’association\nUne association peut posséder des attributs.\nGraphiquement, les attributs d’association sont représentés comme les attributs d’entité, par des ellipses. Les ellipses sont reliées au losange de l’association par une arête\n\nDans world, l’association is-spoken-in peut être munie d’un attribut official qui précise si une langue donnée est officielle dans un territoire donné."
  },
  {
    "objectID": "slides/Modelisation_1.html#partipations-multiples-à-une-association",
    "href": "slides/Modelisation_1.html#partipations-multiples-à-une-association",
    "title": "Modélisation I : Entité/Association",
    "section": "Partipations multiples à une association",
    "text": "Partipations multiples à une association\n Une même entité peut participer plusieurs fois à une même association\nOn distingue ces participations grâce à des rôles qui étiquettent les arêtes qui relient le rectangle entité au losange association."
  },
  {
    "objectID": "slides/Modelisation_1.html#exemples-de-rôle-dans-une-association-réflexive",
    "href": "slides/Modelisation_1.html#exemples-de-rôle-dans-une-association-réflexive",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemples de rôle dans une association réflexive",
    "text": "Exemples de rôle dans une association réflexive\nDans une base de donnée généalogique, on part d’une entité individu. On définit une auto-association mère qui relie l’entité individu avec elle-même.\n\nCette auto-association n’est pas symétrique: quand on écrit qu’Elizabeth est mère de Charles, Elisabeth et Charles ne jouent pas le même rôle.\n\n\nDans une instance \\((x,y)\\) de l’association mère \\(x\\) joue le rôle de la génitrice, \\(y\\) de l’enfant.\n\n\nOn peut rendre compte de ces rôles en marquant les arêtes qui lient l’entité individu à l’association mère (pour est-maman-de)"
  },
  {
    "objectID": "slides/Modelisation_1.html#une-association-darité-supérireure-à-2",
    "href": "slides/Modelisation_1.html#une-association-darité-supérireure-à-2",
    "title": "Modélisation I : Entité/Association",
    "section": "Une association d’arité supérireure à 2",
    "text": "Une association d’arité supérireure à 2\nPour construire un modèle des vols aériens (comme dans nycflights13), on définit des entités airline plane, airport et une association quaternaire flight\n\nL’association flight est quaternaire: une instance de flight associe un aéroport d’origine à un aéroport de destination (2 arêtes entre airport et flight), elle associe aussi une instance de plane et une instance de airline\n\n\nOn distingue les deux participations de airport à flight par des rôles"
  },
  {
    "objectID": "slides/Modelisation_1.html#principe-et-objet",
    "href": "slides/Modelisation_1.html#principe-et-objet",
    "title": "Modélisation I : Entité/Association",
    "section": "Principe et objet",
    "text": "Principe et objet\nDans une association entre plusieurs entités, les instances d’une entité peuvent participer a priori 0, 1, ou un nombre illimité de fois aux instances de l’association\nPour traduire les associations dans le langage des tables et des contraintes (LDD), il est très utile d’encadrer le plus précisément possible le nombre de participations d’une instance d’une entité aux instances d’une associations\nLes cardinalités sont des décorations sur les arêtes qui relient entités et associations"
  },
  {
    "objectID": "slides/Modelisation_1.html#cas-des-relations-binaires-2-entités",
    "href": "slides/Modelisation_1.html#cas-des-relations-binaires-2-entités",
    "title": "Modélisation I : Entité/Association",
    "section": "Cas des relations binaires (2 entités)",
    "text": "Cas des relations binaires (2 entités)"
  },
  {
    "objectID": "slides/Modelisation_1.html#exemples-11",
    "href": "slides/Modelisation_1.html#exemples-11",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemples 1:1",
    "text": "Exemples 1:1\nDans le modèle world,\n\nune instance de city apparaît 1 et 1 seule fois dans l’association is-in. On dira que is-in est de cardinalité 1:1 du côté de city. Une ville se situe sur le territoire d’un pays (et d’un seul)"
  },
  {
    "objectID": "slides/Modelisation_1.html#exemples-1n",
    "href": "slides/Modelisation_1.html#exemples-1n",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemples 1:n",
    "text": "Exemples 1:n\nDans le modèle world,\n\nune instance de country peut apparaître une nombre arbitraire de fois dans l’association ‘is-in’. On dira que is-in est de cardinalité 0:n du côté de city. Un territoire peut ne comporter aucune ville de population supérieure à un seuil. Il n’y a pas de borne a priori sur le nombre de grandes villes situées sur un territoire"
  },
  {
    "objectID": "slides/Modelisation_1.html#exemples-0n",
    "href": "slides/Modelisation_1.html#exemples-0n",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemples 0:n",
    "text": "Exemples 0:n\nDans le modèle world,\n\nune instance de language peut apparaître une nombre arbitraire de fois dans l’association is-spoken-in. On dira que is-spoken-in est de cardinalité 0:n du côté de language.\nune instance de country peut apparaître une nombre arbitraire de fois dans l’association ‘is-spoken-in’. On dira que is-spoken-in est de cardinalité 0:n du côté de country."
  },
  {
    "objectID": "slides/Modelisation_1.html#diagrammes",
    "href": "slides/Modelisation_1.html#diagrammes",
    "title": "Modélisation I : Entité/Association",
    "section": "Diagrammes",
    "text": "Diagrammes\nUne indication de cardinalité comporte une borne inférieure (0 ou 1) et une borne supérieure (1 ou \\(n\\))\nOn décore le lien entité-association avec l’indication de cardinalité"
  },
  {
    "objectID": "slides/Modelisation_1.html#représentation-graphique-des-cardinalités",
    "href": "slides/Modelisation_1.html#représentation-graphique-des-cardinalités",
    "title": "Modélisation I : Entité/Association",
    "section": "Représentation graphique des cardinalités",
    "text": "Représentation graphique des cardinalités\n\n\n\n\n\n\nER\n\n\n\ncountry\n\ncountry\n\n\n\niso\n\niso3\n\n\n\ncountry--iso\n\n\n\n\ncity\n\ncity\n\n\n\nname1\n\nname\n\n\n\ncity--name1\n\n\n\n\nid\n\nid\n\n\n\ncity--id\n\n\n\n\nis-in\n\nis-in\n\n\n\ncity--is-in\n\n1:1\n\n\n\nis-capital\n\nis-capital\n\n\n\ncity--is-capital\n\n0:1\n\n\n\nlanguage\n\nlanguage\n\n\n\nname2\n\nname\n\n\n\nlanguage--name2\n\n\n\n\nisol\n\niso\n\n\n\nlanguage--isol\n\n\n\n\nis-spoken-in\n\nis-spoken-in\n\n\n\nlanguage--is-spoken-in\n\n0:n\n\n\n\nname0\n\nname\n\n\n\nname0--country\n\n\n\n\npopulation\n\npopulation\n\n\n\npopulation--country\n\n\n\n\ngovernmentForm\n\ngovernmentForm\n\n\n\ngovernmentForm--country\n\n\n\n\nheadOfState\n\nheadOfState\n\n\n\nheadOfState--country\n\n\n\n\nis-in--country\n\n0:n\n\n\n\nis-spoken-in--country\n\n0:n\n\n\n\nis-capital--country\n\n0:1"
  },
  {
    "objectID": "slides/Modelisation_1.html#représentation-graphique-des-cardinalités-suite",
    "href": "slides/Modelisation_1.html#représentation-graphique-des-cardinalités-suite",
    "title": "Modélisation I : Entité/Association",
    "section": "Représentation graphique des cardinalités (suite)",
    "text": "Représentation graphique des cardinalités (suite)\nOn peut utilement préciser les cardinalités dans notre schéma des vols.\n\n\n\n\n\n\nER\n\n\n\nairport\n\nairport\n\n\n\nflight\n\nflight\n\n\n\nairport--flight\n\norig\n0:n\n\n\n\nplane\n\nplane\n\n\n\nairline\n\nairline\n\n\n\nflight--airport\n\ndest\n0:n\n\n\n\nflight--plane\n\n0:n\n\n\n\nflight--airline\n\n0:n"
  },
  {
    "objectID": "slides/Modelisation_1.html#définition-6",
    "href": "slides/Modelisation_1.html#définition-6",
    "title": "Modélisation I : Entité/Association",
    "section": "Définition",
    "text": "Définition\n\n\n\n\n\n\nNote\n\n\nUne entité faible \\(E\\) est définie relativement à une entité \\(A\\). C’est une collection d’objets apparentés (comme une entité), mais chaque instance de \\(E\\) est liée (est partie de) à une et une seule instance de \\(A\\)."
  },
  {
    "objectID": "slides/Modelisation_1.html#exemple",
    "href": "slides/Modelisation_1.html#exemple",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemple",
    "text": "Exemple\nDans world, on peut considérer que les instances de country sont des unités territoriales de niveau 0. Ces unités territoriales de niveau 1 sont parfois découpées en unités territoriales de niveau 1 : les régions en France, en Italie, les Länder en Allemagne, …\nChaque unité territoriale de niveau 1 est située dans une et une seule unité territoriale de niveau 0, elle fait partie de l’unité territoriale de niveau 0.\nUnités territoriales\n\nNous allons ajouter à notre modèle EA Géographie une entité faible appelée nut1 (pour Nouvelle Unité Territoriale de niveau 1)\nL’entité faible nut1 est liée à l’entité forte country par une association faible is-in."
  },
  {
    "objectID": "slides/Modelisation_1.html#diagrammes-pour-les-entités-faibles",
    "href": "slides/Modelisation_1.html#diagrammes-pour-les-entités-faibles",
    "title": "Modélisation I : Entité/Association",
    "section": "Diagrammes pour les entités faibles",
    "text": "Diagrammes pour les entités faibles\n\n\n\n\n\n\nER\n\n\n\ncountry\n\ncountry\n\n\n\niso\n\niso3\n\n\n\ncountry--iso\n\n\n\n\ncity\n\ncity\n\n\n\nname1\n\nname\n\n\n\ncity--name1\n\n\n\n\nid\n\nid\n\n\n\ncity--id\n\n\n\n\nis-in\n\nis-in\n\n\n\ncity--is-in\n\n1:1\n\n\n\nis-capital\n\nis-capital\n\n\n\ncity--is-capital\n\n0:1\n\n\n\nlanguage\n\nlanguage\n\n\n\nname2\n\nname\n\n\n\nlanguage--name2\n\n\n\n\nisol\n\niso\n\n\n\nlanguage--isol\n\n\n\n\nis-spoken-in\n\nis-spoken-in\n\n\n\nlanguage--is-spoken-in\n\n0:n\n\n\n\nname0\n\nname\n\n\n\nname0--country\n\n\n\n\npopulation\n\npopulation\n\n\n\npopulation--country\n\n\n\n\ngovernmentForm\n\ngovernmentForm\n\n\n\ngovernmentForm--country\n\n\n\n\nheadOfState\n\nheadOfState\n\n\n\nheadOfState--country\n\n\n\n\nis-in--country\n\n0:n\n\n\n\nis-spoken-in--country\n\n0:n\n\n\n\nis-capital--country\n\n0:1\n\n\n\nnut1\n\n\nnut1\n\n\n\nis-in2\n\n\nis-in\n\n\n\nnut1--is-in2\n\n1:1\n\n\n\nis-in2--country\n\n0:n"
  },
  {
    "objectID": "slides/Modelisation_1.html#identifiant-pour-les-entités-faibles",
    "href": "slides/Modelisation_1.html#identifiant-pour-les-entités-faibles",
    "title": "Modélisation I : Entité/Association",
    "section": "Identifiant pour les entités faibles",
    "text": "Identifiant pour les entités faibles\nPour identifier une instance d’une entité faible, on utilise l’identifiant de l’instance associée de l’entité faible et on le complète à l’aide d’un identifiant relatif.\n Deux instances distinctes d’une identité faible peuvent porter le même identifiant relatif (si elles sont parties de deux instances différentes de l’entité forte).\n\nNous ajoutons à notre modèle EA un identifiant relatif/faible id pour l’entité faible nut1\nPour identifier une instance de nut1, il faut disposer de son identifiant relatif id et de l’identifiant iso3 de l’instance associée dans l’entité forte.\nOn dit que l’association faible is-in est identifiante"
  },
  {
    "objectID": "slides/Modelisation_1.html#définition-7",
    "href": "slides/Modelisation_1.html#définition-7",
    "title": "Modélisation I : Entité/Association",
    "section": "Définition",
    "text": "Définition\n\n\n\n\n\n\nNote\n\n\nUne association qui relie une entité faible à une entité forte qui participe à l’identification des instances de l’entité faible est dite faible.\nLes instances de l’entité faible participentt à cette association faible avec une cardinalité 1:1\nLes instances de l’entité forte participent à l’association faible avec une cardinalitę 0:n"
  },
  {
    "objectID": "slides/Modelisation_1.html#exemple-1",
    "href": "slides/Modelisation_1.html#exemple-1",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemple",
    "text": "Exemple\nDans nycflights, si on représente les vols (flight) comme des entités faibles, les associations entre vols et aéroports (décolle de, atterrit à) sont des associations faibles, chaque instance de flight participe une fois exactement à chaque association faible."
  },
  {
    "objectID": "slides/Modelisation_1.html#association-darité-quelconque-en-associations-binaires",
    "href": "slides/Modelisation_1.html#association-darité-quelconque-en-associations-binaires",
    "title": "Modélisation I : Entité/Association",
    "section": "Association d’arité quelconque en associations binaires",
    "text": "Association d’arité quelconque en associations binaires\nOn définit une entité faible de même nom que l’association.\nPour chaque entité participant à l’association, on définit une association faible entre l’entité participante et la nouvelle entité faible.\nSi une entité participe plusieurs fois à l’association, on définit autant d’associations faibles qu’on nomme à l’aide des rôles\nL’entité faible participe aux associations faibles avec une cardinalité 1:1\nLes entités participantes sont reliées aux associations faibles avec les cardinalités de leur participation à l’associatoin \\(n\\)-aire."
  },
  {
    "objectID": "slides/Modelisation_1.html#transformation-du-diagramme-des-vols",
    "href": "slides/Modelisation_1.html#transformation-du-diagramme-des-vols",
    "title": "Modélisation I : Entité/Association",
    "section": "Transformation du diagramme des vols",
    "text": "Transformation du diagramme des vols\nOn définit donc\n\nune entité faible flight\nquatre associations faibles dest, orig, operates, uses\n\n\nLes quatre associations faibles sont identifiantes\nPour identifier une instance de l’entité faible flight, il faut disposer des identifiants des instances des entités fortes associées (une par entité forte, compte tenu des cardinalités)"
  },
  {
    "objectID": "slides/Modelisation_1.html#définition-8",
    "href": "slides/Modelisation_1.html#définition-8",
    "title": "Modélisation I : Entité/Association",
    "section": "Définition",
    "text": "Définition\n\n\n\n\n\n\nDéfinition\n\n\nUne association est-un entre une entité A et une entité B indique que toute instance (élément) de A est aussi instance (élément) de B (autrement dit en langage ensembliste que A ⊆ B)\nOn note graphiquement les associations est-un avec un symbole spécial : un triangle (A ◃ B)\n\n\n\n\n\n\n\n\n\n\nRemarques\n\n\n\nUne association est-un est binaire\nUne entité peut participer à plusieurs associations est-un\nSi A ◃ B on dit (souvent) que A est une spécialisation de B"
  },
  {
    "objectID": "slides/Modelisation_1.html#propriété",
    "href": "slides/Modelisation_1.html#propriété",
    "title": "Modélisation I : Entité/Association",
    "section": "Propriété",
    "text": "Propriété\nPour les associations est-un, il n’est pas nécessaire de préciser les cardinalités.\n\n\n\n\n\n\nCardinalités des associations est-un\n\n\n\n1:1 du côté de l’entité spécialisée\n0:1 du côté de l’entité générale\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nL’association est identifiante : une instance de l’entité spécialisée hérite de l’identifiant de l’entité générale"
  },
  {
    "objectID": "slides/Modelisation_1.html#exemple-2",
    "href": "slides/Modelisation_1.html#exemple-2",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemple",
    "text": "Exemple\nUn médecin peut exercer en mode libéral, au sein d’un cabinet, ou dans une clinique (ou les deux) ou exercer en milieu hospitalier.\nIl est aussi possible qu’un médecin partage son temps entre une activité hospitalière et une activité libérale.\nOn peut définir une entité générale médecin et deux entités spécialisées hospitalier et libéral. Les entités spécialisées sont reliées à l’entité générale par une association est-un.\n Une association est-un nous indique qu’une entité (un emsemble) est incluse dans une autre entité (un au ensemble)\nTout attribut (fonction) défini sur l’entité générale est défini sur les entités spécialisées\nCertains attributs peuvent être définis sur une entité spécialisée sans être définis sur toute l’entité générale\nPar exemple, on peut définir un attribut hôpital pour l’entité hospitalier, et un attribut cabinet pour l’entité libéral."
  },
  {
    "objectID": "slides/Modelisation_1.html#diagramme",
    "href": "slides/Modelisation_1.html#diagramme",
    "title": "Modélisation I : Entité/Association",
    "section": "Diagramme",
    "text": "Diagramme\n\n\n\n\n\n\nER\n\n\n\nmédecin\n\nmédecin\n\n\n\nmatricule\n\nmatricule\n\n\n\nmédecin--matricule\n\n\n\n\nhospitalier\n\nhospitalier\n\n\n\nis-a-1\n\nest-un\n\n\n\nhospitalier--is-a-1\n\n\n\n\nlibéral\n\nlibéral\n\n\n\nis-a-2\n\nest-un\n\n\n\nlibéral--is-a-2\n\n\n\n\nis-a-1--médecin\n\n\n\n\nis-a-2--médecin\n\n\n\n\nhôpital\n\nhôpital\n\n\n\nhôpital--hospitalier\n\n\n\n\ncabinet\n\ncabinet\n\n\n\ncabinet--libéral"
  },
  {
    "objectID": "slides/Modelisation_1.html#compléter-le-schéma",
    "href": "slides/Modelisation_1.html#compléter-le-schéma",
    "title": "Modélisation I : Entité/Association",
    "section": "Compléter le schéma",
    "text": "Compléter le schéma\nLe schéma/diagramme ne restitue pas toujours intégralement les informations récoltées pendant la phase de définition du système d’information\nLes contraintes de cardinalité ne sont pas les seules possibles\nLes autres contraintes rentrent dans la catégorie des contraintes dites externes (elles sont externes au diagramme)\nLes contraintes externes doivent être consignées et prises en compte ultérieurement lors de la traduction en modèle relationnel"
  },
  {
    "objectID": "slides/Modelisation_1.html#types-de-contraintes",
    "href": "slides/Modelisation_1.html#types-de-contraintes",
    "title": "Modélisation I : Entité/Association",
    "section": "Types de contraintes",
    "text": "Types de contraintes\n\nContraintes d’exclusion\n\nDans nycflights, deux instances de l’association flights portant sur le même aéronef ne devraient pas se chevaucher dans le temps\n\nContraintes de spécialisation\n\nContrainte de spécialisation disjointe : une instance appartient à au plus une spécialisation\nContrainte de spécialisation totale : une instance appartient à au moins une spécialisation\nContrainte de spécialisation disjointe et totale : une instance appartient à exactement une spécialisation"
  },
  {
    "objectID": "slides/Modelisation_1.html#restructuration-des-spécialisations",
    "href": "slides/Modelisation_1.html#restructuration-des-spécialisations",
    "title": "Modélisation I : Entité/Association",
    "section": "Restructuration des spécialisations",
    "text": "Restructuration des spécialisations\nPourquoi ?\n\nPlusieurs manières de procéder:\n\nÉliminer les entités mères (spécialisation totale avec peu d’attributs propres à l’entié mère)\n\nOU\n\nÉliminer les entités filles (entités filles ont peu d’attributs propres, participent à peu d’associations)\n\nOU\n\nSimuler la spécialisation avec une association faible (les entités filles sont vues comme des entités faibles)"
  },
  {
    "objectID": "slides/Modelisation_1.html#sites-et-livres",
    "href": "slides/Modelisation_1.html#sites-et-livres",
    "title": "Modélisation I : Entité/Association",
    "section": "Sites et Livres",
    "text": "Sites et Livres\n\nGarcia-Molina, H., Ullman, J. D., & Widom, J. (2002). Database systems-the complete book (International Ed.). Prenctice Hall, Upper Saddle River.\nChen, P. P. S. (1976). The entity-relationship model—toward a unified view of data. ACM transactions on database systems (TODS), 1(1), 9-36.\nSilberschatz, A., Korth, H. F., & Sudarshan, S. (2011). Database system concepts."
  },
  {
    "objectID": "slides/SQL_0.html#un-peu-de-formalisation",
    "href": "slides/SQL_0.html#un-peu-de-formalisation",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Un peu de formalisation",
    "text": "Un peu de formalisation\nRappel sur la notion de relation (au sens classique).\n\n\n\n\n\n\nDefinition : Domaine\n\n\nUn ensemble d’éléments.\n\n\n\n\nExemples : entiers \\(\\mathbb{Z}\\), flottants, chaines de caractères \\(\\mathcal{A}^*\\), date, …\nLes types d’un langage de programmation comme C, Java, …"
  },
  {
    "objectID": "slides/SQL_0.html#remarque",
    "href": "slides/SQL_0.html#remarque",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Remarque",
    "text": "Remarque\nUn domaine peut se définir :\n\nen extension (en donnant la liste de toutes les valeurs possibles) ou\nen intention (en donnant une propriété caractéristique)."
  },
  {
    "objectID": "slides/SQL_0.html#produit-cartésien",
    "href": "slides/SQL_0.html#produit-cartésien",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Produit cartésien",
    "text": "Produit cartésien\n\n\n\n\n\n\nDéfinition : Produit cartésien d’ensembles/domaines\n\n\nLe Produit cartésien d’une liste de domaines \\(D_1, D_2, \\dots, D_k\\), noté\n\\[D_1 \\times D_2 \\times \\dots \\times D_k\\]\nest l’ensemble\n\\[\\Bigl\\{(t_1,t_2,\\dots,t_k);\\ t_i\\in D_i \\text{ pour } i=1,\\dots,k\\Bigr\\}\\]\nUn élément \\(t=(t_1,t_2,\\dots,t_k)\\in D_1 \\times D_2 \\times \\dots \\times  D_k\\) est appelé \\(k\\)-uplet."
  },
  {
    "objectID": "slides/SQL_0.html#exemple",
    "href": "slides/SQL_0.html#exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Exemple",
    "text": "Exemple\n\n\nDeux domaines\n\\[D_1=\\left\\{1,2,5\\right\\} \\quad\\text{et}\\quad D_2=\\left\\{2,4\\right\\}\\]\nUn produit cartésien\n\\[D_1 \\times D_2 = \\left\\{(1,2),(1,4),(2,2),(2,4),(5,2),(5,4)\\right\\}\\]\nUne relation\n\\[R =\\left\\{(1,2),(1,4),(5,2),(5,4)\\right\\}\\]\nUne relation est un (sous-) ensemble (d’un produit cartésien)\n\nOn peut représenter \\(R\\) par le tableau :\n\n\n\n\\(X_1\\)\n\\(X_2\\)\n\n\n\n1\n2\n\n\n1\n4\n\n\n5\n2\n\n\n5\n4\n\n\n\n\nChaque ligne de la table correspond à un élément de la relation \\(R\\)"
  },
  {
    "objectID": "slides/SQL_0.html#relations-classiques",
    "href": "slides/SQL_0.html#relations-classiques",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Relations (classiques)",
    "text": "Relations (classiques)\nDans ce cours, toutes les relations ont un nombre fini d’éléments !\n\n\n\n\n\n\nDéfinition : Cardinalité de la relation \\(R\\): \\(|R|\\)\n\n\nOn appelle cardinalité d’une relation \\(R\\), notée \\(|R|\\), le nombre d’éléments de \\(R\\).\n\n\n\n\n\n\n\n\n\n\nDéfinition : Arité de la relation \\(R\\)\n\n\nSoit \\(R\\subset D_1\\times D_2\\times \\cdots \\times D_k\\), l’entier \\(k\\) est appelé arité de \\(R\\).\n\n\n\n\n\nOn parle parfois aussi de degré d’une relation.\n\n\nUne relation binaire est une relation d’arité \\(2\\)"
  },
  {
    "objectID": "slides/SQL_0.html#relations-et-schémas",
    "href": "slides/SQL_0.html#relations-et-schémas",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Relations et schémas",
    "text": "Relations et schémas\n\nUne relation (classique) peut se voir comme une table à deux dimensions :\n\nchaque ligne correspond alors à un \\(k\\)-uplet (si la relation est d’arité \\(k\\)),\nchaque élément d’une colonne est à valeur dans un domaine.\nUn domaine peut apparaître plusieurs fois dans la définition d’une relation."
  },
  {
    "objectID": "slides/SQL_0.html#schéma-dune-relation",
    "href": "slides/SQL_0.html#schéma-dune-relation",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Schéma d’une relation",
    "text": "Schéma d’une relation\n\n\n\n\n\n\nDéfinition : schéma\n\n\nLe Schéma d’une relation \\(R\\) est la donnée des attributs et domaines de la relation.\n\n\n\nLe schéma peut se noter\n\\[R(A_1\\! :\\! D_1,A_2\\! :\\! D_2,\\dots,A_k\\! :\\! D_k)\\]\noù \\(A_i\\) : attribut et \\(D_i\\) : domaine."
  },
  {
    "objectID": "slides/SQL_0.html#exemple-de-schéma-table-bebes-dans-babynames",
    "href": "slides/SQL_0.html#exemple-de-schéma-table-bebes-dans-babynames",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Exemple de schéma : table bebes dans babynames\n",
    "text": "Exemple de schéma : table bebes dans babynames\n\n\n\n\nbd_2023-24&gt; \\d bebes\n+--------+------------------------+-----------+\n| Column | Type                   | Modifiers |\n|--------+------------------------+-----------|\n| sexe   | integer                |           |\n| prenom | character varying(500) |           |\n| annee  | integer                |           |\n| nombre | integer                |           |\n+--------+------------------------+-----------+\nLa relation bebes a donc pour schéma : \\(\\left((\\textsf{sexe}, \\mathbb{Z}), (\\textsf{prenom}, \\texttt{string}), (\\texttt{annee}, \\mathbb{Z}), (\\texttt{nombre}, \\mathbb{Z})\\right)\\)\n\nDonnées INSEE. Une ligne de la table bebes nous informe qu’en France (héxagone?), pendant une annee, le nombre de naissances de sexe sexe, ayant reçu le prénom prenom est donnée par la colonne nombre.\nbd_2023-24&gt; SELECT * \nFROM bebes \nWHERE sexe=1 AND annee=2000 AND prenom='THÉO' ;\n\n+------+--------+-------+--------+\n| sexe | prenom | annee | nombre |\n|------+--------+-------+--------|\n| 1    | THÉO   | 2000  | 7961   |\n+------+--------+-------+--------+\nL’arité de bebes est \\(4\\), sa cardinalité est \\(648 614\\)."
  },
  {
    "objectID": "slides/SQL_0.html#particularité-de-la-définition-orientée-bdd-dune-relation",
    "href": "slides/SQL_0.html#particularité-de-la-définition-orientée-bdd-dune-relation",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Particularité de la définition orientée BDD d’une relation \n",
    "text": "Particularité de la définition orientée BDD d’une relation \n\nEn BD, l’ordre des colonnes n’a pas d’importance car on désigne chaque composante d’un \\(k\\)-uplet par son nom d’attribut et non par sa position/rang."
  },
  {
    "objectID": "slides/SQL_0.html#résumé-informel",
    "href": "slides/SQL_0.html#résumé-informel",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Résumé informel",
    "text": "Résumé informel\n\nRELATION ↔︎ TABLE À DEUX DIMENSIONS\n(NOM DE) COLONNE ↔︎ ATTRIBUT\nEN-TÊTE DU TABLEAU ↔︎ SCHEMA DE LA RELATION\nLIGNE ↔︎ TUPLE\nENSEMBLE DES LIGNES ↔︎ CONTENU DE LA RELATION"
  },
  {
    "objectID": "slides/SQL_0.html#langage-de-manipulation-de-données",
    "href": "slides/SQL_0.html#langage-de-manipulation-de-données",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Langage de manipulation de données",
    "text": "Langage de manipulation de données\nL’algèbre relationnelle est un système de calcul sur des tables.\nElle est formée d’une collection d’opérateurs qui prennent en argument des tables et retournent des tables.\n\n\n\n\n\n\nRemarque :\n\n\nLes opérateurs prennent en général des arguments supplémentaires qui ne sont pas des tables. La notion d’algèbre relationnelle est inspirée par les structures algébriques comme les groupes, les anneaux, les corps où des opérations internes opèrent sur un ensemble (par exemple \\((\\mathbb{R}, +, \\times)\\)), mais elle ne rentre pas exactement dans le cadre.\n\n\n\n\nL’algèbre n’est pas aussi expressive qu’un langage de programmation classique (comme Python). C’est cela qui rend ce modèle de calcul intéressant : il permet de faire des choses pas triviales, mais il est plus facile à utiliser qu’un langage de programmation."
  },
  {
    "objectID": "slides/SQL_0.html#opérateurs-de-base",
    "href": "slides/SQL_0.html#opérateurs-de-base",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Opérateurs de base",
    "text": "Opérateurs de base\n\n\n\n\n\n\nListe des opérateurs\n\n\nL’algèbre relationnelle est d’abord un Langage de Manipulation de Données (LMD).\n\nUnion: \\(\\Large{\\cup}\\)\nIntersection: \\(\\Large{\\cap}\\)\nDifférence: \\(\\Large{\\backslash}\\)\nProjection: \\(\\Large{\\Pi}\\)\nSélection: \\(\\Large{\\sigma}\\)\nProduit cartésien: \\(\\Large{\\times}\\)\nRenommage: \\(\\Large{\\rho}\\)\n\nCes opérateurs s’appliquent à des relations pour produire d’autres relations (le résultat)."
  },
  {
    "objectID": "slides/SQL_0.html#union-cup-et-intersection-cap",
    "href": "slides/SQL_0.html#union-cup-et-intersection-cap",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Union \\(\\cup\\) et intersection \\(\\cap\\)\n",
    "text": "Union \\(\\cup\\) et intersection \\(\\cap\\)\n\n\n\n\n\n\n\nDéfinition\n\n\n\nL’union et l’intersection sont des opérations portant sur deux relations \\(R_1\\) et \\(R_2\\) de même schéma,\n\\(T=R_1\\cup R_2\\) est constituée des tuples appartenant à \\(R_1\\) ou à \\(R_2\\),\n\\(T=R_1\\cap R_2\\) est constituée des tuples appartenant à \\(R_1\\) et à \\(R_2\\).\nLes schémas de \\(R_1\\cup R_2\\), \\(R_1\\cap R_2\\) sont les mêmes que ceux de \\(R_1\\) et \\(R_2\\)."
  },
  {
    "objectID": "slides/SQL_0.html#union-exemple",
    "href": "slides/SQL_0.html#union-exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Union : exemple",
    "text": "Union : exemple\n\n\n\n-- THEO_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n| 1    | THEOPHANE | 1900  | 3      |\n+------+-----------+-------+--------+\n\n-- THEO_2000\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEO      | 2000  | 6      |\n| 1    | THAO      | 2000  | 4      |\n| 1    | THÉO      | 2000  | 7961   |\n| 1    | THÉO-PAUL | 2000  | 3      |\n| 1    | THEODOR   | 2000  | 3      |\n| 1    | THEOPHANE | 2000  | 47     |\n| 1    | THEODORE  | 2000  | 149    |\n| 1    | THEOPHILE | 2000  | 336    |\n| 1    | THEOPHYLE | 2000  | 4      |\n| 1    | THEOS     | 2000  | 3      |\n| 1    | THEOTIM   | 2000  | 4       |\n| 1    | THEOTIME  | 2000  | 73     |\n+------+-----------+-------+--------+\n\nTHEO_1900 ∪ THEO_2000\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEODOR   | 2000  | 3      |\n| 1    | THAO      | 2000  | 4      |\n| 1    | THÉO      | 2000  | 7961   |\n| 1    | THÉO-PAUL | 2000  | 3      |\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEO      | 2000  | 6      |\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n| 1    | THEODORE  | 2000  | 149    |\n| 1    | THEOPHANE | 1900  | 3      |\n| 1    | THEOPHANE | 2000  | 47     |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEOTIME  | 2000  | 73     |\n| 1    | THEOPHILE | 2000  | 336    |\n| 1    | THEOPHYLE | 2000  | 4      |\n| 1    | THEOS     | 2000  | 3      |\n| 1    | THEOTIM   | 2000  | 4      |\n+------+-----------+-------+--------+"
  },
  {
    "objectID": "slides/SQL_0.html#intersection-exemple",
    "href": "slides/SQL_0.html#intersection-exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Intersection : exemple",
    "text": "Intersection : exemple\n\n\n-- THEO_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n| 1    | THEOPHANE | 1900  | 3      |\n+------+-----------+-------+--------+\n\n-- THEOD_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n+------+-----------+-------+--------+\n\nTHEO_1900 ∩ THEOD_1900\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n+------+-----------+-------+--------+\ncar THEOD_1900 ⊂ THEO_1900"
  },
  {
    "objectID": "slides/SQL_0.html#différence",
    "href": "slides/SQL_0.html#différence",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Différence",
    "text": "Différence\n\n\n\n\n\n\nDéfinition\n\n\n\nLa différence de deux relations \\(R_1\\) et \\(R_2\\) (de même schéma) est une relation \\(T\\),\nde même schéma que \\(R_1\\) et \\(R_2\\),\nconstituée des tuples appartenant à \\(R_1\\) et n’appartenant pas à \\(R_2\\).\nOn note \\(T = R_1 - R_2\\) ou \\(T = R_1 \\setminus R_2\\).\n\n\n\n\n\n\n\n\n\n\n\nOpération non commutative !\n\n\n\\(R_1 - R_2\\neq  R_2 - R_1\\) (en général)."
  },
  {
    "objectID": "slides/SQL_0.html#différence-exemple",
    "href": "slides/SQL_0.html#différence-exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Différence : exemple",
    "text": "Différence : exemple\n\n\n-- THEO_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n| 1    | THEOPHANE | 1900  | 3      |\n+------+-----------+-------+--------+\n\n-- THEOD_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n+------+-----------+-------+--------+\n\nTHEO_1900 ∖ THEOD_1900\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEOPHANE | 1900  | 3      |\n+------+-----------+-------+--------+"
  },
  {
    "objectID": "slides/SQL_0.html#produit-cartésien-1",
    "href": "slides/SQL_0.html#produit-cartésien-1",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Produit Cartésien",
    "text": "Produit Cartésien\n\n\n\n\n\n\nDéfinition\n\n\nSoient \\(R_1\\) et \\(R_2\\) dont les schémas \\(R_1(A_1,A_2,...,A_k)\\) et \\(R_2(B_1,B_2,...,B_\\ell)\\) n’ont pas d’attributs communs.\n\nDans le contexte “classique” : \\(R_1 \\times R_2= \\{(e_1,e_2): e_1\\in R_1, e_2\\in R_2\\}\\).\nDans le contexte BDD, \\(R_1 \\times R_2\\) contient tous les tuples formés par concaténation d’un tuple de \\(R_1\\) et d’un tuple de \\(R_2\\).\nLe schéma de \\(R=R_1 \\times R_2\\) est \\(R(A_1,A_2,...,A_k,B_1,B_2,...,B_\\ell)\\) obtenu par concaténation des schémas de \\(R_1\\) et \\(R_2\\).\n\n\nLa condition sur les schémas est indispensable pour que le schéma du résultat n’ait pas deux attributs identiques. On peut contourner ce problème avec un renommage (voir plus loin).\n\n\n\n\n\n\n\n\n\n\nAttention\n\n\nEn algèbre relationnelle, on ne tient pas compte de l’ordre des attributs dans le schéma d’une relation puisque que les attributs ont des noms deux à deux distincts. De ce fait, le produit cartésien est commutatif ( \\(R_1\\times R_2 = R_2\\times R_1\\) ce qui n’est pas vrai classiquement) et associatif."
  },
  {
    "objectID": "slides/SQL_0.html#produit-cartésien-2",
    "href": "slides/SQL_0.html#produit-cartésien-2",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Produit cartésien",
    "text": "Produit cartésien\n\n\n\n\n\n\nDéfinition formelle\n\n\n\\(R=R_1\\times R_2\\) est la relation de schéma \\(R(A_1,A_2,...,A_k,B_1,B_2,...,B_\\ell)\\) vérifiant :\n\nPour tout \\(t\\in R\\), il existe \\(t_1\\in R_1\\), \\(t_2\\in R_2\\) tels que :\n\n\\[t.A_1=t_1.A_1, \\ldots, t.A_k=t_1.A_k,\\quad t.B_1=t_2.B_1, \\ldots, t.B_\\ell=t_2.B_\\ell\\]\n\nRéciproquement, pour tout \\(t_1\\in R_1\\), \\(t_2\\in R_2\\) , il existe \\(t\\in R\\) tels que :\n\n\\[t.A_1=t_1.A_1, \\ldots, t.A_k=t_1.A_k,\\quad \\text{et}\\quad t.B_1=t_2.B_1, \\ldots, t.B_\\ell=t_2.B_\\ell\\quad \\text{et}\\]\n\\[$\\forall t_1 \\in R_1, \\forall t_2 \\in R_2, \\exists t \\in R, \\qquad  t.A_1=t_1.A_1, \\ldots, t.A_k=t_1.A_k,\\quad \\text{et} \\quad t.B_1=t_2.B_1, \\ldots, t.B_\\ell=t_2.B_\\ell \\qquad\\qquad\\qquad\\]"
  },
  {
    "objectID": "slides/SQL_0.html#projection-largepi",
    "href": "slides/SQL_0.html#projection-largepi",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Projection ( \\(\\Large{\\pi}\\) )",
    "text": "Projection ( \\(\\Large{\\pi}\\) )\n\n\n\n\n\n\nDéfinition\n\n\n\nLa projection d’une relation \\(R\\) de schéma \\(R(A_1,\\dots, A_k)\\) sur les attributs \\(A_{i_1}, \\dots, A_{i_p}\\), avec \\(i_1,..., i_p\\in \\{1,...,k\\}\\), est la relation \\(S\\)\n\nde schéma \\(S(A_{i_1}, \\dots,A_{i_p})\\)\n\ndont les tuples sont obtenus par élimination des attributs non mentionnés dans \\(A_{i_1}, \\dots, A_{i_p}\\) (et par élimination des doublons).\nOn note \\(S = \\pi_{A_{i_1}, \\dots, A_{i_p}} (R)\\).\n\n\nDéfinition formelle : \\(s\\in S\\quad  \\iff \\quad \\exists t\\in R, \\forall k\\in\\left\\{1,\\dots,p\\right\\}\\qquad s.A_{i_k}=t.A_{i_k}\\)\n\n\n\n\n\n\n\n\n\n\n\n\nRemarque\n\n\nImplicitement, on a élimination des doublons car une projection peut produire plusieurs fois le même tuple. Or une relation est un ensemble de tuples, et un ensemble ne peut pas contenir plusieurs fois le même élément."
  },
  {
    "objectID": "slides/SQL_0.html#projection-exemple",
    "href": "slides/SQL_0.html#projection-exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Projection : Exemple",
    "text": "Projection : Exemple\nPROJECTION(THEOD_1900, prenom, nombre)\n+-----------+---------+\n| prenom    |  nombre |\n|-----------+---------+\n| THEODORE  |  227    |\n| THEODOSE  |  3      |\n| THEODULE  |  39     |\n+-----------+---------+\nIci, aucune éliminitation de doublons n’a été nécessaire"
  },
  {
    "objectID": "slides/SQL_0.html#sélection-largesigma",
    "href": "slides/SQL_0.html#sélection-largesigma",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Sélection ( \\(\\Large{\\sigma}\\) )",
    "text": "Sélection ( \\(\\Large{\\sigma}\\) )\n\n\n\n\n\n\nDéfinition\n\n\n\n\nLa sélection d’une relation \\(R\\) par une condition \\(C\\) est une relation \\(S\\) :\n\nde même schéma que \\(R\\),\ndont les tuples sont ceux de \\(R\\) qui satisfont la condition \\(C\\).\nOn note \\(S = \\sigma_C (R)\\).\n\n\n\nLa condition \\(C\\) :\n\ns’exprime à l’aide des noms d’attributs de la relation et de constantes (pour les opérandes),\non peut utiliser des opérateurs arithmétiques de comparaison ( \\(=, \\neq, \\leq, \\geq, &lt;, &gt;\\) ) ainsi que des connecteurs logiques ( \\(\\lnot, \\land, \\lor\\) ).\n\n\n\n\n\n\n\n\n\n\n\n\n\nMise en garde\n\n\nOn peut utiliser le terme Restriction à la place de Sélection."
  },
  {
    "objectID": "slides/SQL_0.html#sélection-exemple",
    "href": "slides/SQL_0.html#sélection-exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Sélection : Exemple",
    "text": "Sélection : Exemple\nSELECTION(THEO_1900, ¬ prenom LIKE ‘THEOD%’)\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEOPHANE | 1900  | 3      |\n+------+-----------+-------+--------+"
  },
  {
    "objectID": "slides/SQL_0.html#renommage",
    "href": "slides/SQL_0.html#renommage",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Renommage",
    "text": "Renommage\n\n\n\n\n\n\nDéfinition\n\n\n\nSoit \\(R\\) de schéma \\(R(A_1,\\dots, A_k)\\), le renommage d’un attribut \\(A_i\\), \\(i\\leq k\\), en \\(B\\) est une relation \\(S\\) :\n\nde même contenu (mêmes lignes)\nde schéma \\(S(A_1,...,A_{i-1},B,A_{i+1},..., A_k)\\)\n\nOn le note \\(S=\\rho_{A_i\\mapsto B}(R)\\)"
  },
  {
    "objectID": "slides/SQL_0.html#renommage-exemple",
    "href": "slides/SQL_0.html#renommage-exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Renommage : Exemple",
    "text": "Renommage : Exemple\n-- THEOD_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n+------+-----------+-------+--------+\nρ(THEOD_1900, sexe→sex, prenom→name, annee→year, nombre→count)\n-- THEOD_1900\n\n+------+-----------+-------+--------+\n| sex  | name      | year  | count  |\n|------+-----------+-------+--------|\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n+------+-----------+-------+--------+\nUtilité : le renommage permet d’étendre certains opérateurs à des relations de schémas non-disjoints (c.a.d. ayant des noms d’attributs communs), par exemple le produit cartésien."
  },
  {
    "objectID": "slides/SQL_0.html#algèbre-relationnelle",
    "href": "slides/SQL_0.html#algèbre-relationnelle",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Algèbre relationnelle",
    "text": "Algèbre relationnelle\nPour interroger une BD, on compose les opérateurs :\n\nOpérations ensemblistes classiques : \\(\\cup\\), \\(\\cap\\), \\(\\setminus\\), \\(\\times\\).\nProjection : élimine des colonnes,\nSélection : élimine des lignes."
  },
  {
    "objectID": "slides/SQL_0.html#exemple-1",
    "href": "slides/SQL_0.html#exemple-1",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Exemple",
    "text": "Exemple\nπ(σ(THEO_1900, prenom LIKE ‘THEOD%’), prenom, nombre)\n\nρ(π(σ(THEO_1900, prenom LIKE ‘THEOD%’), prenom, nombre), prenom→name, nombre→count)"
  },
  {
    "objectID": "slides/SQL_0.html#de-la-composition-aux-tuyaux-pipelines",
    "href": "slides/SQL_0.html#de-la-composition-aux-tuyaux-pipelines",
    "title": "BD I: Algèbre Relationnelle",
    "section": "De la composition aux tuyaux (pipelines)",
    "text": "De la composition aux tuyaux (pipelines)\nOn peut rendre la composition de fonctions plus lisible (pour l’humain) en reprenant un mécanisme d’Unix : le pipe (tuyau) |&gt; (notation de )\nPlutôt qu’écrire \\(g(f(x,y), z, t)\\), on convient d’écrire f(x,y) |&gt; g(z, t) voire x |&gt; f(y) |&gt; g(z,t)\nEt pour rendre l’expression encore plus lisible on peut écrire\nx |&gt; \n  f(y) |&gt; \n  g(z,t)"
  },
  {
    "objectID": "slides/SQL_0.html#de-la-composition-aux-tuyaux-suite",
    "href": "slides/SQL_0.html#de-la-composition-aux-tuyaux-suite",
    "title": "BD I: Algèbre Relationnelle",
    "section": "De la composition aux tuyaux (suite)",
    "text": "De la composition aux tuyaux (suite)\nOn peut ainsi réécrire\nρ(π(σ(THEO_1900, prenom LIKE ‘THEOD%’), prenom, nombre), prenom→name, nombre→count)\nen\nTHEO_1900  |&gt;\n  σ(prenom LIKE 'THEOD%') |&gt;\n  π(prenom, nombre) |&gt;\n  ρ(prenom→name, nombre→count)\n\n\nDans le langage  (&gt; 4.x), le pipe s’écrit |&gt;"
  },
  {
    "objectID": "slides/SQL_0.html#les-jointures",
    "href": "slides/SQL_0.html#les-jointures",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Les jointures",
    "text": "Les jointures\nOn va définir des opérations pratiques pour la manipulation de données : les jointures\n\nJointure\nJointure naturelle\n\\(\\theta\\)-jointure et équi-jointure"
  },
  {
    "objectID": "slides/SQL_0.html#jointure",
    "href": "slides/SQL_0.html#jointure",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Jointure",
    "text": "Jointure\n\n\n\n\n\n\nDéfinition\n\n\nConsidérons deux relations \\(R_1\\) et \\(R_2\\) de schémas disjoints.\nLa jointure de \\(R_1\\) et \\(R_2\\) sous la condition \\(C\\) est la relation \\(T\\) :\n\nde schéma la concaténation des schémas de \\(R_1\\) et \\(R_2\\),\nformée des tuples du produit cartésien \\(R_1  \\times R_2\\) qui satisfont la condition \\(C\\),\non note \\(T=R_1\\bowtie_C R_2\\).\n\nRègles de formation de la condition de jointure : comme pour la sélection.\n\n\n\n\n\n\n\n\n\n\nDéfinition formelle\n\n\n\\[R_1 \\bowtie_C R_2 = \\sigma_C(R_1\\times R_2)\\]"
  },
  {
    "objectID": "slides/SQL_0.html#exemple-sur-le-schéma-world",
    "href": "slides/SQL_0.html#exemple-sur-le-schéma-world",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Exemple sur le schéma world\n",
    "text": "Exemple sur le schéma world\n\n\n\n\n\nLier les pays (les lignes de country) à leur capitale, c’est à dire les couples de lignes de country et de city qui satisfont capital = id"
  },
  {
    "objectID": "slides/SQL_0.html#exemple-sur-le-schéma-world-suite",
    "href": "slides/SQL_0.html#exemple-sur-le-schéma-world-suite",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Exemple sur le schéma world (suite)",
    "text": "Exemple sur le schéma world (suite)\nT =  JOINTURE(country, city, country.capital = city.id)\nS =  PROJECTION(T, name_country, name)\n\n+----------------------+------------------+\n| name_country         | name             |\n|----------------------+------------------|\n| Afghanistan          | Kabul            |\n| Netherlands          | Amsterdam        |\n| Netherlands Antilles | Willemstad       |\n| Albania              | Tirana           |\n| Algeria              | Alger            |\n...\n+----------------------+------------------+\n\n\nOn a affiché seulement les cinq premières lignes du résultat."
  },
  {
    "objectID": "slides/SQL_0.html#différentes-variétés-de-jointures",
    "href": "slides/SQL_0.html#différentes-variétés-de-jointures",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Différentes variétés de jointures",
    "text": "Différentes variétés de jointures\nAutour de la jointure ⋈(R, S, C) on a pris l’habitude de distinguer des types de jointure selon la forme de l’expression de jointure (la condition C)\nOn distingue\n\nles équi-jointures,\nles θ-jointures,\nles jointures naturelles.\n\n\n\n\n\n\n\nNote\n\n\nCes distinctions portent sur la condition C. Elles ne sont pas de même nature que les distinctions qui portent sur la manière dont le résultat final est calculé et qui définissent les jointures internes, externes (voir plus loin)."
  },
  {
    "objectID": "slides/SQL_0.html#équi-jointure",
    "href": "slides/SQL_0.html#équi-jointure",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Équi-jointure",
    "text": "Équi-jointure\n\n\n\n\n\n\nDéfinition\n\n\nJointure où la condition est une égalité entre des attributs de types comparables\n\n\n\n\nJOINTURE(country, city, country.capital = city.id)"
  },
  {
    "objectID": "slides/SQL_0.html#thetajointure",
    "href": "slides/SQL_0.html#thetajointure",
    "title": "BD I: Algèbre Relationnelle",
    "section": "\n\\(\\theta\\)–jointure",
    "text": "\\(\\theta\\)–jointure\n\n\n\n\n\n\nDéfinition\n\n\nCondition de jointure entre attributs de types comparables et comportant au moins un opérateur différent de l’égalité, c’est-à-dire dans \\(\\left\\{&lt;,&gt;,\\leq,\\geq, \\neq\\right\\}\\).\n\n\n\n\nJOINTURE(country, city, country.capital = city.id  ∧ city.population &gt; .5 * country.population_country)"
  },
  {
    "objectID": "slides/SQL_0.html#jointure-naturelle",
    "href": "slides/SQL_0.html#jointure-naturelle",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Jointure naturelle",
    "text": "Jointure naturelle\n\n\n\n\n\n\nDéfinition\n\n\nC’est une équi-jointure où la condition portent implicitement sur tous les attributs communs (de même nom) aux schémas des deux relations.\nDans le résultat, les attributs communs n’apparaissent qu’une seule fois  puisque la relation résultat ne peut pas avoir deux attributs de même nom.\nOn note cette opération : \\(R_1 \\bowtie R_2\\).\n\n\n\nOn peut écrire la jointure naturelle comme une équi-jointure sur tous les attributs communs suivie d’une projection pour éliminer les attributs doublons."
  },
  {
    "objectID": "slides/SQL_0.html#jointure-naturelle-formalisation",
    "href": "slides/SQL_0.html#jointure-naturelle-formalisation",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Jointure naturelle (formalisation)",
    "text": "Jointure naturelle (formalisation)\nConsidérons deux relations \\(R_1(A_1,..,A_k,B_1,...,B_h)\\) et \\(R_2(A_1,..,A_k,B_{h+1},...,B_\\ell)\\) de schémas non disjoints avec :\n\n\\(A_1,..., A_k\\) : attributs communs,\n\\(\\{B_1,...,B_h\\}\\cap \\{ B_{h+1},...,B_\\ell \\}=\\emptyset\\),\n\nSoit \\(A'_1, ...., A'_k\\) des noms tels que \\(\\{A_1,..., A_k\\}\\cap \\{ A'_1, ...., A'_k \\}=\\emptyset\\).\nConsidérons la relation \\(S(A_1',..,A_k',B_{h+1},...,B_l)\\) définie par : \\(\\quad S=\\rho_{A_1\\mapsto A_1'}(\\rho_{A_2\\mapsto A_2'}(\\cdots (\\rho_{A_k\\mapsto A_k'}(R_2)\\cdots ))\\)\nLa jointure naturelle sur les relations \\(R_1\\) et \\(R_2\\) est la relation \\(R\\)\n\nde schéma \\(R(A_1,..,A_k,B_1,...,B_h, B_{h+1},...,B_\\ell)\\)\ndéfinie par : \\(\\quad R = \\pi_{A_1,..,A_k,B_1,...,B_h, B_{h+1},...,B_\\ell}(R_1\\bowtie_{C} S)\\quad\\) où \\(C\\) est \\((A_1=A_1') \\wedge (A_2=A'_2) \\wedge \\ldots \\wedge (A_k=A_k')\\)\n\n\n\n En préfixant les noms des attributs par ceux de la relation, la condition \\(C\\) s’écrit alors : \\[(R_1.A_1=R_2.A_1) \\wedge \\ldots \\wedge (R_1.A_k=R_2.A_k)\\]"
  },
  {
    "objectID": "slides/SQL_0.html#exemple-de-jointure-naturelle",
    "href": "slides/SQL_0.html#exemple-de-jointure-naturelle",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Exemple de Jointure naturelle",
    "text": "Exemple de Jointure naturelle\nAfficher la liste des langues parlées en France (schéma world).\n\n\nbd_2023-24&gt; \\d countrylanguage\n+-------------+--------------+-----------+\n| Column      | Type         | Modifiers |\n|-------------+--------------+-----------|\n| countrycode | character(3) |  not null |\n| language    | text         |  not null |\n| isofficial  | boolean      |  not null |\n| percentage  | real         |  not null |\n+-------------+--------------+-----------+\nbd_2023-24&gt; \\d city\n+-------------+--------------+-----------+\n| Column      | Type         | Modifiers |\n|-------------+--------------+-----------|\n| id          | integer      |  not null |\n| name        | text         |  not null |\n| countrycode | character(3) |  not null |\n| district    | text         |  not null |\n| population  | integer      |  not null |\n+-------------+--------------+-----------+\n\nbd_2023-24&gt; \\d country\n+--------------------+---------------+-----------+\n| Column             | Type          | Modifiers |\n|--------------------+---------------+-----------|\n| countrycode        | character(3)  |  not null |\n| name_country       | text          |  not null |\n| continent          | text          |  not null |\n| region             | text          |  not null |\n| surfacearea        | real          |  not null |\n| indepyear          | smallint      |           |\n| population_country | integer       |  not null |\n| lifeexpectancy     | real          |           |\n| gnp                | numeric(10,2) |           |\n| gnpold             | numeric(10,2) |           |\n| localname          | text          |  not null |\n| governmentform     | text          |  not null |\n| headofstate        | text          |           |\n| capital            | integer       |           |\n| code2              | character(2)  |  not null |\n+--------------------+---------------+-----------+"
  },
  {
    "objectID": "slides/SQL_0.html#exemple-de-jointure-naturelle-suite",
    "href": "slides/SQL_0.html#exemple-de-jointure-naturelle-suite",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Exemple de Jointure naturelle (suite)",
    "text": "Exemple de Jointure naturelle (suite)\n\n\nT = JOINTURE(country, countrylanguage)\nS = SELECTION(T, name_country='France')\nR = PROJECTION(S, name_country, language)\n+--------------+------------+\n| name_country | language   |\n|--------------+------------|\n| France       | French     |\n| France       | Arabic     |\n| France       | Portuguese |\n| France       | Italian    |\n| France       | Spanish    |\n| France       | Turkish    |\n+--------------+------------+\n\n\n\n\n\n\n\nNote\n\n\nDu point de la complexité des opérations à faire par le serveur, il vaut mieux faire le plus en amont possible les sélections puis les projections et enfin les jointures qui sont plus coûteuses en temps de calcul.\n\n\n\nOn écrira donc plutôt :\nS = SELECTION(country, name_country='France')\nT = JOINTURE(S, countrylanguage)\nR = PROJECTION(T, name_country, language)"
  },
  {
    "objectID": "slides/SQL_0.html#exemples-de-requêtes",
    "href": "slides/SQL_0.html#exemples-de-requêtes",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Exemples de requêtes",
    "text": "Exemples de requêtes\n\nDéterminer les noms des capitales des pays situés en Asie.\n\n\nS =  SELECTION(country, continent='Asia')\nT =  JOINTURE(S, city, S.capital=city.id)\nR =  PROJECTION(T, name)\nLe début de R est\n+-------------+\n| name        |\n|-------------+\n| Kabul       |\n| Abu Dhabi   |\n| Yerevan     | \n| al-Manama   |"
  },
  {
    "objectID": "slides/SQL_0.html#exemples-de-requêtes-suite",
    "href": "slides/SQL_0.html#exemples-de-requêtes-suite",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Exemples de requêtes (suite)",
    "text": "Exemples de requêtes (suite)\n\nDéterminer les langues parlées dans les pays d’Asie.\n\n\nS = SELECTION(country, continent='Asia')\nT = JOINTURE(R1, countrylanguage)\nR = PROJECTION(R2, language)\nLe début de R est\n+-------------+\n| name        |\n|-------------+\n| Pashto      |\n| Arabic      |\n| Armenian    | \n| Azerbaijani |"
  },
  {
    "objectID": "slides/SQL_0.html#jointure-externe",
    "href": "slides/SQL_0.html#jointure-externe",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Jointure externe",
    "text": "Jointure externe\n\n\n\n\n\n\nPerte d’information dans les jointures internes\n\n\nDans les jointures que nous avons vues, les tuples du produit cartésien ne satisfaisant pas la condition C (non appariés) disparaissent.\nOn appelle ces jointures des jointures internes.\nOn définit aussi des jointures externes qui n’adoptent pas ce comportement.\n\n\n\n\n\n\n\n\n\n\nDéfinition\n\n\nLa jointure externe entre \\(R_1\\) et \\(R_2\\) est une jointure qui produit une relation R3 à laquelle on ajoute les tuples de R1 et de R2 exclus par la jointure, en complétant avec des valeurs nulles pour les attributs de l’autre relation.\nNotation : \\(R_1 {}^+\\!\\bowtie^+ R_2\\)."
  },
  {
    "objectID": "slides/SQL_0.html#jointure-externe-gauche",
    "href": "slides/SQL_0.html#jointure-externe-gauche",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Jointure externe gauche",
    "text": "Jointure externe gauche\n\n\n\n\n\n\nDéfinition\n\n\nLa jointure externe gauche entre R1 et R2 est une jointure externe pour laquelle on ajoute seulement les tuples de R1 (c’est à dire la relation de gauche) ayant été exclus.\nSynonyme : Jointure gauche\nNotation : \\(R_1 {}^+\\!\\bowtie R_2\\)\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n Le + est du côté où on ajoute les tupes manquants."
  },
  {
    "objectID": "slides/SQL_0.html#jointure-externe-droite",
    "href": "slides/SQL_0.html#jointure-externe-droite",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Jointure externe droite",
    "text": "Jointure externe droite\n\n\n\n\n\n\nDéfinition\n\n\nLa jointure externe droite entre R1 et R2 est une jointure externe pour laquelle on ajoute seulement les tuples de R2 (c’est à dire la relation de droite) ayant été exclus.\nSynonyme : Jointure droite\nNotation : \\(R_1 \\bowtie^+ R_2\\)\n\n\n\n\n\n\n\n\n\nNote\n\n\nUne jointure externe droite peut être réécrite par une jointure externe gauche (et réciproquement) en échangeant l’ordre de R1 et R2.\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nOn peut aussi utiliser une notation fonctionnelle et nommer ces jointures par des mots par exemple OUTER JOIN, LEFT JOIN, RIGHT JOIN."
  },
  {
    "objectID": "slides/SQL_0.html#jointure-externe-exemple",
    "href": "slides/SQL_0.html#jointure-externe-exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Jointure externe (exemple)",
    "text": "Jointure externe (exemple)\nOn veut une table formée par les codes ISO, les noms des pays et (si possible) les noms des capitales. Les territoires sans capitale doivent apparaître en fin de table, avec une colonne nom de capitale nulle.\n\nObtenir la première partie de la réponse avec une jointure est facile. Pour trouver les territoires sans capitale, il faudrait faire une sélection dans country sur le critère capital IS NULL puis une UNION des deux relations.\n\nAvec une jointure droite, on peut obtenir le résultat en une opération :\n\nS = RIGHT JOIN(city, country, city.id = country.capital) \nR = PROJECTION(S, countrycode, name_country, name)"
  },
  {
    "objectID": "slides/SQL_0.html#division",
    "href": "slides/SQL_0.html#division",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Division",
    "text": "Division\n\n\n\n\n\n\nDéfinition\n\n\nLa division ou quotient\n\nd’une relation \\(R\\) de schéma \\(R(A_1,A_2,\\dots,A_k)\\)\npar une relation \\(S\\) de schéma \\(S(A_{p+1},\\dots ,A_k)\\)\n\nest la relation \\(T\\) de schéma \\(T(A_1, \\dots, A_p)\\) formée des tuples qui, complétés par chaque tuple de \\(S\\), donnent un tuple de \\(R\\).\nAutrement dit\n\\[\\begin{array}{l} t\\in T(A_1,\\dots,A_p)  \\quad \\text{ si et seulement si } \\\\\n\\forall s\\in S(A_{p+1},\\dots ,A_k) \\quad \\exists r\\in R \\quad \\begin{cases}\nt.A_1=r.A_1, \\dots, t.A_p=r.A_p\\\\ s.A_{p+1}=r.A_{p+1},\\dots, s.A_{k}=r.A_{k} \\end{cases} \\end{array}\\]\nOn note : \\(\\quad T = R \\div S\\)"
  },
  {
    "objectID": "slides/SQL_0.html#division-exemple",
    "href": "slides/SQL_0.html#division-exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Division (exemple)",
    "text": "Division (exemple)\nLa division permet de répondre à des questions du type :\n“Donner tous les X qui ont toutes les valeurs existantes d’une propriété Y”.\nExemple : lister les langues parlées sur tous les continents.\n\nJ = JOINTURE(country, countrylanguage)\nCL =  PROJECTION(J, continent, language)\nC = PROJECTION(CL, continent)\n\nCL ÷ C\n\n\nAutre possibilité sans la division\nJ = JOINTURE(country, countrylanguage)\nCL =  PROJECTION(J, continent, language)\n\nC = PROJECTION(CL, continent)\nL = PROJECTION(CL, language)\n--- LPPTC Langues Pas Parlées dans Tous les Continents\nLPPTC = PROJECTION((C × L  ∖  CL ), language)\n\nR = L  ∖  LPPTC"
  },
  {
    "objectID": "slides/SQL_0.html#interdéfinissabilité-des-opérateurs",
    "href": "slides/SQL_0.html#interdéfinissabilité-des-opérateurs",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Interdéfinissabilité des opérateurs",
    "text": "Interdéfinissabilité des opérateurs\n\nL’union, la différence, le produit cartésien, la sélection et la projection et le renommage sont suffisants pour définir tous les opérateurs que l’on a vus.\nMais avoir un panier plus large d’opérateurs simplifie l’écriture des requêtes."
  },
  {
    "objectID": "slides/SQL_0.html#définitions-des-autres-opérateurs-à-partir-de-cet-ensemble-minimal",
    "href": "slides/SQL_0.html#définitions-des-autres-opérateurs-à-partir-de-cet-ensemble-minimal",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Définitions des autres opérateurs à partir de cet ensemble minimal",
    "text": "Définitions des autres opérateurs à partir de cet ensemble minimal\n\n\nPour la jointure : \\(R \\bowtie_C S = \\sigma_C (R \\times S)\\)\n\n\n\n\n\nPour l’intersection : \\(A \\cap B = A \\cup B - ((B - A) \\cup (A - B))\\)\n\n\n\n\n\nPour la division :\n\nsoient \\(R(A_1,A_2,\\dots,A_k)\\) et \\(S(A_{p+1},\\dots ,A_k)\\),\n\\(T= R ÷ S\\quad\\) a pour schéma \\(\\quad T(A_1, \\dots, A_p)\\) et\n\\[T = {\\Pi}(R, A) \\setminus {\\Pi}\\left(\\left(\\left({\\Pi}\\left(R, A\\right) × S\\right) \\setminus R\\right), A\\right)\\]\noù \\(A = (A_1, \\dots, A_p)\\)."
  },
  {
    "objectID": "slides/SQL_0.html#depuis-wikipedia",
    "href": "slides/SQL_0.html#depuis-wikipedia",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Depuis Wikipedia",
    "text": "Depuis Wikipedia\n\nIn the 1960s and 1970s he [Codd] worked out his theories of data arrangement, issuing his paper “A Relational Model of Data for Large Shared Data Banks” in 1970.[ To his disappointment, IBM proved slow to exploit his suggestions until commercial rivals started implementing them.\n\n\nInitially, IBM refused to implement the relational model to preserve revenue from IMS/DB. Codd then showed IBM customers the potential of the implementation of its model, and they in turn pressured IBM. Then IBM included in its Future Systems project a System R subproject – but put in charge of it developers who were not thoroughly familiar with Codd’s ideas, and isolated the team from Codd. As a result, they did not use Codd’s own Alpha language but created a non-relational one, SEQUEL. Even so, SEQUEL was so superior to pre-relational systems that it was copied, in 1979, based on pre-launch papers presented at conferences, by Larry Ellison, of Relational Software Inc, in his Oracle Database, which actually reached market before SQL/DS – because of the then-already proprietary status of the original name, SEQUEL had been renamed SQL.\n\n\nCodd continued to develop and extend his relational model, sometimes in collaboration with Christopher J. Date. One of the normalised forms, the Boyce–Codd normal form, is named after him.\n\n\nCodd’s theorem, a result proven in his seminal work on the relational model, equates the expressive power of relational algebra and relational calculus."
  },
  {
    "objectID": "slides/SQL_2.html#opérateurs-ensemblistes-propriétés-requises",
    "href": "slides/SQL_2.html#opérateurs-ensemblistes-propriétés-requises",
    "title": "BD II: SQL II",
    "section": "Opérateurs ensemblistes: propriétés requises",
    "text": "Opérateurs ensemblistes: propriétés requises\nLe résultat d’une requête SQL est un ensemble de tuples… donc une relation.\nLes opérateurs ensemblistes (\\(\\cap\\), \\(\\cup\\), \\(\\setminus\\)) permettent de combiner les résultats de deux requêtes (ou plus).\n\n\n\n\n\n\nImportant\n\n\nLes requêtes combinées doivent avoir des schémas compatibles :\n\nmême nombre de colonnes,\nmême type de données pour les colonnes de même position."
  },
  {
    "objectID": "slides/SQL_2.html#intersect-union-except",
    "href": "slides/SQL_2.html#intersect-union-except",
    "title": "BD II: SQL II",
    "section": "INTERSECT, UNION, EXCEPT",
    "text": "INTERSECT, UNION, EXCEPT\n\nINTERSECT : tuples de l’intersection des résultats des requêtes.\n&lt;requete1&gt; \nINTERSECT \n&lt;requete2&gt;\nUNION : tuples de l’union des résultats des requêtes.\n&lt;requete1&gt; \nUNION \n&lt;requete2&gt;\nEXCEPT : tuples de la différence ensembliste des résultats des requêtes\n&lt;requete1&gt; \nEXCEPT \n&lt;requete2&gt;\n\n\n\n\n\n\n\n\nNote\n\n\nUNION ne conserve pas les tuples doublons entre les deux requêtes.\nPour les conserver, il faut utiliser l’opérateur UNION ALL."
  },
  {
    "objectID": "slides/SQL_2.html#exemple-pour-except",
    "href": "slides/SQL_2.html#exemple-pour-except",
    "title": "BD II: SQL II",
    "section": "Exemple pour EXCEPT",
    "text": "Exemple pour EXCEPT\nConsidérons les tables de schémas suivants :\n`Fournisseur (NomF : varchar, VilleF : varchar, AdresseF : varchar)` \n\n`Piece(NomP : varchar, Prix : money, Couleur : varchar)`\n\n`Livraison(NumLiv : integer, NomP : varchar, NomF : varchar, DateLiv : date, Quantite : numeric)`\nFournisseurs qui ont livré la pièce x22 mais pas la pièce x21\n\nSELECT NomF \nFROM Livraison \nWHERE NomP='x22'\n\nEXCEPT \n\nSELECT NomF\nFROM Livraison \nWHERE NomP='x21';"
  },
  {
    "objectID": "slides/SQL_2.html#sous-requête-dans-la-clause-where",
    "href": "slides/SQL_2.html#sous-requête-dans-la-clause-where",
    "title": "BD II: SQL II",
    "section": "Sous-requête dans la clause WHERE",
    "text": "Sous-requête dans la clause WHERE\n\nDans la clause WHERE d’une requête, on peut utiliser une autre requête, appelée sous-requête ou requête imbriquée.\nLa sous-requête est exécutée pour chaque tuple formé par la clause FROM. Ce tuple sera sélectionné en fonction du test effectué sur le résultat de la sous-requête.\nDans une sous-requête, on peut se référer aux tables nommées dans la clause FROM de la requête de niveau supérieur."
  },
  {
    "objectID": "slides/SQL_2.html#opérateurs-de-sous-requête",
    "href": "slides/SQL_2.html#opérateurs-de-sous-requête",
    "title": "BD II: SQL II",
    "section": "Opérateurs de sous-requête",
    "text": "Opérateurs de sous-requête\n\nIN, EXISTS, ALL, ANY sont des fonctions (ou opérations) qui prennent en argument une sous-requête.\nElles effectuent des tests sur l’ensemble des résultats d’une sous-requête.\n\n\n\n\n\n\n\nMise en garde\n\n\nAttention au comportement de chaque opérateur si le résultat de la sous-requête est vide ou s’il contient la valeur NULL : il faut appliquer la logique trivalente à l’évaluation de l’opérateur."
  },
  {
    "objectID": "slides/SQL_2.html#opérateur-in",
    "href": "slides/SQL_2.html#opérateur-in",
    "title": "BD II: SQL II",
    "section": "Opérateur IN",
    "text": "Opérateur IN\nL’opérateur IN permet de tester si une valeur est présente dans le résultat d’une sous-requête.\n&lt;attribut&gt; [NOT] IN (&lt;sous-requete&gt;)\nEvaluée à vraie si &lt;attribut&gt; appartient au résultat de la sous-requête.\n\n\n\n\n\n\nMise en garde\n\n\nSi le résultat de la sous-requête est vide, IN renvoie faux, NOT IN renvoie vrai.\nSi &lt;attribut&gt; vaut NULL, IN et NOT IN renvoient UNKNOWN.\nL’évaluation de IN s’effectue par un OU entre des tests \\(=\\). Pour les valeurs NULL du résultat de la sous-requête, le test d’égalité retourne UNKNOWN. Donc si &lt;attribut&gt; est présent dans le résultat, IN retourne True sinon UNKNOWN.\nL’évaluation de NOTIN s’effectue par un ET entre des tests \\(\\neq\\). Donc si le résultat de la sous-requête contient au moins une valeur NULL, NOT IN retourne UNKNOWN."
  },
  {
    "objectID": "slides/SQL_2.html#exemple-1-de-sous-requête-avec-in",
    "href": "slides/SQL_2.html#exemple-1-de-sous-requête-avec-in",
    "title": "BD II: SQL II",
    "section": "Exemple 1 de sous-requête avec IN",
    "text": "Exemple 1 de sous-requête avec IN\nLister les villes de fournisseurs qui ont livré la pièce ‘x21’.\n\n\n\nSELECT DISTINCT VilleF \n\nFROM Fournisseur \n\nWHERE NomF IN ( \n  SELECT NomF  \n  FROM Livraison \n  WHERE NomP = 'x21'\n) ;  \n\nest équivalente à :\nSELECT DISTINCT F.VilleF \n\nFROM Fournisseur F, Livraison L \n\nWHERE (F.NomF = L.NomF) AND \n  (L.NomP = 'x21');"
  },
  {
    "objectID": "slides/SQL_2.html#exemple-2-de-sous-requête-avec-in",
    "href": "slides/SQL_2.html#exemple-2-de-sous-requête-avec-in",
    "title": "BD II: SQL II",
    "section": "Exemple 2 de sous-requête avec IN",
    "text": "Exemple 2 de sous-requête avec IN\n\n\n\n\n\n\n\nNote\n\n\nPratique à utiliser sous la forme NOT IN pour coder l’opération de différence.\n\n\n\nLister les noms de pièces pour lesquelles il n’y a jamais eu de livraison.\n\nSELECT NomP\nFROM Piece P \nWHERE NomP NOT IN  (\n  SELECT NomP\n  FROM  Livraison\n);\n\n\nEquivalence en algèbre relationnelle :\n\\[\\pi_{\\text{NomP}}(\\text{Piece}) - \\pi_{\\text{NomP}}(\\text{Livraison})\\]"
  },
  {
    "objectID": "slides/SQL_2.html#exemple-3-de-sous-requête-avec-in",
    "href": "slides/SQL_2.html#exemple-3-de-sous-requête-avec-in",
    "title": "BD II: SQL II",
    "section": "Exemple 3 de sous-requête avec IN",
    "text": "Exemple 3 de sous-requête avec IN\nLes capitales dont la population est plus grande que la moitié de la population du pays.\n\nSELECT name FROM city\nWHERE id IN (\n  SELECT capital \n  FROM country\n  WHERE population&gt;=population_country*.5\n);\n\n\nest équivalente à :\nSELECT name \nFROM country JOIN city \n  ON capital=id\nWHERE population&gt;=population_country*.5;"
  },
  {
    "objectID": "slides/SQL_2.html#opérateur-all-et-any-any-all",
    "href": "slides/SQL_2.html#opérateur-all-et-any-any-all",
    "title": "BD II: SQL II",
    "section": "Opérateur ALL et ANY : ANY, ALL",
    "text": "Opérateur ALL et ANY : ANY, ALL\nCe sont des quantificateurs qui s’utilisent dans des tests.\n\nANY : évalué à vrai si au moins un résultat de la sous-requête vérifie le test.\n\n&lt;attributs&gt; =|&lt;&gt;|&lt;=|&lt;|&gt;|=&gt; ANY (&lt;sous-requete&gt;)\n\n\nALL : évalué à vraie si tous les résultats de la sous-requête vérifient le test.\n\n&lt;attributs&gt; =|&lt;&gt;|&lt;=|&lt;|&gt;|=&gt; ALL (&lt;sous-requete&gt;)\n\n\n\n\n\n\n\n\nNote\n\n\n&lt;attributs&gt;: peut être une liste d’attributs"
  },
  {
    "objectID": "slides/SQL_2.html#exemple-de-sous-requête-avec-any",
    "href": "slides/SQL_2.html#exemple-de-sous-requête-avec-any",
    "title": "BD II: SQL II",
    "section": "Exemple de sous-requête avec ANY",
    "text": "Exemple de sous-requête avec ANY\nAlternative au IN.\nLister les noms de fournisseurs qui ont livré la pièce ‘x21’.\nSELECT NomF\nFROM Fournisseur\nWHERE NomF = ANY (\n    SELECT NomF\n    FROM Livraison\n    WHERE NomP = 'x21' \n);\n\n\n\n\n\n\nMise en garde\n\n\nSi le résultat de la sous-requête est vide, ANY renvoie False.\nSi l’attribut NomF vaut NULL, le résultat de la comparaison avec ANY est UNKNOWN.\nL’évaluation de ANY s’effectue par un OU entre des tests =|&lt;&gt;|&lt;=|&lt;|&gt;|=&gt;. Pour les valeurs NULL du résultat de la sous-requête, le test retourne UNKNOWN. Donc si le test est vrai pour un tuple du résultat, ANY retourne True sinon UNKNOWN."
  },
  {
    "objectID": "slides/SQL_2.html#exemple-1-de-sous-requête-avec-all",
    "href": "slides/SQL_2.html#exemple-1-de-sous-requête-avec-all",
    "title": "BD II: SQL II",
    "section": "Exemple 1 de sous-requête avec ALL",
    "text": "Exemple 1 de sous-requête avec ALL\nLa ville la plus peuplée de chaque pays.\nSELECT c1.name \nFROM city as c1\nWHERE population &gt;= ALL (\n  SELECT c2.population \n  FROM city as c2\n  WHERE c1.countrycode=c2.countrycode\n);\n\n\n\n\n\n\nMise en garde\n\n\nSi le résultat de la sous-requête est vide, ALL renvoie True.\nSi l’attribut population vaut NULL, le résultat de la comparaison avec ALL est UNKNOWN.\nL’évaluation de ALL s’effectue par un ET entre des tests =|&lt;&gt;|&lt;=|&lt;|&gt;|=&gt;. Pour les valeurs NULL du résultat de la sous-requête, le test retourne UNKNOWN. Donc si le résultat de la sous-requête contient au moins une valeur NULL, ALL retourne UNKNOWN."
  },
  {
    "objectID": "slides/SQL_2.html#exemple-2-de-sous-requête-avec-all",
    "href": "slides/SQL_2.html#exemple-2-de-sous-requête-avec-all",
    "title": "BD II: SQL II",
    "section": "Exemple 2 de sous-requête avec ALL",
    "text": "Exemple 2 de sous-requête avec ALL\nLes pays dont toutes les villes ont plus de 1 000 000 habitants.\nLa requête :\nSELECT co.name_country\nFROM country co\nWHERE 1000000 &lt;= ALL (\n  SELECT ci.population \n  FROM city ci\n  WHERE ci.countrycode=co.countrycode\n)\nrenvoie également les pays qui n’ont pas de ville !\nOn peut corriger en ajoutant un opérateur EXISTS sur la sous-requête.\nMais la meilleure solution est d’utiliser les fonctions d’agrégation que nous verrons plus tard."
  },
  {
    "objectID": "slides/SQL_2.html#opérateur-exists",
    "href": "slides/SQL_2.html#opérateur-exists",
    "title": "BD II: SQL II",
    "section": "Opérateur EXISTS",
    "text": "Opérateur EXISTS\nC’est un quantificateur qui retourne un booléen.\nEXISTS retourne vrai si le résultat de la sous-requête n’est pas vide.\n[NOT] EXISTS (&lt;sous-requete&gt;)\n\n\n\n\n\n\nMise en garde\n\n\nSi le résultat de la sous-requête ne contient que la valeur NULL, EXISTS renvoie vrai car le résultat de la sous-requête contient au moins un tuple."
  },
  {
    "objectID": "slides/SQL_2.html#exemple-1-de-sous-requête-avec-exists",
    "href": "slides/SQL_2.html#exemple-1-de-sous-requête-avec-exists",
    "title": "BD II: SQL II",
    "section": "Exemple 1 de sous-requête avec EXISTS",
    "text": "Exemple 1 de sous-requête avec EXISTS\nPays qui n’ont pas de ville\nSELECT co.name_country\nFROM country co\nWHERE NOT EXISTS(\n  SELECT * \n  FROM city ci\n  WHERE ci.countrycode=co.countrycode\n);\néquivalent à\nSELECT name_country\nFROM country\nEXCEPT\nSELECT name_country\nFROM country natural join city;\n\n\n\n\n\n\nNote\n\n\nNOT EXISTS permet souvent d’écrire une alternative à EXCEPT."
  },
  {
    "objectID": "slides/SQL_2.html#exemple-2-de-sous-requête-avec-exists",
    "href": "slides/SQL_2.html#exemple-2-de-sous-requête-avec-exists",
    "title": "BD II: SQL II",
    "section": "Exemple 2 de sous-requête avec EXISTS",
    "text": "Exemple 2 de sous-requête avec EXISTS\nNom des Fournisseurs ayant livré la pièce x21 mais qui n’ont jamais livré la pièce a22.\nSELECT DISTINCT NomF \nFROM Livraison L1 \nWHERE L1.NomP='x21' AND \n  NOT EXISTS (\n    SELECT * \n    FROM Livraison L2 \n    WHERE L2.NomP='a22' AND L2.NomF=L1.NomF\n  );"
  },
  {
    "objectID": "slides/SQL_2.html#exemple-3-de-sous-requête-avec-exists",
    "href": "slides/SQL_2.html#exemple-3-de-sous-requête-avec-exists",
    "title": "BD II: SQL II",
    "section": "Exemple 3 de sous-requête avec EXISTS",
    "text": "Exemple 3 de sous-requête avec EXISTS\nLes régions qui ont au moins une langue officielle :\nSELECT DISTINCT region \nFROM country AS co\nWHERE EXISTS (\n  SELECT * \n  FROM countrylanguage AS cl\n  WHERE co.countrycode = cl.countrycode  AND cl.isofficial\n);\néquivalent à\nSELECT DISTINCT region \nFROM country AS co join world.countrylanguage as cl \non co.countrycode = cl.countrycode and cl.isofficial;"
  },
  {
    "objectID": "slides/SQL_2.html#sous-requête-scalaire",
    "href": "slides/SQL_2.html#sous-requête-scalaire",
    "title": "BD II: SQL II",
    "section": "Sous-requête scalaire",
    "text": "Sous-requête scalaire\n\nRenvoie un tuple unique avec une colonne unique (un scalaire).\nLe plus souvent écrite avec une fonction d’agrégation (SUM, AVG, COUNT, MAX, MIN, …) que nous étudierons dans la suite du cours.\nUtilisation possible dans une clause WHERE.\n\nExemple : lister les noms de pays dont la densité est inférieure à la densité mondiale.\n\nSELECT name_country , population_country / surfacearea as population_density\nFROM country\nWHERE population_country / surfacearea &lt;= (\n  SELECT sum(population_country) / sum(surfacearea)\n  FROM country\n)\norder by name_country;\n\n\n\n\n\n\nNote\n\n\nNe pas confondre la densité mondiale moyenne (environ \\(40\\ \\text{h/km}^2\\) d’après la BDD world, en fait \\(55\\ \\text{h/km}^2\\) en 2025) avec la densité moyenne des pays (environ \\(400\\ \\text{h/km}^2\\))."
  },
  {
    "objectID": "slides/SQL_2.html#tables-dérivés",
    "href": "slides/SQL_2.html#tables-dérivés",
    "title": "BD II: SQL II",
    "section": "Tables dérivés",
    "text": "Tables dérivés\nDans une clause FROM, on peut écrire une sous-requête qui renvoie une table nommée avec un alias : on parle de table dérivée, dans le sens qu’elle dérive des tables existantes.\n\n\n\n\n\n\nNote\n\n\nIl s’agit d’une composition de requêtes."
  },
  {
    "objectID": "slides/SQL_2.html#exemple-de-sous-requête-dans-la-clause-from",
    "href": "slides/SQL_2.html#exemple-de-sous-requête-dans-la-clause-from",
    "title": "BD II: SQL II",
    "section": "Exemple de sous-requête dans la clause FROM",
    "text": "Exemple de sous-requête dans la clause FROM\nLister les pays (code, nom, espérance de vie) dont le PNB a progressé de 10% et dont la population de la capitale est supérieure à 2 millions.\nSELECT bo.countrycode, name_country, lifeexpectancy\nFROM \n  (\n    SELECT countrycode, name_country, lifeexpectancy, capital\n    FROM country\n    WHERE gnpold &gt;0 AND gnp / gnpold &gt; 1.1  -- test gnpold &gt;0 pour gérer les valeurs nulles\n  ) AS bo \n  JOIN \n  (\n    SELECT id, countrycode\n    FROM city \n    WHERE population &gt; 2000000\n  ) AS bc  \n  ON bc.id=bo.capital ;"
  },
  {
    "objectID": "slides/SQL_2.html#opérateur-lateral",
    "href": "slides/SQL_2.html#opérateur-lateral",
    "title": "BD II: SQL II",
    "section": "Opérateur LATERAL",
    "text": "Opérateur LATERAL\n\n\n\n\n\n\nNote\n\n\nDans l’exemple précédent, chaque table dérivée est calculée indépendemment puis la jointure est effectuée.\n\n\n\nAvec l’opérateur LATERAL, on peut faire dépendre le calcul d’une table dérivée du résultat des tables précédentes du FROM."
  },
  {
    "objectID": "slides/SQL_2.html#evaluation-de-lateral",
    "href": "slides/SQL_2.html#evaluation-de-lateral",
    "title": "BD II: SQL II",
    "section": "Evaluation de LATERAL",
    "text": "Evaluation de LATERAL\nLa table dérivée est calculée pour chaque tuple \\(u\\) obtenu par les opérations précédentes du FROM.\nPuis chaque tuple \\(v\\) la table dérivée est concaténé à \\(u\\) par produit cartésien.\nOn peut aussi concaténer \\(u\\) et \\(v\\) avec une jointure."
  },
  {
    "objectID": "slides/SQL_2.html#exemple-1-avec-lateral",
    "href": "slides/SQL_2.html#exemple-1-avec-lateral",
    "title": "BD II: SQL II",
    "section": "Exemple 1 avec LATERAL",
    "text": "Exemple 1 avec LATERAL\nPour chaque pays, donner la liste des villes de son térritoire.\nSolution avec LATERAL\nSELECT co.name_country, sr.name \nFROM country co, LATERAL (  \n  SELECT name       \n  FROM city  ci            \n  WHERE ci.countrycode=co.countrycode\n) sr;\néquivalent à\n\n\nAvec jointure sur une table dérivée\nSELECT co.name_country, sr.name \nFROM country co NATURAL JOIN (  \n  SELECT countrycode, name       \n  FROM city\n) sr  \n\nou bien sans table dérivée\nSELECT name_country, name \nFROM country co JOIN city ci ON ci.countrycode=co.countrycode\nORDER BY name_country;"
  },
  {
    "objectID": "slides/SQL_2.html#exemple-2-avec-lateral",
    "href": "slides/SQL_2.html#exemple-2-avec-lateral",
    "title": "BD II: SQL II",
    "section": "Exemple 2 avec LATERAL",
    "text": "Exemple 2 avec LATERAL\nPlus intéressant : pour chaque pays, donner la ville la plus peuplée.\nSELECT co.name_country, sr.name \nFROM country co, LATERAL (  \n  SELECT name       \n  FROM city ci            \n  WHERE ci.countrycode=co.countrycode\n  ORDER BY ci.population DESC\n  LIMIT 1\n) sr\nORDER BY co.name_country;\nEvaluation : si la table dérivée est vide, le tuple \\(u\\) de la table country n’est pas retenu car \\(\\lbrace u\\rbrace \\times \\emptyset = \\emptyset\\).\nDonc les pays sans ville ne sont pas affichés."
  },
  {
    "objectID": "slides/SQL_2.html#clause-with",
    "href": "slides/SQL_2.html#clause-with",
    "title": "BD II: SQL II",
    "section": "Clause WITH",
    "text": "Clause WITH\nUne clause WITH permet d’écrire des requêtes intermédiaires et d’alléger l’écriture d’une requête complexe.\nWITH r AS (\n  SELECT ...\n  FROM ...\n  WHERE ...\n), s AS (\n  SELECT ...\n  FROM ...\n  WHERE ...    -- références possibles à r \n)\nSELECT ...\nFROM   ...     -- références possibles à r \nWHERE ...\n\n\n\n\n\n\nNote\n\n\nCes expressions/requêtes sont appelées Common Table Expressions ou CTEs ou ETCs en français.\nLes CTEs peuvent être des requêtes SELECT, mais aussi des expressions de manipulation (mise à jour, insertion, suppression) de données.\nLes CTEs permettent de coller plus fidèlement à l’algèbre relationnelle que les requêtes imbriquées."
  },
  {
    "objectID": "slides/SQL_2.html#avantages-des-ctes",
    "href": "slides/SQL_2.html#avantages-des-ctes",
    "title": "BD II: SQL II",
    "section": "Avantages des CTEs",
    "text": "Avantages des CTEs\n\n\n\n\n\n\nNote\n\n\nLes CTEs permettent de composer des requêtes de même que les requêtes imbriquées dans les clauses WHERE et FROM.\nPar rapport à ces deux autres techniques, les avantages sont :\n\namélioration de la lisibilité et de la maintenance des requêtes complexes.\nune ETC peut être utilisée plusieurs fois dans une même requête."
  },
  {
    "objectID": "slides/SQL_2.html#exemple-de-requête-avec-with",
    "href": "slides/SQL_2.html#exemple-de-requête-avec-with",
    "title": "BD II: SQL II",
    "section": "Exemple de requête avec WITH",
    "text": "Exemple de requête avec WITH\nLister les pays (code, nom, espérance de vie) dont le PNB a progressé de 10% et dont la population de la capitale est supérieure à 2 millions.\nWITH better_off AS (\n  SELECT countrycode, name_country, lifeexpectancy, capital\n  FROM country\n  WHERE gnpold &gt;0 AND gnp / gnpold &gt; 1.1  -- gnpold &gt;0 pour gérer les valeurs nulles\n),\nbig_capital AS (\n  SELECT id, countrycode\n  FROM city \n  WHERE population &gt; 2000000\n)\nSELECT bo.countrycode, name_country, lifeexpectancy\nFROM better_off bo JOIN big_capital bc ON\n  bc.id=bo.capital ;"
  },
  {
    "objectID": "slides/SQL_4.html#pourquoi",
    "href": "slides/SQL_4.html#pourquoi",
    "title": "Fonctions SQL et Vues",
    "section": "Pourquoi ?",
    "text": "Pourquoi ?\nLorsqu’une collection de requêtes de même forme est utilisée sur une base de données, il est pertinent de préparer ces requêtes\nLes objectifs de cette préparation sont divers:\n\néviter de coder de façon répétitive\npermettre une planification en amont des requêtes\néviter de recalculer des jointures coûteuses\n…\n\n\n\nOn cherche à suivre le principe DRY (Don’t Repeat Yourself) plutôt que la routine WET (Write Everything Twice ou We Enjoy Typing)"
  },
  {
    "objectID": "slides/SQL_4.html#comment",
    "href": "slides/SQL_4.html#comment",
    "title": "Fonctions SQL et Vues",
    "section": "Comment ?",
    "text": "Comment ?\nLes SGBD relationnels offrent une gamme d’outils pour combler ces besoins\n\nLes PREPARED STATEMENT\nLes fonctions\nLes vues"
  },
  {
    "objectID": "slides/SQL_4.html#syntaxe-générale-des-fonctions",
    "href": "slides/SQL_4.html#syntaxe-générale-des-fonctions",
    "title": "Fonctions SQL et Vues",
    "section": "Syntaxe générale des fonctions",
    "text": "Syntaxe générale des fonctions\nCREATE OR REPLACE FUNCTION \n  func_name(arg1 arg1_datatype DEFAULT arg1_default)\n\nRETURNS some type | set of some type | TABLE (..) AS\n$$\n\nBODY of function\n\n$$\nLANGUAGE language_of_function\n\n\nlangage_of_function peut prendre différentes valeurs :\n\n\nSQL (Trusted)\n\nPL/pgSQL (Trusted)\nC\n\nPL/Python (Untrusted)\n…\n\n\nSELECT lanname \nFROM pg_language;\nlanname |\n--------+\ninternal|\nc       |\nsql     |\nplpgsql |"
  },
  {
    "objectID": "slides/SQL_4.html#signature-de-la-fonction",
    "href": "slides/SQL_4.html#signature-de-la-fonction",
    "title": "Fonctions SQL et Vues",
    "section": "Signature de la fonction",
    "text": "Signature de la fonction\nCREATE OR REPLACE FUNCTION \n  &lt;func_name&gt;(&lt;arg1&gt; &lt;arg1_datatype&gt; [DEFAULT &lt;arg1_default&gt;])\n\nRETURNS &lt;some type&gt; | SETOF &lt;some type&gt; | TABLE (..)\nLa signature d’une fonction est formée par:\n\nle nom de la fonction &lt;func_name&gt;\n\nla liste des arguments (nom &lt;arg1&gt; et type attendu )\n\nle type du résultat retourné par la fonction"
  },
  {
    "objectID": "slides/SQL_4.html#signature-de-la-fonction-suite",
    "href": "slides/SQL_4.html#signature-de-la-fonction-suite",
    "title": "Fonctions SQL et Vues",
    "section": "Signature de la fonction (suite)",
    "text": "Signature de la fonction (suite)\n\n\n&lt;arg1_datatype&gt;:\n\ntype prédéfini ou non, voir CREATE TYPE ...\n\ntype de colonne d’une table : country.countrycode%TYPE\n\ntype des tuples d’une table : country%ROWTYPE…\n\n\n&lt;arg1_default&gt;: litéral ou expression\n\nType du résultat:\n\ntype prédéfini ou non\n\nSETOF ... (table)\nTABLE (...)\n\n\n\n\n\nChaque schéma de table définit (implicitement) un type"
  },
  {
    "objectID": "slides/SQL_4.html#types-définis-par-lusager",
    "href": "slides/SQL_4.html#types-définis-par-lusager",
    "title": "Fonctions SQL et Vues",
    "section": "Types définis par l’usager",
    "text": "Types définis par l’usager\nCREATE TYPE  type_utilisateur AS (\n  &lt;identifiant&gt; &lt;type défini&gt;\n  [, &lt;identifiant&gt; &lt;type défini&gt;]*\n);\nUsage pour une création de table\nCREATE TABLE &lt;nom de table&gt; OF \n  type_utilisateur\n  (CONSTRAINT &lt;nom de contrainte&gt; PRIMARY KEY  (&lt;nom de colonne&gt;));\nPratique pour créer des tables de même schéma\n\n\n\n\n\n\nNote\n\n\nquand on crée une table, PostgreSQL crée automatiquement un type associé (bis)"
  },
  {
    "objectID": "slides/SQL_4.html#exemple",
    "href": "slides/SQL_4.html#exemple",
    "title": "Fonctions SQL et Vues",
    "section": "Exemple",
    "text": "Exemple\n\nDéfinition d’un type\n\nCREATE TYPE basic_user AS (\n  user_name varchar(50), \n  pwd varchar(10)\n);\n\nUsage du type défini par usager\n\nCREATE TABLE super_users OF basic_user \n  (CONSTRAINT pk_su PRIMARY KEY  (user_name));"
  },
  {
    "objectID": "slides/SQL_4.html#annotations",
    "href": "slides/SQL_4.html#annotations",
    "title": "Fonctions SQL et Vues",
    "section": "Annotations",
    "text": "Annotations\nLes définitions de fonctions comportent parfois des qualifications supplémentaires\n\nVOLATILITY: IMMUTABLE, STABLE, VOLATILE (default)\nSECURITY : SECURITY DEFINER, SECURITY INVOKER"
  },
  {
    "objectID": "slides/SQL_4.html#les-fonctions-écrites-en-langage-sql",
    "href": "slides/SQL_4.html#les-fonctions-écrites-en-langage-sql",
    "title": "Fonctions SQL et Vues",
    "section": "Les fonctions écrites en langage SQL",
    "text": "Les fonctions écrites en langage SQL\nSQL est d’abord un langage permettant d’émettre des requêtes, il peut aussi être utilisé pour écrire des fonctions\nDans PostgreSQL, l’utilisation d’un morceau de SQL existant est facile :\n\nprenez vos instructions SQL existantes (éventuellement plusieurs)\najoutez un en-tête et une conclusion fonctionnels\n\net … vous avez terminé"
  },
  {
    "objectID": "slides/SQL_4.html#les-fonctions-écrites-en-langage-sql-suite",
    "href": "slides/SQL_4.html#les-fonctions-écrites-en-langage-sql-suite",
    "title": "Fonctions SQL et Vues",
    "section": "Les fonctions écrites en langage SQL (suite)",
    "text": "Les fonctions écrites en langage SQL (suite)\nMais cette facilité a un prix \nVous ne pouvez pas :\n\nutiliser des structures de contrôle (boucles, alternatives) ou des définitions de variables locales\nexécuter des instructions SQL dynamiques que vous assemblez à la volée en utilisant les arguments passés dans la fonction\n\n\nMais, tout de même\n\nle planificateur de requêtes peut examiner une fonction SQL et en optimiser l’exécution"
  },
  {
    "objectID": "slides/SQL_4.html#corps-de-la-fonction",
    "href": "slides/SQL_4.html#corps-de-la-fonction",
    "title": "Fonctions SQL et Vues",
    "section": "Corps de la fonction",
    "text": "Corps de la fonction\n La syntaxe du corps de la fonction dépend du language_of_function\nDans le cas où language_of_function est SQL\n$$\n\nBODY of function\n\n$$"
  },
  {
    "objectID": "slides/SQL_4.html#références-aux-argument",
    "href": "slides/SQL_4.html#références-aux-argument",
    "title": "Fonctions SQL et Vues",
    "section": "Références aux argument",
    "text": "Références aux argument\nOn peut faire références aux arguments en les nommant dans le corps de la fonction\nSi les arguments ne sont pas nommés, vous faites référence aux arguments par leur position dans la signature : $1, $2, $3, etc\n Si vous nommez les arguments, vous pouvez utiliser la notation\nbig_elephant(name =&gt; 'Wooly', ear_size =&gt; 1.2)\nlors des appels à la fonction"
  },
  {
    "objectID": "slides/SQL_4.html#exemple-1",
    "href": "slides/SQL_4.html#exemple-1",
    "title": "Fonctions SQL et Vues",
    "section": "Exemple",
    "text": "Exemple\nCREATE OR REPLACE FUNCTION \n  write_to_log(param_user_name varchar,\n               param_description text)\nRETURNS integer AS\n$$\nINSERT INTO logs\n   (user_name, description) \n   VALUES($1, $2)\nRETURNING log_id;\n$$\nLANGUAGE 'sql' VOLATILE;\n\nInvocation\nSELECT write_to_log('alex', \n    'Logged in at 11:59 AM.') AS new_id;"
  },
  {
    "objectID": "slides/SQL_4.html#exemple-de-fonction-retournant-un-type-simple",
    "href": "slides/SQL_4.html#exemple-de-fonction-retournant-un-type-simple",
    "title": "Fonctions SQL et Vues",
    "section": "Exemple de fonction retournant un type simple",
    "text": "Exemple de fonction retournant un type simple\nDans le schéma world, on veut écrire une fonction qui prend en argument une région et renvoie la population maximale parmi les capitales de la région\nCREATE OR REPLACE \n  FUNCTION username.taille_max_capitale_region(p_region text)\n  RETURNS INTEGER \n  LANGUAGE SQL AS\n$$\nSELECT MAX(population) AS max_pop\nFROM world.country c \n  JOIN world.city cc ON (c.capital=cc.id)\nWHERE c.region=p_region AND\n cc.population IS NOT NULL;\n$$ ;"
  },
  {
    "objectID": "slides/SQL_4.html#fonctions-qui-retournent-un-type-composé-défini-par-les-lignes-dune-table",
    "href": "slides/SQL_4.html#fonctions-qui-retournent-un-type-composé-défini-par-les-lignes-dune-table",
    "title": "Fonctions SQL et Vues",
    "section": "Fonctions qui retournent un type composé défini par les lignes d’une table",
    "text": "Fonctions qui retournent un type composé défini par les lignes d’une table\nDans le schéma world, on veut écrire une fonction qui prend en argument une région et renvoie la description de la capitale la plus peuplée de cette région\nOn se contente de nommer la table pour indiquer que le résultat doit avoir même structure qu’une ligne de la table\n  CREATE OR REPLACE FUNCTION username.capitale(p_region text)\n  RETURNS world.city  \n  LANGUAGE SQL AS\n  $$\n  WITH r AS(\n    SELECT cc.*, RANK() OVER (PARTITION BY c.region ORDER BY cc.population DESC) AS rnk\n    FROM world.country c JOIN world.city cc ON (c.capital=cc.id)\n    WHERE c.region=p_region)\n  SELECT r.id, r.name, r.countrycode, r.district, r.population\n  FROM r \n  WHERE r.rnk = 1 ;\n  $$ ;"
  },
  {
    "objectID": "slides/SQL_4.html#fonctions-qui-retournent-une-table",
    "href": "slides/SQL_4.html#fonctions-qui-retournent-une-table",
    "title": "Fonctions SQL et Vues",
    "section": "Fonctions qui retournent une table",
    "text": "Fonctions qui retournent une table\nDans le schéma world, on veut écrire une fonction qui prend en argument une région et renvoie la table des capitales de la région"
  },
  {
    "objectID": "slides/SQL_4.html#table-de-schéma-explicite",
    "href": "slides/SQL_4.html#table-de-schéma-explicite",
    "title": "Fonctions SQL et Vues",
    "section": "Table de schéma explicite",
    "text": "Table de schéma explicite\nOn se contente d’abord de renvoyer le nom de la capitale.\nOn explicite le schéma de la table résultat\nCREATE OR REPLACE FUNCTION username.capitales_region(p_region text)\nRETURNS TABLE (name_capital text) \nLANGUAGE SQL AS\n$$\nSELECT cc.name \nFROM world.country c JOIN world.city cc ON (c.capital=cc.id)\nWHERE c.region=p_region ;\n$$ ;"
  },
  {
    "objectID": "slides/SQL_4.html#table-de-même-schéma-quune-autre-table",
    "href": "slides/SQL_4.html#table-de-même-schéma-quune-autre-table",
    "title": "Fonctions SQL et Vues",
    "section": "Table de même schéma qu’une autre table",
    "text": "Table de même schéma qu’une autre table\nhttps://www.postgresql.org/docs/15/xfunc-sql.html\nOn veut maintenant récupérer une table de même schéma que city.\nLa solution est très simple.\nOn profite de ce qu’à chaque table correspond un type de même nom et on utilise le mot-clé SETOF.\nCREATE OR REPLACE FUNCTION username.capitales_region_large(p_region text)\nRETURNS SETOF world.city  \nLANGUAGE SQL AS\n$$\nSELECT cc.* \nFROM world.country c JOIN world.city cc ON (c.capital=cc.id)\nWHERE c.region=p_region ;\n$$ ;"
  },
  {
    "objectID": "slides/SQL_4.html#autres-langages",
    "href": "slides/SQL_4.html#autres-langages",
    "title": "Fonctions SQL et Vues",
    "section": "Autres langages",
    "text": "Autres langages\n\nPL/pgSQL\nC\nPL/Python\nPL/R\n…"
  },
  {
    "objectID": "slides/SQL_4.html#fonction-reprise-depuis-pagila",
    "href": "slides/SQL_4.html#fonction-reprise-depuis-pagila",
    "title": "Fonctions SQL et Vues",
    "section": "Fonction reprise depuis pagila\n",
    "text": "Fonction reprise depuis pagila\n\nCREATE OR REPLACE FUNCTION user.inventory_held_by_customer(\n    p_inventory_id integer,\n    OUT customer_id int2) AS \n$$\n  SELECT customer_id \n  FROM pagila.rental\n  WHERE return_date IS NULL AND inventory_id = p_inventory_id ;\n$$ LANGUAGE 'sql' ;"
  },
  {
    "objectID": "slides/SQL_4.html#fonctions-de-pagila",
    "href": "slides/SQL_4.html#fonctions-de-pagila",
    "title": "Fonctions SQL et Vues",
    "section": "Fonctions de pagila\n",
    "text": "Fonctions de pagila\n\nCREATE OR REPLACE FUNCTION uname.film_in_stock(\n  p_film_id integer, \n  p_store_id integer, \n  OUT p_film_count integer)\n RETURNS SETOF integer\nAS $$\n     SELECT inventory_id\n     FROM pagila.inventory\n     WHERE film_id = $1\n     AND store_id = $2\n     AND pagila.inventory_in_stock(inventory_id);\n$$ LANGUAGE sql ;"
  },
  {
    "objectID": "slides/SQL_4.html#invocation",
    "href": "slides/SQL_4.html#invocation",
    "title": "Fonctions SQL et Vues",
    "section": "Invocation",
    "text": "Invocation\nSELECT * \nFROM pagila.film_in_stock(12, 1) ;\n\n\np_film_count\n\n\n\n60\n\n\n61\n\n\n62"
  },
  {
    "objectID": "slides/SQL_4.html#section-1",
    "href": "slides/SQL_4.html#section-1",
    "title": "Fonctions SQL et Vues",
    "section": "",
    "text": "Presque tous les SGBD relationnels proposent des vues comme niveau d’abstraction des tables. Dans une vue, vous pouvez interroger plusieurs tables et présenter des colonnes dérivées supplémentaires basées sur des calculs complexes.\n\n\nLes vues sont généralement en lecture seule, mais PostgreSQL vous permet de mettre à jour les données sous-jacentes en mettant à jour la vue, à condition que la vue provienne d’une seule table.\n\n\nPour mettre à jour des données à partir de vues qui joignent plusieurs tables, vous devez créer une gachette contre la vue.\n\n\nLes vues matérialisées mettent en cache les données afin d’accélérer les requêtes les plus courantes, au détriment des données les plus récentes."
  },
  {
    "objectID": "slides/SQL_4.html#motivation",
    "href": "slides/SQL_4.html#motivation",
    "title": "Fonctions SQL et Vues",
    "section": "Motivation",
    "text": "Motivation\n\n\n\n\n\n\nAstuce\n\n\nSi vous vous retrouvez à écrire tous les jours la même requête, créer une vue !\n\n\n\nUne vue n’est rien d’autre qu’une requête stockée de façon persistante"
  },
  {
    "objectID": "slides/SQL_4.html#vues-sur-une-seule-table",
    "href": "slides/SQL_4.html#vues-sur-une-seule-table",
    "title": "Fonctions SQL et Vues",
    "section": "Vues sur une seule table",
    "text": "Vues sur une seule table\nCREATE OR REPLACE VIEW co_asia AS\nSELECT * \nFROM world.country \nWHERE continent = 'Asia' ;"
  },
  {
    "objectID": "slides/SQL_4.html#interroger-une-vue",
    "href": "slides/SQL_4.html#interroger-une-vue",
    "title": "Fonctions SQL et Vues",
    "section": "Interroger une vue",
    "text": "Interroger une vue\nUne vue s’interroge comme une table :\nSELECT region, sum(population_country) AS pop \nFROM co_asia \nGROUP BY region \nORDER BY pop DESC ;\nregion                   |pop       |\n-------------------------+----------+\nEastern Asia             |1507328000|\nSouthern and Central Asia|1490776000|\nSoutheast Asia           | 518541000|\nMiddle East              | 188380700|"
  },
  {
    "objectID": "slides/SQL_4.html#vues-et-manipulation-de-données",
    "href": "slides/SQL_4.html#vues-et-manipulation-de-données",
    "title": "Fonctions SQL et Vues",
    "section": "Vues et manipulation de données",
    "text": "Vues et manipulation de données\nSi\n\nla vue (VIEW) provient d’une table unique\nla vue contient la clé primaire de la table d’origine\n\nAlors\non peut modifier la table au travers de la vue. On peut\n\ninsérer\nsupprimer\nmettre à jour\n\n\n\n\n\n\n\nExemple\n\n\n\nLa vue co_asia provient d’une unique table : world.country\n\nLa vue co_asia contient la clé primaire countrycode de la table world.country"
  },
  {
    "objectID": "slides/SQL_4.html#section-2",
    "href": "slides/SQL_4.html#section-2",
    "title": "Fonctions SQL et Vues",
    "section": "",
    "text": "Cette instruction :\nUPDATE co_asia\n  SET continent='Antarctica';\n… est légale !\n–\nMais, après exécution :\n\nla vue co_asia est vide \nles pays d’Asie de country sont délocalisés en Antarctique"
  },
  {
    "objectID": "slides/SQL_4.html#pour-éviter-ca-with-check-option",
    "href": "slides/SQL_4.html#pour-éviter-ca-with-check-option",
    "title": "Fonctions SQL et Vues",
    "section": "Pour éviter ca : WITH CHECK OPTION\n",
    "text": "Pour éviter ca : WITH CHECK OPTION\n\n\nCREATE OR REPLACE VIEW boucheron.co_asia AS\n  SELECT * \n  FROM world.country \n  WHERE continent = 'Asia' \n\nWITH CHECK OPTION ;\n\nAjouter cette modification lors de la création de la vue et PostgreSQL s’opposera à une tentative d’insertion hors de la vue ou à une tentative de mise à jour qui placerait des tuples hors de la vue"
  },
  {
    "objectID": "slides/SQL_4.html#section-3",
    "href": "slides/SQL_4.html#section-3",
    "title": "Fonctions SQL et Vues",
    "section": "",
    "text": "CREATE OR REPLACE VIEW pagila.actor_info\nAS SELECT a.actor_id,\n    a.first_name,\n    a.last_name,\n    pagila.group_concat(DISTINCT (c.name::text || ': '::text) || \n        (( SELECT pagila.group_concat(f.title::text) AS group_concat\n           FROM pagila.film f\n             JOIN pagila.film_category fc_1 ON f.film_id = fc_1.film_id\n             JOIN pagila.film_actor fa_1 ON f.film_id = fa_1.film_id\n          WHERE fc_1.category_id = c.category_id AND fa_1.actor_id = a.actor_id\n          GROUP BY fa_1.actor_id))\n        ) AS film_info\n   FROM pagila.actor a\n     LEFT JOIN pagila.film_actor fa ON a.actor_id = fa.actor_id\n     LEFT JOIN pagila.film_category fc ON fa.film_id = fc.film_id\n     LEFT JOIN pagila.category c ON fc.category_id = c.category_id\n  GROUP BY a.actor_id, a.first_name, a.last_name;"
  },
  {
    "objectID": "slides/SQL_4.html#vues-multi-tables-exemple-de-vue-sur-world",
    "href": "slides/SQL_4.html#vues-multi-tables-exemple-de-vue-sur-world",
    "title": "Fonctions SQL et Vues",
    "section": "Vues multi-tables : exemple de vue sur world\n",
    "text": "Vues multi-tables : exemple de vue sur world\n\nCREATE OR REPLACE VIEW country_info AS\n\n  SELECT\n    cn.countrycode, \n    cn.name_country, \n    cn.region,\n    string_agg(DISTINCT ci.name::text , ', '::text) AS cities\n\n  FROM world.country cn LEFT JOIN \n       world.city ci \n       ON (cn.countrycode = ci.countrycode)\n\n  GROUP BY cn.countrycode, cn.name_country, cn.region;\nStackoverflow"
  },
  {
    "objectID": "slides/SQL_4.html#insertionmise-à-joursuppression-sur-les-vues-multi-tables",
    "href": "slides/SQL_4.html#insertionmise-à-joursuppression-sur-les-vues-multi-tables",
    "title": "Fonctions SQL et Vues",
    "section": "Insertion/Mise à jour/Suppression sur les vues multi-tables",
    "text": "Insertion/Mise à jour/Suppression sur les vues multi-tables\nProblème : quelles tables doivent être modifiées ?\nDELETE \nFROM boucheron.country_info\nWHERE countrycode = 'FRA' ;\n\nsupprimer les lignes de country ?\nsupprimer les lignes de city ?\n\nDatabase abstraction"
  },
  {
    "objectID": "slides/SQL_4.html#vues-matérialisées",
    "href": "slides/SQL_4.html#vues-matérialisées",
    "title": "Fonctions SQL et Vues",
    "section": "Vues matérialisées",
    "text": "Vues matérialisées\nLes vue matérialisées cachent les données récupérées\nCela se produit\n\nlors de la création de la vue et\nlorsque on exécute REFRESH MATERIALIZED VIEW ..."
  },
  {
    "objectID": "slides/SQL_3.html#exemple-de-sous-requête-avec-des-fonctions-fenêtres",
    "href": "slides/SQL_3.html#exemple-de-sous-requête-avec-des-fonctions-fenêtres",
    "title": "BD IV: SQL III",
    "section": "Exemple de sous-requête avec des fonctions fenêtres",
    "text": "Exemple de sous-requête avec des fonctions fenêtres\nAfficher les 10 pays les plus peuplés\n\nWITH S AS (        \n  SELECT c.*, row_number() \n    OVER (ORDER BY population_country DESC) AS rpc  \n  FROM world.country c\n)\n\nSELECT name_country, continent, population_country\nFROM S   \nWHERE rpc &lt;= 10 \nORDER BY rpc DESC;\n\n\n------------------+-------------+------------------+\nname_country      |continent    |population_country|\n------------------+-------------+------------------+\nChina             |Asia         |        1277558000|\nIndia             |Asia         |        1013662000|\nUnited States     |North America|         278357000|\nIndonesia         |Asia         |         212107000|\nBrazil            |South America|         170115000|\nPakistan          |Asia         |         156483000|\nRussian Federation|Europe       |         146934000|\nBangladesh        |Asia         |         129155000|\nJapan             |Asia         |         126714000|\nNigeria           |Africa       |         111506000|"
  },
  {
    "objectID": "slides/SQL_3.html#exemple-avec-cube",
    "href": "slides/SQL_3.html#exemple-avec-cube",
    "title": "BD IV: SQL III",
    "section": "Exemple avec CUBE\n",
    "text": "Exemple avec CUBE\n\n\n\n\nSELECT continent, region, governmentform, \n       count(*) AS cnt, \n       max(lifeexpectancy)\nFROM country c \nWHERE continent LIKE '%America'\nGROUP BY CUBE (continent,region,governmentform)\nHAVING COUNT(*) &gt; 5;\n\n\n|continent    |region         |governmentform               |cnt|max |\n|-------------|---------------|-----------------------------|---|----|\n|             |               |                             |51 |79,4|\n|South America|South America  |Republic                     |9  |75,7|\n|North America|Central America|Republic                     |6  |75,8|\n|North America|Caribbean      |Constitutional Monarchy      |8  |75,2|\n|North America|Caribbean      |                             |24 |78,9|\n|South America|South America  |                             |14 |76,1|\n|North America|Central America|                             |8  |75,8|\n|South America|               |                             |14 |76,1|\n|North America|               |                             |37 |79,4|\n|             |Caribbean      |Constitutional Monarchy      |8  |75,2|\n|             |South America  |Republic                     |9  |75,7|\n|             |Central America|Republic                     |6  |75,8|\n|             |South America  |                             |14 |76,1|\n|             |Central America|                             |8  |75,8|\n|             |Caribbean      |                             |24 |78,9|\n|North America|               |Constitutional Monarchy      |9  |75,2|\n|North America|               |Republic                     |10 |75,8|\n|South America|               |Republic                     |9  |75,7|\n|North America|               |Dependent Territory of the UK|6  |78,9|\n|             |               |Republic                     |19 |75,8|\n|             |               |Constitutional Monarchy      |9  |75,2|\n|             |               |Dependent Territory of the UK|7  |78,9|"
  },
  {
    "objectID": "slides/SQL_3.html#options-all-et-distinct-des-fonctions-dagrégation",
    "href": "slides/SQL_3.html#options-all-et-distinct-des-fonctions-dagrégation",
    "title": "BD IV: SQL III",
    "section": "Options ALL et DISTINCT des fonctions d’agrégation",
    "text": "Options ALL et DISTINCT des fonctions d’agrégation\nCes options sont disponibles pour toutes les fonctions\nmais sont surtout utiles pour COUNT :\n\nALL, option par défaut : toutes les valeurs de la colonne sont utilisées,\nDISTINCT : les valeurs doublons ne sont utilisées qu’une fois."
  },
  {
    "objectID": "slides/SQL_3.html#fonction-dagrégation-sur-des-valeurs-toutes-null",
    "href": "slides/SQL_3.html#fonction-dagrégation-sur-des-valeurs-toutes-null",
    "title": "BD IV: SQL III",
    "section": "Fonction d’agrégation sur des valeurs toutes NULL\n",
    "text": "Fonction d’agrégation sur des valeurs toutes NULL\n\n\n\n\n\n\n\nAvertissement\n\n\nQue se passe-t-il si, après une éventuelle sélection, toutes les valeurs de du calcul d’agrégat sont NULL ?\nLa valeur calculée est alors NULL, ce qui signifie “pas de valeur”.\nEssayez SELECT MIN(gnpold) FROM country WHERE gnpold IS NULL; !"
  },
  {
    "objectID": "slides/SQL_3.html#fonction-dagrégation-sur-une-table-vide",
    "href": "slides/SQL_3.html#fonction-dagrégation-sur-une-table-vide",
    "title": "BD IV: SQL III",
    "section": "Fonction d’agrégation sur une table vide",
    "text": "Fonction d’agrégation sur une table vide\n\n\n\n\n\n\nAvertissement\n\n\nLes fonctions d’agrégation renvoie un scalaire même sur une table vide.\nPour une table vide, la valeur calculée est NULL.\n\n\n\n\nSELECT \n  SUM(population) AS urban_pop\nFROM city  ci\nWHERE ci.countrycode = 'zzz' ;\n\n\n+-----------+\n| urban_pop |\n|-----------|\n| &lt;null&gt;    |\n+-----------+\nEst-ce cohérent?\nLe résultat signifie : “Pour le pays de code ‘zzz’, pas de données”"
  },
  {
    "objectID": "slides/SQL_3.html#opérations-sur-des-fonctions-dagrégation",
    "href": "slides/SQL_3.html#opérations-sur-des-fonctions-dagrégation",
    "title": "BD IV: SQL III",
    "section": "Opérations sur des fonctions d’agrégation",
    "text": "Opérations sur des fonctions d’agrégation\nPNB moyen par habitant du continent South America\nSELECT \n  ROUND(SUM(1e6*gnp)/SUM(population_country),2) as pnb_avg\nFROM \n  country \nWHERE \n  continent = 'South America';\nRésultat : 4372,36\n\n\n\n\n\n\nNote\n\n\n\\(10^6\\) s’écrit 1e6. On a écrit 1e6*gnp car gnp est exprimé en millions de USD.\nROUND(x,s) effectue un arrondi de x avec s chiffres après la virgule. s négatif accepté.\nDocumentation des fonctions mathématiques"
  },
  {
    "objectID": "slides/SQL_3.html#fonctions-dagrégation-sur-des-opérations",
    "href": "slides/SQL_3.html#fonctions-dagrégation-sur-des-opérations",
    "title": "BD IV: SQL III",
    "section": "Fonctions d’agrégation sur des opérations",
    "text": "Fonctions d’agrégation sur des opérations\n\n\n\n\n\n\nNote\n\n\nLes fonctions d’agrégation peuvent s’appliquer à des opérations arithmétiques entre les différents attributs d’un même tuple…\n\n\n\n\nMoyenne des PNB/habitant des pays du continent ‘South America’. A ne pas confondre avec la requête précédente !\nSELECT \n  ROUND(AVG(1e6*gnp/population_country),2) as pnb_country_avg\nFROM country \nWHERE \n  continent = 'South America' AND population_country &gt; 0 ;\n-- Le test population_country &gt; 0 évite les divisions par 0\nRésultat : 3176,44"
  },
  {
    "objectID": "computing-dbeaver.html",
    "href": "computing-dbeaver.html",
    "title": "Client dbeaver",
    "section": "",
    "text": "Note\n\n\n\nGuide pour utiliser le client dBeaver avec un tunnel ssh",
    "crumbs": [
      "Support",
      "Client dbeaver"
    ]
  },
  {
    "objectID": "computing-dbeaver.html#connection",
    "href": "computing-dbeaver.html#connection",
    "title": "Client dbeaver",
    "section": "Connection",
    "text": "Connection\nLa première étape après la création d’un projet est la création d’une connexion à un serveur de bases de données.\nPour cet enseignement, vous devez d’abord créer un tunnel ssh avec le serveur etu-pgsql.math.univ-paris-diderot.fr avec une redirection de port (cf. Connexion au serveur).\nNous supposons par la suite que vous avez établi un tunnel en redirigeant le port local 5436 vers le port distant 5432.\nIl faut ensuite sélectionner votre projet dans l’onglet Projets puis faire une clic droit et Créer-&gt;Connexion, choisir le pilote PostgreSQL (regarder les icônes), puis Suivant et saisir dans le formulaire les informations suivantes :\n\nOnglet Main ou Général\n\nConnect by Host,\n\nHost: localhost,\nPort: 5436 (le nom du port local utilisé par votre tunnel ssh)\nDatabase: bd_2023-24\nDécocher Show all databases\n\nAuthentification: Database Native\n\nUsername: username (ENT)\nPassword: xxxxxxx (ENT)\nCocher Save password\n\n\n\nPuis cliquer sur Terminer. Eventuellement, dBeaver demandera à installer le pilote ‘PostgreSQL’.\nMaintenant la connexion bd_2023-24 apparaît dans votre projet. Elle apparaît également dans le Navigateur de Bases de données (Fenêtres-&gt;Navigateur de Bases de données).\nEn déroulant la connexion bd_2023-24-&gt;Bases de données-&gt;bd_2023-2024-&gt;Schémas, vous pouvez visualiser la liste des schémas existants sur le serveur.\n\n\n\n\n\n\nTip\n\n\n\nSi vous créez un nouveau projet avec une connexion déjà définie dans un autre, il vous suffit de copier-coller la connexion entre les projets ou depuis le Navigateur de Bases de données.",
    "crumbs": [
      "Support",
      "Client dbeaver"
    ]
  },
  {
    "objectID": "computing-dbeaver.html#bookmarkssignets",
    "href": "computing-dbeaver.html#bookmarkssignets",
    "title": "Client dbeaver",
    "section": "Bookmarks/Signets",
    "text": "Bookmarks/Signets\nVous pouvez jeter un coup d’oeil à cette documentation sur les signets.\n\n\n\n\n\n\nTip\n\n\n\nVous pouvez créer des signets pour retrouver facilement les schémas sur lesquels vous travaillez, ou avez travaillé.",
    "crumbs": [
      "Support",
      "Client dbeaver"
    ]
  },
  {
    "objectID": "computing-dbeaver.html#dashboardstableaux-de-bord",
    "href": "computing-dbeaver.html#dashboardstableaux-de-bord",
    "title": "Client dbeaver",
    "section": "Dashboards/Tableaux de bord",
    "text": "Dashboards/Tableaux de bord\nIls servent à superviser l’utilisation des ressources. Cela ne vous sera pas utile pour cet enseignement.",
    "crumbs": [
      "Support",
      "Client dbeaver"
    ]
  },
  {
    "objectID": "computing-dbeaver.html#diagrams",
    "href": "computing-dbeaver.html#diagrams",
    "title": "Client dbeaver",
    "section": "Diagrams",
    "text": "Diagrams\ndBeaver permet de faire un peu de rétro-ingénieurie et de visualiser (partiellement) un schéma. Outil utile quand on veut retoucher un schéma ou simplement le comprendre.",
    "crumbs": [
      "Support",
      "Client dbeaver"
    ]
  },
  {
    "objectID": "computing-dbeaver.html#scripts",
    "href": "computing-dbeaver.html#scripts",
    "title": "Client dbeaver",
    "section": "Scripts",
    "text": "Scripts\n\nCréer un dossier de script pour chaque TP puis un script pour chaque exercice,\nNommer le script de façon utile (avec rename),\nCommenter le script,\nSéparer les requêtes par des lignes blanches et une ligne de commentaire blanche --,\nUtiliser le reformattage pour rendre votre code plus lisible.",
    "crumbs": [
      "Support",
      "Client dbeaver"
    ]
  },
  {
    "objectID": "computing-dbeaver.html#paramétrage-pour-éviter-lerreur-fatal-too-many-connections",
    "href": "computing-dbeaver.html#paramétrage-pour-éviter-lerreur-fatal-too-many-connections",
    "title": "Client dbeaver",
    "section": "Paramétrage pour éviter l’erreur FATAL: too many connections",
    "text": "Paramétrage pour éviter l’erreur FATAL: too many connections\nPar défaut, Dbeaver crée une connexion par fenêtre de l’éditeur SQL. Si vous ne modifiez pas ce paramètre, votre compte sera bloqué rapidement par une erreur FATAL: too many connections car vous aurez atteint le nombre maximum de connexions auquel vous avez droit.\nLors de votre première utilisation du client, il faut modifier ce paramètre en sélectionnant dans la barre de menu Editeur SQL-&gt;Open separate connection-&gt;never.",
    "crumbs": [
      "Support",
      "Client dbeaver"
    ]
  },
  {
    "objectID": "computing-dbeaver.html#survol",
    "href": "computing-dbeaver.html#survol",
    "title": "Client dbeaver",
    "section": "Survol",
    "text": "Survol\n Explorer les possibilités du client dBeaver\n\n\n\n\n\n\nTipOuvrir un tunnel ssh\n\n\n\nVous utiliserez dBeaver pour interroger le serveur Postgre via un tunnel ssh. Pour établir ce tunnel reportez-vous à la page Connexion au serveur",
    "crumbs": [
      "Support",
      "Client dbeaver"
    ]
  },
  {
    "objectID": "slides/SQL_3.html#utilisation-de-case-when-...then-...-else-...-end",
    "href": "slides/SQL_3.html#utilisation-de-case-when-...then-...-else-...-end",
    "title": "BD IV: SQL III",
    "section": "Utilisation de CASE WHEN ...THEN ... [ELSE ...] END\n",
    "text": "Utilisation de CASE WHEN ...THEN ... [ELSE ...] END\n\nDans une fonction d’agrégation, une expression CASE WHEN teste des conditions sur le tuple courant et renvoie la valeur correspondant à la première condition vraie.\nCASE\n    WHEN condition1 THEN result1\n    [WHEN condition2 THEN result2]\n    [WHEN conditionN THEN resultN]\n    [ELSE result]\nEND;\n\n\n\n\n\n\nAvertissement\n\n\nSi aucune condition n’est vraie et qu’il n’y pas de clause ELSE, CASE retourne NULL.\n\n\n\nSELECT \n  SUM(\n    CASE \n      WHEN countrycode='GBR' THEN population \n    END) AS urban_pop \n FROM city ;\n+-----------+\n| urban_pop |\n|-----------|\n| 22436673  |\n+-----------+"
  },
  {
    "objectID": "slides/SQL_3.html#gestion-des-valeurs-manquantes-avec-case-when-...then-...-else-...-end",
    "href": "slides/SQL_3.html#gestion-des-valeurs-manquantes-avec-case-when-...then-...-else-...-end",
    "title": "BD IV: SQL III",
    "section": "Gestion des valeurs manquantes avec CASE WHEN ...THEN ... [ELSE ...] END\n",
    "text": "Gestion des valeurs manquantes avec CASE WHEN ...THEN ... [ELSE ...] END\n\nSELECT \n  AVG(\n    CASE \n      WHEN gnpold IS NOT NULL THEN gnpold \n      ELSE 0 \n    END)::NUMERIC(8,2) AS avg_gnpold \n FROM world.country \n WHERE continent = 'Europe';\nRetourne 203956,54\nSELECT \n  AVG(gnpold)::NUMERIC(8,2) AS avg_gnpold \n FROM world.country \n WHERE continent = 'Europe';\nRetourne 260611,14"
  },
  {
    "objectID": "slides/SQL_3.html#autres-possibilités-avec-case-when-...then-...-else-...-end",
    "href": "slides/SQL_3.html#autres-possibilités-avec-case-when-...then-...-else-...-end",
    "title": "BD IV: SQL III",
    "section": "Autres possibilités avec CASE WHEN ...THEN ... [ELSE ...] END\n",
    "text": "Autres possibilités avec CASE WHEN ...THEN ... [ELSE ...] END\n\nSELECT \n  SUM(CASE \n    WHEN governmentform LIKE '%Monarchy%' THEN population_COUNTRY \n    ELSE 0    -- résultat identique si on enlève cette ligne\n  END) AS pop_monarch,  \n  SUM(CASE \n    WHEN governmentform LIKE '%Republic%' THEN population_COUNTRY \n    ELSE 0   -- résultat identique si on enlève cette ligne\n  END) AS pop_repu \nFROM country ;\n+-------------+------------+\n| pop_monarch | pop_repu   |\n|-------------+------------|\n| 519485000   | 5502453700 |\n+-------------+------------+"
  }
]