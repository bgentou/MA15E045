[
  {
    "objectID": "slides/SQL_7.html#table-babynames",
    "href": "slides/SQL_7.html#table-babynames",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Table babynames\n",
    "text": "Table babynames\n\n\nstopifnot(\n  require(dplyr),\n  require(tibble),\n  require(babynames),\n  require(gt)\n)\n\n\nbabynames |&gt; \n  glimpse()\n\nRows: 1,924,665\nColumns: 5\n$ year &lt;dbl&gt; 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880,…\n$ sex  &lt;chr&gt; \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", …\n$ name &lt;chr&gt; \"Mary\", \"Anna\", \"Emma\", \"Elizabeth\", \"Minnie\", \"Margaret\", \"Ida\",…\n$ n    &lt;int&gt; 7065, 2604, 2003, 1939, 1746, 1578, 1472, 1414, 1320, 1288, 1258,…\n$ prop &lt;dbl&gt; 0.07238359, 0.02667896, 0.02052149, 0.01986579, 0.01788843, 0.016…"
  },
  {
    "objectID": "slides/SQL_7.html#petit-rappel-sur-lalgèbre-relationnelle",
    "href": "slides/SQL_7.html#petit-rappel-sur-lalgèbre-relationnelle",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Petit rappel sur l’algèbre relationnelle",
    "text": "Petit rappel sur l’algèbre relationnelle\n\n\n\n\n\n\nPrincipe\n\n\nUne opération de l’algèbre relationnelle accepte des opérandes (des relations) et parfois une expression.\nUne opération de l’algèbre relationnelle retourne une relation/table.\n\n\n\n\n\n\n\n\n\n\nEn passant\n\n\nUne relation c’est un schéma (définition des colonnes/attributs) et une instance (une collection de lignes qui obéissent au schéma).\nUne opération de l’algèbre relationnelle définit le schéma de la table résultat à partir des schémas des tables opérandes\nUne opération de l’algèbre relationnelle définit l’instance du schéma résultat à partir des instances des tables opérandes (et peut-être de l’expression)."
  },
  {
    "objectID": "slides/SQL_7.html#opérateurs-de-base",
    "href": "slides/SQL_7.html#opérateurs-de-base",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Opérateurs de base",
    "text": "Opérateurs de base\n\n\n\n\n\n\nListe des opérateurs\n\n\nL’algèbre relationnelle est d’abord un *Langage de Manipulation de Données& (LMD)}.\n\nUnion: \\(\\Large{\\cup}\\)\nIntersection: \\(\\Large{\\cap}\\)\nDifférence: \\(\\Large{\\backslash}\\)\nProjection: \\(\\Large{\\Pi}\\) (avec une expression formée par la liste des attributs de projection)\nSélection: \\(\\Large{\\sigma}\\) (avec une expression qui définit la condition de filtrage)\nProduit cartésien: \\(\\Large{\\times}\\)\nRenommage: \\(\\Large{\\rho}\\) (avec une expression formée par la liste des renommages)\n\ns’appliquent à des relations (les opérandes) pour produire d’autres relations (le résultat)."
  },
  {
    "objectID": "slides/SQL_7.html#union-cup-et-intersection-cap",
    "href": "slides/SQL_7.html#union-cup-et-intersection-cap",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Union \\(\\cup\\) et intersection \\(\\cap\\)\n",
    "text": "Union \\(\\cup\\) et intersection \\(\\cap\\)\n\n\n\n\n\n\n\nDéfinition\n\n\n\nL’union et l’intersection sont des opérations portant sur deux relations \\(R_1\\) et \\(R_2\\) de même schéma\n\\(T=R_1\\cup R_2\\) est constituée des tuples appartenant à \\(R_1\\) ou à \\(R_2\\).\n\\(T=R_1\\cap R_2\\) est constituée des tuples appartenant à \\(R_1\\) et à \\(R_2\\).\nLe schémas de \\(R_1\\cup R_2\\), \\(R_1\\cap R_2\\) sont les mêmess que ceux de \\(R_1\\) et \\(R_2\\)"
  },
  {
    "objectID": "slides/SQL_7.html#union-et-intersection",
    "href": "slides/SQL_7.html#union-et-intersection",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Union et intersection",
    "text": "Union et intersection"
  },
  {
    "objectID": "slides/SQL_7.html#exemple",
    "href": "slides/SQL_7.html#exemple",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Exemple",
    "text": "Exemple\n\n\nTrain 1\n\n\nh-dep\ndest\nnum\n\n\n\n13h15\nLyon\n213\n\n\n13h29\nMarseille\n1024\n\n\n14h15\nLyon\n214\n\n\n\nTrain 2\n\n\nh-dep\ndest\nnum\n\n\n\n13h39\nAvignon\n43\n\n\n14h15\nLyon\n214\n\n\n\n\nTrain 1 \\(\\cup\\) Train 2\n\n\nh-dep\ndest\nnum\n\n\n\n13h15\nLyon\n213\n\n\n13h29\nMarseille\n1024\n\n\n14h15\nLyon\n214\n\n\n13h39\nAvignon\n43\n\n\n\nTrain 1 \\(\\cap\\) Train 2\n\n\nh-dep\ndest\nnum\n\n\n14h15\nLyon\n214"
  },
  {
    "objectID": "slides/SQL_7.html#différence",
    "href": "slides/SQL_7.html#différence",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Différence",
    "text": "Différence\n\n\n\n\n\n\nDéfinition\n\n\n\nLa différence de deux relations \\(R_1\\) et \\(R_2\\) (de même schéma) est une relation \\(T\\)\nde même schéma que \\(R_1\\) et \\(R_2\\)\nconstituée des tuples appartenant à \\(R_1\\) et n’appartenant pas à \\(R_2\\).\nOn note \\(T = R_1 - R_2\\).\n\n\n\n\n\n\n\n\n\n\n\nOpération non commutative !\n\n\nR_1 - R_2R_2 - R_1$ (en général)."
  },
  {
    "objectID": "slides/SQL_7.html#différence-exemple",
    "href": "slides/SQL_7.html#différence-exemple",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Différence : exemple",
    "text": "Différence : exemple"
  },
  {
    "objectID": "slides/SQL_7.html#produit-cartésien",
    "href": "slides/SQL_7.html#produit-cartésien",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Produit Cartésien",
    "text": "Produit Cartésien\n\n\n\n\n\n\nDéfinition\n\n\n\n\nSoient:\n\n\n\\(R_1\\) de schéma \\(R_1(A_1,A_2,...,A_k)\\)\n\n\n\\(R_2\\) de schéma \\(R_2(B_1,B_2,...,B_\\ell)\\)\n\navec \\(A_i\\neq B_j\\), pour tout \\(i=1,...,k\\), \\(j=1,..,\\ell\\)\n\n\n\nDans le contexte “classique” : \\(R_1 \\times R_2= \\{(e_1,e_2): e_1\\in R_1, e_2\\in R_2\\}\\)\n\\(R=R_1 \\times R_2\\) de schéma \\(R(A_1,A_2,...,A_k,B_1,B_2,...,B_\\ell)\\). Le schéma de \\(R\\) est l’union des schémas de \\(R_1\\) et \\(R_2\\)\n\n\n\n\n\n\n\n\n\n\nAttention\n\n\nEn algèbre relationnelle, cette opération est commutative ( \\(R_1\\times R_2 = R_2\\times R_1\\) ) et associative (parce que l’on nomme des attributs/colonnes, on ne les désigne pas par une position)"
  },
  {
    "objectID": "slides/SQL_7.html#produit-cartésien-1",
    "href": "slides/SQL_7.html#produit-cartésien-1",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Produit cartésien :",
    "text": "Produit cartésien :\n\n\n\n\n\n\nDéfinition formelle\n\n\n\\(R=R_1\\times R_2\\) est la relation de schéma \\(R(A_1,A_2,...,A_k,B_1,B_2,...,B_\\ell)\\) vérifiant~:\n\nPour tout \\(t\\in R\\), il existe \\(t_1\\in R_1\\), \\(t_2\\in R_2\\) (\\(\\forall t \\in R, \\exists t_1 \\in R_1, \\exists t_2 \\in R_2, \\ldots\\)) tels que :\n\n\\[t.A_1=t_1.A_1, \\ldots, t.A_k=t_1.A_k,\\quad t.B_1=t_2.B_1, \\ldots, t.B_\\ell=t_2.B_\\ell\\]\n\nRéciproquement, pour tout \\(t_1\\in R_1\\), \\(t_2\\in R_2\\) , il existe \\(t\\in R\\) tels que :\n\n\\[t.A_1=t_1.A_1, \\ldots, t.A_k=t_1.A_k,\\quad \\text{et} \\quad t.B_1=t_2.B_1, \\ldots, t.B_\\ell=t_2.B_\\ell\\]\n\\[\\forall t_1 \\in R_1, \\forall t_2 \\in R_2, \\exists t \\in R, \\qquad  t.A_1=t_1.A_1, \\ldots, t.A_k=t_1.A_k,\\quad \\text{et} \\quad t.B_1=t_2.B_1, \\ldots, t.B_\\ell=t_2.B_\\ell\\]"
  },
  {
    "objectID": "slides/SQL_7.html#produit-cartésien-avec-dplyr-dplyrcross_join",
    "href": "slides/SQL_7.html#produit-cartésien-avec-dplyr-dplyrcross_join",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Produit cartésien avec dplyr: dplyr::cross_join()\n",
    "text": "Produit cartésien avec dplyr: dplyr::cross_join()\n\n\\(R \\times S\\) se traduit en\ncross_join(R, S)"
  },
  {
    "objectID": "slides/SQL_7.html#projection-largepi",
    "href": "slides/SQL_7.html#projection-largepi",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Projection ( \\(\\Large{\\pi}\\) )",
    "text": "Projection ( \\(\\Large{\\pi}\\) )\n\n\n\n\n\n\nDéfinition\n\n\n\nLa projection d’une relation \\(R\\) de schéma \\(R(A_1,\\dots, A_k)\\) sur les attributs \\(A_{i_1}, \\dots, A_{i_p}\\), \\(i_1,..., i_p\\in \\{1,...,k\\}\\), est la relation \\(S\\)\n\nde schéma \\(S(A_{i_1}, \\dots,A_{i_p})\\)\n\ndont les tuples sont obtenus par élimination des attributs non mentionnés dans \\(A_{i_1}, \\dots, A_{i_p}\\) (et par élimination des doublons).\nOn note \\(S = \\pi_{A_{i_1}, \\dots, A_{i_p}} (R)\\).\n\n\nDéfinition formelle :\n\n\\[s\\in S\\quad  \\iff \\quad \\exists t\\in R, \\forall n\\in\\left\\{1,\\dots,p\\right\\}\\qquad s.A_{i_n}=t.A_{i_n}\\]\n\n\n\nImplicitement, on a élimination des doublons car une projection peut produire plusieurs fois le même tuple."
  },
  {
    "objectID": "slides/SQL_7.html#projection-avec-dplyrselect",
    "href": "slides/SQL_7.html#projection-avec-dplyrselect",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Projection avec dplyr::select()\n",
    "text": "Projection avec dplyr::select()\n\n\\(S = \\pi_{A_{i_1}, \\dots, A_{i_p}} (R)\\) se traduit en\nS &lt;- dplyr::select(R, Ai1, Ai2, ..., Aip)"
  },
  {
    "objectID": "slides/SQL_7.html#projection-exemples",
    "href": "slides/SQL_7.html#projection-exemples",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Projection : Exemples",
    "text": "Projection : Exemples"
  },
  {
    "objectID": "slides/SQL_7.html#projection-vitaminée-tidy-selection",
    "href": "slides/SQL_7.html#projection-vitaminée-tidy-selection",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Projection vitaminée (tidy selection)",
    "text": "Projection vitaminée (tidy selection)\nSélection bien tempérée"
  },
  {
    "objectID": "slides/SQL_7.html#sélection-σ",
    "href": "slides/SQL_7.html#sélection-σ",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Sélection (σ)",
    "text": "Sélection (σ)\n\n\n\n\n\n\nDéfinition\n\n\n\n\nLa sélection d’une relation \\(R\\) par une condition \\(C\\) est une relation \\(S\\)\n\nde même schéma que \\(R\\)\ndont les tuples sont ceux de \\(R\\) qui satisfont la condition \\(C\\).\n\n\nOn note \\(S = σ(R, C)\\).\n\nLa condition \\(C\\)\n\ns’exprime à l’aide des noms d’attributs de la relation ou de constantes (pour les opérandes)\non peut utiliser des opérateurs arithmétiques de comparaison ( \\(=, \\neq, \\leq, \\geq, &lt;, &gt;\\) ) ainsi que des connecteurs logiques (¬, ∧, ∨)..\ns’évalue pour chaque ligne de \\(R\\)"
  },
  {
    "objectID": "slides/SQL_7.html#sélection-avec-dplyrfilter",
    "href": "slides/SQL_7.html#sélection-avec-dplyrfilter",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Sélection avec dplyr::filter\n",
    "text": "Sélection avec dplyr::filter\n\n\\(S = σ(R, C)\\) se traduit en\nS &lt;- filter(R, C)"
  },
  {
    "objectID": "slides/SQL_7.html#sélection-exemple",
    "href": "slides/SQL_7.html#sélection-exemple",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Sélection : Exemple",
    "text": "Sélection : Exemple"
  },
  {
    "objectID": "slides/SQL_7.html#renommage",
    "href": "slides/SQL_7.html#renommage",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Renommage",
    "text": "Renommage\n\n\n\n\n\n\nDéfinition\n\n\n\nSoit \\(R\\) de schéma \\(R(A_1,\\dots, A_k)\\), le renommage d’un attribut \\(A_i\\), \\(i\\leq k\\), en \\(B\\) est une relation \\(S\\) :\n\nde même contenu (mêmes lignes)\nde schéma \\(S(A_1,...,A_{i-1},B,A_{i+1},..., A_k)\\)\n\nOn le note \\(S=ρ(R, A_i\\mapsto B)\\)"
  },
  {
    "objectID": "slides/SQL_7.html#renommage-avec-dplyrrename",
    "href": "slides/SQL_7.html#renommage-avec-dplyrrename",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Renommage avec dplyr::rename()\n",
    "text": "Renommage avec dplyr::rename()\n\n\\(S=ρ(R, A_i\\mapsto B)\\) se traduit en\nS &lt;- rename(R, B=Ai)"
  },
  {
    "objectID": "slides/SQL_7.html#exemple-1",
    "href": "slides/SQL_7.html#exemple-1",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Exemple",
    "text": "Exemple\nr$&gt; rename(flights, destination=dest) |&gt; \n    select(flight,tailnum, origin, destination, carrier, time_hour) |&gt;\n    head()\n# A tibble: 6 × 6\n  flight tailnum origin destination carrier time_hour          \n   &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;       &lt;chr&gt;   &lt;dttm&gt;             \n1   1545 N14228  EWR    IAH         UA      2013-01-01 05:00:00\n2   1714 N24211  LGA    IAH         UA      2013-01-01 05:00:00\n3   1141 N619AA  JFK    MIA         AA      2013-01-01 05:00:00\n4    725 N804JB  JFK    BQN         B6      2013-01-01 05:00:00\n5    461 N668DN  LGA    ATL         DL      2013-01-01 06:00:00\n6   1696 N39463  EWR    ORD         UA      2013-01-01 05:00:00\nUtilité Va permettre d’étendre certains opérateurs pour des relations de schémas non-disjoints"
  },
  {
    "objectID": "slides/SQL_7.html#les-opérateurs-comme-fonctions",
    "href": "slides/SQL_7.html#les-opérateurs-comme-fonctions",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Les opérateurs comme fonctions",
    "text": "Les opérateurs comme fonctions\n\\(\\pi_{Ai1, Aip}\\left(\\sigma_C(R)\\right)\\)\nse traduit en\nselect(filter(R, C), Ai1, ..., Aip)\nqui s’avère difficile à lire, surtout si on compose plus d’opérations élémentaires\nLa composition de fonctions se conçoit facilement mais l’expression correspondante est difficile à lire"
  },
  {
    "objectID": "slides/SQL_7.html#réécriture-de-la-composition-avec",
    "href": "slides/SQL_7.html#réécriture-de-la-composition-avec",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Réécriture de la composition avec |>\n",
    "text": "Réécriture de la composition avec |&gt;\n\nS &lt;- select(filter(R, C), Ai1, ..., Aip)\npeut être réécrite en\nS &lt;- R |&gt; \n  filter(C) |&gt;\n  select(Ai1,.., Aip)"
  },
  {
    "objectID": "slides/SQL_7.html#exemple-2",
    "href": "slides/SQL_7.html#exemple-2",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Exemple",
    "text": "Exemple\nLes origines et destinations des vols avec un retard au départ d’au moins 30 minutes e\n\n\nflights |&gt;\n  filter(dep_delay&gt;30) |&gt;\n  select(origin, dest) |&gt;\n  distinct()\n\nou directement\nflights |&gt;\n  filter(dep_delay&gt;30) |&gt;\n  distinct(origin, dest)"
  },
  {
    "objectID": "slides/SQL_7.html#les-jointures",
    "href": "slides/SQL_7.html#les-jointures",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Les jointures",
    "text": "Les jointures\nOn va définir des opérations pratiques pour la manipulation de données~: les jointures\n\nJointure\nJointure naturelle\n\\(\\theta\\)-jointure et équi-jointure"
  },
  {
    "objectID": "slides/SQL_7.html#jointure",
    "href": "slides/SQL_7.html#jointure",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Jointure",
    "text": "Jointure\n\n\n\n\n\n\nDéfinition\n\n\nLa jointure \\(T=R_1\\bowtie_C R_2\\) de deux relations \\(R_1\\) et \\(R_2\\) de schémas disjoints sous la condition \\(C\\) est la relation \\(T\\):\n\nde schéma la concaténation des schémas de \\(R_1\\) et \\(R_2\\)\nformée des tuples du produit cartésien \\(R_1  \\times R_2\\) qui satisfont la condition \\(C\\)\n\nRègles de formation de la condition de jointure : comme pour la sélection\n\n\n\n\n\n\n\n\n\nDéfinition formelle\n\n\n\\[R_1 \\bowtie_C R_2 = \\sigma_C(R_1\\times R_2)\\]"
  },
  {
    "objectID": "slides/SQL_7.html#exemple-3",
    "href": "slides/SQL_7.html#exemple-3",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Exemple",
    "text": "Exemple\nTrDep\n\n\nhdep\ndest\nnumdep\n\n\n\n13h15\nLyon\n213\n\n\n13h29\nMarseille\n1024\n\n\n\nTrArr\n\n\nharr\nprov\nnumarr\n\n\n\n13h39\nAvignon\n43\n\n\n15h15\nParis\n213\n\n\n\n\\(\\texttt{TrDep} \\bowtie_{\\text{numdep} &gt; \\text{numar}} \\texttt{TrArr}\\)\n\n\n\n\n\n\n\n\n\n\nhdep\ndest\nnumdep\nharr\nprov\nnumarr\n\n\n\n13h15\nLyon\n213\n13h39\nAvignon\n43\n\n\n13h29\nMarseille\n1024\n13h39\nAvignon\n43\n\n\n13h29\nMarseille\n1024\n15h15\nParis\n213"
  },
  {
    "objectID": "slides/SQL_7.html#équi-jointure-theta-jointure",
    "href": "slides/SQL_7.html#équi-jointure-theta-jointure",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Équi-jointure, \\(\\theta\\)-jointure",
    "text": "Équi-jointure, \\(\\theta\\)-jointure\n\n\n\n\n\n\nÉqui-jointure\n\n\nJointure avec égalité entre attributs de types comparables\n\n\n\n\\[\\texttt{TrDep} \\bowtie_{\\text{numdep} = \\text{numarr}} \\texttt{TrArr}\\]\n\n\n\n\n\n\n\n\n\n\nhdep\ndest\nnumdep\nharr\nprov\nnumarr\n\n\n13h15\nLyon\n213\n15h15\nParis\n213\n\n\n\n\n\n\n\n\n\n\\(\\theta\\)-jointure\n\n\nCondition de jointure entre attributs de types comparables et avec un opérateur différent de l’égalité, c’est-à-dire dans \\(\\left\\{&lt;,&gt;,\\leq,\\geq, \\neq\\right\\}\\).\n\\[\\text{TrDep} \\bowtie_{\\text{numdep} &gt; \\text{numarr}} \\text{TrArr}\\]"
  },
  {
    "objectID": "slides/SQL_7.html#jointure-naturelle",
    "href": "slides/SQL_7.html#jointure-naturelle",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Jointure naturelle",
    "text": "Jointure naturelle\n\n\n\n\n\n\nDéfinition\n\n\nC’est une équi-jointure concernant les attributs communs (même nom et même type) de deux relations\nOn ne garde dans le résultat qu’une copie des attributs communs \n\n\n\nOn considère\n\n\\(R_1\\) d’attributs \\(A_1,..,A_k,B_1,...,B_h\\)\n\\(R_2\\) d’attributs \\(A_1,..,A_k,B_{h+1},...,B_\\ell\\)\n\\(A_1,..., A_k\\) : attributs communs et \\(\\{B_1,...,B_h\\}\\cap \\{ B_{h+1},...,B_\\ell \\}=\\emptyset\\)\nSoit \\(A'_1, ...., A'_k\\) tels que \\(\\{A_1,..., A_k\\}\\cap \\{ A'_1, ...., A'_k \\}=\\emptyset\\)"
  },
  {
    "objectID": "slides/SQL_7.html#jointure-naturelle-formalisation",
    "href": "slides/SQL_7.html#jointure-naturelle-formalisation",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Jointure naturelle (formalisation)",
    "text": "Jointure naturelle (formalisation)\nConsidérons \\(S\\) d’attributs \\(A_1',..,A_k',B_{h+1},...,B_l\\) définie par :\n\\[S=\\rho_{A_1\\mapsto A_1'}(\\rho_{A_2\\mapsto A_2'}(\\cdots (\\rho_{A_k\\mapsto A_k'}(R_2)\\cdots ))\\]\nLa jointure naturelle sur deux relations \\(R_1\\) et \\(R_2\\) est la relation\n\nd’attributs \\(A_1,..,A_k,B_1,...,B_h, B_{h+1},...,B_\\ell\\)\ndéfinie par :\n\n\\[\\pi_{A_1,..,A_k,B_1,...,B_h, B_{h+1},...,B_\\ell}(R_1\\bowtie_{C} S)\\]\noù \\(C\\) est \\((A_1=A_1') \\wedge (A_2=A'_2) \\wedge \\ldots \\wedge (A_k=A_k')\\)\n on réalise une équi-jointure sur tous les attributs communs et on ne garde qu’un seul “exemplaire” de ces attributs communs par projection.\nOn note cette opération : \\(R_1 \\bowtie R_2\\).\n\nPour éviter le renommage, on peut décider de préfixer les noms des attributs par ceux de la relation. La condition \\(C\\) devient :\n\\[(R_1.A_1=R_2.A_1) \\wedge \\ldots \\wedge (R_1.A_k=R_2.A_k)\\]"
  },
  {
    "objectID": "slides/SQL_7.html#exemple-de-jointure-naturelle",
    "href": "slides/SQL_7.html#exemple-de-jointure-naturelle",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Exemple de Jointure naturelle",
    "text": "Exemple de Jointure naturelle\n\n\nTrDep\n\n\nhdep\ndest\nnum\n\n\n\n13h15\nLyon\n213\n\n\n13h29\nMarseille\n1024\n\n\n\nTrArr\n\n\nharr\nprov\nnum\n\n\n\n13h39\nAvignon\n43\n\n\n15h15\nParis\n213\n\n\n\n\n\\[\\text{TrDep} \\bowtie \\text{TrArr}\\]\n\n\n\n\n\n\n\n\n\nhdep\ndest\nnum\nharr\nprov\n\n\n13h15\nLyon\n213\n15h15\nParis"
  },
  {
    "objectID": "slides/SQL_7.html#exemples-de-requêtes",
    "href": "slides/SQL_7.html#exemples-de-requêtes",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Exemples de requêtes",
    "text": "Exemples de requêtes\nBase constituée des trois tables suivantes:\nfournisseurs(fno, nom, adresse, ville)\nproduits(pno, design, prix, poids, couleur)\ncommandes(cno, fno, pno, qte)"
  },
  {
    "objectID": "slides/SQL_7.html#exemples-de-requêtes-suite",
    "href": "slides/SQL_7.html#exemples-de-requêtes-suite",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Exemples de requêtes (suite)",
    "text": "Exemples de requêtes (suite)\n\ndéterminer les numéros des fournisseurs ayant comme nom “Durand”\n\n\\[\\pi_{\\text{fno}} \\bigl( \\sigma_{\\text{nom}=\\text{'Durand'}} (\\text{fournisseurs})\\bigr)\\]\n\ndéterminer les références, prix et quantités des produits commandés à plus de 10 exemplaires.\n\n\\[\\pi_{\\text{pno,prix,qte}} \\bigl( \\sigma_{\\text{qte}&gt;10} (\\text{commandes} \\bowtie \\text{produits})\\bigr)\\]"
  },
  {
    "objectID": "slides/SQL_7.html#jointure-externe",
    "href": "slides/SQL_7.html#jointure-externe",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Jointure externe",
    "text": "Jointure externe\n\n\n\n\n\n\nPerte d’information dans jointure naturelle\n\n\nLes tuples ne satisfaisant pas la condition (non appariés) disparaissent\n\n\n\n\n\n\n\n\n\nDéfinition\n\n\n\nOn ajoute symboliquement” une ligne dont les valeurs sont vides (ou avec valeur spéciale NULL) pour garder les tuples initiaux “non satisfaisants” après la jointure\nOn note cette opération entre deux relations \\(R\\) et \\(S\\) :\n\\[R \\bowtie^+ S\\]"
  },
  {
    "objectID": "slides/SQL_7.html#jointure-externe-exemple",
    "href": "slides/SQL_7.html#jointure-externe-exemple",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Jointure externe (exemple)",
    "text": "Jointure externe (exemple)\n\n\nTrDep\n\n\nhdep\ndest\nnum\n\n\n\n13h15\nLyon\n213\n\n\n13h29\nMarseille\n1024\n\n\n\nTrArr\n\n\nharr\nprov\nnum\n\n\n\n13h39\nAvignon\n43\n\n\n15h15\nParis\n213\n\n\n\n\n\\[\\text{TrDep} \\bowtie^+ \\text{TrArr}\\]\n\n\n\n\n\n\n\n\n\nhdep\ndest\nnum\nharr\nprov\n\n\n\n13h15\nLyon\n213\n15h15\nParis\n\n\n13h29\nMarseille\n1024\n-\n-\n\n\n-\n-\n43\n13h39\nAvignon"
  },
  {
    "objectID": "slides/SQL_7.html#inner_join",
    "href": "slides/SQL_7.html#inner_join",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "inner_join()",
    "text": "inner_join()"
  },
  {
    "objectID": "slides/SQL_7.html#join_by...",
    "href": "slides/SQL_7.html#join_by...",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "join_by(...)",
    "text": "join_by(...)\n\njoin_by() constructs a specification that describes how to join two tables using a small domain specific language.\n\nArguments\nExpressions specifying the join.\n. . .\nEach expression should consist of one of the following:\n\nEquality condition: ==\nInequality conditions: &gt;=, &gt;, &lt;=, or &lt;\nRolling helper: closest()\nOverlap helpers: between(), within(), or overlaps()\n\n\n\nOther expressions are not supported. If you need to perform a join on a computed variable, e.g. join_by(sales_date - 40 &gt;= promo_date), you’ll need to precompute and store it in a separate column."
  },
  {
    "objectID": "slides/SQL_7.html#left_join",
    "href": "slides/SQL_7.html#left_join",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "left_join()",
    "text": "left_join()"
  },
  {
    "objectID": "slides/SQL_7.html#division",
    "href": "slides/SQL_7.html#division",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Division",
    "text": "Division\n\n\n\n\n\n\nDéfinition\n\n\nLa division ou quotient\n\nd’une relation \\(R\\) de schéma \\(R(A_1,A_2,\\dots,A_k)\\)\npar une relation \\(S\\) de schéma \\(S(A_{p+1},\\dots ,A_k)\\)\n\nest la relation \\(T\\) de schéma \\(T(A_1, \\dots, A_p)\\) formée des tuples qui complétés par chaque tuple de \\(S\\) donnent un tuple de \\(R\\).\nAutrement dit\n\\[\\begin{array}{l} t\\in T(A_1,\\dots,A_p)  \\quad \\Longleftrightarrow \\\\\n\\forall s\\in S(A_{p+1},\\dots ,A_k) \\quad \\exists r\\in R \\quad \\begin{cases}\nt.A_1=r.A_1, \\dots, t.A_p=r.A_p\\\\ s.A_{p+1}=r.A_{p+1},\\dots, s.A_{k}=r.A_{k} \\end{cases} \\end{array}\\]\nOn note \\[T = R \\div S\\]"
  },
  {
    "objectID": "slides/SQL_7.html#division-exemple",
    "href": "slides/SQL_7.html#division-exemple",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Division (exemple)",
    "text": "Division (exemple)\n\n\nVoyage : contient pour chaque numéro de client la ville de départ et d’arrivée des voyages qu’il a effectué\n\n\nnumclient\nvdep\nvarr\n\n\n\n1\nParis\nMarseille\n\n\n3\nMarseille\nLyon\n\n\n1\nParis\nNantes\n\n\n5\nMarseille\nAvignon\n\n\n4\nParis\nNantes\n\n\n3\nParis\nMarseille\n\n\n2\nCaen\nLe Mans\n\n\n3\nParis\nNantes\n\n\n\n\nVilles contient des couples villes de départ/villes d’arrivée\n\n\nvdep\nvarr\n\n\n\nParis\nMarseille\n\n\nParis\nNantes"
  },
  {
    "objectID": "slides/SQL_7.html#division-exemple-suite",
    "href": "slides/SQL_7.html#division-exemple-suite",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Division (exemple, suite)",
    "text": "Division (exemple, suite)\n\\[\\texttt{Voyage} \\div \\texttt{Villes}\\]\n\n\nnumclient\n\n\n\n1\n\n\n3\n\n\n\nRésultat : numéros des clients ayant effectué tous les voyages entre les villes de la table Villes (i.e. à la fois un Paris-Marseille et un Paris-Nantes.)"
  },
  {
    "objectID": "slides/SQL_7.html#interdéfinissabilité-des-opérateurs",
    "href": "slides/SQL_7.html#interdéfinissabilité-des-opérateurs",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Interdéfinissabilité des opérateurs",
    "text": "Interdéfinissabilité des opérateurs\n\nL’union, la différence, le produit cartésien, la sélection et la projection et le renommage sont suffisants pour définir tous les opérateurs que l’on a vu.\nMais avoir un panier plus large d’opérateurs simplifie l’écriture des requêtes.\n\nQuelques définitions\n\nPour la Jointure : \\(R \\bowtie_C S \\equiv \\sigma_C (R \\times S)\\)\nPour l’intersection : \\(A \\cap B = A \\cup B - ((B - A) \\cup (A - B))\\)"
  },
  {
    "objectID": "slides/SQL_7.html#définition-de-la-division",
    "href": "slides/SQL_7.html#définition-de-la-division",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Définition de la division",
    "text": "Définition de la division\n\n\n\n\n\n\nFormalisation\n\n\nSoient \\(R\\) de schéma \\(R(A_1,A_2,\\dots,A_k)\\), \\(S\\) de schéma \\(S(A_{p+1},\\dots ,A_k)\\)\nest la relation \\(T= R \\div S\\) de schéma \\(T(A_1, \\dots, A_p)\\)."
  },
  {
    "objectID": "slides/SQL_7.html#from-wikipedia-smaller",
    "href": "slides/SQL_7.html#from-wikipedia-smaller",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "From Wikipedia {smaller}",
    "text": "From Wikipedia {smaller}\n\nIn the 1960s and 1970s he worked out his theories of data arrangement, issuing his paper “A Relational Model of Data for Large Shared Data Banks”[14] in 1970, after an internal IBM paper one year earlier.[15] To his disappointment, IBM proved slow to exploit his suggestions until commercial rivals started implementing them.[16]\n\n\nInitially, IBM refused to implement the relational model to preserve revenue from IMS/DB.[citation needed] Codd then showed IBM customers the potential of the implementation of its model, and they in turn pressured IBM. Then IBM included in its Future Systems project a System R subproject – but put in charge of it developers who were not thoroughly familiar with Codd’s ideas, and isolated the team from Codd.[citation needed] As a result, they did not use Codd’s own Alpha language but created a non-relational one, SEQUEL. Even so, SEQUEL was so superior to pre-relational systems that it was copied, in 1979, based on pre-launch papers presented at conferences, by Larry Ellison, of Relational Software Inc, in his Oracle Database, which actually reached market before SQL/DS – because of the then-already proprietary status of the original name, SEQUEL had been renamed SQL.\n\n\nCodd continued to develop and extend his relational model, sometimes in collaboration with Christopher J. Date. One of the normalised forms, the Boyce–Codd normal form, is named after him.\n\n\nCodd’s theorem, a result proven in his seminal work on the relational model, equates the expressive power of relational algebra and relational calculus.[14]"
  },
  {
    "objectID": "slides/SQL_7.html#summarizedqta-...-byexpr-dans-dplyr",
    "href": "slides/SQL_7.html#summarizedqta-...-byexpr-dans-dplyr",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "\nsummarize(dqta, ... , by=expr) dans dplyr()\n",
    "text": "summarize(dqta, ... , by=expr) dans dplyr()"
  },
  {
    "objectID": "slides/SQL_7.html#summarize-avec-sélection-bien-tempérée-avec-across...-...",
    "href": "slides/SQL_7.html#summarize-avec-sélection-bien-tempérée-avec-across...-...",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "\nsummarize() avec sélection bien tempérée avec across(..., ...)\n",
    "text": "summarize() avec sélection bien tempérée avec across(..., ...)"
  },
  {
    "objectID": "slides/SQL_7.html#le-problème-group-by-en-sql",
    "href": "slides/SQL_7.html#le-problème-group-by-en-sql",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Le problème GROUP BY en SQL\n",
    "text": "Le problème GROUP BY en SQL"
  },
  {
    "objectID": "slides/SQL_7.html#des-tables-avec-des-domaines-tabulaires",
    "href": "slides/SQL_7.html#des-tables-avec-des-domaines-tabulaires",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Des tables avec des domaines tabulaires",
    "text": "Des tables avec des domaines tabulaires"
  },
  {
    "objectID": "slides/SQL_7.html#group_by-et-les-grouped-tibbles",
    "href": "slides/SQL_7.html#group_by-et-les-grouped-tibbles",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "\ngroup_by() et les grouped tibbles\n",
    "text": "group_by() et les grouped tibbles"
  },
  {
    "objectID": "slides/SQL_7.html#ungroup",
    "href": "slides/SQL_7.html#ungroup",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "ungroup()",
    "text": "ungroup()"
  },
  {
    "objectID": "slides/SQL_7.html#nest-et-unnest",
    "href": "slides/SQL_7.html#nest-et-unnest",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "\nnest() et unnest()\n",
    "text": "nest() et unnest()"
  },
  {
    "objectID": "slides/SQL_7.html#enframe",
    "href": "slides/SQL_7.html#enframe",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "enframe()",
    "text": "enframe()"
  },
  {
    "objectID": "slides/SQL_7.html#références-sur-les-tqbles-partitionnées",
    "href": "slides/SQL_7.html#références-sur-les-tqbles-partitionnées",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Références sur les tqbles partitionnées",
    "text": "Références sur les tqbles partitionnées\ndplyr sur le groupement"
  },
  {
    "objectID": "slides/SQL_7.html#types-de-mises-à-jour-de-tables-en-sql",
    "href": "slides/SQL_7.html#types-de-mises-à-jour-de-tables-en-sql",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Types de mises à jour de tables en SQL\n",
    "text": "Types de mises à jour de tables en SQL\n\n\nmodification du schéma ALTER TABLE ...\n\najout de colonnes\nsuppression de colonnes\nmodification de domaines\n\n\nmodification des lignes\n\nmises à jour d’attributs sur certaines lignes\nsuppression de lignes\ninsertions de lignes"
  },
  {
    "objectID": "slides/SQL_7.html#point-de-vue-fonctionnel",
    "href": "slides/SQL_7.html#point-de-vue-fonctionnel",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Point de vue fonctionnel",
    "text": "Point de vue fonctionnel"
  },
  {
    "objectID": "slides/SQL_7.html#mutate",
    "href": "slides/SQL_7.html#mutate",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "mutate()",
    "text": "mutate()\n\najout de colonnes\nmodification de domaines\nmises à jour d’attributs sur certaines lignes"
  },
  {
    "objectID": "slides/SQL_7.html#ajout-de-lignes",
    "href": "slides/SQL_7.html#ajout-de-lignes",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Ajout de lignes",
    "text": "Ajout de lignes"
  },
  {
    "objectID": "slides/SQL_5.html#trois-objectifs",
    "href": "slides/SQL_5.html#trois-objectifs",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Trois objectifs",
    "text": "Trois objectifs\n\nAutomatisation de taches répétitives (administration)\n\n\nOn veut répéter une même tache sur une collection de schémas\nOn veut traiter une collection de roles\n\n\n\nCalculs impossibles à réaliser en SQL :\n\n\nCalculer la fermeture transitive d’une relation comme film_actors\n\nL’algèbre relationnelle est un modèle de calculabilité restreint·\n\n\nTriggers\n\n\nCertaines contraintes ne peuvent pas être mises en place avec les seules constructions primary key , unique, foreign key, check et exclude (notamment des contraintes d’exclusion qui mettent en jeu plusieurs tables).\nOn peut les maintenir à l’aide de traitements spéciaux : les triggers\n\nLes triggers reposent sur des fonctions spéciales\n\n\nExtensions procédurales de SQL\nplpgsql : Programming Language PostGres SQL"
  },
  {
    "objectID": "slides/SQL_5.html#automatisation-des-tâches-répétitives-deux-outils-nécessaires",
    "href": "slides/SQL_5.html#automatisation-des-tâches-répétitives-deux-outils-nécessaires",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Automatisation des tâches répétitives : deux outils nécessaires",
    "text": "Automatisation des tâches répétitives : deux outils nécessaires\nLorsqu’on administre une base, on doit souvent engendrer des requêtes dynamiques à l’intérieur d’une fonction PL/pgSQL, c’est à dire des commandes qui vont concerner des tables ou des types différents à chaque exécution\nLes requêtes préparées sont alors très utilement combinées avec les structures de contrôle (itérations, alternatives) pour automatiser les tâches !\n\n 2 outils (pour étendre SQL) :\n\nrequêtes dynamiques EXECUTE, PREPARE\n\nstructures de contrôles IF, LOOP, ... Transforment SQL en un langage de programmation"
  },
  {
    "objectID": "slides/SQL_5.html#fonction-inventory_in_stock",
    "href": "slides/SQL_5.html#fonction-inventory_in_stock",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Fonction inventory_in_stock()\n",
    "text": "Fonction inventory_in_stock()\n\nObjectif : calculer si un dvd est en stock ou pas\nUn DVD est en stock\n\ns’il n’a jamais été loué\n\nOU\n\nsi toutes les locations de ce DVD sont déjà terminées (return_date n’est pas nul)\n\n-- AN ITEM IS IN-STOCK IF THERE ARE EITHER NO ROWS IN THE rental TABLE\n-- FOR THE ITEM OR ALL ROWS HAVE return_date POPULATED"
  },
  {
    "objectID": "slides/SQL_5.html#fonction-inventory_in_stock-1",
    "href": "slides/SQL_5.html#fonction-inventory_in_stock-1",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Fonction inventory_in_stock\n",
    "text": "Fonction inventory_in_stock\n\nCREATE OR REPLACE FUNCTION sakila.inventory_in_stock(p_inventory_id integer)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\nDECLARE                 \n    v_rentals INTEGER;  #&lt;&lt;\n    v_out     INTEGER;  #&lt;&lt;\nBEGIN\n    SELECT count(*) INTO v_rentals  #&lt;&lt;\n    FROM rental\n    WHERE inventory_id = p_inventory_id;\n\n    IF v_rentals = 0 THEN   #&lt;&lt;\n      RETURN TRUE;          #&lt;&lt; \n    END IF;                 #&lt;&lt;\n\n    SELECT COUNT(rental_id) INTO v_out     #&lt;&lt; \n    FROM inventory LEFT JOIN rental USING(inventory_id)\n    WHERE inventory.inventory_id = p_inventory_id AND rental.return_date IS NULL;\n\n    IF v_out &gt; 0 THEN\n      RETURN FALSE;\n    ELSE\n      RETURN TRUE;\n    END IF;\nEND $function$ ;"
  },
  {
    "objectID": "slides/SQL_5.html#section",
    "href": "slides/SQL_5.html#section",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "",
    "text": "SELECT ... INTO ...\n\nLe résultat de la requête est ici un entier, il est affecté à une variable locale comme v_rentals, v_out, …\nEn plpgsql, le résultat d’une requête doit être mémorisé ou explicitement négligé en utilisant PERFORM plutôt que SELECT\n\nIF ... THEN ...\n\nAlternative, comme dans un langage de programmation ordinaire\n\nRETURN\n\nRetourne le résultat et termine l’exécution de la fonction"
  },
  {
    "objectID": "slides/SQL_5.html#une-tâche-de-surveillancemaintenance",
    "href": "slides/SQL_5.html#une-tâche-de-surveillancemaintenance",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Une tâche de surveillance/maintenance",
    "text": "Une tâche de surveillance/maintenance\n\nDéterminer pour chaque usager (schéma) le nombre de tuples dans la table ville_pays de cet usager.\nPour chaque schéma schema, on veut évaluer une requête\nSELECT COUNT(*) \nFROM schema.ville_pays ;\nIci schema doit être calculé en interrogeant le SGBD\n\nSituation inédite :\n\ncomment déterminer les schémas pertinents ?"
  },
  {
    "objectID": "slides/SQL_5.html#la-métabase-information_schema-et-pg_catalog",
    "href": "slides/SQL_5.html#la-métabase-information_schema-et-pg_catalog",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "La métabase : information_schema et pg_catalog\n",
    "text": "La métabase : information_schema et pg_catalog\n\nOn va s’aider des tables d’administration du SGBD\nChaque usager correspond à un role et ce rôle correspond dans notre cas à un schema créé à partir du rôle via l’instruction\nCREATE SCHEMA AUTHORIZATION user_name ;\nOn a envie d’écrire une requête comme\nSELECT COUNT(*) FROM username.tournaments ; \noù username est collectée à partir de\nSELECT usename  FROM pg_catalog.pg_user ;"
  },
  {
    "objectID": "slides/SQL_5.html#deux-schémas-pour-ladministration-la-métabase",
    "href": "slides/SQL_5.html#deux-schémas-pour-ladministration-la-métabase",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Deux schémas pour l’administration : la métabase\n",
    "text": "Deux schémas pour l’administration : la métabase\n\n\ninformation_schema\n\nCe schema contient l’information sur les schémas du cluster/catalogue :\n\nles définitions de tables, de vues, de colonnes, les contraintes, …\nil est formé de tables et surtout de (très nombreuses) vues\nles instructions, CREATE, ALTER,  DROP modifient le contenu de ce schéma (une seule instruction ALTER  TABLE peut engendrer plusieurs mises à jours dans les tables de information_schema\n\n\n\npg_catalog\n\nCe schema contient lui aussi beaucoup de tables et de vues utiles au fonctionnement du serveur"
  },
  {
    "objectID": "slides/SQL_5.html#exemple-de-vue-de-pg_catalog-pg_user",
    "href": "slides/SQL_5.html#exemple-de-vue-de-pg_catalog-pg_user",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Exemple de vue de pg_catalog : pg_user\n",
    "text": "Exemple de vue de pg_catalog : pg_user\n\n\n\nSchéma\n+--------------+---------+-------------+\n| Column       | Type    | Modifiers   |\n|--------------+---------+-------------|\n| usename      | name    |             |\n| usesysid     | oid     |             |\n| usecreatedb  | boolean |             |\n| usesuper     | boolean |             |\n| userepl      | boolean |             |\n| usebypassrls | boolean |             |\n| passwd       | text    |             |\n| valuntil     | abstime |             |\n| useconfig    | text[]  |             |\n+--------------+---------+-------------+\n\npg_user nous renseigne sur :\n\n\n les usagers (usename)\n\n leur statut (usesuper : super-utilisateur ou pas)\n\n leurs privilèges (createdb : peut créer une base ou non)"
  },
  {
    "objectID": "slides/SQL_5.html#autre-exemple-dusage-de-la-métabase",
    "href": "slides/SQL_5.html#autre-exemple-dusage-de-la-métabase",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Autre exemple d’usage de la métabase",
    "text": "Autre exemple d’usage de la métabase\nSELECT datname, application_name, client_addr, backend_start, state \nFROM pg_catalog.pg_stat_activity psa \nWHERE datname='bd_2023';                                               \n\n+-----------+-------------------------------------------+---------------+-------------------------------+---------+\n| datname   | application_name                          | client_addr   | backend_start                 | state   |\n|-----------+-------------------------------------------+---------------+-------------------------------+---------|\n| bd_2023   | DBeaver 22.2.0 - Main &lt;bd_2023&gt;           | 127.0.0.1     | 2022-10-04 22:48:59.57231+02  | idle    |\n| bd_2023   | DBeaver 22.2.0 - Metadata &lt;bd_2023&gt;       | 127.0.0.1     | 2022-10-04 22:48:59.693656+02 | idle    |\n| bd_2023   | DBeaver 22.2.0 - SQLEditor &lt;Script-4.sql&gt; | 127.0.0.1     | 2022-10-04 22:48:59.958616+02 | idle    |\n| bd_2023   | pgcli                                     | &lt;null&gt;        | 2022-10-04 23:23:19.739258+02 | active  |\n| bd_2023   | pgcli                                     | &lt;null&gt;        | 2022-10-04 23:23:19.770006+02 | idle    |\n+-----------+-------------------------------------------+---------------+-------------------------------+---------+"
  },
  {
    "objectID": "slides/SQL_5.html#tentative",
    "href": "slides/SQL_5.html#tentative",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Tentative",
    "text": "Tentative\nOn engendre dynamiquement une série de requêtes par une instruction de la forme :\nSELECT \n    'SELECT ' || quote_literal(usename) || ', COUNT(*)  FROM ' || usename || '.ville_pays ;'\nFROM pg_catalog.pg_user  ;\n A quoi sert quote_literal() ?"
  },
  {
    "objectID": "slides/SQL_5.html#le-résultat-est-une-table-de-chaines-de-caractères",
    "href": "slides/SQL_5.html#le-résultat-est-une-table-de-chaines-de-caractères",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Le résultat est une table de chaines de caractères",
    "text": "Le résultat est une table de chaines de caractères\nrqt                                                      |\n---------------------------------------------------------+\nSELECT 'postgres', COUNT(*)  FROM postgres.ville_pays ;  |\nSELECT 'shinken', COUNT(*)  FROM shinken.ville_pays ;    |\nSELECT 'aalahy99', COUNT(*)  FROM aalahy99.ville_pays ;  |\nSELECT 'etemam', COUNT(*)  FROM etemam.ville_pays ;      |\nSELECT 'durand', COUNT(*)  FROM durand.ville_pays ;      |\n...\n\nTel quel, cela ne fonctionnera pas !\n\nIl faut pouvoir confier ces chaines de caractères à l’évaluateur de requêtes\nIl faut pouvoir le faire pour chacune des chaines de caractères produites par la requête (itérer)"
  },
  {
    "objectID": "slides/SQL_5.html#mode-opératoire",
    "href": "slides/SQL_5.html#mode-opératoire",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Mode opératoire",
    "text": "Mode opératoire\nCREATE OR REPLACE FUNCTION taille_ville_pays()\nLANGUAGE plpgsql RETURNS  TEXT AS\n$$\nDECLARE\n  stmt CHARACTER VARYING ;\n  usename CHARACTER VARYING ;\n  result CHARACTER VARYING    := '' ;\n  resp CHARACTER VARYING := '' ;\nBEGIN\nFOR usename IN SELECT u.usename  #&lt;&lt;\n  FROM pg_catalog.pg_user AS u JOIN\n  information_schema.tables t ON\n  (u.usename=t.table_schema and t.table_name ='ville_pays')\nLOOP\n  stmt = 'SELECT CAST(COUNT(*) AS VARCHAR) FROM '|| usename||'.ville_pays #&lt;&lt;\n  result:=result || usename || ': ' ||resp| '; ';   #&lt;&lt; \nEND LOOP ;\nRETURN result ; #&lt;&lt; \nEND;$$ ;"
  },
  {
    "objectID": "slides/SQL_5.html#extension-de-sql",
    "href": "slides/SQL_5.html#extension-de-sql",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Extension de SQL",
    "text": "Extension de SQL\nA travers ces deux exemples, on a vu quelques particularités des extensions possible de SQL en un langage procédural pgplSQL. Le principe est le même dans la plupart des SGBD permettant une telle extension (Oracle, SQL Server, …). Il repose sur la norme SQL.\nOn a besoin :\n\nd’instructions conditionnelles (si … alors … sinon)\nd’instruction itératives (boucles)\nde la capacité à définir des variables\n\nde mécanismes d’articulations entre SQL et son extension procédurale :\n\nPouvoir stocker le résultat d’une requête (avec résultat unique) dans une variable\nPouvoir stocker, les uns après les autres, les résultats d’une requêtes complexes pour traitement, définir un curseur (CURSOR)"
  },
  {
    "objectID": "slides/SQL_5.html#extension-de-sql-1",
    "href": "slides/SQL_5.html#extension-de-sql-1",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Extension de SQL",
    "text": "Extension de SQL\nOn doit avoir un mécanisme qui permet conserver les programmes écrits pour les utiliser lors de sessions futures\nLe langage plpgsql permet :\n\nde définir des fonctions et procédures stockées…\nqui vont avoir la même persistence que les tables, vues, etc\nL’existence de ces fonctions, leurs codes, etc, seront conservés dans des tables et vue d’administration (information_schema.routines)."
  },
  {
    "objectID": "slides/SQL_5.html#exemple",
    "href": "slides/SQL_5.html#exemple",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Exemple",
    "text": "Exemple\nSELECT routine_catalog, routine_schema, routine_name, data_type, security_type\nFROM information_schema.routines    #&lt;&lt; \nWHERE routine_type='FUNCTION' AND specific_schema='sakila'   #&lt;&lt; \n\nroutine_catalog|routine_schema|routine_name              |data_type   |security_type|\n---------------+--------------+--------------------------+------------+-------------+\nbd_2023        |sakila        |_group_concat             |text        |INVOKER      |\nbd_2023        |sakila        |film_in_stock             |integer     |INVOKER      |\nbd_2023        |sakila        |film_not_in_stock         |integer     |INVOKER      |\nbd_2023        |sakila        |get_customer_balance      |numeric     |INVOKER      |\nbd_2023        |sakila        |inventory_held_by_customer|integer     |INVOKER      |\nbd_2023        |sakila        |inventory_in_stock        |boolean     |INVOKER      |\nbd_2023        |sakila        |last_day                  |date        |INVOKER      |\nbd_2023        |sakila        |last_updated              |trigger     |INVOKER      |\nbd_2023        |sakila        |rewards_report            |USER-DEFINED|DEFINER      |"
  },
  {
    "objectID": "slides/SQL_5.html#rewards_report-signature",
    "href": "slides/SQL_5.html#rewards_report-signature",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "\nrewards_report signature",
    "text": "rewards_report signature\nCREATE OR REPLACE FUNCTION \n    sakila.rewards_report(min_monthly_purchases integer, \n                          min_dollar_amount_purchased numeric)\n RETURNS SETOF sakila.customer\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    last_month_start DATE;\n    last_month_end DATE;\nrr RECORD;\ntmpSQL TEXT;\nBEGIN\n...\nEND $$ ;\nDétermine la liste des bons clients qui beaucoup consommé durant le dernier mois écoulé"
  },
  {
    "objectID": "slides/SQL_5.html#section-1",
    "href": "slides/SQL_5.html#section-1",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "",
    "text": "la signature comporte une déclaration de type originale\nla déclaration des variables locales mentionne un type fourre-tout\n\nSETOF customer\nTable de même schéma que customer (mêmes colonnes)\nConstruction très très utile : SETOF nom_de_table\nRECORD\nUn type générique (fourre-tout) pour désigner les types composés (en particulier comme les types définis à partir des tables)"
  },
  {
    "objectID": "slides/SQL_5.html#rewards_report-corps-i",
    "href": "slides/SQL_5.html#rewards_report-corps-i",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "\nrewards_report corps (I)",
    "text": "rewards_report corps (I)\nBEGIN\n    /* Some sanity checks... */\n    IF min_monthly_purchases = 0 THEN\n        RAISE EXCEPTION 'Minimum monthly purchases parameter must be &gt; 0';\n    END IF;\n    IF min_dollar_amount_purchased = 0.00 THEN\n        RAISE EXCEPTION 'Minimum monthly dollar amount purchased parameter must be &gt; $0.00';  #&lt;&lt; \n    END IF;\n\n    last_month_start := CURRENT_DATE - '3 month'::interval;\n    last_month_start := to_date((extract(YEAR FROM last_month_start) || '-' || extract(MONTH FROM last_month_start) || '-01'),'YYYY-MM-DD');\n    last_month_end := LAST_DAY(last_month_start);\n...\n\n RAISE EXCEPTION 'msg'\ntermine (en erreur) l’exécution de la fonction envoie un message d’erreur"
  },
  {
    "objectID": "slides/SQL_5.html#rewards_report-corps-ii",
    "href": "slides/SQL_5.html#rewards_report-corps-ii",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "\nrewards_report corps (II)",
    "text": "rewards_report corps (II)\n/*\n    Create a temporary storage area for Customer IDs.\n    */\n    CREATE TEMPORARY TABLE tmpCustomer (customer_id INTEGER NOT NULL PRIMARY KEY);\n\n    /*\n    Find all customers meeting the monthly purchase requirements\n    */\n\n    tmpSQL := 'INSERT INTO tmpCustomer (customer_id)\n        SELECT p.customer_id\n        FROM payment AS p\n        WHERE DATE(p.payment_date) BETWEEN '|| quote_literal(last_month_start) ||' AND '|| quote_literal(last_month_end) || '\n        GROUP BY customer_id\n        HAVING SUM(p.amount) &gt; ' || min_dollar_amount_purchased || \n        'AND COUNT(customer_id) &gt; ' || \n        min_monthly_purchases ;\n\n    EXECUTE tmpSQL;  #&lt;&lt;"
  },
  {
    "objectID": "slides/SQL_5.html#create-temporary-table-...",
    "href": "slides/SQL_5.html#create-temporary-table-...",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "\n CREATE TEMPORARY TABLE ...\n",
    "text": "CREATE TEMPORARY TABLE ...\n\nCrée une table (très simple ici) qui sera détruite avant la fin de l’exécution de la fonction.\nSi l’exécution de la fonction devait être interrompue, cette table ne survivrait pas à la session qui a invoqué la fonction"
  },
  {
    "objectID": "slides/SQL_5.html#pourquoi-utiliser-une-requête-créée-dynamiquement",
    "href": "slides/SQL_5.html#pourquoi-utiliser-une-requête-créée-dynamiquement",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Pourquoi utiliser une requête créée dynamiquement ?",
    "text": "Pourquoi utiliser une requête créée dynamiquement ?\n\nEst ce une nécessité ici ?\nSi non, quel est l’intérêt ?"
  },
  {
    "objectID": "slides/SQL_5.html#rewards_report-corps-iii",
    "href": "slides/SQL_5.html#rewards_report-corps-iii",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "\nrewards_report corps III",
    "text": "rewards_report corps III\n/*\n    Output ALL customer information of matching rewardees.\n    Customize output as needed.\n    */\n    FOR rr IN EXECUTE 'SELECT c.* FROM tmpCustomer AS t INNER JOIN customer AS c ON t.customer_id = c.customer_id' LOOP\n        RETURN NEXT rr;   #&lt;&lt;\n    END LOOP;\n\n    /* Clean up */\n    tmpSQL := 'DROP TABLE tmpCustomer';\n    EXECUTE tmpSQL;\n\nRETURN;   #&lt;&lt;\nEND\n$function$ ;"
  },
  {
    "objectID": "slides/SQL_3.html#limite-de-lalgèbre-relationnelle-pure",
    "href": "slides/SQL_3.html#limite-de-lalgèbre-relationnelle-pure",
    "title": "BD IV: SQL III",
    "section": "Limite de l’algèbre relationnelle pure",
    "text": "Limite de l’algèbre relationnelle pure\nL’algèbre relationnelle pure (σ, π, ⋈) ne sait pas tout calculer.\nCertains problèmes aisément solubles par un langage de programmation complet (Python, C, R, …) ne sont pas solubles dans l’algèbre relationnelle pure :\n\ncompter. Exemple simple : calculer le nombre de lignes d’une table.\ndans une table décrivant une arborescence (une organisation hiérarchisée), déterminer tous les descendants d’un enregistrement."
  },
  {
    "objectID": "slides/SQL_3.html#fonctions-dagrégation-1",
    "href": "slides/SQL_3.html#fonctions-dagrégation-1",
    "title": "BD IV: SQL III",
    "section": "Fonctions d’agrégation ?",
    "text": "Fonctions d’agrégation ?\nPossibilité de compter, de faire des moyennes, de trouver un maximum, … en SQL (contrairement à l’algèbre relationnelle “classique”)."
  },
  {
    "objectID": "slides/SQL_3.html#extension-possible-de-lalgèbre-relationnelle",
    "href": "slides/SQL_3.html#extension-possible-de-lalgèbre-relationnelle",
    "title": "BD IV: SQL III",
    "section": "Extension possible de l’algèbre relationnelle",
    "text": "Extension possible de l’algèbre relationnelle\n\n\n\n\n\n\nIdée\n\n\nIntroduire un opérateur \\(Résume()\\) qui admet comme arguments une table \\(T\\) et une suite d’expressions susceptibles de calculer des agrégats : moyenne, somme, comptage, etc.\nProposition de syntaxe :\n\\(Résume(T, expr_1, ..., expr_k)\\) retourne une table \\(S\\) à une ligne et \\(k\\) colonnes.\nLa colonne \\(i\\) de \\(S\\) contient l’évaluation de \\(expr_i\\) sur la table \\(T\\).\n\n\n\n\n\n\n\n\n\nAvertissement\n\n\nIl n’est pas évident de définir ce que peut être une fonction d’agrégation et un agrégat.\nNous travaillerons à partir d’exemples."
  },
  {
    "objectID": "slides/SQL_3.html#fonctions-dagrégation-sum-et-avg",
    "href": "slides/SQL_3.html#fonctions-dagrégation-sum-et-avg",
    "title": "BD IV: SQL III",
    "section": "Fonctions d’agrégation SUM et AVG\n",
    "text": "Fonctions d’agrégation SUM et AVG\n\n\nSomme des valeurs prises par nomattribut\n\n\nRésume(T, SOMME(nomattribut))\nse traduit en\nSELECT \n  SUM ([DISTINCT|ALL] &lt;nomattribut&gt;)  \nFROM T\n\n\nMoyenne des valeurs prises par nomattribut\n\n\nRésume(T, MOYENNE(nomattribut))\nse traduit en\nSELECT \n  AVG ([DISTINCT|ALL] &lt;nom_attribut&gt;) \nFROM T\n\n\n\n\n\n\nAvertissement\n\n\nLe type de l’attribut doit correspondre à un nombre (cf. spécifications de chaque fonction dans la documentation)."
  },
  {
    "objectID": "slides/SQL_3.html#options-all-et-distinct-des-fonctions-dagrégation",
    "href": "slides/SQL_3.html#options-all-et-distinct-des-fonctions-dagrégation",
    "title": "BD IV: SQL III",
    "section": "Options ALL et DISTINCT des fonctions d’agrégation",
    "text": "Options ALL et DISTINCT des fonctions d’agrégation\nCes options sont disponibles pour toutes les fonctions\nmais sont surtout utiles pour COUNT :\n\nALL, option par défaut : toutes les valeurs de la colonne sont utilisées,\nDISTINCT : les valeurs doublons ne sont utilisées qu’une fois."
  },
  {
    "objectID": "slides/SQL_3.html#exemples-avec-sum-et-avg",
    "href": "slides/SQL_3.html#exemples-avec-sum-et-avg",
    "title": "BD IV: SQL III",
    "section": "Exemples avec SUM et AVG\n",
    "text": "Exemples avec SUM et AVG\n\n\nSomme des populations des villes du pays de code FRA (dans le schéma world).\n\nSELECT SUM(population)  \nFROM city \nWHERE countrycode = 'FRA';\nTraduction de\n\nR1 = σ(city, countrycode = 'FRA')\nR = Résume(R1, SOMME(population))\n\n\n\nMoyenne des populations des villes du continent Europe et Afrique.\n\nSELECT AVG(ci.population)  \nFROM city ci join country co on ci.countrycode = co.countrycode\nWHERE co.continent in ('Afrique','Europe');\nTraduction de\n\nR1 = ⋈(city, country, city.countrycode = country.countrycode)\nR2 = σ(R1, continent in ('Afrique','Europe'))\nR = Résume(R1, avg(population))"
  },
  {
    "objectID": "slides/SQL_3.html#fonctions-de-calcul-max-min",
    "href": "slides/SQL_3.html#fonctions-de-calcul-max-min",
    "title": "BD IV: SQL III",
    "section": "Fonctions de calcul MAX, MIN\n",
    "text": "Fonctions de calcul MAX, MIN\n\n\nmaximum des valeurs prises par &lt;nomattribut&gt; dans T :\n\nSELECT \n  MAX (&lt;nomattribut&gt;)  \nFROM T ;\n\n\nminimum des valeurs prises par &lt;nomattribut&gt; dans T :\n\nSELECT \n  MIN (&lt;nomattribut&gt;)  \nFROM T \n\n\nExemple :\nSELECT max(gnp)   \nFROM country \nWHERE region = 'Caribbean';"
  },
  {
    "objectID": "slides/SQL_3.html#gestion-des-données-manquantes-null",
    "href": "slides/SQL_3.html#gestion-des-données-manquantes-null",
    "title": "BD IV: SQL III",
    "section": "Gestion des données manquantes (NULL)",
    "text": "Gestion des données manquantes (NULL)\n\nEn statistique : données manquantes prises en compte dans les fonctions d’agrégation.\n\nEn SQL : données manquantes ignorées dans les fonctions d’agrégation,\nà l’exception de COUNT(*).\n\n\n\nSELECT name_country, gnpold, gnp\nFROM country\nWHERE continent = 'Europe' AND (gnp IS NULL OR gnpold IS NULL)\nRésultat : 10 lignes.\n\n\nPourtant, ces données manquantes n’empèchent pas le calcul du maximum sur ces colonnes.\nSELECT max(gnpold) AS max_gnpold, max(gnp) AS max_gnp   \nFROM country \nWHERE continent  = 'Europe';\n+-------------+------------+\n|  max_gnpold |  max_gnp   |\n+-------------+------------+\n|  2102826.00 | 2133367.00 |\n+-------------+------------+"
  },
  {
    "objectID": "slides/SQL_3.html#fonction-dagrégation-sur-des-valeurs-toutes-null",
    "href": "slides/SQL_3.html#fonction-dagrégation-sur-des-valeurs-toutes-null",
    "title": "BD IV: SQL III",
    "section": "Fonction d’agrégation sur des valeurs toutes NULL\n",
    "text": "Fonction d’agrégation sur des valeurs toutes NULL\n\n\n\n\n\n\n\nAvertissement\n\n\nQue se passe-t-il si, après une éventuelle sélection, toutes les valeurs de du calcul d’agrégat sont NULL ?\nLa valeur calculée est alors NULL, ce qui signifie “pas de valeur”.\nEssayez SELECT MIN(gnpold) FROM country WHERE gnpold IS NULL; !"
  },
  {
    "objectID": "slides/SQL_3.html#fonction-dagrégation-sur-une-table-vide",
    "href": "slides/SQL_3.html#fonction-dagrégation-sur-une-table-vide",
    "title": "BD IV: SQL III",
    "section": "Fonction d’agrégation sur une table vide",
    "text": "Fonction d’agrégation sur une table vide\n\n\n\n\n\n\nAvertissement\n\n\nLes fonctions d’agrégation renvoie un scalaire même sur une table vide.\nPour une table vide, la valeur calculée est NULL.\n\n\n\n\nSELECT \n  SUM(population) AS urban_pop\nFROM city  ci\nWHERE ci.countrycode = 'zzz' ;\n\n\n+-----------+\n| urban_pop |\n|-----------|\n| &lt;null&gt;    |\n+-----------+\nEst-ce cohérent?\nLe résultat signifie : “Pour le pays de code ‘zzz’, pas de données”"
  },
  {
    "objectID": "slides/SQL_3.html#fonctions-de-calcul-count",
    "href": "slides/SQL_3.html#fonctions-de-calcul-count",
    "title": "BD IV: SQL III",
    "section": "Fonctions de calcul : COUNT\n",
    "text": "Fonctions de calcul : COUNT\n\nOn peut aussi compter le nombre de tuples d’une table :\nSELECT \n  COUNT(* |[ALL | DISTINCT] &lt;nomattribut&gt;)  \nFROM T\n-- | pour indiquer une alternative, [ ] pour une option.\n\n\n\n\n\n\nNote\n\n\nOptions de la fonction COUNT :\n\n\n* : compte le nombre de lignes dans la table ou la sous-requête, en incluant les valeurs NULL.\n\nDISTINCT : sans les doublons et sans les valeurs NULL,\n\nALL : avec les doublons mais sans les valeurs NULL,\n\nSi la table est vide, COUNT renvoie 0.\n\n\n\n\nNombre de pays dans la région Carribean\nSELECT COUNT(*)  \nFROM country\nWHERE region = 'Caribbean';"
  },
  {
    "objectID": "slides/SQL_3.html#exemples-dutilisation-des-options-de-la-fonction-count",
    "href": "slides/SQL_3.html#exemples-dutilisation-des-options-de-la-fonction-count",
    "title": "BD IV: SQL III",
    "section": "Exemples d’utilisation des options de la fonction COUNT\n",
    "text": "Exemples d’utilisation des options de la fonction COUNT\n\nSELECT COUNT(*) FROM country;\nretourne 239, le nombre de lignes de la table country.\n\n \nSELECT COUNT (indepyear) FROM country;\nSELECT COUNT (ALL indepyear) FROM country;\nretournent 192, le nombre de valeurs non NULL de la colonne indepyear.\n\n\n \nSELECT COUNT (DISTINCT indepyear) FROM country;\nretourne 88, le nombre de valeurs disctintes et non NULL de la colonne indepyear.\n\n\n \nSELECT COUNT(*) FROM (SELECT indepyear FROM country) as T;\nretourne 239 car T contient une seule colonne avec 239 lignes, les 47 lignes NULL sont comptées comme les autres."
  },
  {
    "objectID": "slides/SQL_3.html#opérations-sur-des-fonctions-dagrégation",
    "href": "slides/SQL_3.html#opérations-sur-des-fonctions-dagrégation",
    "title": "BD IV: SQL III",
    "section": "Opérations sur des fonctions d’agrégation",
    "text": "Opérations sur des fonctions d’agrégation\nPNB moyen par habitant du continent South America\nSELECT \n  ROUND(SUM(1e6*gnp)/SUM(population_country),2) as pnb_avg\nFROM \n  country \nWHERE \n  continent = 'South America';\nRésultat : 4372,36\n\n\n\n\n\n\nNote\n\n\n\\(10^6\\) s’écrit 1e6. On a écrit 1e6*gnp car gnp est exprimé en millions de USD.\nROUND(x,s) effectue un arrondi de x avec s chiffres après la virgule. s négatif accepté.\nDocumentation des fonctions mathématiques"
  },
  {
    "objectID": "slides/SQL_3.html#fonctions-dagrégation-sur-des-opérations",
    "href": "slides/SQL_3.html#fonctions-dagrégation-sur-des-opérations",
    "title": "BD IV: SQL III",
    "section": "Fonctions d’agrégation sur des opérations",
    "text": "Fonctions d’agrégation sur des opérations\n\n\n\n\n\n\nNote\n\n\nLes fonctions d’agrégation peuvent s’appliquer à des opérations arithmétiques entre les différents attributs d’un même tuple…\n\n\n\n\nMoyenne des PNB/habitant des pays du continent ‘South America’. A ne pas confondre avec la requête précédente !\nSELECT \n  ROUND(AVG(1e6*gnp/population_country),2) as pnb_country_avg\nFROM country \nWHERE \n  continent = 'South America' AND population_country &gt; 0 ;\n-- Le test population_country &gt; 0 évite les divisions par 0\nRésultat : 3176,44"
  },
  {
    "objectID": "slides/SQL_3.html#utilisation-de-case-when-...then-...-else-...-end",
    "href": "slides/SQL_3.html#utilisation-de-case-when-...then-...-else-...-end",
    "title": "BD IV: SQL III",
    "section": "Utilisation de CASE WHEN ...THEN ... [ELSE ...] END\n",
    "text": "Utilisation de CASE WHEN ...THEN ... [ELSE ...] END\n\nDans une fonction d’agrégation, une expression CASE WHEN teste des conditions sur le tuple courant et renvoie la valeur correspondant à la première condition vraie.\nCASE\n    WHEN condition1 THEN result1\n    [WHEN condition2 THEN result2]\n    [WHEN conditionN THEN resultN]\n    [ELSE result]\nEND;\n\n\n\n\n\n\nAvertissement\n\n\nSi aucune condition n’est vraie et qu’il n’y pas de clause ELSE, CASE retourne NULL.\n\n\n\nSELECT \n  SUM(\n    CASE \n      WHEN countrycode='GBR' THEN population \n    END) AS urban_pop \n FROM city ;\n+-----------+\n| urban_pop |\n|-----------|\n| 22436673  |\n+-----------+"
  },
  {
    "objectID": "slides/SQL_3.html#gestion-des-valeurs-manquantes-avec-case-when-...then-...-else-...-end",
    "href": "slides/SQL_3.html#gestion-des-valeurs-manquantes-avec-case-when-...then-...-else-...-end",
    "title": "BD IV: SQL III",
    "section": "Gestion des valeurs manquantes avec CASE WHEN ...THEN ... [ELSE ...] END\n",
    "text": "Gestion des valeurs manquantes avec CASE WHEN ...THEN ... [ELSE ...] END\n\nSELECT \n  AVG(\n    CASE \n      WHEN gnpold IS NOT NULL THEN gnpold \n      ELSE 0 \n    END)::NUMERIC(8,2) AS avg_gnpold \n FROM world.country \n WHERE continent = 'Europe';\nRetourne 203956,54\nSELECT \n  AVG(gnpold)::NUMERIC(8,2) AS avg_gnpold \n FROM world.country \n WHERE continent = 'Europe';\nRetourne 260611,14"
  },
  {
    "objectID": "slides/SQL_3.html#autres-possibilités-avec-case-when-...then-...-else-...-end",
    "href": "slides/SQL_3.html#autres-possibilités-avec-case-when-...then-...-else-...-end",
    "title": "BD IV: SQL III",
    "section": "Autres possibilités avec CASE WHEN ...THEN ... [ELSE ...] END\n",
    "text": "Autres possibilités avec CASE WHEN ...THEN ... [ELSE ...] END\n\nSELECT \n  SUM(CASE \n    WHEN governmentform LIKE '%Monarchy%' THEN population_COUNTRY \n    ELSE 0    -- résultat identique si on enlève cette ligne\n  END) AS pop_monarch,  \n  SUM(CASE \n    WHEN governmentform LIKE '%Republic%' THEN population_COUNTRY \n    ELSE 0   -- résultat identique si on enlève cette ligne\n  END) AS pop_repu \nFROM country ;\n+-------------+------------+\n| pop_monarch | pop_repu   |\n|-------------+------------|\n| 519485000   | 5502453700 |\n+-------------+------------+"
  },
  {
    "objectID": "slides/SQL_3.html#agrégats-sur-des-données-filtrées-filter-where-condition",
    "href": "slides/SQL_3.html#agrégats-sur-des-données-filtrées-filter-where-condition",
    "title": "BD IV: SQL III",
    "section": "Agrégats sur des données filtrées FILTER (WHERE condition)\n",
    "text": "Agrégats sur des données filtrées FILTER (WHERE condition)\n\nAvec une clause FILTER, la fonction d’agrégation n’utilise que les tuples vérifiant la condition.\n\n\nSELECT \n  SUM(population_country) FILTER  \n    (WHERE governmentform LIKE '%Monarchy%') AS pop_monarch,  \n  SUM(population_country) FILTER \n    (WHERE governmentform LIKE '%Republic%') AS pop_repu \nFROM country ;\n\n+-------------+------------+\n| pop_monarch | pop_repu   |\n|-------------+------------|\n| 519485000   | 5502453700 |\n+-------------+------------+\n\n\n\n\n\n\n\n\nMise en garde\n\n\nIl est plus conforme à l’algèbre relationnelle et au SQL d’organiser les données en lignes.\n\n\n\n\n\nSELECT 'Monarchy' as governmentform, SUM(population_country) as population    \nFROM world.country c\nWHERE c.governmentform LIKE '%Monarchy%'\nUNION\nSELECT 'Republic' as governmentform, SUM(population_country) as population    \nFROM world.country c\nWHERE c.governmentform LIKE '%Republic%';\n\n+----------------+------------+\n| governmentform | population |\n|----------------+------------|\n| Monarchy       |  519485000 |\n|----------------+------------|\n| Republic       | 5502453700 |\n+----------------+------------+"
  },
  {
    "objectID": "slides/SQL_3.html#problèmes-defficacité",
    "href": "slides/SQL_3.html#problèmes-defficacité",
    "title": "BD IV: SQL III",
    "section": "Problèmes d’efficacité",
    "text": "Problèmes d’efficacité\nNom des régions comportant plus de \\(15\\) pays.\n\nLa requête suivante est à éviter :\nSELECT DISTINCT c.region \nFROM country c \nWHERE (\n  SELECT COUNT (*)     \n  FROM country co     \n  WHERE co.region = c.region\n) &gt;= 15\nORDER BY c.region;  \n5 lignes.\n\n\n\n\n\n\nMise en garde\n\n\nY-a-t-il des calculs effectués plusieurs fois sur les mêmes données ?"
  },
  {
    "objectID": "slides/SQL_3.html#efficacité",
    "href": "slides/SQL_3.html#efficacité",
    "title": "BD IV: SQL III",
    "section": "Efficacité",
    "text": "Efficacité\n On peut faire plus efficace, gràce à la suite du cours :\nSELECT region    \nFROM country     \nGROUP BY region\nHAVING COUNT(*) &gt;= 15\nORDER BY region;"
  },
  {
    "objectID": "slides/SQL_3.html#pour-en-savoir-plus",
    "href": "slides/SQL_3.html#pour-en-savoir-plus",
    "title": "BD IV: SQL III",
    "section": "Pour en savoir plus ?",
    "text": "Pour en savoir plus ?\nDocumentation PostgreSQL"
  },
  {
    "objectID": "slides/SQL_3.html#partition-de-résultats-de-requêtes",
    "href": "slides/SQL_3.html#partition-de-résultats-de-requêtes",
    "title": "BD IV: SQL III",
    "section": "Partition de résultats de requêtes",
    "text": "Partition de résultats de requêtes\nGROUP BY &lt;nomattribut1&gt;, ..., &lt;nomattributn&gt;\n\nGROUP BY permet de regrouper l’ensemble des résultats d’une requête selon la valeur de certains attributs,\nForme des sous-relations auxquelles on peut appliquer des fonctions d’agrégation (SUM, MAX, …) renvoyant un résultat par sous-relation.\n\n\n\n\n\n\n\n\nAvertissement\n\n\nGestion des valeurs manquantes : les valeurs NULLd’un attribut forment un groupe dans la partition selon celui-ci."
  },
  {
    "objectID": "slides/SQL_3.html#utilisation-group-by",
    "href": "slides/SQL_3.html#utilisation-group-by",
    "title": "BD IV: SQL III",
    "section": "Utilisation GROUP BY\n",
    "text": "Utilisation GROUP BY\n\nCalculer la population de chaque continent.\nSELECT continent, SUM(population_country) as population_continent\nFROM country \nGROUP BY continent;    \n+--------------+----------------------+\n| continent    | population_continent |\n+--------------+----------------------+\n|Asia          |          3705025700  |\n|South America |           345780000  |\n|North America |           482993000  |\n|Oceania       |            30401150  |\n|Antarctica    |                   0  |\n|Africa        |           784475000  |\n|Europe        |           730074600  |\n+--------------+----------------------+\n\n\n\n\n\n\n\nImportant\n\n\nOn peut afficher continent pour chaque groupe parce qu’on a groupé selon cet attribut"
  },
  {
    "objectID": "slides/SQL_3.html#exemple-avec-group-by",
    "href": "slides/SQL_3.html#exemple-avec-group-by",
    "title": "BD IV: SQL III",
    "section": "Exemple avec GROUP BY\n",
    "text": "Exemple avec GROUP BY\n\nQuel est le gnp moyen, le gnp maximum et le gnp minimum par region sur le continent Europe en milliers de USD par habitant ?\n\nSELECT region, \n     ROUND(1000 * SUM(gnp)/SUM(population_country),2) AS avg_gnp,  \n     ROUND(MAX(1000* gnp/population_country),2) AS max_gnp, \n     ROUND(MIN(1000* gnp/population_country),2) AS min_gnp,\nFROM country \nWHERE continent = 'Europe' \nGROUP BY region \nORDER BY avg_gnp DESC;\n+----------------+---------+---------+---------+\n| region         | avg_gnp | max_gnp | min_gnp |\n+----------------+---------+---------+---------+\n|Nordic Countries|   28.00 |   32.66 |    0.00 |\n|Western Europe  |   25.50 |   37.46 |   22.82 | \n|British Islands |   22.94 |   23.12 |   20.11 | \n|Southern Europe |   13.91 |   20.90 |    0.72 | \n|Baltic Countries|    2.96 |    3.70 |    2.64 |\n|Eastern Europe  |    2.15 |    5.35 |    0.36 |\n+----------------+---------+---------+---------+"
  },
  {
    "objectID": "slides/SQL_3.html#précautions-avec-group-by",
    "href": "slides/SQL_3.html#précautions-avec-group-by",
    "title": "BD IV: SQL III",
    "section": "Précautions avec GROUP BY\n",
    "text": "Précautions avec GROUP BY\n\nPour chaque région, indiquer le continent, la région et la population du pays le plus peuplé.\nLa requête suivante n’est pas correcte\nSELECT continent, region, MAX(population_country) \nFROM country \nGROUP BY region;\n\n\n\n\n\n\n\nImportant\n\n\nLes attributs présents dans le SELECT doivent impérativement être présents dans le GROUP BY pour s’assurer qu’ils sont communs à tous les tuples de chaque groupe."
  },
  {
    "objectID": "slides/SQL_3.html#comment-afficher-un-attribut-absent-de-group-by",
    "href": "slides/SQL_3.html#comment-afficher-un-attribut-absent-de-group-by",
    "title": "BD IV: SQL III",
    "section": "Comment afficher un attribut absent de GROUP BY ?",
    "text": "Comment afficher un attribut absent de GROUP BY ?\nPour chaque continent, indiquer le nom et la population du (des) pays le(s) plus peuplé(s).\n\n\n\n\n\n\n\nMise en garde\n\n\nOn ne peut pas utiliser une seule requête puisqu’on veut afficher les pays sans grouper selon les pays. Il faut donc faire les calculs d’agrégats dans une sous-requête.\nPréférez les CTEs (ou éventuellement les requêtes imbriquées dans FROM), plus efficaces que les requêtes imbriquées dans WHERE qui sont ré-exécutées inutilement."
  },
  {
    "objectID": "slides/SQL_3.html#solution",
    "href": "slides/SQL_3.html#solution",
    "title": "BD IV: SQL III",
    "section": "Solution",
    "text": "Solution\nWITH pmc AS\n  (SELECT continent, MAX(population_country) AS pop_max\n  FROM country\n  GROUP BY continent)\nSELECT c.continent, c.name_country AS country_max_pop, c.population_country AS population\nFROM country c JOIN pmc ON c.continent = pmc.continent\nWHERE c.population_country = pmc.pop_max\nORDER BY pmc.pop_max DESC;\n+---------------+----------------------------------------------+------------+\n| continent     | country_max_pop                              | population |\n+---------------+----------------------------------------------+------------+\n| Asia          | China                                        | 1277558000 |\n| North America | United States                                |  278357000 |\n| South America | Brazil                                       |  170115000 |\n| Europe        | Russian Federation                           |  146934000 |\n| Africa        | Nigeria                                      |  111506000 |\n| Oceania       | Australia                                    |   18886000 |\n| Antarctica    | Antarctica                                   |          0 |\n| Antarctica    | Bouvet Island                                |          0 |\n| Antarctica    | South Georgia and the South Sandwich Islands |          0 |\n| Antarctica    | Heard Island and McDonald Islands            |          0 |\n| Antarctica    | French Southern territories                  |          0 |\n+---------------+----------------------------------------------+------------+"
  },
  {
    "objectID": "slides/SQL_3.html#sous-partitionnements",
    "href": "slides/SQL_3.html#sous-partitionnements",
    "title": "BD IV: SQL III",
    "section": "Sous-partitionnements",
    "text": "Sous-partitionnements\nQue fait cette requête ?\nWITH \n  co_urb_rate AS\n  (\n    SELECT co.countrycode, co.name_country, co.continent, SUM(ci.population)/(co.population_country::numeric) AS urb_rate\n    FROM world.country co JOIN world.city ci ON co.countrycode = ci.countrycode\n    WHERE co.population_country &gt; 0\n    GROUP BY co.countrycode, co.name_country, co.continent\n  ),\n  cont_max_ur AS \n  (\n    SELECT continent, MAX(urb_rate) AS max_ur\n    FROM co_urb_rate\n    GROUP BY continent\n  )\nSELECT \n  co.continent, \n  co.name_country, \n  round(co.urb_rate,2)\nFROM co_urb_rate co JOIN cont_max_ur ct ON co.urb_rate = ct.max_ur;"
  },
  {
    "objectID": "slides/SQL_3.html#aller-plus-loin-que-group-by",
    "href": "slides/SQL_3.html#aller-plus-loin-que-group-by",
    "title": "BD IV: SQL III",
    "section": "Aller plus loin que GROUP BY ?",
    "text": "Aller plus loin que GROUP BY ?\n\n\n\n\n\n\nNote\n\n\nL’opération GROUP BY ne renvoie pas une table mais (implicitement) une collection de sous-tables indicées/étiquetées par les valeurs des attributs de groupement.\nL’opération GROUP BY ne peut pas s’intégrer dans une algèbre relationnelle, même étendue.\n\n\n\n\n\n\n\n\n\nMise en garde\n\n\nSQL n’offre pas de moyen d’utiliser le partitionnement effectué par GROUP BY autrement que pour effectuer des calculs d’agrégats et/ou une projection sur les attributs de groupement.\n\n\n\nCette requête n’est pas valide :\n\nSELECT *  \nFROM country \nGROUP BY continent ;\n\nCette requête est valide :\nSELECT continent  \nFROM country \nGROUP BY continent ;"
  },
  {
    "objectID": "slides/SQL_3.html#sélection-sur-les-groupes-having",
    "href": "slides/SQL_3.html#sélection-sur-les-groupes-having",
    "title": "BD IV: SQL III",
    "section": "Sélection sur les groupes HAVING\n",
    "text": "Sélection sur les groupes HAVING\n\n\nLa clause HAVING permet de poser une condition portant sur chacune des sous-relations générées par le GROUP BY,\nLes sous-relations ne vérifiant pas la condition sont écartées du résultat.\n\nListe des continents comportant au moins cinq régions.\nSELECT continent \nFROM country \nGROUP BY continent    \nHAVING COUNT(DISTINCT region) &gt;= 5;"
  },
  {
    "objectID": "slides/SQL_3.html#tri-de-résultats-order-by",
    "href": "slides/SQL_3.html#tri-de-résultats-order-by",
    "title": "BD IV: SQL III",
    "section": "Tri de résultats ORDER BY\n",
    "text": "Tri de résultats ORDER BY\n\nLa clause ORDER BY permet de trier le résultat de la requête, en fournissant la liste des attributs sur lesquels effectuer le tri et en spécifiant le sens du tri pour chacun d’eux (ASC ou DESC).\n\n\n\n\n\n\nMise en garde\n\n\nL’ordre par défaut est ASC.\n\n\n\nListe des pays triés par ordre décroissant de population\nSELECT * \nFROM country \nORDER BY population_country DESC;  \n\n\n\n\n\n\nAvertissement\n\n\nQue se passe-t-il avec les valeurs nulles ?\nLe comportement dépend du serveur. PostgreSQL et Oracle les classent comme plus grandes que toutes les autres. SQL Server (Microsoft), MySQL, SQLite font l’inverse."
  },
  {
    "objectID": "slides/SQL_3.html#ordre-des-opérations-where-group-by-having-order-by",
    "href": "slides/SQL_3.html#ordre-des-opérations-where-group-by-having-order-by",
    "title": "BD IV: SQL III",
    "section": "Ordre des opérations WHERE, GROUP BY, HAVING, ORDER BY\n",
    "text": "Ordre des opérations WHERE, GROUP BY, HAVING, ORDER BY\n\n\n\n\n\n\n\nImportant\n\n\n\nla sélection des tuples (WHERE),\npuis le partitionnement (GROUP BY),\npuis la sélection sur les groupes (HAVING),\nenfin le tri des résultats (ORDER BY) .\n\n\n\n\nQue fait cette requête ?\nSELECT continent, COUNT(*) \nFROM country \nWHERE countrycode IN (\n  SELECT countrycode \n  FROM countrylanguage \n  WHERE language='English' AND percentage &gt; 10 \n) \nGROUP BY continent \nHAVING AVG(1e6*gnpold/population_country) &gt;= 1000 \nORDER BY continent;"
  },
  {
    "objectID": "slides/SQL_3.html#principe-des-fonctions-fenêtres",
    "href": "slides/SQL_3.html#principe-des-fonctions-fenêtres",
    "title": "BD IV: SQL III",
    "section": "Principe des fonctions fenêtres",
    "text": "Principe des fonctions fenêtres\nUne fonction fenêtre effectue une partition puis un calcul sur le groupe de lignes (“une fenêtre”) auquel la ligne courante appartient.\nDocumentation PostgreSQL\n\n\n\n\n\n\n\nNote\n\n\nC’est comparable au type de calcul effectué avec une fonction d’agrégation.\n\n\n\n\n\nMais les fonctions de fenêtre permettent de faire des calculs différents de ceux réalisés avec GROUP BY.\n\nAvec GROUP BY, le résultat rassemble les lignes d’un même groupe en une seule.\nAvec les fonctions fenêtres, chaque ligne de la table reste présente dans le résultat."
  },
  {
    "objectID": "slides/SQL_3.html#fonctions-fenêtres",
    "href": "slides/SQL_3.html#fonctions-fenêtres",
    "title": "BD IV: SQL III",
    "section": "Fonctions fenêtres",
    "text": "Fonctions fenêtres\nSoit f est une fonction d’agrégation (SUM, AVG, MAX, MIN, COUNT, etc.)\n\nf(...) OVER (PARTITION BY attribut) \n\neffectue le calcul sur le groupe de lignes auquel appartient la ligne courante après un partitionnement selon attribut.\nCe groupe de lignes est le cadre de la fonction fenêtre pour la ligne courante."
  },
  {
    "objectID": "slides/SQL_3.html#exemple-de-fonctions-fenêtres",
    "href": "slides/SQL_3.html#exemple-de-fonctions-fenêtres",
    "title": "BD IV: SQL III",
    "section": "Exemple de fonctions fenêtres",
    "text": "Exemple de fonctions fenêtres\nPrésenter pour chaque pays dont la région comprend le motif Countries, l’espérance de vie du pays et les espérance de vie maximale et minimale des pays de la région.\n\n\nSELECT region, name_country, lifeexpectancy, \n     min(lifeexpectancy) OVER (PARTITION BY region),  \n     max(lifeexpectancy) OVER (PARTITION BY region)   \nFROM country \nWHERE region LIKE '%Countries'\nORDER BY region, lifeexpectancy  \nLIMIT 6 ;\n\n+------------------+-----------------+---------------+-----+-----+\n| Region           | Name of country |Life expectancy| min | max |\n+------------------+-----------------+---------------+-----+-----+\n| Baltic Countries | Latvia          |          68.4 | 68.4| 69.5|\n| Baltic Countries | Lithuania       |          69.1 | 68.4| 69.5|\n| Baltic Countries | Estonia         |          69.5 | 68.4| 69.5|\n| Nordic Countries | Denmark         |          76.5 | 76.5| 79.6|\n| Nordic Countries | Finland         |          77.4 | 76.5| 79.6|\n| Nordic Countries | Faroe Islands   |          78.4 | 76.5| 79.6|\n+------------------+-----------------+---------------+-----+-----+\n\n\n\n\n\n\nNote\n\n\nAvec des fonctions d’agrégation sur un partitionnement par GROUP BY region, il n’était pas possible d’afficher une ligne par pays."
  },
  {
    "objectID": "slides/SQL_3.html#sans-utiliser-over-...",
    "href": "slides/SQL_3.html#sans-utiliser-over-...",
    "title": "BD IV: SQL III",
    "section": "Sans utiliser OVER (...)\n",
    "text": "Sans utiliser OVER (...)\n\nPour calculer ce résultat sans fonctions fenêtres :\n\nOn effectue une partition selon la region, une aggrégation par groupe pour calculer min(lifeexpectancy) et max(lifeexpectancy). On obtient une table à trois colonnes.\nOn calcule une (équi)-jointure avec la table country originelle sur la colonne commune region.\nOn projette le résultat sur les cinq colonnes pertinentes.\n\n\n\nWITH R AS (\n  SELECT region, min(lifeexpectancy) AS minlex, max(lifeexpectancy) AS maxlex\n  FROM country\n  WHERE region LIKE '%Countries' AND lifeexpectancy IS NOT NULL \n  GROUP BY region\n)\n\nSELECT region, name_country, lifeexpectancy, minlex, maxlex\nFROM country co NATURAL JOIN R"
  },
  {
    "objectID": "slides/SQL_3.html#fonctions-fenêtres-avec-une-clause-order-by",
    "href": "slides/SQL_3.html#fonctions-fenêtres-avec-une-clause-order-by",
    "title": "BD IV: SQL III",
    "section": "Fonctions fenêtres avec une clause ORDER BY\n",
    "text": "Fonctions fenêtres avec une clause ORDER BY\n\n\nf(...) OVER (\n    PARTITION BY attribut1\n    ORDER BY attribut2 \n  )\n\nLa clause ORDER BY attribut2 :\n\nordonne les lignes de la fenêtre définie par PARTITION BY attribut1,\nrestreint le cadre de la fenêtre, selon cet ordre, de la première ligne jusqu’aux lignes pour lesquelles attribut2 à la même valeur que dans la ligne courante."
  },
  {
    "objectID": "slides/SQL_3.html#exemple-de-fonction-fenêtre-avec-une-clause-order-by",
    "href": "slides/SQL_3.html#exemple-de-fonction-fenêtre-avec-une-clause-order-by",
    "title": "BD IV: SQL III",
    "section": "Exemple de fonction fenêtre avec une clause ORDER BY\n",
    "text": "Exemple de fonction fenêtre avec une clause ORDER BY\n\nrow_number() : fonction d’agrégation qui retourne le numéro de la ligne dans la fenêtre.\n\nPour les pays d’Asie, lister la région, le nom du pays, le rang du pays dans sa région pour l’espérance de vie et le rang du pays dans sa région pour le PNB par habitant.\n\n\nSELECT region, name_country, \n  row_number() OVER (\n    PARTITION BY region   \n    ORDER BY lifeexpectancy DESC\n  ) AS rk_lifeexpectancy,\n  row_number() OVER (\n    PARTITION BY region   \n    ORDER BY gnp / population_country DESC\n  ) AS rk_gnp \nFROM world.country \nWHERE continent LIKE 'Asi%' and lifeexpectancy IS NOT NULL and gnp IS NOT NULL\nORDER BY region, lifeexpectancy DESC;\n\n\n\n\n\n\nAvertissement\n\n\nDans cette requête, il faut rejeter les valeurs NULL sinon le rang n’aurait pas de sens (ces lignes seraient en tête)."
  },
  {
    "objectID": "slides/SQL_3.html#sommes-cumulées-par-groupes-selon-un-ordre",
    "href": "slides/SQL_3.html#sommes-cumulées-par-groupes-selon-un-ordre",
    "title": "BD IV: SQL III",
    "section": "Sommes cumulées par groupes selon un ordre",
    "text": "Sommes cumulées par groupes selon un ordre\nAvec une clause ORDER BY, une fonction fenêtre SUM() effectue une somme cumulée selon l’ordre choisi.\n\nCalculer, pour chaque pays d’Europe, le pourcentage des PNB supérieur ou égal à celui du pays parmi ceux de sa région.\n\n\nSELECT \n  region, name_country,  \n  ROUND(SUM(gnp) OVER (\n    PARTITION BY region  \n  ORDER BY gnp DESC) \n  / sum(gnp) OVER (\n    PARTITION BY region), 4)*100  \n  AS pc_sum_GNP    \nFROM world.country c \nWHERE continent = 'Europe'\norder by region, gnp DESC;"
  },
  {
    "objectID": "slides/SQL_3.html#clause-range-dans-une-fonction-fenêtre",
    "href": "slides/SQL_3.html#clause-range-dans-une-fonction-fenêtre",
    "title": "BD IV: SQL III",
    "section": "Clause RANGE dans une fonction fenêtre",
    "text": "Clause RANGE dans une fonction fenêtre\nIl est possible d’ajouter une clause RANGE à une clause ORDER BY pour modifier le cadre de la fenêtre :\nf(...) OVER (\n    PARTITION BY attribut1\n    ORDER BY attribut2 \n    RANGE BETWEEN ... AND ...\n  )\nOn utilise les mots clés UNBOUNDED, PRECEDING, FOLLOWING et CURRENT ROW pour spécifier les bornes de l’intervalle que doit respecter attribut2.\n\n\n\n\n\n\nNote\n\n\n\n\nRANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING : le cadre s’étend à tout le groupe défini par la partition.\n\nRANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW : le cadre s’étend de la première ligne du groupe défini par la partition à la ligne courante."
  },
  {
    "objectID": "slides/SQL_3.html#exemples-de-clause-range-dans-une-fonction-fenêtre",
    "href": "slides/SQL_3.html#exemples-de-clause-range-dans-une-fonction-fenêtre",
    "title": "BD IV: SQL III",
    "section": "Exemples de clause RANGE dans une fonction fenêtre",
    "text": "Exemples de clause RANGE dans une fonction fenêtre\n\n\nCalcul d’une moyenne mobile sur l’intervalle [GNP ligne courante - 1000 , GNP ligne courante + 1000]\nSELECT \n  continent, name_country, \n  AVG(gnp) OVER \n  (\n    PARTITION BY continent  \n    ORDER BY gnp DESC\n    RANGE BETWEEN 10000 PRECEDING AND 10000 FOLLOWING \n  ) mob_avg_gnp\nFROM world.country c \nORDER BY continent, gnp DESC;\n\nCalcul d’une moyenne mobile sur l’intervalle [GNP ligne courante - 1000 , GNP ligne courante]\nSELECT \n  continent, name_country, \n  AVG(gnp) OVER \n  (\n    PARTITION BY continent  \n    ORDER BY gnp DESC\n    RANGE BETWEEN 10000 PRECEDING AND CURRENT ROW \n  ) mob_avg_gnp\nFROM world.country c \nORDER BY continent, gnp DESC;"
  },
  {
    "objectID": "slides/SQL_3.html#limites-dutilisation-des-fonctions-fenêtres",
    "href": "slides/SQL_3.html#limites-dutilisation-des-fonctions-fenêtres",
    "title": "BD IV: SQL III",
    "section": "Limites d’utilisation des fonctions fenêtres",
    "text": "Limites d’utilisation des fonctions fenêtres\n\n\n\n\n\n\nAvertissement\n\n\nLes fonctions de fenêtre ne sont autorisées que dans les clauses SELECT et ORDER BY de la requête.\nElles sont interdites ailleurs, par exemple dans les clauses GROUP BY, HAVING et WHERE.\nEn effet, elles s’exécutent logiquement après le traitement de ces clauses.\n\n\n\n\n\n\n\n\n\n\nMise en garde\n\n\nDe même, les fonctions de fenêtre s’exécutent après les fonctions d’agrégation habituelles.\nCela signifie qu’il est pertinent d’inclure un appel de fonction d’agrégation dans les arguments d’une fonction de fenêtre, mais pas l’inverse."
  },
  {
    "objectID": "slides/SQL_3.html#introduction",
    "href": "slides/SQL_3.html#introduction",
    "title": "BD IV: SQL III",
    "section": "Introduction",
    "text": "Introduction\nIntroduits dans SQL avec la mode du Data mining (Fouille de données) dans les années 1990.\nPermet de réaliser de facon apparemment simultanée des aggrégations de régularités emboîtées.\nDans le monde des statistiques, lorsqu’on aggrège des comptages de grains différents, on parle de tables de contingences (contingency tables).\nDocumentation PostgreSQL"
  },
  {
    "objectID": "slides/SQL_3.html#grouping-sets",
    "href": "slides/SQL_3.html#grouping-sets",
    "title": "BD IV: SQL III",
    "section": "GROUPING SETS",
    "text": "GROUPING SETS\nUn GROUPING SETS permet d’effectuer simultanément des calculs d’agrégats pour différentes partitions de la table.\nIl s’écrit dans la clause GROUP BY avec une liste d’ensemble d’attributs de la forme ((c1,c2), (c1), (c2)).\nGROUP BY GROUPING SETS ((c1,c2), (c1), ())\nsignifie que l’on fera les calculs d’agrégats successivement pour les regroupements selon c1,c2, puis pour les regroupements selon c1, puis sans regroupement.\nDans le résultat, lorsque le partitionnement selon c1 est effectué, la colonne c2 a la valeur NULL (i.e. pas de valeur), ce qui cohérent avec le fonctionnement de GROUP BY."
  },
  {
    "objectID": "slides/SQL_3.html#exemple-avec-grouping-sets",
    "href": "slides/SQL_3.html#exemple-avec-grouping-sets",
    "title": "BD IV: SQL III",
    "section": "Exemple avec GROUPING SETS\n",
    "text": "Exemple avec GROUPING SETS\n\nSELECT continent, region, max(lifeexpectancy)\nFROM country c \nWHERE continent LIKE '%America'\nGROUP BY GROUPING SETS  ((continent, region), (continent), ())  \nORDER BY continent, region ;\n|continent    |region         |max |\n|-------------|---------------|----|\n|North America|Caribbean      |78,9|\n|North America|Central America|75,8|\n|North America|North America  |79,4|\n|North America|               |79,4|\n|South America|South America  |76,1|\n|South America|               |76,1|\n|             |               |79,4|"
  },
  {
    "objectID": "slides/SQL_3.html#rollup",
    "href": "slides/SQL_3.html#rollup",
    "title": "BD IV: SQL III",
    "section": "ROLLUP",
    "text": "ROLLUP\nROLLUP ( a, b, c, ... )\nest un raccourci pour\nGROUPING SETS (\n    ( a, b, c, ... ),\n    ...\n    ( a, b ),\n    ( a ),\n    ( )\n)"
  },
  {
    "objectID": "slides/SQL_3.html#exemple-avec-rollup",
    "href": "slides/SQL_3.html#exemple-avec-rollup",
    "title": "BD IV: SQL III",
    "section": "Exemple avec ROLLUP\n",
    "text": "Exemple avec ROLLUP\n\n\nSELECT continent, region, max(lifeexpectancy)\nFROM country c \nWHERE continent LIKE '%America'\nGROUP BY ROLLUP  (continent, region)  \nORDER BY continent, region ;\n\n+-------------+---------------+----+\n|Continent    |Region         |max |\n+-------------+---------------+----+\n|North America|Caribbean      |78.9|\n|North America|Central America|75.8|\n|North America|North America  |79.4|\n|North America|               |79.4|\n|South America|South America  |76.1|\n|South America|               |76.1|\n|             |               |79.4|"
  },
  {
    "objectID": "slides/SQL_3.html#cube",
    "href": "slides/SQL_3.html#cube",
    "title": "BD IV: SQL III",
    "section": "CUBE",
    "text": "CUBE\nCUBE (a, b, c) est un raccourci pour un GROUPING SETS contenant toutes les parties de (a, b, c), c.a.d\nGROUPING SETS (\n    (         )\n    ( a, b, c ),\n    ( a, b    ),\n    ( a       ),\n    (    b, c ),\n    (    b    ),\n    ( a,    c ),\n    (       c ),\n)"
  },
  {
    "objectID": "slides/SQL_3.html#exemple-avec-cube",
    "href": "slides/SQL_3.html#exemple-avec-cube",
    "title": "BD IV: SQL III",
    "section": "Exemple avec CUBE\n",
    "text": "Exemple avec CUBE\n\n\n\n\nSELECT continent, region, governmentform, \n       count(*) AS cnt, \n       max(lifeexpectancy)\nFROM country c \nWHERE continent LIKE '%America'\nGROUP BY CUBE (continent,region,governmentform)\nHAVING COUNT(*) &gt; 5;\n\n\n|continent    |region         |governmentform               |cnt|max |\n|-------------|---------------|-----------------------------|---|----|\n|             |               |                             |51 |79,4|\n|South America|South America  |Republic                     |9  |75,7|\n|North America|Central America|Republic                     |6  |75,8|\n|North America|Caribbean      |Constitutional Monarchy      |8  |75,2|\n|North America|Caribbean      |                             |24 |78,9|\n|South America|South America  |                             |14 |76,1|\n|North America|Central America|                             |8  |75,8|\n|South America|               |                             |14 |76,1|\n|North America|               |                             |37 |79,4|\n|             |Caribbean      |Constitutional Monarchy      |8  |75,2|\n|             |South America  |Republic                     |9  |75,7|\n|             |Central America|Republic                     |6  |75,8|\n|             |South America  |                             |14 |76,1|\n|             |Central America|                             |8  |75,8|\n|             |Caribbean      |                             |24 |78,9|\n|North America|               |Constitutional Monarchy      |9  |75,2|\n|North America|               |Republic                     |10 |75,8|\n|South America|               |Republic                     |9  |75,7|\n|North America|               |Dependent Territory of the UK|6  |78,9|\n|             |               |Republic                     |19 |75,8|\n|             |               |Constitutional Monarchy      |9  |75,2|\n|             |               |Dependent Territory of the UK|7  |78,9|"
  },
  {
    "objectID": "slides/SQL_3.html#portrait-robot-dune-requête",
    "href": "slides/SQL_3.html#portrait-robot-dune-requête",
    "title": "BD IV: SQL III",
    "section": "Portrait robot d’une requête",
    "text": "Portrait robot d’une requête\nSELECT &lt;attributs&gt;           -- les colonnes de la table résultat\n\nFROM &lt;relations&gt;             -- la/les table/s qui émettent les données\n\n[WHERE &lt;condition&gt; ]         -- filtre\n\n[GROUP BY &lt;attributs de partitionnement&gt;   -- découpage en groupes\n\n[HAVING &lt;condition&gt;]]      -- filtrage des groupes\n\n[ORDER BY &lt;critere&gt;]       -- trier \n\n\nSELECT : attributs du résultat (avec agrégations éventuelles)\n\nWHERE : condition de sélection indépendante du GROUP BY\n\n\nHAVING : condition de sélection portant sur les groupes"
  },
  {
    "objectID": "slides/SQL_3.html#ordre-dexécution-des-éléments-dune-requête",
    "href": "slides/SQL_3.html#ordre-dexécution-des-éléments-dune-requête",
    "title": "BD IV: SQL III",
    "section": "Ordre d’exécution des éléments d’une requête",
    "text": "Ordre d’exécution des éléments d’une requête\n\nRassembler les données mentionnées dans la clause FROM\nFilter les lignes selon la clause WHERE\nRegrouper les lignes selon la clause GROUP BY\nFiltrer les groupes selon la clause HAVING\nSpecifier les colonnes du résultat selon la clause SELECT\nTrier le résultat final selon la clause ORDER BY"
  },
  {
    "objectID": "slides/SQL_1.html#sql-structured-query-language",
    "href": "slides/SQL_1.html#sql-structured-query-language",
    "title": "BD II: SQL I",
    "section": "SQL : Structured Query Language",
    "text": "SQL : Structured Query Language\nLe SQL est un langage permettant :\n\ninterrogation des données (requêtes)\ndéfinition des données et des contraintes structurelles sur celles-ci\nmanipulation des données (insertion, suppression, mise à jour)\ndéfinition des vues et des index\nadministration des bases de données"
  },
  {
    "objectID": "slides/SQL_1.html#plusieurs-fois-normalisés-par-liso",
    "href": "slides/SQL_1.html#plusieurs-fois-normalisés-par-liso",
    "title": "BD II: SQL I",
    "section": "Plusieurs fois normalisés par l’ISO …",
    "text": "Plusieurs fois normalisés par l’ISO …\n\nSQL-86, SQL-89, SQL-92, SQL-99,\n…\nSQL-2003, SQL-2008, SQL-2011, SQL-2016,\n…\n\nNous utiliserons le dialecte PostgreSQL (https://www.postgresql.org){target=“_blank”}\nLa norme est révisée environ tous les 5 ans, acutellement ISO/IEC 9075-1:2023 de l’ISO (https://www.iso.org/){target=“_blank”}"
  },
  {
    "objectID": "slides/SQL_1.html#un-langage-de-requête",
    "href": "slides/SQL_1.html#un-langage-de-requête",
    "title": "BD II: SQL I",
    "section": "Un langage de requête",
    "text": "Un langage de requête\n\nAvec SQL, on envoit au serveur des requêtes composées d’instructions,\nLes opérations de l’Algèbre relationnel ne sont pas directement disponibles.\n\n\nLa principale instruction est SELECT. Elle permet de combiner :\n\nrestriction/filtrage (sélection) \\(\\sigma\\)\nprojection \\(\\pi\\)\nrenommage \\(\\rho\\)\net bien d’autres choses.\n\nD’autres instructions pour définir et manipuler les données, administrer une BDD."
  },
  {
    "objectID": "slides/SQL_1.html#format-de-linstruction-select",
    "href": "slides/SQL_1.html#format-de-linstruction-select",
    "title": "BD II: SQL I",
    "section": "Format de l’instruction SELECT\n",
    "text": "Format de l’instruction SELECT\n\nSELECT &lt;liste attribut&gt;\n\nFROM &lt;table&gt;\n\nWHERE &lt;condition&gt; ;\ntraduit l’expression\n\\(\\Pi\\left(\\sigma \\left(\\text{&lt;table&gt;}, \\text{&lt;condition&gt;}\\right), \\text{&lt;liste attribut&gt;}\\right)\\)"
  },
  {
    "objectID": "slides/SQL_1.html#autres-langages-autres-choix",
    "href": "slides/SQL_1.html#autres-langages-autres-choix",
    "title": "BD II: SQL I",
    "section": "Autres langages, autres choix",
    "text": "Autres langages, autres choix\nOn peut faire autrement : dans les extensions du langage R, notamment celles qui relèvent de tidyverse, on associe des fonctions à chaque opérateur de l’algèbre relationnelle. Pour les opérateurs qui portent sur une seule table, le premier argument de chaque fonction est toujours la table sur laquelle on opère. Les autres arguments sont soit les attributs de projection, soit la spécification d’une condition de sélection, soit …\nL’usage d’un opérateur pipe (comme dans Unix) permet de composer de facon lisible les opérations.\n&lt;table&gt; |&gt;\n  filter(&lt;condition&gt; ) |&gt;\n  select(&lt;liste attribut&gt;) |&gt; \n  ..."
  },
  {
    "objectID": "slides/SQL_1.html#syntaxe---requêtes-simples",
    "href": "slides/SQL_1.html#syntaxe---requêtes-simples",
    "title": "BD II: SQL I",
    "section": "Syntaxe - requêtes simples",
    "text": "Syntaxe - requêtes simples\nSELECT [DISTINCT] * | &lt;liste attribut&gt;\n\nFROM &lt;liste de tables&gt;\n\n[WHERE &lt;condition&gt;] ;\n\n* : sélection de tous les attributs (pas de projection)\n[...] : clause, expression facultative.\nDISTINCT : supprime les doublons."
  },
  {
    "objectID": "slides/SQL_1.html#exemples-de-requête",
    "href": "slides/SQL_1.html#exemples-de-requête",
    "title": "BD II: SQL I",
    "section": "Exemples de requête",
    "text": "Exemples de requête\n\n\nSchémas des tables :\n\nEmploye(Nu, NomE, Annee, Tel, Nudept)\nFournisseur (NomF, Ville, Adresse)\nPiece(NomP, Prix, Couleur)\n\nLa requête\nSELECT *\n\nFROM Fournisseur ;\n\nest équivalente à : \\(\\quad Fournisseur\\)\n\n\nLa requête\nSELECT NomF\n\nFROM Fournisseur\n\nWHERE Ville='Paris' ;\n\n\nest équivalente à : \\(\\quad \\pi((\\sigma(\\texttt{Fournisseur}, \\texttt{Ville}=\\texttt{'Paris'})), \\texttt{NomF})\\)"
  },
  {
    "objectID": "slides/SQL_1.html#structure-de-base",
    "href": "slides/SQL_1.html#structure-de-base",
    "title": "BD II: SQL I",
    "section": "Structure de base",
    "text": "Structure de base\nLa structure de base d’une requête s’appuie sur les trois mots clés suivants :\n\nSELECT correspond à l’opérateur de projection sur la liste d’attributs demandée, il peut aussi être suivi de fonctions d’attributs\nFROM indique la ou les relations concernées\nWHERE précise une condition et correspond à l’opération de restriction/sélection en algèbre relationnelle."
  },
  {
    "objectID": "slides/SQL_1.html#syntaxe-de-la-condition-de-sélection-where-...",
    "href": "slides/SQL_1.html#syntaxe-de-la-condition-de-sélection-where-...",
    "title": "BD II: SQL I",
    "section": "Syntaxe de la condition de sélection (WHERE ...)",
    "text": "Syntaxe de la condition de sélection (WHERE ...)\nUne condition se construit à l’aide des opérations suivantes :\n\n\nComparaison avec opérateurs : =, &lt;&gt;, &gt;,&lt;, &gt;=, &lt;=\n\n\nSELECT *\n\nFROM Employe\n\nWHERE NomE &lt;&gt;'Durand'  ;  \n\n\n\n\n\n\nMise en garde\n\n\nUtiliser * en production n’est pas une bonne idée car une modification du schéma de la table Employe modifiera le schéma du résultat."
  },
  {
    "objectID": "slides/SQL_1.html#syntaxe-de-la-condition-de-sélection-where-...---suite",
    "href": "slides/SQL_1.html#syntaxe-de-la-condition-de-sélection-where-...---suite",
    "title": "BD II: SQL I",
    "section": "Syntaxe de la condition de sélection (WHERE ...) - suite",
    "text": "Syntaxe de la condition de sélection (WHERE ...) - suite\nCombinaison de conditions à l’aide des opérateurs logiques: AND, OR, NOT\nSELECT DISTINCT NomF\n\nFROM Fournisseur\n\nWHERE (Ville='Londres') OR (Ville='Paris');  \n Attention aux priorités dans l’évaluation des expressions logiques\n\n\n\n\n\n\n\nAvertissement\n\n\nAND est prioritaire sur OR. Il est utile de parenthéser !\n\n\n\n\n\n Attention aux valeurs NULL c.a.d. manquantes/indéterminées."
  },
  {
    "objectID": "slides/SQL_1.html#logique-trivalente",
    "href": "slides/SQL_1.html#logique-trivalente",
    "title": "BD II: SQL I",
    "section": "Logique trivalente",
    "text": "Logique trivalente\nWHERE C ne sélectionne que les tuples vérifiant C = TRUE.\nUne comparaison sur un attribut NULL renvoie UNKNOWN, à l’exception de IS [NOT] NULL.\n\nLes opérateurs logiques sont trivalents : TRUE, FALSE, UNKNOWN\nOn compléte les règles habituelles :\n\nNOT NULL = NOT UNKNOWN = UNKNOWN car résultat incertain\nTRUE AND UNKNOWN = UNKNOWN car résultat incertain\nFALSE AND UNKNOWN = FALSE car résultat certain\nTRUE OR UNKNOWN = TRUE car résultat certain\nFALSE OR UNKNOWN = UNKNOWN car résultat incertain"
  },
  {
    "objectID": "slides/SQL_1.html#test-between",
    "href": "slides/SQL_1.html#test-between",
    "title": "BD II: SQL I",
    "section": "Test BETWEEN\n",
    "text": "Test BETWEEN\n\nPermet de vérifier si la valeur d’un attribut est comprise entre deux constantes\nSELECT NomE\n\nFROM Employe\n\nWHERE Annee BETWEEN 2022 AND 2025;   \n\n\n\n\n\n\nMise en garde\n\n\nÉviter de manipuler les dates et heures comme des chaînes de caractères"
  },
  {
    "objectID": "slides/SQL_1.html#test-is-null",
    "href": "slides/SQL_1.html#test-is-null",
    "title": "BD II: SQL I",
    "section": "Test IS NULL\n",
    "text": "Test IS NULL\n\nVérifie si une valeur est égale à NULL (c-à-d est inconnue).\nSELECT *\n\nFROM Employe\n\nWHERE Tel IS NULL;    \n\n\n\n\n\n\nMise en garde\n\n\n Attention à la gestion des valeurs manquantes."
  },
  {
    "objectID": "slides/SQL_1.html#test-in",
    "href": "slides/SQL_1.html#test-in",
    "title": "BD II: SQL I",
    "section": "Test IN\n",
    "text": "Test IN\n\ntest appartenance : permet de vérifier si la valeur d’un attribut appartient à une liste de constantes.\nSELECT *\n\nFROM Fournisseur\n\nWHERE Ville IN ('Paris', 'Londres');"
  },
  {
    "objectID": "slides/SQL_1.html#test-like",
    "href": "slides/SQL_1.html#test-like",
    "title": "BD II: SQL I",
    "section": "Test LIKE\n",
    "text": "Test LIKE\n\nPermet de vérifier si un attribut de type chaîne de caractères contient une ou plusieurs sous-chaînes.\n\\(\\_\\) : remplace n’importe quel caractère,\n\\(\\%\\) : remplace n’importe quelle chaîne de caractères.\nSELECT Ville\n\nFROM Fournisseur\n\nWHERE Ville LIKE 'Saint%';\nCette requête sélectionne les noms de ville commençant par ‘Saint’.\n\n\n\n\n\n\nAvertissement\n\n\n\nLIKE est sensible à la casse,\nILIKE est insensible à la casse."
  },
  {
    "objectID": "slides/SQL_1.html#requêtes-multi-relations-1",
    "href": "slides/SQL_1.html#requêtes-multi-relations-1",
    "title": "BD II: SQL I",
    "section": "Requêtes multi-relations",
    "text": "Requêtes multi-relations\nQuand l’information est dispersée sur plusieurs tables, on utilise des jointures\n\nOn peut :\n\nUtiliser plusieurs tables dans la clause FROM,\nFaire intervenir des conditions complexes impliquant ces tables dans la clause WHERE."
  },
  {
    "objectID": "slides/SQL_1.html#détails-du-schéma-world",
    "href": "slides/SQL_1.html#détails-du-schéma-world",
    "title": "BD II: SQL I",
    "section": "Détails du schéma World\n",
    "text": "Détails du schéma World\n\nImages et tables créées grâce à DbSchema (https://dbschema.com){target=“_blank”}"
  },
  {
    "objectID": "slides/SQL_1.html#modèle-relationnel-du-schéma-world",
    "href": "slides/SQL_1.html#modèle-relationnel-du-schéma-world",
    "title": "BD II: SQL I",
    "section": "Modèle relationnel du schéma World\n",
    "text": "Modèle relationnel du schéma World\n\n\nimg"
  },
  {
    "objectID": "slides/SQL_1.html#table-world.city",
    "href": "slides/SQL_1.html#table-world.city",
    "title": "BD II: SQL I",
    "section": "Table world.city",
    "text": "Table world.city\n\n\n* 🔑 ⬋\nid\ninteger\n\n\n*\nname\ntext\n\n\n*\ncountrycode\nchar(3)\n\n\n*\ndistrict\ntext\n\n\n*\npopulation\ninteger"
  },
  {
    "objectID": "slides/SQL_1.html#table-world.country",
    "href": "slides/SQL_1.html#table-world.country",
    "title": "BD II: SQL I",
    "section": "Table world.country",
    "text": "Table world.country\n\n\n\n\n* 🔑 ⬋\ncode\nchar(3)\n\n\n*\nname\ntext\n\n\n*\ncontinent\ntext\n\n\n*\nregion\ntext\n\n\n*\nsurfacearea\nreal\n\n\n\nindepyear\nsmallint\n\n\n*\npopulation\ninteger\n\n\n\nlifeexpectancy\nreal\n\n\n\ngnp\nnumeric(10,2)\n\n\n\ngnpold\nnumeric(10,2)\n\n\n*\nlocalname\ntext\n\n\n*\ngovernmentform\ntext\n\n\n\nheadofstate\ntext\n\n\n⬈\ncapital\ninteger\n\n\n*\ncode2\nchar(2)\n\n\n\nForeign Keys\n\n\ncountry_capital_fkey\n( capital ) ref world.city (id)\n\nConstraints\n\n\n\n\n\n\ncountry_continent_check\n((continent = ‘Asia’::text) OR (continent = ‘Europe’::text) OR (continent = ‘North America’::text) OR (continent = ‘Africa’::text) OR (continent = ‘Oceania’::text) OR (continent = ‘Antarctica’::text) OR (continent = ‘South America’::text))"
  },
  {
    "objectID": "slides/SQL_1.html#table-world.countrylanguage",
    "href": "slides/SQL_1.html#table-world.countrylanguage",
    "title": "BD II: SQL I",
    "section": "Table world.countrylanguage",
    "text": "Table world.countrylanguage\n\n\n* 🔑 ⬈\ncountrycode\nchar(3)\n\n\n* 🔑\nlanguage\ntext\n\n\n*\nisofficial\nboolean\n\n\n*\npercentage\nreal\n\n\nForeign Keys\n\n\ncountrylanguage_countrycode_fkey\n( countrycode ) ref world.country (code)"
  },
  {
    "objectID": "slides/SQL_1.html#première-jointure-sur-schéma-world",
    "href": "slides/SQL_1.html#première-jointure-sur-schéma-world",
    "title": "BD II: SQL I",
    "section": "Première jointure sur schéma world\n",
    "text": "Première jointure sur schéma world\n\nQuels sont les pays qui portent le même nom que leur capitale ?\n\nSELECT name_country\nFROM country co, city ci   \nWHERE co.capital=ci.id AND co.name_country=ci.name;\n\n\nqui correspond à\n\\(\\pi_{\\text{name\\_country}}(\\sigma_{\\text{capital}=\\text{id} \\wedge \\text{name\\_country}=\\text{name}}(\\text{country}\\times \\text{city}))\\)\nautrement dit à\n\\(\\pi_{\\text{name\\_country}}(\\text{country} \\bowtie_{\\text{capital}=\\text{id} \\wedge  \\text{name\\_country}=\\text{name}} \\text{city}))\\)"
  },
  {
    "objectID": "slides/SQL_1.html#syntaxe-normalisée-pour-les-jointures-join-et-on",
    "href": "slides/SQL_1.html#syntaxe-normalisée-pour-les-jointures-join-et-on",
    "title": "BD II: SQL I",
    "section": "Syntaxe normalisée pour les jointures : JOIN et ON\n",
    "text": "Syntaxe normalisée pour les jointures : JOIN et ON\n\nQuels sont les pays qui portent le même nom que leur capitale ?\n\nSELECT name_country\nFROM country co join city ci \nON co.capital=ci.id  \nWHERE co.name_country = ci.name;\nqui correspond à\n\\(\\pi_{\\text{name\\_country}}(\\sigma_{\\text{capital}=id \\wedge  \\text{name\\_country}=\\text{name}}(\\text{country} \\times \\text{city}))\\)"
  },
  {
    "objectID": "slides/SQL_1.html#renommage",
    "href": "slides/SQL_1.html#renommage",
    "title": "BD II: SQL I",
    "section": "Renommage",
    "text": "Renommage\nSi on veut faire une jointure d’une table avec elle-même, on utilise AS pour obtenir deux tables de noms différents\n\nQuels sont les noms de ville qui apparaissent dans deux pays différents?\n\n\nSELECT DISTINCT c1.name, c1.countrycode, c2.countrycode\nFROM city AS c1 JOIN city AS c2   \nON c1.countrycode != c2.countrycode AND c1.name=c2.name  \nORDER BY c1.name;\n\n\n\n\n\n\nNote\n\n\nLe mot AS est optionnel."
  },
  {
    "objectID": "slides/SQL_1.html#jointure-naturelle",
    "href": "slides/SQL_1.html#jointure-naturelle",
    "title": "BD II: SQL I",
    "section": "Jointure naturelle",
    "text": "Jointure naturelle\nQuels sont les noms des pays où le français est parlé ?\n\nSELECT co.name_country, cl.language\nFROM country co, countrylanguage cl\nWHERE co.countrycode=cl.countrycode AND cl.language='French';\nC’est une jointure naturelle.\n\n\nSyntaxe normalisée : NATURAL JOIN\nSELECT co.name_country, cl.language\nFROM country co NATURAL JOIN countrylanguage cl\nWHERE cl.language='French';"
  },
  {
    "objectID": "slides/SQL_1.html#jointure-naturelle-suite",
    "href": "slides/SQL_1.html#jointure-naturelle-suite",
    "title": "BD II: SQL I",
    "section": "Jointure naturelle (suite)",
    "text": "Jointure naturelle (suite)\nQuels sont les pays dont une ville a le même nom qu’une langue parlée dans ce pays?\nSELECT DISTINCT co.name_country, ci.name, language\nFROM country co NATURAL JOIN  \n     city ci NATURAL JOIN     \n     countrylanguage cl     \nWHERE cl.language = ci.name;\n\n\n\n\n\n\nAvertissement\n\n\n\nla syntaxe nom_table.nom_attribut améliore la lisibilité d’une requète multi-table.\nOn peut utiliser des alias très systématiquement pour alléger les notations."
  },
  {
    "objectID": "slides/SQL_1.html#schéma-world-pour-mémoire",
    "href": "slides/SQL_1.html#schéma-world-pour-mémoire",
    "title": "BD II: SQL I",
    "section": "Schéma world pour mémoire",
    "text": "Schéma world pour mémoire"
  },
  {
    "objectID": "slides/SQL_1.html#jointure-externe",
    "href": "slides/SQL_1.html#jointure-externe",
    "title": "BD II: SQL I",
    "section": "Jointure externe",
    "text": "Jointure externe\n\nLEFT OUTER JOIN : jointure externe gauche. On garde les tuples de la table de gauche qui n’ont pas de correspondant dans l’autre table.\nRIGHT OUTER JOIN : jointure externe droite. Idem à droite.\nFULL OUTER JOIN : on garde les tuples de chacune des tables qui n’ont pas de correspondant.\nOn complète les valeurs non renseignées par NULL."
  },
  {
    "objectID": "slides/SQL_1.html#exemple-de-jointure-externe",
    "href": "slides/SQL_1.html#exemple-de-jointure-externe",
    "title": "BD II: SQL I",
    "section": "Exemple de jointure externe",
    "text": "Exemple de jointure externe\n\nCertains pays n’ont pas de capitale.\n\n\nSELECT name_country\nFROM country\nWHERE capital IS NULL;\nLe résultat contient 8 lignes.\n\n\n\nQuels sont les pays qui n’ont pas de capitale ou portent le même nom que leur capitale ?\n\n\n\nSELECT co.name_country, ci.name\nFROM country co LEFT OUTER JOIN city ci   \n     ON co.capital=ci.id                  \nWHERE ci.name IS NULL OR co.name_country=ci.name ;"
  },
  {
    "objectID": "slides/Modelisation_2.html#entre-modèle-ea-et-modèle-relationnel",
    "href": "slides/Modelisation_2.html#entre-modèle-ea-et-modèle-relationnel",
    "title": "Modélisation II :",
    "section": "Entre modèle EA et modèle relationnel",
    "text": "Entre modèle EA et modèle relationnel\nDans le modèle conceptuel des données (modèle EA)\n\nPlusieurs types de briques de bases : Entités (noms) et Associations (verbes)\nUn formalisme accessible (en principe) aux usagers du système d’information\n\nDans le modèle logique des données relationnel (MRD)\n\nUne seule brique de base : les tables"
  },
  {
    "objectID": "slides/Modelisation_2.html#objectifs",
    "href": "slides/Modelisation_2.html#objectifs",
    "title": "Modélisation II :",
    "section": "Objectifs",
    "text": "Objectifs\n\nUne technique de traduction du formalisme EA vers le formalisme relationnel.\nVisualisation des contraintes référentielles via les pattes de corbeaux.\nUn formalisme graphique très proche de la description physique en SQL.\nUn formalisme graphique utilisé pour documenter les bases de données relationnelles"
  },
  {
    "objectID": "slides/Modelisation_2.html#origines",
    "href": "slides/Modelisation_2.html#origines",
    "title": "Modélisation II :",
    "section": "Origines",
    "text": "Origines\n\nCréé par Gordon Everest (fin des années 1970)\nNormalisé par Finkelstein et Martin"
  },
  {
    "objectID": "slides/Modelisation_2.html#diagrammes",
    "href": "slides/Modelisation_2.html#diagrammes",
    "title": "Modélisation II :",
    "section": "Diagrammes",
    "text": "Diagrammes\nDeux briques de base\nLes modèles relationnelles des données (MRD) sont formés :\n\nde tables,\nde liens entre tables.\n\nLes liens \n\nReprésentent des associations binaires un-un, ou un-vers-plusieurs\nLes cardinalités sont visualisées par les extrémités des liens"
  },
  {
    "objectID": "slides/Modelisation_2.html#les-cardinalités",
    "href": "slides/Modelisation_2.html#les-cardinalités",
    "title": "Modélisation II :",
    "section": "Les cardinalités",
    "text": "Les cardinalités\n\n\n\n\nSymbole\n\n\nInterprétation\n\n\n\n\n\n\n\n\n\nZéro ou un\n\n\n\n\n\n\n\nExactement un\n\n\n\n\n\n\n\nZéro ou plus (pas de borne supérieure)\n\n\n\n\n\n\n\nUn ou plus (pas de borne supérieure)"
  },
  {
    "objectID": "slides/Modelisation_2.html#interprétation-des-cardinalités-du-mrd",
    "href": "slides/Modelisation_2.html#interprétation-des-cardinalités-du-mrd",
    "title": "Modélisation II :",
    "section": "Interprétation des cardinalités du MRD",
    "text": "Interprétation des cardinalités du MRD\n\n\n\n\n\n\n\n\n\nAssociation is-in : une valeur de l’attribut countrycode de COUNTRY (donc une instance de COUNTRY car c’est l’identifiant) peut être référencée 0 à plusieurs fois dans la table CITY.\nAssociation is-capital : une valeur de l’attribut id de CITY (donc une instance de CITY) est référencée 0 à 1 fois dans la table COUNTRY."
  },
  {
    "objectID": "slides/Modelisation_2.html#les-liens-dans-un-mrd",
    "href": "slides/Modelisation_2.html#les-liens-dans-un-mrd",
    "title": "Modélisation II :",
    "section": "Les liens dans un MRD",
    "text": "Les liens dans un MRD\n\n\n\n\n\n\nAvertissement\n\n\n\nUn lien dans un MRD définit une contrainte d’intégrité référentielle entre deux tables.\nIl ne peut pas représenter directement un association d’arité supérieure à 2.\nIl ne porte pas d’attributs propres."
  },
  {
    "objectID": "slides/Modelisation_2.html#les-entités",
    "href": "slides/Modelisation_2.html#les-entités",
    "title": "Modélisation II :",
    "section": "Les entités",
    "text": "Les entités\n\nEntité forte du MCD \\(\\rightarrow\\) table du MRD de même nom et de mêmes attributs\nEntité faible du MCD \\(\\rightarrow\\) table du MRD de même nom et de mêmes attributs\nEntité spécialisée du MCD \\(\\rightarrow\\) table du MRD de même nom et de mêmes attributs\nLes identifiants des entités deviennent les identifiants (clés primaires) des tables.\nOn décompose les identifiants concaténés des entités faibles en autant d’attributs qui forment ensemble la clé primaire de la table créée."
  },
  {
    "objectID": "slides/Modelisation_2.html#exemple-du-mcd-world",
    "href": "slides/Modelisation_2.html#exemple-du-mcd-world",
    "title": "Modélisation II :",
    "section": "Exemple du MCD World",
    "text": "Exemple du MCD World\nLes entités COUNTRY, CITY et LANGUAGE sont traduits en 3 tables:\n\nCOUNTRY d’identifiant countrycode,\nCITY d’identifiant id,\nLANGAGE d’identifiant name."
  },
  {
    "objectID": "slides/Modelisation_2.html#associations-binaires-1-à-1-1-à-plusieurs-plusieurs-à-plusieurs",
    "href": "slides/Modelisation_2.html#associations-binaires-1-à-1-1-à-plusieurs-plusieurs-à-plusieurs",
    "title": "Modélisation II :",
    "section": "Associations binaires 1 à 1, 1 à plusieurs, plusieurs à plusieurs",
    "text": "Associations binaires 1 à 1, 1 à plusieurs, plusieurs à plusieurs\n\n\n\n\n\n\nDéfinition\n\n\nOn dit qu’une association binaire du MCD est de type \\(a\\) à \\(b\\) si la cardinalité maximale de l’association est \\(a\\) pour une entité, \\(b\\) pour l’autre."
  },
  {
    "objectID": "slides/Modelisation_2.html#exemples-sur-le-mcd-world",
    "href": "slides/Modelisation_2.html#exemples-sur-le-mcd-world",
    "title": "Modélisation II :",
    "section": "Exemples sur le MCD World",
    "text": "Exemples sur le MCD World\n\n\n\n\n\n\n\n\n\n\n\n\nis-capital est une association \\(1\\) à \\(1\\).\nis-in est une association \\(1\\) à plusieurs.\nis-spoken-in est une association plusieurs à plusieurs."
  },
  {
    "objectID": "slides/Modelisation_2.html#traduction-des-associations-binaires-1-à-1-du-mcd",
    "href": "slides/Modelisation_2.html#traduction-des-associations-binaires-1-à-1-du-mcd",
    "title": "Modélisation II :",
    "section": "Traduction des associations binaires 1 à 1 du MCD",
    "text": "Traduction des associations binaires 1 à 1 du MCD\nSoit \\(A\\) une association 1 à 1 entre deux \\(E_1\\) et \\(E_2\\) telle que le taux de participation des instances de \\(E_1\\) à l’association \\(A\\) est plus grand que celui des instances de \\(E_2\\).\n\nTraduction en tables de \\(E_1\\) et \\(E_2\\).\nAjout d’un attribut dans \\(E_1\\) (une clé étrangère) qui référence l’identifiant de \\(E_2\\) (la clé primaire de \\(E_2\\)).\nAjout des attributs de \\(A\\) dans \\(E_1\\).\nCréation d’un lien entre les deux tables.\nOn fait figurer du coté de la clé étrangère les cardinalités de \\(A\\) qui dans le modèle E/A, étaient du côté l’entité référencée.\n\n\n\n\n\n\n\n\nChoix entre \\(E_1\\) et \\(E_2\\)\n\n\n\nPour les instances de \\(E_1\\) qui ne participent pas à l’association, les âttributs ajoutés par traduction de \\(A\\) seront NULL.\nOn choisit \\(E_1\\) plutôt que \\(E_2\\) pour minimiser le nombre de valeur NULL. Mais choisir \\(E_2\\) plutôt que \\(E_1\\) est possible."
  },
  {
    "objectID": "slides/Modelisation_2.html#exemple-de-la-relation-is-capital-de-world",
    "href": "slides/Modelisation_2.html#exemple-de-la-relation-is-capital-de-world",
    "title": "Modélisation II :",
    "section": "Exemple de la relation is-capital de World",
    "text": "Exemple de la relation is-capital de World\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\nLa cardinalité maximale 1 du MRD sur la clé étrangère capital de COUNTRY se traduira en SQL par une contrainte UNIQUE sur capital."
  },
  {
    "objectID": "slides/Modelisation_2.html#traduction-des-associations-binaires-1-à-plusieurs-du-mcd",
    "href": "slides/Modelisation_2.html#traduction-des-associations-binaires-1-à-plusieurs-du-mcd",
    "title": "Modélisation II :",
    "section": "Traduction des associations binaires 1 à plusieurs du MCD",
    "text": "Traduction des associations binaires 1 à plusieurs du MCD\nSoit \\(A\\) une association 1 à plusieurs entre deux \\(E_1\\) et \\(E_2\\) (plusieurs du côté de \\(E_2\\)) :\n\nTraduction en tables de \\(E_1\\) et \\(E_2\\).\nAjout d’un attribut dans \\(E_1\\) (une clé étrangère) qui référence l’identifiant de \\(E_2\\) (la clé primaire de \\(E_2\\)).\nAjout des attributs de \\(A\\) dans \\(E_1\\).\nCréation d’un lien entre les deux tables.\nOn fait figurer du coté de la clé étrangère les cardinalités de \\(A\\) qui dans le modèle E/A, étaient du côté l’entité référencée."
  },
  {
    "objectID": "slides/Modelisation_2.html#exemple-de-la-relation-is-in-de-world",
    "href": "slides/Modelisation_2.html#exemple-de-la-relation-is-in-de-world",
    "title": "Modélisation II :",
    "section": "Exemple de la relation is-in de World",
    "text": "Exemple de la relation is-in de World\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\nLa cardinalité minimale 1 du côté de CITY dans le MCD n’est pas traduite dans le MRD mais elle se traduira en SQL par une contrainte NOT NULL sur la clé étrangère countrycode de la table CITY."
  },
  {
    "objectID": "slides/Modelisation_2.html#traduction-des-associations-faibles-et-des-spécialisations",
    "href": "slides/Modelisation_2.html#traduction-des-associations-faibles-et-des-spécialisations",
    "title": "Modélisation II :",
    "section": "Traduction des associations faibles et des spécialisations",
    "text": "Traduction des associations faibles et des spécialisations\n\nLes spécialisations et les associations faibles du modèle E/A sont des associations binaires un à plusieurs qui sont traduites selon le principe précédent.\nPour les spécialisations, comme l’entité spécialisée n’avait pas d’identifiant, l’attribut introduit par traduction de l’association de spécialisation devient la clé primaire.\nPour les entités faibles, l’assocation faible avec l’entité forte de référence est déjà traduite par décomposition de l’identifiant concaténé en deux attributs qui forment la clé primaire de la table traduisant l’entité faible."
  },
  {
    "objectID": "slides/Modelisation_2.html#exemple-de-traduction-dune-association-faible",
    "href": "slides/Modelisation_2.html#exemple-de-traduction-dune-association-faible",
    "title": "Modélisation II :",
    "section": "Exemple de traduction d’une association faible",
    "text": "Exemple de traduction d’une association faible"
  },
  {
    "objectID": "slides/Modelisation_2.html#exemple-de-traduction-dune-spécialisation",
    "href": "slides/Modelisation_2.html#exemple-de-traduction-dune-spécialisation",
    "title": "Modélisation II :",
    "section": "Exemple de traduction d’une spécialisation",
    "text": "Exemple de traduction d’une spécialisation"
  },
  {
    "objectID": "slides/Modelisation_2.html#traduction-des-associations-binaires-plusieurs-à-plusieurs",
    "href": "slides/Modelisation_2.html#traduction-des-associations-binaires-plusieurs-à-plusieurs",
    "title": "Modélisation II :",
    "section": "Traduction des associations binaires plusieurs à plusieurs",
    "text": "Traduction des associations binaires plusieurs à plusieurs\nSoit \\(A\\) une association plusieurs à plusieurs entre deux entités \\(E_1\\) et \\(E_2\\) :\n\nTraduction en tables de \\(E_1\\) et \\(E_2\\).\nTraduction de \\(A\\) en une entité faible intermédiaire dont l’identifiant est le couple des identifiants de \\(E_1\\) et \\(E_2\\).\nCréation de deux associations binaires faibles \\(A_1\\) et \\(A_2\\) respectivement entre \\(A\\) et \\(E_1\\) et entre \\(A\\) et \\(E_2\\).\nTraduction en tables de cette décomposition.\n\n\n\n\n\n\n\n\nRemarque\n\n\nDu côté de l’entité faible, la cardinalité d’une association faible est toujours 1:1 donc les associations faibles sont de type un à plusieurs ou un à un."
  },
  {
    "objectID": "slides/Modelisation_2.html#exemple-de-la-relation-is-spoken-in-de-world",
    "href": "slides/Modelisation_2.html#exemple-de-la-relation-is-spoken-in-de-world",
    "title": "Modélisation II :",
    "section": "Exemple de la relation is-spoken-in de World",
    "text": "Exemple de la relation is-spoken-in de World"
  },
  {
    "objectID": "slides/Modelisation_2.html#mrd-world",
    "href": "slides/Modelisation_2.html#mrd-world",
    "title": "Modélisation II :",
    "section": "MRD world",
    "text": "MRD world"
  },
  {
    "objectID": "slides/Modelisation_2.html#mrd-world-simplifié",
    "href": "slides/Modelisation_2.html#mrd-world-simplifié",
    "title": "Modélisation II :",
    "section": "MRD world simplifié",
    "text": "MRD world simplifié\n\n\n\n\n\n\nSimplification\n\n\n\nOn peut choisir de supprimer la table LANGUAGE car elle n’a pas d’autre attribut que l’identifiant.\nMais cela supprime une contrainte d’intégrité référentielle, c.a.d. la contrainte d’appartenance de l’attribut is-spohen-in.language à un ensemble déterminé de valeurs : les valeurs stockées dans language.name."
  },
  {
    "objectID": "slides/Modelisation_2.html#traduction-dune-association-n-aire",
    "href": "slides/Modelisation_2.html#traduction-dune-association-n-aire",
    "title": "Modélisation II :",
    "section": "Traduction d’une association \\(n\\)-aire",
    "text": "Traduction d’une association \\(n\\)-aire\nSoient \\(n&gt;2\\), \\(E_1\\), \\(\\dots\\), \\(E_n\\) des entités et \\(A\\) une association \\(n\\)-aire entre ces entités.\n\nDécomposition de l’association \\(A\\) en une entité faible et \\(n\\) associations binaires de type 1 à plusieurs ou 1 à 1.\nTraduction en tables de cette décomposition."
  },
  {
    "objectID": "slides/Modelisation_2.html#exemple-de-lassociation-flight",
    "href": "slides/Modelisation_2.html#exemple-de-lassociation-flight",
    "title": "Modélisation II :",
    "section": "Exemple de l’association flight",
    "text": "Exemple de l’association flight\nMCD avant décomposition\n\n\n\n\n\n\nER\n\n\n\nAIRPORT\n\nAIRPORT\n\n\n\nflight\n\nflight\n\n\n\nAIRPORT--flight\n\norig\n0:n\n\n\n\nPLANE\n\nPLANE\n\n\n\nAIRLINE\n\nAIRLINE\n\n\n\nflight--AIRPORT\n\ndest\n0:n\n\n\n\nflight--PLANE\n\n0:n\n\n\n\nflight--AIRLINE\n\n0:n"
  },
  {
    "objectID": "slides/Modelisation_2.html#mcd-flight-décomposé",
    "href": "slides/Modelisation_2.html#mcd-flight-décomposé",
    "title": "Modélisation II :",
    "section": "MCD flight décomposé",
    "text": "MCD flight décomposé\n\n\n\n\n\n\nER\n\n\n\nAIRPORT\n\nAIRPORT\n\n\n\norig\n\n\norig\n\n\n\nAIRPORT--orig\n\n0:n\n\n\n\ndest\n\n\ndest\n\n\n\nAIRPORT--dest\n\n0:n\n\n\n\nPLANE\n\nPLANE\n\n\n\nAIRLINE\n\nAIRLINE\n\n\n\nFLIGHT\n\n\nFLIGHT\n\n\n\noperates\n\n\noperates\n\n\n\nFLIGHT--operates\n\n1:1\n\n\n\nuses\n\n\nuses\n\n\n\nFLIGHT--uses\n\n1:1\n\n\n\norig--FLIGHT\n\n1:1\n\n\n\ndest--FLIGHT\n\n1:1\n\n\n\noperates--AIRLINE\n\n0:n\n\n\n\nuses--PLANE\n\n0:n"
  },
  {
    "objectID": "slides/Modelisation_2.html#mrd-flight",
    "href": "slides/Modelisation_2.html#mrd-flight",
    "title": "Modélisation II :",
    "section": "MRD flight",
    "text": "MRD flight"
  },
  {
    "objectID": "slides/Modelisation_2.html#une-traduction-immédiate",
    "href": "slides/Modelisation_2.html#une-traduction-immédiate",
    "title": "Modélisation II :",
    "section": "Une traduction immédiate",
    "text": "Une traduction immédiate\n\nChaque table du MRD correspond à une table SQL.\nLes identifiants sont définis comme clés primaires.\nLes liens du MRD se traduisent en contraintes d’intégrité référentielle.\nLes contraintes du MCD se traduisent autant que possible en contraintes SQL selon les possibilités du SGBD choisi."
  },
  {
    "objectID": "slides/Modelisation_2.html#contraintes-unique-traduites-des-cardinalités-du-mrd",
    "href": "slides/Modelisation_2.html#contraintes-unique-traduites-des-cardinalités-du-mrd",
    "title": "Modélisation II :",
    "section": "Contraintes UNIQUE traduites des cardinalités du MRD",
    "text": "Contraintes UNIQUE traduites des cardinalités du MRD\n\n\n\n\n\n\nImportant\n\n\nUne cardinalité maximale 1 du MRD sur une clé étrangère se traduit en SQL par une contrainte UNIQUE sur cette clé étrangère."
  },
  {
    "objectID": "slides/Modelisation_2.html#exemple-de-lassociation-is-capital-de-world",
    "href": "slides/Modelisation_2.html#exemple-de-lassociation-is-capital-de-world",
    "title": "Modélisation II :",
    "section": "Exemple de l’association is-capital de World",
    "text": "Exemple de l’association is-capital de World\n\n\n\n\n\nOn ajoute une contrainte UNIQUE sur la clé étrangère capital de la table country."
  },
  {
    "objectID": "slides/Modelisation_2.html#contraintes-not-null-traduites-des-cardinalités-du-mcd",
    "href": "slides/Modelisation_2.html#contraintes-not-null-traduites-des-cardinalités-du-mcd",
    "title": "Modélisation II :",
    "section": "Contraintes NOT NULL traduites des cardinalités du MCD",
    "text": "Contraintes NOT NULL traduites des cardinalités du MCD\n\n\n\n\n\n\nImportant\n\n\nUne cardinalité minimale 1 du MCD du côté de l’entité à laquelle on ajoute une clé étrangère n’est pas traduite dans le MRD mais elle se traduit en SQL par une contrainte NOT NULL sur la clé étrangère."
  },
  {
    "objectID": "slides/Modelisation_2.html#exemple-de-lassociation-is-in-de-world",
    "href": "slides/Modelisation_2.html#exemple-de-lassociation-is-in-de-world",
    "title": "Modélisation II :",
    "section": "Exemple de l’association is-in de World",
    "text": "Exemple de l’association is-in de World\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn ajoute une contrainte NOT NULL sur la clé étrangère countrycode de la table city."
  },
  {
    "objectID": "slides/Modelisation_2.html#la-modélisation-un-exercice-très-général",
    "href": "slides/Modelisation_2.html#la-modélisation-un-exercice-très-général",
    "title": "Modélisation II :",
    "section": "La modélisation : un exercice très général",
    "text": "La modélisation : un exercice très général\nEn Informatique, la modélisation concerne aussi la conception des interfaces humains-machines, des sites WWW, des traitements divers, des entrepots de données, des lacs de données, ….\nChaque situation a suscité une méthode apropriée\n\nQuelques exemples :\n\nModèles Relation-Objet (Object Relational Model ORM)\nUML (Universal Modeling Language)"
  },
  {
    "objectID": "slides/LDD_2.html#schema-de-world",
    "href": "slides/LDD_2.html#schema-de-world",
    "title": "BD VII: gestion avancée des contraintes",
    "section": "Schema de world",
    "text": "Schema de world\n\nModèle relationnel du schéma World"
  },
  {
    "objectID": "slides/LDD_2.html#conraintes-sur-la-table-country",
    "href": "slides/LDD_2.html#conraintes-sur-la-table-country",
    "title": "BD VII: gestion avancée des contraintes",
    "section": "Conraintes sur la table country",
    "text": "Conraintes sur la table country\n\nUn pays est identifié par son countrycode,\nDeux pays ne devraient pas avoir le même nom,\nUne région ne devrait appartenir qu’à un seul continent,\nLa capitale d’un pays devrait être une ville connue dans city,\nLa capitale d’un pays devrait être une ville de ce pays,\nLes capitales de deux pays différents devraient être des villes différentes,\n…\n\n Ce ne sont pas les seules contraintes possibles"
  },
  {
    "objectID": "slides/LDD_2.html#mise-en-œuvre-des-contraintes",
    "href": "slides/LDD_2.html#mise-en-œuvre-des-contraintes",
    "title": "BD VII: gestion avancée des contraintes",
    "section": "Mise en œuvre des contraintes",
    "text": "Mise en œuvre des contraintes\n\nUn pays est identifié par son countrycode : PRIMARY KEY\nDeux pays ne devraient pas avoir le même nom : UNIQUE\nUne région ne devrait appartenir qu’à un seul continent : ??? -&gt; EXCLUDE\nLa capitale d’un pays devrait être une ville connue dans city : REFERENCES\nLa capitale d’un pays devrait être une ville de ce pays : ??? -&gt; trigger\nLes capitales de deux pays différents devraient être des villes différentes : UNIQUE\nDeux pays différents ne peuvent avoir le même code2 : UNIQUE"
  },
  {
    "objectID": "slides/LDD_2.html#examen-du-schema-de-country",
    "href": "slides/LDD_2.html#examen-du-schema-de-country",
    "title": "BD VII: gestion avancée des contraintes",
    "section": "Examen du schema de country",
    "text": "Examen du schema de country\n+--------------------+---------------+-----------+\n| Column             | Type          | Modifiers | \n|--------------------+---------------+-----------+-\n| countrycode        | character(3)  |  not null | \n| name_country       | text          |  not null | \n| continent          | text          |  not null | \n| region             | text          |  not null |\n| surfacearea        | real          |  not null |\n| indepyear          | smallint      |           | \n| population_country | integer       |  not null | \n| lifeexpectancy     | real          |           | \n| gnp                | numeric(10,2) |           | \n| gnpold             | numeric(10,2) |           | \n| localname          | text          |  not null | \n| governmentform     | text          |  not null | \n| headofstate        | text          |           | \n| capital            | integer       |           | \n| code2              | character(2)  |  not null | \n+--------------------+---------------+-----------+\n Un schéma de table ne se réduit pas à la données des noms et domaines des colonnes."
  },
  {
    "objectID": "slides/LDD_2.html#suite",
    "href": "slides/LDD_2.html#suite",
    "title": "BD VII: gestion avancée des contraintes",
    "section": "suite",
    "text": "suite\nIndexes:\n    \"country_pkey\" PRIMARY KEY, btree (countrycode)\nCheck constraints:\n    \"country_continent_check\" CHECK (continent = 'Asia'::text OR \n                                     continent = 'Europe'::text OR \n                                     continent = 'North America'::text OR \n                                     continent = 'Africa'::text OR\n                                     continent = 'Oceania'::text OR\n                                     continent = 'Antarctica'::text OR\n                                     continent = 'South America'::text),\nForeign-key constraints:\n    \"country_capital_fkey\" FOREIGN KEY (capital) REFERENCES city(id)"
  },
  {
    "objectID": "slides/LDD_2.html#ddl-pour-country",
    "href": "slides/LDD_2.html#ddl-pour-country",
    "title": "BD VII: gestion avancée des contraintes",
    "section": "DDL pour country",
    "text": "DDL pour country\nCREATE TABLE world.country (\n    countrycode bpchar(3) NOT NULL,\n    name_country text NOT NULL,\n    continent text NOT NULL,\n    region text NOT NULL,\n    surfacearea float4 NOT NULL,\n    indepyear int2 NULL,\n    population_country int4 NOT NULL,\n    lifeexpectancy float4 NULL,\n    gnp numeric(10, 2) NULL,\n    gnpold numeric(10, 2) NULL,\n    localname text NOT NULL,\n    governmentform text NOT NULL,\n    headofstate text NULL,\n    capital int4 NULL,\n    code2 bpchar(2) NOT NULL,\n    CONSTRAINT country_continent_check CHECK (((continent = 'Asia'::text) \n    OR (continent = 'Europe'::text) \n    OR (continent = 'North America'::text) \n    OR (continent = 'Africa'::text) \n    OR (continent = 'Oceania'::text)\n    OR (continent = 'Antarctica'::text) \n    OR (continent = 'South America'::text))),\n    CONSTRAINT country_pkey PRIMARY KEY (countrycode)\n);"
  },
  {
    "objectID": "slides/LDD_2.html#ajout-de-contraintes-référentielles",
    "href": "slides/LDD_2.html#ajout-de-contraintes-référentielles",
    "title": "BD VII: gestion avancée des contraintes",
    "section": "Ajout de contraintes référentielles",
    "text": "Ajout de contraintes référentielles\n\nUne contrainte d’intégrité référentielle impose l’inclusion de l’ensemble des valeurs d’une colonne (la colone qui référence) à l’ensemble des valeurs d’une autre colonne (la colonne référencée).\n\n\n\nLa colonne référencée est quasiment toujours la clé primaire d’une autre table. On peut alors définir la contrainte en n’indiquant que la table référencée (car la clé primaire est unique) :\n\nALTER TABLE world.country ADD CONSTRAINT \n  country_capital_fkey FOREIGN KEY (capital) REFERENCES world.city;\n\n\n\nSi la colonne référencée n’est pas une clé primaire, elle doit vérifier une contrainte d’unicité. Il faut alors préciser le nom de la table et le nom de la colonne référencée avec cette syntaxe : REFERENCES nom_table(nom_colonne)"
  },
  {
    "objectID": "slides/LDD_2.html#gestion-de-la-mise-à-jour-ou-de-la-suppression-dun-attribut-référencé",
    "href": "slides/LDD_2.html#gestion-de-la-mise-à-jour-ou-de-la-suppression-dun-attribut-référencé",
    "title": "BD VII: gestion avancée des contraintes",
    "section": "Gestion de la mise à jour ou de la suppression d’un attribut référencé",
    "text": "Gestion de la mise à jour ou de la suppression d’un attribut référencé\n\n\n\n\n\n\nImportant\n\n\nAprès la définition de la contrainte country_capital_fkey, la mise à jour ou la suppression d’une valeur de l’attribut city.id référencée dans l’attribut country.capital est bloquée par le SGBD.\n\n\n\n\nOn peut définir différentes actions pour les rendre possibles :\n\nCASCADE : supprime ou met à jour en cascade les lignes qui référencent la valeur supprimée ou mise à jour.\n\n\n\n\nSET NULL : met à NULL la ou les colonnes des lignes qui référencent la valeur supprimée ou mise à jour.\n\n\n\n\nSET DEFAULT : met à leur valeur par défaut la ou les colonnes des lignes qui référencent la valeur supprimée ou mise à jour."
  },
  {
    "objectID": "slides/LDD_2.html#utilisation-de-laction-cascade",
    "href": "slides/LDD_2.html#utilisation-de-laction-cascade",
    "title": "BD VII: gestion avancée des contraintes",
    "section": "Utilisation de l’action CASCADE",
    "text": "Utilisation de l’action CASCADE\nALTER TABLE world.city \n  ADD CONSTRAINT city_countrycode_fkey \n    FOREIGN KEY (countrycode) \n    REFERENCES world.country\n    ON DELETE CASCADE\n    ON UPDATE CASCADE;\n\nSi un countrycode est suprrimé dans la table country, toutes les lignes de la table city où ce code est présent seront supprimées, et si ces lignes sont référencées dans un autre table, les lignes qui les référencent seront elles-mêmes supprimées et ainsi de suite “en cascade”.\n\n\n\nSi un countrycode est mis à jour dans la table country, toutes les lignes de la table city où ce code est présent seront mises à jour, et si ces mises à jour sont référencées dans un autre table, les lignes qui les référencent seront elles-mêmes mises à jour et ainsi de suite “en cascade”."
  },
  {
    "objectID": "slides/LDD_2.html#utilisation-de-laction-set-null",
    "href": "slides/LDD_2.html#utilisation-de-laction-set-null",
    "title": "BD VII: gestion avancée des contraintes",
    "section": "Utilisation de l’action SET NULL",
    "text": "Utilisation de l’action SET NULL\nALTER TABLE world.city \n  ADD CONSTRAINT country_capital_fkey \n    FOREIGN KEY (capital) \n    REFERENCES world.city(id)\n    ON DELETE SET NULL\n    ON UPDATE CASCADE;\n\nSi un id est suprrimé dans la table city, les lignes de la table country où ce code est présent ne seront pas supprimées, la colonne capital sera mise à NULL. Cette action est possible car la valeur NULL est autorisée pour la colonne capital."
  },
  {
    "objectID": "slides/LDD_2.html#une-région-nappartient-quà-un-seul-continent",
    "href": "slides/LDD_2.html#une-région-nappartient-quà-un-seul-continent",
    "title": "BD VII: gestion avancée des contraintes",
    "section": "Une région n’appartient qu’à un seul continent",
    "text": "Une région n’appartient qu’à un seul continent\nCette contrainte signifie que le résultat de la requête suivante est vide :\nSELECT *\nFROM \n  world.country c1 \nJOIN \n  world.country c2 ON (c1.continent&lt;&gt; c2.continent AND c1.region=c2.region);\n\nOn exclut l’existence de deux lignes qui coïncideraient sur region mais pas sur continent\nNous postulons l’existence d’une dépendance fonctionnelle\n\\[\\texttt{region} \\longrightarrow \\texttt{continent}\\]"
  },
  {
    "objectID": "slides/LDD_2.html#deux-attitudes",
    "href": "slides/LDD_2.html#deux-attitudes",
    "title": "BD VII: gestion avancée des contraintes",
    "section": "Deux attitudes",
    "text": "Deux attitudes\nDans sa forme actuelle, la table country de world contient des informations redondantes: on répète plusieurs fois que la région Western Europe est située dans le continent Europe.\nCes redondances représentent un gaspillage de mémoire (très modeste ici) et un risque pour le maintien de la cohérence de la base : chaque insertion, mise-à-jour est susceptible de mettre en défaut la dépendance fonctionnelle.\nOn peut considérer qu’il s’agit d’une anomalie de schéma et normaliser le schéma.\nLa normalisation suppose une révision du schéma. Si le schéma est muni de vues et de fonctions, il faudra éventuellement réécrire ces vues et ces fonctions."
  },
  {
    "objectID": "slides/LDD_2.html#autre-possibilité-avec-une-contrainte-dexclusion",
    "href": "slides/LDD_2.html#autre-possibilité-avec-une-contrainte-dexclusion",
    "title": "BD VII: gestion avancée des contraintes",
    "section": "Autre possibilité avec une contrainte d’exclusion",
    "text": "Autre possibilité avec une contrainte d’exclusion\nAvec une contrainte d’exclusion (EXCLUDE), on ne touchera pas au schéma, les vues et les fonctions resteront utilisables.\nLa contrainte d’exclusion permettra de maintenir la dépendance fonctionnelle."
  },
  {
    "objectID": "slides/LDD_2.html#les-contraintes-dexclusion",
    "href": "slides/LDD_2.html#les-contraintes-dexclusion",
    "title": "BD VII: gestion avancée des contraintes",
    "section": "Les contraintes d’exclusion",
    "text": "Les contraintes d’exclusion\n\n\n\n\n\n\nObjectifs\n\n\n\nMise en place de dépendances fonctionnelles,\nMise en place de contraintes de non-recouvrement (données spatiales ou temporelles),\nMise en place de contraintes très diverses."
  },
  {
    "objectID": "slides/LDD_2.html#clause-exclude",
    "href": "slides/LDD_2.html#clause-exclude",
    "title": "BD VII: gestion avancée des contraintes",
    "section": "Clause EXCLUDE",
    "text": "Clause EXCLUDE\nUne clause EXCLUDE empêche que deux lignes vérifient toutes les comparaisons sur les colonnes spécifiées en utilisant les opérateurs indiqués par le mot clé WITH.\nALTER TABLE country\n   ADD CONSTRAINT xcl_country_region_continent \n      EXCLUDE USING GIST\n      (\n         region WITH =, \n         continent WITH &lt;&gt;\n      );\nCette contrainte d’exclusion empèche que deux lignes de la table country aient la colonne region égale et la colonne continent différente.\n\n\n\n\n\n\nNote\n\n\nLa clause USING définit le type d’index utilisé pour vérifier la contrainte d’exclusion.\nEn pratique, le type d’index sera toujours GiST ou SP-GiST (GIST est l’acronyme de Generalized Search Tree)."
  },
  {
    "objectID": "slides/LDD_0.html#définition-de-données",
    "href": "slides/LDD_0.html#définition-de-données",
    "title": "BD II: SQL LDD",
    "section": "Définition de données",
    "text": "Définition de données\nSQL est un monde à part entière\nOn peut :\n\nInterroger des données par des requêtes (déjà vu en partie)\nAdministrer les bases de données :\n\nCréer celles-ci : définition des tables (schémas, etc), contraintes..\nCréer de nouvelles données, en insérer, supprimer, mettre à jour, etc\nCréer et gérer les utilisateurs, leurs droits sur les objets de la base,\n…\n\n\n\nDans ce cours : création des tables (version simplifiée) et des données"
  },
  {
    "objectID": "slides/LDD_0.html#création-de-tables-1",
    "href": "slides/LDD_0.html#création-de-tables-1",
    "title": "BD II: SQL LDD",
    "section": "Création de tables",
    "text": "Création de tables\n\nInstruction : CREATE TABLE ...\n\nPermet de définir :\n\nLes noms et les domaines (type) des attributs ainsi que des contraintes d’intégrité comme :\n\nContraintes de clés primaires (PRIMARY KEY)\nContraintes référentielles (clés étrangères FOREIGN KEY, par exemple)\n\nDes contraintes assez générales (de contrôle des données)\nDes index (pour la recherche et l’exécution efficaces)"
  },
  {
    "objectID": "slides/LDD_0.html#création-de-tables-noms-et-domaines-dattributs",
    "href": "slides/LDD_0.html#création-de-tables-noms-et-domaines-dattributs",
    "title": "BD II: SQL LDD",
    "section": "Création de tables : noms et domaines d’attributs",
    "text": "Création de tables : noms et domaines d’attributs\nChaque relation est définie par un nom de relation et une liste d’attributs\nCREATE TABLE &lt;nom_relation&gt; (\n  &lt;element de relation&gt;\n  &lt;,element de relation&gt;*\n  &lt;,contrainte de relation&gt;* );\n\nChaque attribut est défini par un nom d’attribut et un type de données\n&lt;element de relation&gt; ::= &lt;nom_attrib&gt;&lt;type_donnees&gt;[&lt;contrainte_attrib&gt;*]\n\n\nExemples de types\n&lt;type_donnees&gt; ::=  VARCHAR &lt;longueur&gt;| INT | REAL | DATE"
  },
  {
    "objectID": "slides/LDD_0.html#exemple",
    "href": "slides/LDD_0.html#exemple",
    "title": "BD II: SQL LDD",
    "section": "Exemple",
    "text": "Exemple\nSchéma:\nfournisseur(nomf, villef),\npiece(nomp, prix, couleur),\nlivraison(numliv, nomf, nomp, dateliv, quantite)\n\nCREATE TABLE fournisseur(\n    nomf VARCHAR(20),\n    villef VARCHAR(20)\n);\n\nCREATE TABLE piece(\n    nomp VARCHAR(20),\n    prix REAL,\n    couleur VARCHAR(15)\n);"
  },
  {
    "objectID": "slides/LDD_0.html#exemple-avec-valeurs-par-défaut",
    "href": "slides/LDD_0.html#exemple-avec-valeurs-par-défaut",
    "title": "BD II: SQL LDD",
    "section": "Exemple avec valeurs par défaut",
    "text": "Exemple avec valeurs par défaut\nCREATE TABLE livraison(\n    numLiv INT,\n    nomf VARCHAR(20),\n    nomp VARCHAR(20),\n    dateliv DATE DEFAULT NOW(),\n    quantite INT DEFAULT 1\n);\n\n\n\n\n\n\n\nValeurs par défaut\n\n\n\nPour dateliv, c’est la date courante lors de l’insertion de la ligne dans la table,\nPour quantite, c’est une constante."
  },
  {
    "objectID": "slides/LDD_0.html#exemple-schéma-world",
    "href": "slides/LDD_0.html#exemple-schéma-world",
    "title": "BD II: SQL LDD",
    "section": "Exemple : schéma world",
    "text": "Exemple : schéma world"
  },
  {
    "objectID": "slides/LDD_0.html#exemple-schéma-world-avec-clé-primaire-composée",
    "href": "slides/LDD_0.html#exemple-schéma-world-avec-clé-primaire-composée",
    "title": "BD II: SQL LDD",
    "section": "Exemple : schéma world avec clé primaire composée",
    "text": "Exemple : schéma world avec clé primaire composée\nCREATE TABLE world.countrylanguage (\n    countrycode bpchar(3) NOT NULL,\n    \"language\" text NOT NULL,\n    isofficial bool NOT NULL,\n    percentage float4 NOT NULL,\n    CONSTRAINT countrylanguage_pkey\n        PRIMARY KEY (countrycode, language)\n);\n\n\n\n\n\n\n\nAttention\n\n\nUne clé peut être composée de plusieurs attributs"
  },
  {
    "objectID": "slides/LDD_0.html#exemple-schéma-world-suite",
    "href": "slides/LDD_0.html#exemple-schéma-world-suite",
    "title": "BD II: SQL LDD",
    "section": "Exemple: schéma world (suite)",
    "text": "Exemple: schéma world (suite)\nCREATE TABLE world.country (\n    countrycode bpchar(3) NOT NULL,\n    name_country text NOT NULL,\n    continent text NOT NULL,\n    region text NOT NULL,\n    surfacearea float4 NOT NULL,\n    indepyear int2 NULL,\n    population_country int4 NOT NULL,\n    lifeexpectancy float4 NULL,\n    gnp numeric(10, 2) NULL,\n    gnpold numeric(10, 2) NULL,\n    localname text NOT NULL,\n    governmentform text NOT NULL,\n    headofstate text NULL,\n    capital int4 NULL,\n    code2 bpchar(2) NOT NULL,\n    CONSTRAINT country_continent_check CHECK (\n        ((continent = 'Asia'::text) OR (\n            continent = 'Europe'::text) OR\n            (continent = 'North America'::text) OR\n            (continent = 'Africa'::text) OR\n            (continent = 'Oceania'::text) OR\n            (continent = 'Antarctica'::text) OR\n            (continent = 'South America'::text))),\n    CONSTRAINT country_pkey PRIMARY KEY (countrycode)\n);"
  },
  {
    "objectID": "slides/LDD_0.html#suppression-dune-table",
    "href": "slides/LDD_0.html#suppression-dune-table",
    "title": "BD II: SQL LDD",
    "section": "Suppression d’une table",
    "text": "Suppression d’une table\nDROP TABLE fournisseur;\nDROP TABLE piece;\nDROP TABLE livraison;\n\n\n\n\n\n\nSuppression n’est pas vidange\n\n\nSupprimer une table, c’est supprimer son contenu (vidange) mais aussi son schéma"
  },
  {
    "objectID": "slides/LDD_0.html#contenu-des-relations",
    "href": "slides/LDD_0.html#contenu-des-relations",
    "title": "BD II: SQL LDD",
    "section": "Contenu des relations",
    "text": "Contenu des relations\nOn peut gérer le contenu des tables directement dans le langage SQL :\n\nAjouter des tuples à une table : INSERT INTO ...\nMettre à jour des tuples d’une relation : UPDATE ...\nSupprimer des tuples : DELETE FROM ..."
  },
  {
    "objectID": "slides/LDD_0.html#insertion-de-tuples-syntaxe",
    "href": "slides/LDD_0.html#insertion-de-tuples-syntaxe",
    "title": "BD II: SQL LDD",
    "section": "Insertion de tuples : syntaxe",
    "text": "Insertion de tuples : syntaxe\nINSERT INTO &lt;nom_relation&gt;\n    [(nom_attrib [, nom_attrib]*)]\n    VALUES (valeur [, valeur]*);\n\nINSERT INTO piece VALUES('x21', 1.51, 'rouge');\n\nINSERT INTO piece (nomp,couleur) VALUES('x22', 'vert');\n\n+--------+--------+-----------+\n| nomp   | prix   | couleur   |\n|--------+--------+-----------|\n| x21    | 1.51   | rouge     |\n| x22    | &lt;null&gt; | vert      |\n+--------+--------+-----------+\n\n\n\n\n\n\nAttention\n\n\n\nLes valeurs doivent être fournies dans l’ordre de déclaration des attributs,\nLes valeurs non spécifiées sont affectées à NULL"
  },
  {
    "objectID": "slides/LDD_0.html#insertion-exemple-suite",
    "href": "slides/LDD_0.html#insertion-exemple-suite",
    "title": "BD II: SQL LDD",
    "section": "Insertion, exemple (suite)",
    "text": "Insertion, exemple (suite)\nINSERT INTO world.Country\n  (countrycode, name_country, continent,\n   region, surfacearea, indepyear, population_country,\n   lifeexpectancy, gnp, gnpold,\n   localname, governmentform, headofstate, capital, code2)\nVALUES(\n    'SYL', 'Syldavia', 'Europe',\n    'Eastern Europe', 200000, 1918, 21345717, 81.2, 25213, 24878,\n    'Syldavie', 'Constitutional Monarchy', 'Ottokar II', 0, 'SY'\n);"
  },
  {
    "objectID": "slides/LDD_0.html#remarques",
    "href": "slides/LDD_0.html#remarques",
    "title": "BD II: SQL LDD",
    "section": "Remarques",
    "text": "Remarques\nLa dernière partie du constructeur multiligne, qui commence avec VALUES est souvent appelée la liste de valeurs.\n\nUne liste de valeurs peut être définie sans référence à une table existante et définir à la volée une nouvelle table virtuelle/éphémère.\n\n\nSELECT *\nFROM (\n  VALUES\n    ('robe', 'logged in', '2011-01-10 10:15 AM EST'::timestamptz),\n    ('lhsu', 'logged out', '2011-01-11 10:20 AM EST'::timestamptz)\n) AS l (user_name, description, log_ts);\n\n\n\n\n\n\nNote\n\n\nQuand on utilise VALUES pour définir une table virtuelle, il faut spécifier le nom des colonnes.\nPar défaut, les types des colonnes sont inférés. Si l’inférence de type n’est pas possible, il faut effectuer explicitement des conversions de type comme ici avec ::timestamptz."
  },
  {
    "objectID": "slides/LDD_0.html#exemple-insertion-de-tuples-suite",
    "href": "slides/LDD_0.html#exemple-insertion-de-tuples-suite",
    "title": "BD II: SQL LDD",
    "section": "Exemple : Insertion de tuples (suite)",
    "text": "Exemple : Insertion de tuples (suite)\nINSERT INTO livraison\n    VALUES\n    (1, 'fournisseur1', 'x21', '2019-07-13', 2);\n\n-- Avec des colonnes non renseignées\n\nINSERT INTO livraison\n   (numliv, dateliv, quantite)\n    VALUES\n   (2, '2018-07-29', 10);\n\n\n+----------+--------------+--------+------------+------------+\n| numliv   | nomf         | nomp   | dateliv    | quantite   |\n|----------+--------------+--------+------------+------------|\n| 1        | fournisseur1 | x21    | 2019-07-13 | 2          |\n| 2        | &lt;null&gt;       | &lt;null&gt; | 2018-07-29 | 10         |\n+----------+--------------+--------+------------+------------+"
  },
  {
    "objectID": "slides/LDD_0.html#insertion-de-tuples-par-requête",
    "href": "slides/LDD_0.html#insertion-de-tuples-par-requête",
    "title": "BD II: SQL LDD",
    "section": "Insertion de tuples par requête",
    "text": "Insertion de tuples par requête\n\nOn peut faire une insertion par le biais d’une requête,\nLa clause VALUES est remplacée par une requête,\nLes résultats de la requête sont insérés comme valeurs dans la table.\nPour respecter les contraintes d’unicité, le mot clé DISTINCT peut être nécessaire, en particulier lorsqu’il y a une jointure.\n\n\nExemple 1\nINSERT INTO FournisseursParisiens (\n  SELECT *\n  FROM Fournisseur\n  WHERE VilleF='Paris'\n);"
  },
  {
    "objectID": "slides/LDD_0.html#exemple-2",
    "href": "slides/LDD_0.html#exemple-2",
    "title": "BD II: SQL LDD",
    "section": "Exemple 2",
    "text": "Exemple 2\nCREATE TABLE monschema.city () \n  INHERITS (world.city) ;\n\nCREATE TABLE monschema.country () \n  INHERITS (world.country) ;\n\nINSERT INTO monschema.country (\n    SELECT * \n    FROM world.country\n    WHERE continent = 'Europe' \n);\n\nINSERT INTO monschema.city (\n    SELECT ci.*  \n    FROM world.city ci NATURAL JOIN \n      world.country co\n    WHERE co.continent = 'Europe'\n) ;"
  },
  {
    "objectID": "slides/LDD_0.html#mise-à-jour-de-colonnes-de-cellules",
    "href": "slides/LDD_0.html#mise-à-jour-de-colonnes-de-cellules",
    "title": "BD II: SQL LDD",
    "section": "Mise à jour de colonnes, de cellules",
    "text": "Mise à jour de colonnes, de cellules\nOn peut mettre à jour des tuples d’une table par le biais d’une requête UPDATE.\nUPDATE nom_table1\nSET nom_attribut = &lt;expression de valeur&gt; \n    [ , nom_attribut = &lt;expression de valeur&gt; ]\n[FROM nom_table2 [, [JOIN] nom_table3]]\n[WHERE &lt;condition de recherche&gt; ];\n\n\n\n\n\n\n\nNote\n\n\n&lt;expression de valeur&gt; peut être :\n\nNULL,\nune constante explicite,\nune expression arithmétique sur les attributs des tables des clauses SET ou FROM,\nle résultat d’une requête scalaire.\n\n\n\n\n\n\n\n\n\n\n\n\nAvertissement\n\n\nOn ne peut pas utiliser la notation nom_table.nom_attribut dans la clause SET."
  },
  {
    "objectID": "slides/LDD_0.html#exemple-de-mise-à-jour-de-tuples",
    "href": "slides/LDD_0.html#exemple-de-mise-à-jour-de-tuples",
    "title": "BD II: SQL LDD",
    "section": "Exemple de mise à jour de tuples",
    "text": "Exemple de mise à jour de tuples\nAugmentation du prix d’une pièce\nUPDATE Piece\nSET prix = prix * 1.05\nWHERE nomp = 'x21';"
  },
  {
    "objectID": "slides/LDD_0.html#calcul-de-la-nouvelle-valeur-par-une-sous-requête",
    "href": "slides/LDD_0.html#calcul-de-la-nouvelle-valeur-par-une-sous-requête",
    "title": "BD II: SQL LDD",
    "section": "Calcul de la nouvelle valeur par une sous-requête",
    "text": "Calcul de la nouvelle valeur par une sous-requête\nUPDATE Piece\nSET Prix = (\n    SELECT prix\n    FROM Piece\n    WHERE nomp = 'x21'\n)\nWHERE Prix &lt;= 1000;"
  },
  {
    "objectID": "slides/LDD_0.html#utilisation-de-la-clause-from",
    "href": "slides/LDD_0.html#utilisation-de-la-clause-from",
    "title": "BD II: SQL LDD",
    "section": "Utilisation de la clause FROM",
    "text": "Utilisation de la clause FROM\n\nOn peut avoir besoin de plusieurs tables pour sélectionner les tuples à mettre à jour.\nLa syntaxe à utiliser varie un peu selon le SGBD.\nAvec PostgreSQL, on écrira les tables suplémentaires dans une clause FROM (JOIN possible si au moins deux tables supplémentaires).\n\nUPDATE Piece p\nSET p.prix = p.prix * 1.1\nFROM Livraison l\nWHERE\n    p.nomp = l.nomp\n    AND l.quantite &gt; 2* (SELECT MIN(quantite) FROM Livraison);\n\n\n\n\n\n\nMise en garde\n\n\nSi, pour une même ligne de la table Piece, plusieurs lignes de la table Livraison vérifient la condition, la mise à jour n’est effectuée qu’une seule fois."
  },
  {
    "objectID": "slides/LDD_0.html#update-avec-cte",
    "href": "slides/LDD_0.html#update-avec-cte",
    "title": "BD II: SQL LDD",
    "section": "UPDATE avec CTE",
    "text": "UPDATE avec CTE\nIl est parfois pratique d’écrire une CTE pour définir les couples (identifiant, nouvelle valeur).\nWITH r AS (\n  SELECT p.nomp AS id, p.prix * 1.1 AS newvalue\n  FROM Piece p\n  JOIN Livraison l ON p.nomp = l.nomp\n  WHERE l.quantite &gt; 2* (SELECT MIN(quantite) FROM Livraison)\n)\nUPDATE Piece p\nSET prix = r.newvalue\nFROM r\nWHERE p.nomp = r.id"
  },
  {
    "objectID": "slides/LDD_0.html#suppression-de-tuples-1",
    "href": "slides/LDD_0.html#suppression-de-tuples-1",
    "title": "BD II: SQL LDD",
    "section": "Suppression de tuples",
    "text": "Suppression de tuples\nDELETE FROM &lt;nom_relation&gt;\n[USING nom_table2 [, [JOIN] nom_table3]]\n[WHERE &lt;condition de recherche&gt;];\n\n\n\n\n\n\nImportant\n\n\nL’oubli de la clause where supprime toutes les données de la table."
  },
  {
    "objectID": "slides/LDD_0.html#exemple-de-suppression-de-tuples",
    "href": "slides/LDD_0.html#exemple-de-suppression-de-tuples",
    "title": "BD II: SQL LDD",
    "section": "Exemple de suppression de tuples",
    "text": "Exemple de suppression de tuples\nDELETE FROM Fournisseur\nWHERE NomF = 'FastDelivery';\nOn supprime dans Fournisseur les tuples correspondant au fournisseur nommé 'FastDelivery'"
  },
  {
    "objectID": "slides/LDD_0.html#suppression-de-tuples-avec-requête-imbriquée",
    "href": "slides/LDD_0.html#suppression-de-tuples-avec-requête-imbriquée",
    "title": "BD II: SQL LDD",
    "section": "Suppression de tuples avec requête imbriquée",
    "text": "Suppression de tuples avec requête imbriquée\nDELETE FROM Livraison\nWHERE NomP IN (\n    SELECT NomP\n    FROM Piece\n    WHERE Couleur='Rouge'\n);"
  },
  {
    "objectID": "slides/LDD_0.html#utilisation-de-la-clause-using",
    "href": "slides/LDD_0.html#utilisation-de-la-clause-using",
    "title": "BD II: SQL LDD",
    "section": "Utilisation de la clause USING",
    "text": "Utilisation de la clause USING\n\nOn peut avoir besoin de plusieurs tables pour sélectionner les tuples à supprimer.\nLa syntaxe à utiliser varie un peu selon le SGBD. PostgreSQL ne supporte pas l’utilisation de JOIN dans la clause FROM d’une instruction DELETE.\nOn écrira les tables suplémentaires dans une clause USING (JOIN possible si au moins deux tables supplémentaires).\n\nDELETE FROM monschema.city AS ci\nUSING monschema.country AS co\nWHERE \n  ci.countrycode = co.countrycode AND \n  co.region= 'Eastern Europe' AND \n  co.indepyear = 1991 ;"
  },
  {
    "objectID": "slides/LDD_0.html#suppression-de-données-et-contraintes-dintégrité-référentielle",
    "href": "slides/LDD_0.html#suppression-de-données-et-contraintes-dintégrité-référentielle",
    "title": "BD II: SQL LDD",
    "section": "Suppression de données et contraintes d’intégrité référentielle",
    "text": "Suppression de données et contraintes d’intégrité référentielle\n\n\n\n\n\n\nAvertissement\n\n\nLa requête précédente pose-t’elle problème ?\n\n\n\n\nLes identifiants de l’attribut country.capital pour les pays vérifiant country.region = 'Eastern Europe' AND  country.indepyear = 1991 ne seront plus référencés dans la table city."
  },
  {
    "objectID": "slides/DF_norm_1.html#conception-du-modèle-relationnel",
    "href": "slides/DF_norm_1.html#conception-du-modèle-relationnel",
    "title": "Normalisation I",
    "section": "Conception du modèle relationnel",
    "text": "Conception du modèle relationnel\nUne première approche pour concevoir un modèle relationnel (l’ensemble des schémas de tables d’une bd) consiste à :\n\nIdentifier les attributs d’intérêt\nRépartir les attributs dans plusieurs relations\n\n\n\nComment savoir si le modèle relationnel est bon ?\n\n\n\n\nSi ce n’est pas le cas : y a-t-il des techniques pour le transformer en un bon modèle?"
  },
  {
    "objectID": "slides/DF_norm_1.html#qualité-dun-schéma",
    "href": "slides/DF_norm_1.html#qualité-dun-schéma",
    "title": "Normalisation I",
    "section": "Qualité d’un schéma",
    "text": "Qualité d’un schéma\nQuelles sont de bonnes propriétés d’un schéma ?\nExemple\nAttributs relatifs à des vendeurs, produits et livraisons\n\n\nAttribut\nUsage\n\n\n\nV#\nnuméro du vendeur\n\n\nVnom\nnom du vendeur\n\n\nVville\nville du vendeur\n\n\nP#\nnuméro du produit\n\n\nPnom\nnom du produit\n\n\nPville\nville où le produit est stocké\n\n\nQte\nquantité de produit livrée au vendeur"
  },
  {
    "objectID": "slides/DF_norm_1.html#qualité-dun-schéma-1",
    "href": "slides/DF_norm_1.html#qualité-dun-schéma-1",
    "title": "Normalisation I",
    "section": "Qualité d’un schéma",
    "text": "Qualité d’un schéma\nUn schéma relationnel possible : une seule relation R avec tous les attributs\nR(V#, Vnom, Vville, P#, Pnom, Pville, Qte)\n\n\n C’est une mauvaise modélisation.\n Pourquoi ?"
  },
  {
    "objectID": "slides/DF_norm_1.html#qualité-dun-schéma-relationnel",
    "href": "slides/DF_norm_1.html#qualité-dun-schéma-relationnel",
    "title": "Normalisation I",
    "section": "Qualité d’un schéma relationnel",
    "text": "Qualité d’un schéma relationnel\n\n\n\n\n\n\nRedondance\n\n\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\n3\nMagicV\nParis\n…\n…\n…\n…\n\n\n3\nMagicV\nParis\n…\n…\n…\n…\n\n\n2\nIdealB\nLyon\n…\n…\n…\n…\n\n\n2\nIdealB\nLyon\n…\n…\n…\n…\n\n\n\nVnom et Vville sont déterminés parV# :\nsi deux livraisons ont le même V#, elles ont aussi le même Vville et le même Vnom"
  },
  {
    "objectID": "slides/DF_norm_1.html#section",
    "href": "slides/DF_norm_1.html#section",
    "title": "Normalisation I",
    "section": "",
    "text": "Anomalies de mise à jour\n\nVnom ou Vville pourrait être mis à jour dans une livraison et pas dans une autre, ce qui donnerait une incohérence. Les mesures pour éviter cela rendent la mise à jour est coûteuse\n\n\nAnomalies d’insertion\n\nOn ne peut pas enregistrer un vendeur s’il ne reçoit pas de livraison\n\n\n\nAnomalies de suppression\n\nSi on supprime toutes les livraisons à un vendeur, on perd toute l’information sur ce vendeur"
  },
  {
    "objectID": "slides/DF_norm_1.html#qualité-dun-schéma-relationnel-1",
    "href": "slides/DF_norm_1.html#qualité-dun-schéma-relationnel-1",
    "title": "Normalisation I",
    "section": "Qualité d’un schéma relationnel",
    "text": "Qualité d’un schéma relationnel\n\nUn bon schéma\n\nVendeur(V#, Vnom, Vville)    Clef : V#\nProduit(P#, Pnom, Pville)    Clef : P#\nLivraison(V#, P#, Qte)       Clef : (V#,P#)\n\nPlus d’anomalie ! Comment y arriver?\n\n\nLa théorie de la normalisation des BD relationnelles fournit\n\nla notion de forme normale : propriétés d’un schéma qui garantissent l’absence de redondance et des anomalies qui en dérivent. Ces propriétés sont définies par rapport à un ensemble de contraintes\ndes techniques de normalisation : passage d’un schéma arbitraire (mauvais) à un schéma en forme normale (obtenu typiquement par décomposition)"
  },
  {
    "objectID": "slides/DF_norm_1.html#df-exemple-suite",
    "href": "slides/DF_norm_1.html#df-exemple-suite",
    "title": "Normalisation I",
    "section": "DF exemple (suite)",
    "text": "DF exemple (suite)\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\n3\nMagicV\nParis\n322\nmanteau\nLille\n2\n\n\n1\nStarV\nRome\n546\nveste\nRome\n1\n\n\n3\nMagicV\nParis\n322\nmanteau\nLille\n5\n\n\n2\nIdealB\nLyon\n145\njupe\nParis\n7\n\n\n2\nIdealB\nLyon\n234\njupe\nLille\n1\n\n\n\n\n\nR satisfait V# ⟶ Vnom Vville et P# ⟶ Pnom Pville\nR viole V# P# ⟶ Qte"
  },
  {
    "objectID": "slides/DF_norm_1.html#autre-exemple",
    "href": "slides/DF_norm_1.html#autre-exemple",
    "title": "Normalisation I",
    "section": "Autre Exemple",
    "text": "Autre Exemple\nSchéma Films(titre, année, durée, genre, producteur, acteur)\n\n\n\n\n\n\n\n\n\n\ntitre\nannée\ndurée\ngenre\nproducteur\nacteur\n\n\n\nStar Wars\n1977\n124\nSciFi\nFox\nCarrie Fisher\n\n\nStar Wars\n1977\n124\nSciFi\nFox\nMark Hamill\n\n\nStar Wars\n1977\n124\nSciFi\nFox\nHarrison Ford\n\n\nGone With The Wind\n1939\n231\ndrame\nMGM\nVivien Leigh\n\n\nWayne’s World\n1992\n95\ncomédie\nParamount\nDana Carvey\n\n\nWayne’s World\n1992\n95\ncomédie\nParamount\nMike Meyers\n\n\n…"
  },
  {
    "objectID": "slides/DF_norm_1.html#définition-dune-dépendance-fonctionnelle",
    "href": "slides/DF_norm_1.html#définition-dune-dépendance-fonctionnelle",
    "title": "Normalisation I",
    "section": "Définition d’une dépendance fonctionnelle",
    "text": "Définition d’une dépendance fonctionnelle\n\n\n\n\n\n\nDéfinition : Dépendance fonctionnelle\n\n\nSoit \\(\\mathcal{A}\\) un schéma de relation (\\(\\mathcal{A}\\) est un ensemble d’attributs)\nUne dépendance fonctionnelle sur \\(\\mathcal{A}\\) est une expression de la forme\n\\[X → Y\\]\noù \\(X ⊆ \\mathcal{A}\\) et \\(Y ⊆ \\mathcal{A}\\)\nUne relation \\(R\\) de schéma \\(\\mathcal{A}\\) satisfait \\(X → Y\\) si pour tous tuples \\(s,t ∈ R\\) on a\n\\[\\bigl(∀ A∈ X\\ s.A=t.A\\bigr) ⟹ \\bigl(\\forall A∈ Y\\ s.A=t.A\\bigr)\\]\n(si \\(s\\) et \\(t\\) coïncident sur \\(X\\) alors \\(s\\) et \\(t\\) coïncident sur \\(Y\\))\nUne relation \\(R\\), de schéma \\(\\mathcal{A}\\), satisfait un ensemble \\(\\Sigma\\) de DF si \\(R\\) satisfait chaque DF de \\(\\Sigma\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#exemples",
    "href": "slides/DF_norm_1.html#exemples",
    "title": "Normalisation I",
    "section": "Exemples",
    "text": "Exemples\nDans la base Pagila, relation Actor :\n\nActor_id ⟶ last_name, first_name\ncar Actor_id est une clé…"
  },
  {
    "objectID": "slides/DF_norm_1.html#dépendance-fonctionnelle-triviale",
    "href": "slides/DF_norm_1.html#dépendance-fonctionnelle-triviale",
    "title": "Normalisation I",
    "section": "Dépendance fonctionnelle triviale",
    "text": "Dépendance fonctionnelle triviale\nUne DF triviale est une DF satisfaite par toute relation\n\n\n\n\n\n\nDéfinition (dépendance triviale)\n\n\nSoient \\(X,Y⊂ \\mathcal{A}\\)\n\\(X\\rightarrow Y\\) est une dépendance triviale si \\(Y ⊂ X\\)\n\n\n\n\n\n\n\n\n\n\nExemple\n\n\nNo_insee ⟶ No_insee est triviale"
  },
  {
    "objectID": "slides/DF_norm_1.html#implication-pour-les-df",
    "href": "slides/DF_norm_1.html#implication-pour-les-df",
    "title": "Normalisation I",
    "section": "Implication pour les DF",
    "text": "Implication pour les DF\n\nSoit \\(\\mathcal{A}\\) un schéma de relation ( \\(\\mathcal{A}\\) est un ensemble d’attributs) et \\(\\Sigma\\) un ensemble de DF sur \\(\\mathcal{A}\\)\nExemple : \\(\\mathcal{A}=\\{A,B,C\\}\\) et \\(\\Sigma=\\{A\\rightarrow B, B\\rightarrow C\\}\\)\nLes DF données impliquent d’autres DF additionnelles\n\n\n\n\n\n\n\n\nExemple I\n\n\n\\(A\\rightarrow B\\) et \\(B\\rightarrow C\\) impliquent \\(A\\rightarrow C\\)\nc’est-à-dire : toute relation de schéma \\(\\mathcal{A}\\) qui satisfait \\(A\\rightarrow B\\) et \\(B\\rightarrow C\\) satisfait également \\(A\\rightarrow C\\)\n\n\n\n\n\n\n\n\n\n\n\nExemple II\n\n\n\\(A\\rightarrow C\\), \\(BC\\rightarrow D\\), \\(AD\\rightarrow E\\) impliquent \\(AB\\rightarrow E\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#implication-entre-df",
    "href": "slides/DF_norm_1.html#implication-entre-df",
    "title": "Normalisation I",
    "section": "Implication entre DF",
    "text": "Implication entre DF\n\n\n\n\n\n\nDéfinition\n\n\nUn ensemble \\(\\Sigma\\) de DF implique une autre DF \\(X\\rightarrow Y\\) si toute relation (instance) qui satisfait \\(\\Sigma\\) satisfait également \\(X\\rightarrow Y\\).\nNotation pour \\(\\Sigma\\) implique \\(X\\rightarrow Y\\) :\n\\[\\Sigma \\models X \\rightarrow Y\\]\n\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\\(\\Sigma=\\{A\\rightarrow B, B\\rightarrow C\\}\\) implique\n\\(A\\rightarrow B\\), \\(B\\rightarrow C\\), \\(A\\rightarrow C\\), \\(A,B\\rightarrow C\\), …\nmais aussi les DF triviales \\(A\\rightarrow A\\), \\(AB\\rightarrow A\\), …"
  },
  {
    "objectID": "slides/DF_norm_1.html#vérification-de-la-transitivité",
    "href": "slides/DF_norm_1.html#vérification-de-la-transitivité",
    "title": "Normalisation I",
    "section": "Vérification de la transitivité",
    "text": "Vérification de la transitivité\nOn se rammène à vérifier une règle du calcul propositionnel :\nsi p ⇒ q et q ⇒ r alors p ⇒ r\nSoit une instance \\(\\mathcal{R}\\) telle que :\\[\\forall s,t \\in \\mathcal{R} \\qquad\n  \\begin{cases}  \\text{si } s.X =t.X & \\text{alors } s.Y= t.Y \\\\\n   \\text{si } s.Y =t.Y &  \\text{alors } s.Z= t.Z\n\\end{cases}\n\\] On a alors aussi \\(\\forall s,t \\in \\mathcal{R}\\), si \\(s.X =t.X\\) alors \\(s.Z= t.Z\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#tables-de-vérité",
    "href": "slides/DF_norm_1.html#tables-de-vérité",
    "title": "Normalisation I",
    "section": "Tables de vérité",
    "text": "Tables de vérité\n\n\np\nq\nr\np ⇒ q\nq ⇒ r\np ⇒ r\n\n\n\nTRUE\nTRUE\nTRUE\nTRUE\nTRUE\nTRUE\n\n\nFALSE\nTRUE\nTRUE\nTRUE\nTRUE\nTRUE\n\n\nTRUE\nFALSE\nTRUE\nFALSE\nTRUE\nTRUE\n\n\nFALSE\nFALSE\nTRUE\nTRUE\nTRUE\nTRUE\n\n\nTRUE\nTRUE\nFALSE\nTRUE\nFALSE\nFALSE\n\n\nFALSE\nTRUE\nFALSE\nTRUE\nFALSE\nTRUE\n\n\nTRUE\nFALSE\nFALSE\nFALSE\nTRUE\nFALSE\n\n\nFALSE\nFALSE\nFALSE\nTRUE\nTRUE\nTRUE"
  },
  {
    "objectID": "slides/DF_norm_1.html#preuve",
    "href": "slides/DF_norm_1.html#preuve",
    "title": "Normalisation I",
    "section": "Preuve",
    "text": "Preuve"
  },
  {
    "objectID": "slides/DF_norm_1.html#exemples-1",
    "href": "slides/DF_norm_1.html#exemples-1",
    "title": "Normalisation I",
    "section": "Exemples",
    "text": "Exemples\n\\(\\mathcal{A}=\\{A,B,C,D\\}\\),\n\\(\\Sigma= \\{AB\\rightarrow C, C\\rightarrow A, BC\\rightarrow D\\}\\)|\n\\(\\Sigma'=\\{AB\\rightarrow D\\}\\)\n\\(\\Sigma\\models\\Sigma'\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#question-principale",
    "href": "slides/DF_norm_1.html#question-principale",
    "title": "Normalisation I",
    "section": "Question principale",
    "text": "Question principale\n\nComment vérifier si un ensemble \\(\\Sigma\\) de DF implique une DF \\(X\\rightarrow Y\\) ?\n\n\n\nPar les équivalences présentées précédemment, la question se ramène à :\n\nComment vérifier si un ensemble \\(\\Sigma\\) de DF implique une DF \\(X\\rightarrow A\\) où \\(A\\) est un attribut ?"
  },
  {
    "objectID": "slides/DF_norm_1.html#fermeture-dun-ensemble-dattributs-1",
    "href": "slides/DF_norm_1.html#fermeture-dun-ensemble-dattributs-1",
    "title": "Normalisation I",
    "section": "Fermeture d’un ensemble d’attributs",
    "text": "Fermeture d’un ensemble d’attributs\nSoit \\(X \\subset\\mathcal{A}\\) un sous-ensemble d’attributs et \\(\\Sigma\\) un ensemble de DF sur \\(\\mathcal{A}\\)\n\n\n\n\n\n\nDéfinition\n\n\nLa fermeture de \\(X\\) par rapport à \\(\\Sigma\\) est\n\\[X^+=\\{ A\\in\\mathcal{A} \\mid \\Sigma\\models X\\rightarrow A \\}\\]\n\n\n\n\n\nAutrement dit \\(X^+\\) est l’ensemble des attributs déterminés par \\(X\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#exemple-de-fermeture",
    "href": "slides/DF_norm_1.html#exemple-de-fermeture",
    "title": "Normalisation I",
    "section": "Exemple de fermeture",
    "text": "Exemple de fermeture\n\n\\(R(ABCDE)\\)\n\\(\\Sigma=\\{AB\\rightarrow C, C\\rightarrow D, E\\rightarrow D\\}\\)\n\\(\\{A,B\\}^+=\\{A,B,C,D\\}\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#section-2",
    "href": "slides/DF_norm_1.html#section-2",
    "title": "Normalisation I",
    "section": "",
    "text": "Soit \\(\\Sigma\\) un ensemble de DF sur un schéma \\(\\mathcal{A}\\) et \\(X\\subset\\mathcal{A}\\)\n\n\n\n\n\n\nAlgorithme\n\n\nFermeture(X, Σ)\n   Xc = X\n    while (exists Y -&gt; Z in Σ with Y ⊂ Xc and not Z ⊂ Xc)\n       Xc = Xc ∪ Z\n    return Xc"
  },
  {
    "objectID": "slides/DF_norm_1.html#exemple-de-calcul-de-fermeture",
    "href": "slides/DF_norm_1.html#exemple-de-calcul-de-fermeture",
    "title": "Normalisation I",
    "section": "Exemple de calcul de fermeture",
    "text": "Exemple de calcul de fermeture\n\\(\\mathcal{A}=\\{ABCDEF\\}\\), \\(\\Sigma=\\{A\\rightarrow C, BC\\rightarrow D, AD\\rightarrow E\\}\\), \\(X=\\{A,B\\}\\)\n\n\\(X_c=\\{A,B\\}\\)\n\\(A\\rightarrow C\\) donc on obtient \\(X^cc=\\{A,B,C\\}\\)\n\\(BC\\rightarrow D\\) donc on obtient \\(X^c=\\{A,B,C,D\\}\\)\n\\(AD\\rightarrow E\\) donc on obtient \\(X^c=\\{A,B,C,D, E\\}\\)\nOn obtient \\(X^+=\\{A,B,C,D, E\\}\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#terminaison-de-lalgorithme",
    "href": "slides/DF_norm_1.html#terminaison-de-lalgorithme",
    "title": "Normalisation I",
    "section": "Terminaison de l’algorithme",
    "text": "Terminaison de l’algorithme\n \\(X^c\\) grandit à chaque itération\nComme \\(\\mathcal{A}\\) est fini, l’algorithme se termine en au plus \\(|\\mathcal{A}|\\) itérations"
  },
  {
    "objectID": "slides/DF_norm_1.html#correction-de-lalgorithme-de-fermeture",
    "href": "slides/DF_norm_1.html#correction-de-lalgorithme-de-fermeture",
    "title": "Normalisation I",
    "section": "Correction de l’algorithme de fermeture \n",
    "text": "Correction de l’algorithme de fermeture \n\n\nL’algorithme calcule uniquement des attributs dans la fermeture car on a toujours \\(X^c \\subset X^+\\) (récurrence sur le nombre d’itérations de la boucle while).\nL’algorithme calcule tous les attributs dans la fermeture: \\(X_c=X^+\\) quand l’algorithme se termine.\n\n\n\nLe dernier point est le plus délicat. Que peut signifier le fait qu’il existe au moins un attribut \\(Y\\in X^+\\) qui n’appartienne pas à valeur terminale de \\(X^c\\) ?"
  },
  {
    "objectID": "slides/DF_norm_1.html#calcul-de-la-fermeture-transitive-exemple",
    "href": "slides/DF_norm_1.html#calcul-de-la-fermeture-transitive-exemple",
    "title": "Normalisation I",
    "section": "Calcul de la fermeture transitive : exemple",
    "text": "Calcul de la fermeture transitive : exemple\n\n\nSoit \\(R\\) d’ensemble d’attributs\n\\(\\mathcal{A} =\\{A,B,C,D,E,F,G\\}\\)\nSoit \\(X=\\{B,D\\} \\subset \\mathcal{A}\\)\nEt \\(Σ\\) l’ensemble de dépendances fonctionnelles ci-contre\n\n\n\n\\(\\Sigma\\)\n\n\n\n\\(A,B \\rightarrow C\\)\n\n\n\\(C \\rightarrow A\\)\n\n\n\\(B,C \\rightarrow D\\)\n\n\n\\(A,C,D \\rightarrow B\\)\n\n\n\\(F\\rightarrow A,C\\)\n\n\n\\(D \\rightarrow E,G\\)\n\n\n\\(B,E \\rightarrow C\\)\n\n\n\\(C,G \\rightarrow B,D\\)\n\n\n\\(C,E \\rightarrow A,G\\)\n\n\n\n\n\nMontrer que \\(X^+=\\{A,B,C,D,E,G\\}\\)\nDonner une clef de \\(R\\) : par exemple \\(\\{A,B,F\\}\\), \\(\\{E,F\\}\\), \\(\\{F,G\\}\\). Il n’y a pas unicité."
  },
  {
    "objectID": "slides/DF_norm_1.html#forme-normale-de-boyce-codd-fnbc",
    "href": "slides/DF_norm_1.html#forme-normale-de-boyce-codd-fnbc",
    "title": "Normalisation I",
    "section": "Forme normale de Boyce-Codd (FNBC)",
    "text": "Forme normale de Boyce-Codd (FNBC)\n\n\n\n\n\n\nDéfinition\n\n\nUn schéma \\(\\mathcal{A}\\) est en FNBC par rapport à un ensemble de dépendances fonctionnelles \\(\\Sigma\\) sur \\(\\mathcal{A}\\)\nsi\nQuelque soit la DF non triviale \\(X\\rightarrow Y\\) impliquée par \\(\\Sigma\\) (Σ ⊧ X → Y avec \\(¬ Y ⊂ X\\)), \\(X\\) est une super-clef\n\n\n\n\n\n\n \\((\\mathcal{A},\\Sigma)\\) est en FNBC si pour toute DF non triviale impliquée par \\(\\Sigma\\), le membre de gauche (le déterminant) est une super-clef"
  },
  {
    "objectID": "slides/DF_norm_1.html#fnbc-exemple-1",
    "href": "slides/DF_norm_1.html#fnbc-exemple-1",
    "title": "Normalisation I",
    "section": "FNBC : exemple 1",
    "text": "FNBC : exemple 1\n\nSchéma \\(\\mathcal{A}=\\{\\texttt{V\\#, Vnom, Vville, P\\#, Pnom, Pville, Qte}\\}\\)\n\n\nEnsemble de dépendances fonctionnelles \\(\\Sigma\\) :\nV# ⟶ Vnom Vville\nP# ⟶ Pnom Pville\nV# P# ⟶ Qte\n\n\\(\\mathcal{A}\\) n’est pas en FNBC par rapport \\(\\Sigma\\).\nEn effet ni V# ni P# ne sont des super-clefs"
  },
  {
    "objectID": "slides/DF_norm_1.html#fnbc-exemple-2",
    "href": "slides/DF_norm_1.html#fnbc-exemple-2",
    "title": "Normalisation I",
    "section": "FNBC : exemple 2",
    "text": "FNBC : exemple 2\nSchéma Films(titre, année, durée, genre, producteur, acteur)\n\nOn a la dépendance suivante titre, année ⟶ durée, genre, producteur\ntitre, année, acteur est la seule clef\nLa DF titre, année ⟶ durée, genre, producteur} viole la condition de FNBC"
  },
  {
    "objectID": "slides/DF_norm_1.html#fnbc-exemple-3",
    "href": "slides/DF_norm_1.html#fnbc-exemple-3",
    "title": "Normalisation I",
    "section": "FNBC : exemple 3",
    "text": "FNBC : exemple 3\nTrois schémas en FNBC :\n\n\nRelation\nClef\n\n\n\nVendeur(V#, Vnom, Vville)\nV#\n\n\nProduit(P#, Pnom, Pville)\nP#\n\n\nLivraison(V#, P#, Qte)\n(V#,P#)"
  },
  {
    "objectID": "slides/DF_norm_1.html#schéma-avec-deux-attributs",
    "href": "slides/DF_norm_1.html#schéma-avec-deux-attributs",
    "title": "Normalisation I",
    "section": "Schéma avec deux attributs",
    "text": "Schéma avec deux attributs\n\n\n\n\n\n\nProposition\n\n\nSoit \\(\\mathcal{A}=\\{A,B\\}\\) un schéma avec deux attributs et \\(\\Sigma\\) un ensemble de DF non triviales.\n\\(\\mathcal{A}\\) est toujours en FNBC par rapport à \\(\\Sigma\\)\n\n\n\n\n\nPreuve. On distingue 4 cas\n\n\\(\\Sigma=\\emptyset\\)\n\\(\\Sigma=\\{A\\rightarrow B\\}\\)\n\\(\\Sigma=\\{B\\rightarrow A\\}\\)\n\\(\\Sigma=\\{A\\rightarrow B, B\\rightarrow A\\}\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#décomposition-dun-schéma-de-relation",
    "href": "slides/DF_norm_1.html#décomposition-dun-schéma-de-relation",
    "title": "Normalisation I",
    "section": "Décomposition d’un schéma de relation",
    "text": "Décomposition d’un schéma de relation\n\n\n\n\n\n\nDéfinition\n\n\nSoit \\(\\mathcal{A}\\) un schéma de relation\nUn décomposition de \\(\\mathcal{A}\\) est un ensemble \\(\\{\\mathcal{A}_1,..., \\mathcal{A}_k\\}\\) de sous-ensembles de \\(\\mathcal{A}\\) tel que\n\\[\\mathcal{A}_i\\not=\\emptyset, 1\\le i\\le k, \\quad \\text{ et } \\quad \\mathcal{A} = \\bigcup_{i=1}^k \\mathcal{A}_i\\]\n\n\n\n\n Une décomposition n’est pas nécessairement une partition. On n’impose pas que les \\(\\mathcal{A}_i\\) soient deux à deux disjoints."
  },
  {
    "objectID": "slides/DF_norm_1.html#exemple-de-décomposition-i",
    "href": "slides/DF_norm_1.html#exemple-de-décomposition-i",
    "title": "Normalisation I",
    "section": "Exemple de décomposition I",
    "text": "Exemple de décomposition I\nVendeur(V#, Vnom, Vville)\nProduit(P#, Pnom, Pville)\nLivraison(V#, P#, Qte)\nest une décomposition du schéma\nR(V#, Vnom, Vville, P#, Pnom, Pville, Qte)"
  },
  {
    "objectID": "slides/DF_norm_1.html#exemple-de-décomposition-ii",
    "href": "slides/DF_norm_1.html#exemple-de-décomposition-ii",
    "title": "Normalisation I",
    "section": "Exemple de décomposition II",
    "text": "Exemple de décomposition II\nSchéma :\nFilms(titre, année, durée, genre, producteur, acteur)\n\nUne décomposition :\nFilms1(titre, année, durée, genre, producteur)\nFilms2(titre, année, acteur)\n\n\nFilms1 est FNBC par rapport à \\(\\Sigma_1=\\{\\texttt{titre, année ⟶ durée, genre, producteur}\\}\\)\n\n\nFilms2 est en FNBC par rapport à \\(\\Sigma_2=\\emptyset\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#propriétés-dune-décomposition",
    "href": "slides/DF_norm_1.html#propriétés-dune-décomposition",
    "title": "Normalisation I",
    "section": "Propriétés d’une décomposition",
    "text": "Propriétés d’une décomposition\nOn ne peut pas décomposer arbitrairement\nToutes les décompositions ne sont pas intéressantes\n\n\n\n\n\n\n\nConditions pour une décomposition raisonnable :\n\n\n\nDécomposition sans perte d’information\nDécomposition sans perte de dépendance fonctionnelle"
  },
  {
    "objectID": "slides/DF_norm_1.html#décomposition-sans-perte-dinformation-1",
    "href": "slides/DF_norm_1.html#décomposition-sans-perte-dinformation-1",
    "title": "Normalisation I",
    "section": "Décomposition sans perte d’information",
    "text": "Décomposition sans perte d’information\nIdée : Si on remplace le schéma\n(V#, Vnom, Vville, P#, Pnom, Pville, Qte)\npar les trois schémas\nVendeur(V#, Vnom, Vville)\nProduit(P#, Pnom, Pville)\nLivraison(V#, P#, Qte)\nalors au lieu de stocker une relation R(V#, Vnom, Vville, P#, Pnom, Pville, Qte), on stockera ses projections:\n\\[\\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R}) \\qquad \\pi_{\\texttt{P\\#,Pnom,Pville}}(\\texttt{R}) \\qquad \\pi_{\\texttt{V\\#,P\\#,Qte}}(\\texttt{R})\\]\n Peut-on retrouver R à partir de ces trois projections ?"
  },
  {
    "objectID": "slides/DF_norm_1.html#décomposition-sans-perte-dinformation-2",
    "href": "slides/DF_norm_1.html#décomposition-sans-perte-dinformation-2",
    "title": "Normalisation I",
    "section": "Décomposition sans perte d’information",
    "text": "Décomposition sans perte d’information\n\nLa décomposition doit garantir que pour toute relation R, ses projections contiennent la même information que R au sens que l’on doit pouvoir reconstruire R à partir de ses projections\nComment tenter de reconstruire R à partir de ses projections ?\n\nOn considère la jointure naturelle\n\\[\\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{P\\#,Pnom,Pville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{V\\#,P\\#,Qte}}(\\texttt{R})\\]"
  },
  {
    "objectID": "slides/DF_norm_1.html#décomposition-sans-perte-dinformation-3",
    "href": "slides/DF_norm_1.html#décomposition-sans-perte-dinformation-3",
    "title": "Normalisation I",
    "section": "Décomposition sans perte d’information",
    "text": "Décomposition sans perte d’information\nLa propriété souhaitée s’écrit donc\n\\[R = \\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{P\\#,Pnom,Pville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{V\\#,P\\#,Qte}}(\\texttt{R})\\]\npour toute relation R(V#, Vnom, Vville, P#, Pnom, Pville, Qte) satisfaisant les DF\n\n\nEst ce vrai?\nIntuitivement, oui : à partir d’un tuple de Livraison(V#,P#,Qte)\nV# permet de récupérer toutes les informations sur le vendeur (V# ⟶ Vnom Vville)\nP# permet de récupérer toutes les informations sur le produit (P# ⟶ Pnom Pville)\n La propriété d’être sans perte d’information est liée à l’ensemble de DF considéré"
  },
  {
    "objectID": "slides/DF_norm_1.html#décomposition-sans-perte-dinformation-lossless-join",
    "href": "slides/DF_norm_1.html#décomposition-sans-perte-dinformation-lossless-join",
    "title": "Normalisation I",
    "section": "Décomposition sans perte d’information (lossless join)",
    "text": "Décomposition sans perte d’information (lossless join)\n\n\n\n\n\n\nDéfinition\n\n\nSoit \\(\\mathcal{A}\\) un schéma de relation et \\(\\Sigma\\) un ensemble de DF sur \\(\\mathcal{A}\\).\nUne décomposition \\(\\{\\mathcal{A}_1,..., \\mathcal{A}_k\\}\\) est sans perte d’information par rapport à \\(\\Sigma\\) si pour toute relation \\(R\\) de schéma \\(\\mathcal{A}\\) satisfaisant \\(\\Sigma\\) on a\n\\[R= \\pi_{\\mathcal{A}_1}(R) \\bowtie \\pi_{\\mathcal{A}_2}(R) \\bowtie...\\bowtie\\pi_{\\mathcal{A}_k}(R)\\]"
  },
  {
    "objectID": "slides/DF_norm_1.html#exemple-de-décomposition-avec-perte-dinformation",
    "href": "slides/DF_norm_1.html#exemple-de-décomposition-avec-perte-dinformation",
    "title": "Normalisation I",
    "section": "Exemple de décomposition avec perte d’information",
    "text": "Exemple de décomposition avec perte d’information\n\\(\\mathcal{A}=\\{A,B,C\\} \\quad  \\Sigma=\\{AB\\rightarrow C\\}\\)\nDécomposition \\(\\mathcal{A}_1=\\{A,B\\}  \\quad  \\mathcal{A}_2=\\{B,C\\}\\)\n\n\nSoit \\(R\\) la relation\n\n\nA\nB\nC\n\n\n\n1\n2\n3\n\n\n4\n2\n5\n\n\n\n\n\\(\\pi_{AB}(R)=\\)\n\n\nA\nB\n\n\n\n1\n2\n\n\n4\n2\n\n\n\n\n\\(\\pi_{BC}(R)=\\)\n\n\nB\nC\n\n\n\n2\n3\n\n\n2\n5\n\n\n\n\n\\(\\pi_{AB}(R) \\bowtie \\pi_{BC}(R)=\\)\n\n\nA\nB\nC\n\n\n\n1\n2\n3\n\n\n4\n2\n5\n\n\n1\n2\n5\n\n\n4\n2\n3"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite-chase-algorithm",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite-chase-algorithm",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite (chase algorithm)",
    "text": "Algorithme de poursuite (chase algorithm)\n\nComment déterminer si une décomposition est sans perte d’information?\nSi \\(R\\) est une relation de schéma \\(\\mathcal{A}\\) on a toujours que\n\n\\[R ⊆ \\pi_{\\mathcal{A}_1}(R) \\bowtie \\pi_{\\mathcal{A}_2}(R) \\bowtie...\\bowtie\\pi_{\\mathcal{A}_k}(R)\\]\npar définition de la jointure naturelle et de la projection\n\nLe seul problème est que les jointures peuvent générer des tuples supplémentaires\nMais comme \\(R\\) est supposée vérifier les DF de \\(\\Sigma\\), l’inclusion inverse est garantie dans certains cas\n\nPour le savoir, un algorithme simple existe appelé algorithme de poursuite"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite : exemple",
    "text": "Algorithme de poursuite : exemple\nSi on remplace le schéma (V#, Vnom, Vville, P#, Pnom, Pville, Qte) par\nVendeur(V#, Vnom, Vville)}\nProduit(P#, Pnom, Pville)}\nLivraison(V#, P#, Qte)\nA-t-on\n\\[\\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{P\\#,Pnom,Pville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{V\\#,P\\#,Qte}}(R) \\subset \\texttt{R} \\quad ?\\]"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-1",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-1",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite : exemple",
    "text": "Algorithme de poursuite : exemple\nSoit \\(t\\) un tuple dans la jointure\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d\\)\n\\(e\\)\n\\(f\\)\n\\(g\\)\n\n\n\n\\((a, b, c)\\in \\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R})\\) donc il existe \\(e_1, f_1, g_1\\) tels que \\((a, b, c, d_1, e_1, f_1, g_1) \\in \\texttt{R}\\)\n\\((d,e,f) \\in \\pi_{\\texttt{P\\#,Pnom,Pville}}(\\texttt{R})\\) donc il existe \\(a_2, b_2, c_2, g_2\\) tels que \\((a_2, b_2, c_2, d, e, f, g_2)\\in \\texttt{R}\\)\n\\((a,d,g)\\in \\pi_{\\texttt{V\\#,P\\#,Qte}}(R)\\) donc il existe \\(b_3,c_3,e_3,f_3\\) tels que \\((a,b_3,c_3,d,e_3,f_3,g)\\in \\texttt{R}\\)\nOn peut le représenter comme ceci :\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\nVendeur\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d_1\\)\n\\(e_1\\)\n\\(f_1\\)\n\\(g_1\\)\n\n\nProduit\n\\(a_2\\)\n\\(b_2\\)\n\\(c_2\\)\n\\(d\\)\n\\(e\\)\n\\(f\\)\n\\(g_2\\)\n\n\nLivraison\n\\(a\\)\n\\(b_3\\)\n\\(c_3\\)\n\\(d\\)\n\\(e_3\\)\n\\(f_3\\)\n\\(g\\)\n\n\n\n\n\nVendeur (resp. Produit, Livraison) désigne l’ensemble des tuples de \\(R\\) qui se projettent sur \\(a,b,c\\) (resp. \\(d,e,f\\) et \\(a,d,g\\)) lorsque on projette \\(R\\) sur V#,Vnom,Vville (resp. P#, Pnom, Pville et V#, P#, Qte)"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-2",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-2",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite : exemple",
    "text": "Algorithme de poursuite : exemple\n\n\n\n\n\n\n\n\n\n\n\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\nVendeur\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d_1\\)\n\\(e_1\\)\n\\(f_1\\)\n\\(g_1\\)\n\n\nProduit\n\\(a_2\\)\n\\(b_2\\)\n\\(c_2\\)\n\\(d\\)\n\\(e\\)\n\\(f\\)\n\\(g_2\\)\n\n\nLivraison\n\\(a\\)\n\\(b_3\\)\n\\(c_3\\)\n\\(d\\)\n\\(e_3\\)\n\\(f_3\\)\n\\(g\\)\n\n\n\nV# ⟶ Vnom, Vville donc \\(b_3=b\\) et \\(c_3=c\\)\n\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\nVendeur\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d_1\\)\n\\(e_1\\)\n\\(f_1\\)\n\\(g_1\\)\n\n\nProduit\n\\(a_2\\)\n\\(b_2\\)\n\\(c_2\\)\n\\(d\\)\n\\(e\\)\n\\(f\\)\n\\(g_2\\)\n\n\nLivraison\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d\\)\n\\(e_3\\)\n\\(f_3\\)\n\\(g\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-suite",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-suite",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite : exemple (suite)",
    "text": "Algorithme de poursuite : exemple (suite)\nP#⟶ Pnom, Pville donc \\(e_3=e\\) et \\(f_3=f\\)\n\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\nVendeur\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d_1\\)\n\\(e_1\\)\n\\(f_1\\)\n\\(g_1\\)\n\n\nProduit\n\\(a_2\\)\n\\(b_2\\)\n\\(c_2\\)\n\\(d\\)\n\\(e\\)\n\\(f\\)\n\\(g_2\\)\n\n\nLivraison\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d\\)\n\\(e\\)\n\\(f\\)\n\\(g\\)\n\n\n\nOn a obtenu une ligne égale au tuple \\(t=(a,b,c,d,e,f,g)\\) donc \\(t\\in \\texttt{R}\\) (tous les tuples qui se projettent sur \\(a,f,g\\) coïncident avec \\(t\\))\nOn en déduit que la décomposition est Sans Perte d’Information (SPI)"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite-cas-général",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite-cas-général",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite : cas général",
    "text": "Algorithme de poursuite : cas général\n\nEntrée : un schéma \\(\\mathcal{A}\\), une décomposition \\(\\{\\mathcal{A}_1,...,\\mathcal{A}_k\\}\\) et un ensemble \\(\\Sigma\\) de DF\nPour chaque attribut de \\(\\mathcal{A}\\), choisir un symbole (par exemple \\(a\\), \\(b\\), \\(c\\),…). La correspondance doit être injective.\nConstruire un tableau dont les colonnes sont les attributs de \\(\\mathcal{A}\\)\n\nLe tableau a une ligne pour chaque \\(\\mathcal{A}_i\\)\nSur la ligne associée à \\(\\mathcal{A}_i\\), les positions correspondant à \\(\\mathcal{A}_i\\) sont remplies avec les symboles choisis.\nLes autres positions sont remplies avec les symboles indicés par \\(i\\)\n\nRépéter tant que possible : s’il existe une DF \\(X\\rightarrow Y\\) dans \\(\\Sigma\\) et deux lignes du tableau en accord sur \\(X\\), égaliser ces deux lignes sur \\(Y\\)\nSortie : Si on obtient une ligne sans valeur indicée, la décomposition est sans perte d’information, sinon il y a perte d’information"
  },
  {
    "objectID": "slides/DF_norm_1.html#commentaires-sur-lalgorithme-de-poursuite",
    "href": "slides/DF_norm_1.html#commentaires-sur-lalgorithme-de-poursuite",
    "title": "Normalisation I",
    "section": "Commentaires sur l’algorithme de poursuite",
    "text": "Commentaires sur l’algorithme de poursuite\nL’objectif de l’algorithme de poursuite est de vérifier que tout tuple de \\(\\pi_{\\mathcal{A}_1}(R) \\bowtie \\pi_{\\mathcal{A}_2}(R) \\bowtie...\\bowtie\\pi_{\\mathcal{A}_k}(R)\\) est aussi un tuple de \\(R\\)\nÀ l’initialisation, on part d’un tuple de \\(\\pi_{\\mathcal{A}_1}(R) \\bowtie \\pi_{\\mathcal{A}_2}(R) \\bowtie...\\bowtie\\pi_{\\mathcal{A}_k}(R)\\) qu’on note symboliquement \\((a, b, c, \\ldots)\\) avec des symboles non indicés\nPour chaque \\(i \\leq k\\), on utilise le fait que pour chaque tuple de \\(\\pi_{\\mathcal{A}_i}(R)\\) il existe un ensemble de tuples de \\(R\\) qui coïncident avec \\((a, b, c, \\ldots)\\) sur \\(\\mathcal{A}_i\\). On note génériquement ces tuples de \\(R\\) en indiçant les noms de variables par \\(i\\) pour toutes les variables qui ne sont pas dans \\(\\mathcal{A}_i\\)\nChacun des sous-ensembles de tuples indicés par \\(i \\leq k\\) définit un sous-ensemble de tuples de \\(R\\)\nOn veut se convaincre que \\((a, b, c, \\ldots)\\) appartient à l’un de ces sous-ensembles\n\nL’algorithme de poursuite utilise les DF de Σ, pour restreindre les \\(k\\) sous-ensembles"
  },
  {
    "objectID": "slides/DF_norm_1.html#commentaires-suite",
    "href": "slides/DF_norm_1.html#commentaires-suite",
    "title": "Normalisation I",
    "section": "Commentaires (suite)",
    "text": "Commentaires (suite)\nL’algorithme de poursuite est un algorithme de réécriture\n\nL’algorithme de poursuite est non-déterministe : à chaque étape, il est parfois possible d’invoquer plusieurs DFs pour réécrire une ou plusieurs lignes\n\n\nUn point important de l’analyse de l’algorithme de poursuite consiste à vérifier que ce non-déterminisme n’est pas un problème : l’algorithme de poursuite termine par un succès ou un échec (blocage) quelle que soit la suite des choix effectués\n\nPreuve ()."
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-2-1",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-2-1",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite : exemple 2",
    "text": "Algorithme de poursuite : exemple 2\nConsidérons l’exemple : \\(\\mathcal{A}=\\{A,B,C,D\\}\\) avec \\(\\mathcal{A}_1=\\{A,B\\}\\), \\(\\mathcal{A}_2=\\{B,C\\}\\) et \\(\\mathcal{A}_3=\\{C,D\\}\\)\nSoit \\(\\Sigma=\\{{C}\\rightarrow{D}; {B}\\rightarrow{A}\\}\\).\nSoit \\(t=(a,b,c,d)\\). Soit \\(t_1,t_2,t_3\\) les tuples de \\(R\\) suivants:\n\n\n\nA\nB\nC\nD\n\n\n\n\\(t_1\\)\na\nb\n\\(c_1\\)\n\\(d_1\\)\n\n\n\\(t_2\\)\n\\(a_2\\)\nb\nc\n\\(d_2\\)\n\n\n\\(t_3\\)\n\\(a_3\\)\n\\(b_3\\)\nc\nd\n\n\n\nOn a pris \\(c_1,d_1, a_2,d_2, a_3,b_3\\) comme valeurs variables et a,b,c,d comme constantes"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite---exemple-2",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite---exemple-2",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite - exemple 2",
    "text": "Algorithme de poursuite - exemple 2\n\n\n\nA\nB\nC\nD\n\n\n\n\\(t_1\\)\na\nb\n\\(c_1\\)\n\\(d_1\\)\n\n\n\\(t_2\\)\n\\(a_2\\)\nb\nc\n\\(d_2\\)\n\n\n\\(t_3\\)\n\\(a_3\\)\n\\(b_3\\)\nc\nd\n\n\n\nPar la dépendance \\({B}\\rightarrow{A}\\), il vient :\n\n\n\nA\nB\nC\nD\n\n\n\n\\(t_1\\)\na\nb\n\\(c_1\\)\n\\(d_1\\)\n\n\n\\(t_2\\)\na\nb\nc\n\\(d_2\\)\n\n\n\\(t_3\\)\n\\(a_3\\)\n\\(b_3\\)\nc\nd"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-2-2",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-2-2",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite : exemple 2",
    "text": "Algorithme de poursuite : exemple 2\nPar la dépendance \\({C}\\rightarrow{D}\\), il vient :\n\n\n\nA\nB\nC\nD\n\n\n\n\\(t_1\\)\na\nb\n\\(c_1\\)\n\\(d_1\\)\n\n\n\\(t_2\\)\na\nb\nc\nd\n\n\n\\(t_3\\)\n\\(a_3\\)\n\\(b_3\\)\nc\nd\n\n\n\nOn a bien fait apparaître \\(t\\) qui appartient donc à \\(R\\)."
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite---exemple-3",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite---exemple-3",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite - exemple 3",
    "text": "Algorithme de poursuite - exemple 3\nConsidérons toujours l’exemple : \\(\\mathcal{A}=\\{A,B,C,D\\}\\) avec\n\\(\\mathcal{A}_1=\\{A,B\\}\\), \\(\\mathcal{A}_2=\\{B,C\\}\\) et \\(\\mathcal{A}_3=\\{C,D\\}\\)\nMais avec \\(\\Sigma=\\{{B}\\rightarrow{AD}\\}\\).\n\n\nA\nB\nC\nD\n\n\n\na\nb\n\\(c_1\\)\n\\(d_1\\)\n\n\n\\(a_2\\)\nb\nc\n\\(d_2\\)\n\n\n\\(a_3\\)\n\\(b_3\\)\nc\nd\n\n\n\nDans ce cas, en utilisant la seule DF \\({B}\\rightarrow{AD}\\), on obtient \\(a_2=a\\) et \\(d_1=d_2\\) :\n\n\nA\nB\nC\nD\n\n\n\na\nb\n\\(c_1\\)\n\\(d_1\\)\n\n\na\nb\nc\n\\(d_1\\)\n\n\n\\(a_3\\)\n\\(b_3\\)\nc\nd\n\n\n\n\n\n\n\n\n\nNote\n\n\nMais on ne peut pas aller plus loin : la jointure des projections contient des tuples qui ne sont pas dans la relation originelle"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme",
    "href": "slides/DF_norm_1.html#algorithme",
    "title": "Normalisation I",
    "section": "Algorithme",
    "text": "Algorithme\n\n\n\\begin{algorithm} \\caption{Décomposition FNBC} \\begin{algorithmic} \\Procedure{DecompositionFNBC}{$\\mathcal{A}, Σ$} \\State \\Comment{Initialisation de la décomposition} \\State $D ← \\{\\mathcal{A}\\}$ \\State \\While{$\\exists \\mathcal{B} \\in D$ not in BCNF w.r.t. $\\Sigma \\models X → X^+ \\cap \\mathcal{B}$, $X \\subsetneq \\mathcal{B}$} \\State $Y \\leftarrow X^+ \\cap \\mathcal{B} \\setminus X\\qquad$ \\Comment{DF non triviale! $Y \\neq \\emptyset$} \\State $D \\leftarrow D \\setminus \\{\\mathcal{B}\\} \\cup \\{ X \\cup Y, \\mathcal{B} \\setminus Y \\}$ \\EndWhile \\State \\Return $D$ \\EndProcedure \\end{algorithmic} \\end{algorithm}"
  },
  {
    "objectID": "slides/DF_norm_1.html#remarques",
    "href": "slides/DF_norm_1.html#remarques",
    "title": "Normalisation I",
    "section": "Remarques",
    "text": "Remarques\n\n\n\n\n\n\n\nProposition\n\n\n\nL’algorithme termine\nLes éléments de la décomposition finale sont en FNBC\nLa décomposition est Sans Perte d’Information (SPI)"
  },
  {
    "objectID": "slides/DF_norm_1.html#preuves",
    "href": "slides/DF_norm_1.html#preuves",
    "title": "Normalisation I",
    "section": "Preuves \n",
    "text": "Preuves \n\n\nLa terminaison est triviale : à chaque itération le nombre de parties de \\(\\mathcal{A}\\) dans \\(D\\) augmente de \\(1\\) et ce nombre ne peut dépasser \\(\\# \\mathcal{A}\\)\nLa seconde propriété est triviale aussi\nLa propriété SPI se vérifie avec l’algorithme de poursuite (et son analyse): chaque itération de la boucle While est SPI."
  },
  {
    "objectID": "slides-listings.html",
    "href": "slides-listings.html",
    "title": "Diapositives",
    "section": "",
    "text": "Les diapositives fournissent le canevas du cours. Vous pouvez les utiliser pour vous familiariser avec le matériel du prochain cours, pour revoir les cours passés et, pour réviser.\nLes diapositives marquées par l’image  renvoient à des développements effectués en classes.\n\n\n   \n    \n    \n      Order By\n      Default\n      \n        Titre\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Description\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\n\nTitre\n\n\n\nDescription\n\n\n\n\n\n\n\n\nSep 15, 2025\n\n\nIntroduction aux Bases de Données\n\n\nBases de données, Systèmes d’information, Modèle relationnel, OLTP, OLAP\n\n\n\n\n\n\nSep 15, 2025\n\n\nAlgèbre relationnelle\n\n\nAlgèbre relationnelle, Sélection, Projection, Jointure\n\n\n\n\n\n\nSep 22, 2025\n\n\nSQL : requêtes simples\n\n\nAlgèbre relationnelle, SQL, Sélection, Projection, Jointure\n\n\n\n\n\n\nSep 29, 2025\n\n\nSQL : requêtes imbriquées\n\n\nRequêtes imbriquées, CTE\n\n\n\n\n\n\nOct 6, 2025\n\n\nSQL : Agrégations, Partitions, Fenêtres\n\n\nAggrégations, Partitions, Fenêtres\n\n\n\n\n\n\nOct 13, 2025\n\n\nSQL : Définition de données\n\n\nCréation de tables, Insertion, Suppression, Mises à jour\n\n\n\n\n\n\nOct 20, 2025\n\n\nSQL : Définition de données, Contraintes simples\n\n\nContraintes, Check, Primary Key, Foreign Key\n\n\n\n\n\n\nNov 3, 2025\n\n\nSQL : Définition de données, Contraintes d’exclusion\n\n\nContraintes, Exclude, Contraintes multitables\n\n\n\n\n\n\nNov 10, 2025\n\n\nModélisation : Entité-Association\n\n\nModélisation, MCD, Entité-Association, Cardinalités\n\n\n\n\n\n\nNov 17, 2025\n\n\nModélisation Entité-Association : notions avancées\n\n\nModélisation, Entités faibles, Décomposition d’association, Spécialisation/Généralisation, contraintes de spécialisation, CIF, contraintes inter-associations\n\n\n\n\n\n\nNov 24, 2025\n\n\nModélisation : conversion du MCD vers le MLD\n\n\nModélisation, conversion, MCD, MLD, MRD\n\n\n\n\n\n\nDec 1, 2025\n\n\nDépendances Fonctionnelles. Clés. Fermetures. Décompositions. Perte d’informations. Perte de DF.\n\n\nNormalisation, Dépendances fonctionnelles, Implication, Fermeture, Clés, Décomposition\n\n\n\n\n\n\nDec 8, 2025\n\n\nNormalisation : Décompositions FN3 et FNBC\n\n\nNormalisation, FN3, FNBC\n\n\n\n\n\n\nNo matching items\n\n\n\n\n\n\n\nNoteMode d’emploi\n\n\n\nLes diapositives utilisent la bibliothèque revealjs de . Elles s’affichent dans votre navigateur. Vous pouvez accéder au mode d’emploi en tappant",
    "crumbs": [
      "Diapositives"
    ]
  },
  {
    "objectID": "slides/BD_intro.html#situation-du-cours-bases-de-données-ma15e045-dans-la-licence-miashs",
    "href": "slides/BD_intro.html#situation-du-cours-bases-de-données-ma15e045-dans-la-licence-miashs",
    "title": "BD I: Introduction aux SGBD",
    "section": "Situation du cours Bases de Données (MA15E045) dans la Licence MIASHS",
    "text": "Situation du cours Bases de Données (MA15E045) dans la Licence MIASHS\n\nTroisième cours tourné vers l’informatique\n\nInitiation (L1, S1)\nAlgorithmes et Programmation (L2, S3)\n\nUn cours tourné vers les données avant Science des Données (L3, S6)"
  },
  {
    "objectID": "slides/BD_intro.html#le-déluge-des-données-une-mode",
    "href": "slides/BD_intro.html#le-déluge-des-données-une-mode",
    "title": "BD I: Introduction aux SGBD",
    "section": "Le déluge des données : une mode ?",
    "text": "Le déluge des données : une mode ?"
  },
  {
    "objectID": "slides/BD_intro.html#rien-de-neuf-sous-le-soleil",
    "href": "slides/BD_intro.html#rien-de-neuf-sous-le-soleil",
    "title": "BD I: Introduction aux SGBD",
    "section": "Rien de neuf sous le soleil …",
    "text": "Rien de neuf sous le soleil …\n\n De qui sont ces lignes ? Quand furent-elles écrites ?\n\n\nJe croyais que le goût de la statistique était particulier aux administrateurs de nos jours ; mais je me trompais. Vers la fin de l’ancien régime, on envoie souvent à l’intendant de petits tableaux tout imprimés qu’il n’a plus qu’à faire remplir par ses subdélégués et par les syndics des paroisses. Le contrôleur-général se fait faire des rapports sur la nature des terres, sur leur culture, l’espèce et la quantité des produits, le nombre des bestiaux, l’industrie et les mœurs des habitants. Les renseignements ainsi obtenus ne sont guère moins circonstanciés ni plus certains que ceux que fournissent en pareils cas de nos jours les sous-préfets et les maires. Le jugement que les subdélégués portent, à cette occasion, sur le caractère de leurs administrés, est en général peu favorable. Ils reviennent souvent sur cette opinion que « le paysan est naturellement paresseux, et ne travaillerait pas s’il n’y était obligé pour vivre. »\n\n\nC’est là une doctrine économique qui paraît fort répandue chez ces administrateurs."
  },
  {
    "objectID": "slides/BD_intro.html#les-données-intéressent",
    "href": "slides/BD_intro.html#les-données-intéressent",
    "title": "BD I: Introduction aux SGBD",
    "section": "Les données intéressent",
    "text": "Les données intéressent\n\nles sciences\nles administrations\nles entreprises\nles citoyennes (et les citoyens)\n…"
  },
  {
    "objectID": "slides/BD_intro.html#les-données-en-sciences-sociales",
    "href": "slides/BD_intro.html#les-données-en-sciences-sociales",
    "title": "BD I: Introduction aux SGBD",
    "section": "Les données en Sciences Sociales",
    "text": "Les données en Sciences Sociales\n\n\n\nPourquoi ?\nDe quoi sont faites les données ?\nComment les accumuler ?\nComment les interroger ?\nComment les conserver ? les éditer ?\n\n\n\n\n\nBN Salle ovale"
  },
  {
    "objectID": "slides/BD_intro.html#sources-et-usages-des-données",
    "href": "slides/BD_intro.html#sources-et-usages-des-données",
    "title": "BD I: Introduction aux SGBD",
    "section": "Sources et usages des données",
    "text": "Sources et usages des données\n\n\nQuelques références\n\n\n\nData humanities with R. Arnold and Tilton\n\n\nQuantitative tour at social sciences edited by Gelman and Cortina, 2009\n Relational databses on slideshare\n\nQuelques problèmes\n\nConstitution (archivage, etc)\nAcquisition/organisation\nUsage(s)\nMaintenance"
  },
  {
    "objectID": "slides/BD_intro.html#les-données-de-lentreprisedes-administrations",
    "href": "slides/BD_intro.html#les-données-de-lentreprisedes-administrations",
    "title": "BD I: Introduction aux SGBD",
    "section": "Les données de l’entreprise/des administrations",
    "text": "Les données de l’entreprise/des administrations\n\n\n\nLa comptabilité\nLes stocks (ERP)\nLa clientèle (CRM)\n…"
  },
  {
    "objectID": "slides/BD_intro.html#la-vie-des-données-en-résumé",
    "href": "slides/BD_intro.html#la-vie-des-données-en-résumé",
    "title": "BD I: Introduction aux SGBD",
    "section": "La vie des données (en résumé)",
    "text": "La vie des données (en résumé)\n\n\n\n Saisie/Alimentation\n Traitement(s)\n Usage(s)\n Archivage\n Maintenance\n\n\n\n\n\npipelines"
  },
  {
    "objectID": "slides/BD_intro.html#avant-hier",
    "href": "slides/BD_intro.html#avant-hier",
    "title": "BD I: Introduction aux SGBD",
    "section": "Avant-hier",
    "text": "Avant-hier\n\n\nLes entreprises et les administrations ont toujours cultivé une mémoire sous forme de fichiers plus ou moins mécanisés et formattés.\nCes collections de fichiers mécanisées répondaient à des exigences de fiabilité, de convenance (facilité de la recherche, de la maintenance)\n\n\n\n\nFrom https://www.ibm.com/history/punched-card"
  },
  {
    "objectID": "slides/BD_intro.html#aujourdhui",
    "href": "slides/BD_intro.html#aujourdhui",
    "title": "BD I: Introduction aux SGBD",
    "section": "Aujourd’hui",
    "text": "Aujourd’hui\n\n\n\nExplosion des volumes\nExplosion des débits\nUsages (très) divers"
  },
  {
    "objectID": "slides/BD_intro.html#systèmes-dinformation-1",
    "href": "slides/BD_intro.html#systèmes-dinformation-1",
    "title": "BD I: Introduction aux SGBD",
    "section": "Systèmes d’information",
    "text": "Systèmes d’information\n\nUn système d’information (SI) est un ensemble de composants qui fonctionnent ensemble pour collecter, traiter, stocker et diffuser des informations.\n\n\n\nLes systèmes d’information ont des objectifs (très) divers.\n\n\nPar exemple : les systèmes de traitement des transactions (TPS), les systèmes d’information de gestion (MIS), les systèmes d’aide à la décision (DSS) et les systèmes de planification des ressources de l’entreprise (ERP)."
  },
  {
    "objectID": "slides/BD_intro.html#décomposition-des-si",
    "href": "slides/BD_intro.html#décomposition-des-si",
    "title": "BD I: Introduction aux SGBD",
    "section": "Décomposition des SI",
    "text": "Décomposition des SI\nUn système d’information comprend en général les éléments suivants:\n\nMatériel informatique (ou pas) : dispositifs physiques utilisés pour collecter, stocker et traiter l’information (ordinateurs, serveurs, stockage, réseau, …).\nLogiciels : Les programmes exécutés sur le matériel pour gérer les données et effectuer des tâches spécifiques (OS, SGBD, Logiciels applicatifs).\nDonnées\nPersonnes : Les usagers du système d’information\nProcessus : Les flux de travail et les règles régissant la manière dont les données sont collectées, traitées et distribuées, conformément aux objectifs."
  },
  {
    "objectID": "slides/BD_intro.html#systèmes-dinformation-si-et-bases-de-données-bd-sgbd-sgbdr",
    "href": "slides/BD_intro.html#systèmes-dinformation-si-et-bases-de-données-bd-sgbd-sgbdr",
    "title": "BD I: Introduction aux SGBD",
    "section": "Systèmes d’information (SI) et Bases de Données (BD, SGBD, SGBDR)",
    "text": "Systèmes d’information (SI) et Bases de Données (BD, SGBD, SGBDR)\nAu coeur des systèmes d’information (modernes) on trouve (presque toujours) les bases de données\n\n\n\n\n\n\nMise en garde\n\n\nToutes les bases de données ne sont pas relationnelles"
  },
  {
    "objectID": "slides/BD_intro.html#des-propriétés-désirables-acid",
    "href": "slides/BD_intro.html#des-propriétés-désirables-acid",
    "title": "BD I: Introduction aux SGBD",
    "section": "Des propriétés désirables (ACID)",
    "text": "Des propriétés désirables (ACID)\n\n\n\n\n\n\nAtomicité\n\n\nChaque ajout/modification d’information doit former un tout cohérent\nSi tout se passe correctement, les actions de la transaction sont toutes validées, sinon on retourne à l’état initial\n\n\n\n\n\n\n\n\n\n\nCohérence\n\n\nLe contenu de la base de données doit rester conforme à des contraintes définies lors de la conception\n\n\n\n\n\n\n\n\n\n\n\nIsolation\n\n\nLa bases de données doit pouvoir être utilisée concurremment par plusieurs usagers\n\n\n\n\n\n\n\n\n\n\n\nDurabilité\n\n\nLa vie d’une base de données s’étale sur plusieurs dizaines d’années"
  },
  {
    "objectID": "slides/BD_intro.html#bases-de-données",
    "href": "slides/BD_intro.html#bases-de-données",
    "title": "BD I: Introduction aux SGBD",
    "section": " Bases de données",
    "text": "Bases de données\n\nQu’est-ce que c’est (plus précisément) ?\n\n\nCe sont des logiciels intermédiaires (middleware) entre :\n\nSystèmes de gestion de fichiers/Systèmes d’exploitation   …\nApplications (CRM, ERP, CMS, …)    …\n\n\n\nLes bases de données ne sont pas (simplement) un langage (comme JAVA, , )"
  },
  {
    "objectID": "slides/BD_intro.html#collection-de-tablesdata-frames",
    "href": "slides/BD_intro.html#collection-de-tablesdata-frames",
    "title": "BD I: Introduction aux SGBD",
    "section": " Collection de tables/data frames",
    "text": "Collection de tables/data frames\nCaricaturalement :\n\nUne base de données relationnelle est une collection de tables\n\n\nLes tables s’incarnent de plusieurs façons en informatique\nR, Pandas, les tableurs (Excel …), offrent un environnement interactif de manipulation de données et un environnement de définition de données"
  },
  {
    "objectID": "slides/BD_intro.html#data-frame",
    "href": "slides/BD_intro.html#data-frame",
    "title": "BD I: Introduction aux SGBD",
    "section": " Data frame",
    "text": "Data frame\n\n\nUn dataframe est une liste de vecteurs (colonnes)\nLes vecteurs (colonnes) d’un dataframe sont tous de même longueur\nLes éléments d’un vecteur sont d’un même type de base\nChaque vecteur a un nom et son propre type"
  },
  {
    "objectID": "slides/BD_intro.html#autres-environments-excel-java-python",
    "href": "slides/BD_intro.html#autres-environments-excel-java-python",
    "title": "BD I: Introduction aux SGBD",
    "section": "Autres environments (Excel, JAVA, Python)",
    "text": "Autres environments (Excel, JAVA, Python)\n\n\nLes spreadsheet des tableurs \nLes Dataframes de Pandas  \nLes tableaux d’objets en JAVA\n\npermettent de représenter ce que les dataframes représentent en R"
  },
  {
    "objectID": "slides/BD_intro.html#les-sgbd-vont-au-delà",
    "href": "slides/BD_intro.html#les-sgbd-vont-au-delà",
    "title": "BD I: Introduction aux SGBD",
    "section": "Les SGBD vont au delà :",
    "text": "Les SGBD vont au delà :\nIls offrent:\n\n\n\n\n\n\nPersistance\n\n\nEntre deux sessions, les données sont confiées au système de fichiers de l’ordinateur\n\n\n\n\n\n\n\n\n\n\nIntégrité\n\n\nLes données confiées au système de fichiers ne peuvent pas être altérées par d’autres logiciels\n\n\n\n\n\n\n\n\n\n\n\nConcurrence\n\n\nLes données peuvent être manipulées/consultées/mises à jour de manière concurrente par plusieurs voire par une grande quantité d’ utilisateurs."
  },
  {
    "objectID": "slides/BD_intro.html#usages",
    "href": "slides/BD_intro.html#usages",
    "title": "BD I: Introduction aux SGBD",
    "section": "Usages",
    "text": "Usages\n\nSites web dynamiques  \nLogiciels personnels\n\nDerrière certaines applications (gestion de photos, de carnet d’adresses, …), on trouve des bases de données légères (SQLITE)\n\nPartout\n\nsmartphones, tablettes, …\nweb, réseaux sociaux\nadministrations (APOGEE, …)\nentreprises (Stocks Supply Chain, Customer Relationship Management, …)\nNSA"
  },
  {
    "objectID": "slides/BD_intro.html#lidée-clé-codd-1970",
    "href": "slides/BD_intro.html#lidée-clé-codd-1970",
    "title": "BD I: Introduction aux SGBD",
    "section": "L’idée clé (Codd, 1970)",
    "text": "L’idée clé (Codd, 1970)\nOrganiser les informations en tables ou relations\nDévelopper et formaliser un langage de manipulation de tables : l’algèbre relationnelle (langage SQL, Structured Query Language)\n\nL’usager peut définir l’organisation des données\nIl peut interroger celles-ci (par des requêtes)\nLe langage est déclaratif :\n\nOn décrit ce que l’on veut obtenir (quoi mais pas comment)\nLe système fait le reste…\n\nL’évaluation de toutes les requêtes s’arrête (au moins en théorie : si on y met les moyens…)\nL’algèbre relationnelle/SQL n’est pas un langage complet (différence avec JAVA, C, Python, etc)"
  },
  {
    "objectID": "slides/BD_intro.html#quelques-acteurs",
    "href": "slides/BD_intro.html#quelques-acteurs",
    "title": "BD I: Introduction aux SGBD",
    "section": "Quelques acteurs",
    "text": "Quelques acteurs\n\n\nServeurs\n\nORACLE (commercial)\nDB2 (IBM commercial)\nSQLSERVER (Microsoft commercial)\nMySQL (open source)\nPostGres (open source)\nHana (commercial)\n\n\nClients\n\npsql\npgcli\ndbeaver\nPgAdmin\n…"
  },
  {
    "objectID": "slides/BD_intro.html#postgres-postgresql",
    "href": "slides/BD_intro.html#postgres-postgresql",
    "title": "BD I: Introduction aux SGBD",
    "section": "PostGres (PostgreSQL)",
    "text": "PostGres (PostgreSQL)\n\nUn serveur : etu-pgsql\nUn catalogue : bd_2023-24\nDes schémas: world, pagila, nycflights13, ..."
  },
  {
    "objectID": "slides/BD_intro.html#un-exemple-de-schéma-world",
    "href": "slides/BD_intro.html#un-exemple-de-schéma-world",
    "title": "BD I: Introduction aux SGBD",
    "section": "Un exemple de schéma world",
    "text": "Un exemple de schéma world\nUn schema\nDes schémas de table\n\ncontinent : association nom de continent (texte)-code de continent (entier)\ncountry : chaque tuple porte sur un état/territoire\ncity : chaque tuple porte sur une ville (déisgnée par id) qui appartient à un état/territoire désigné par countrycode\ncountrylanguage : chaque tuple indique la part de la population d’un état/territoire (désigné par countrycode) qui parle/connaît une langue (désignée par language) et précise si la langue est officielle dans cet état/territoire."
  },
  {
    "objectID": "slides/BD_intro.html#détails-du-schema-world",
    "href": "slides/BD_intro.html#détails-du-schema-world",
    "title": "BD I: Introduction aux SGBD",
    "section": "Détails du schema world",
    "text": "Détails du schema world\n\n\n\nImage World\n\n\n\n\nUn schéma de table : la donnée des noms des colonnes et des types des colonnes"
  },
  {
    "objectID": "slides/BD_intro.html#quelques-questions-et-propriétés-typiques",
    "href": "slides/BD_intro.html#quelques-questions-et-propriétés-typiques",
    "title": "BD I: Introduction aux SGBD",
    "section": "Quelques questions et propriétés typiques",
    "text": "Quelques questions et propriétés typiques\n\nExtraire de l’information\nAssurer de la cohérence après modification\n\nFaire en sorte que chaque état/territoire soit identifié par un numéro unique\nFaire en sorte que chaque ville soit identifiée par un numéro unique\nNe pas proposer de données sur des villes/territoires/états qui n’existent pas\n\n\n\n\nPropager l’information\n\nHistoriciser le schéma"
  },
  {
    "objectID": "slides/BD_intro.html#objectifs-du-cours",
    "href": "slides/BD_intro.html#objectifs-du-cours",
    "title": "BD I: Introduction aux SGBD",
    "section": "Objectifs du cours",
    "text": "Objectifs du cours\n\nCompétences d’un usager de BD relationnelles\nExprimer des requêtes en algèbre relationnelle et en SQL\nSQL Définition, manipulation et contrôle des données\nConcevoir un Modèle Conceptuel de Données (Entités/Associations)\nDéterminer les dépendances fonctionnelles et normaliser une relation"
  },
  {
    "objectID": "slides/BD_intro.html#plan-du-cours",
    "href": "slides/BD_intro.html#plan-du-cours",
    "title": "BD I: Introduction aux SGBD",
    "section": "Plan du cours",
    "text": "Plan du cours\n\nAlgèbre et calcul relationnels\nSQL (algèbre relationnelle stricte)\nSQL sous-requêtes\nSQL agrégation\nSQL requêtes paramétrées\nDéfinition de données/Conception\nNormalisation"
  },
  {
    "objectID": "slides/BD_intro.html#entrepôts-de-données-fin-des-années-1980",
    "href": "slides/BD_intro.html#entrepôts-de-données-fin-des-années-1980",
    "title": "BD I: Introduction aux SGBD",
    "section": "Entrepôts de données (Fin des années 1980)",
    "text": "Entrepôts de données (Fin des années 1980)\n\n\n\n\n\n\nDatawarehouse\n\n\n\nUn Data Warehouse est une technologie qui regroupe des données structurées provenant d’une ou de plusieurs sources afin qu’elles puissent être comparées et analysées.\n\n\n\n\n\n“Entrepôt de données” sur Wikipedia"
  },
  {
    "objectID": "slides/BD_intro.html#lacs-de-données-2010",
    "href": "slides/BD_intro.html#lacs-de-données-2010",
    "title": "BD I: Introduction aux SGBD",
    "section": "Lacs de données (2010)",
    "text": "Lacs de données (2010)\n\n\n\n\n\n\nDatalake\n\n\nLe concept de Data Lake a été évoqué pour la première fois, en 2010, par James Dixon, comme une solution pour le stockage de données sans pré-traitement et sans connaître précisément l’usage futur qui en sera fait. L’image du lac, permettant d’expliquer, que différentes sources peuvent l’alimenter de manière naturelle et brute, et que les utilisateurs peuvent y plonger pour l’explorer et en rapporter des échantillons à examiner"
  },
  {
    "objectID": "slides/BD_intro.html#au-delà-du-relationnel-no-sql",
    "href": "slides/BD_intro.html#au-delà-du-relationnel-no-sql",
    "title": "BD I: Introduction aux SGBD",
    "section": "Au delà du relationnel: No SQL",
    "text": "Au delà du relationnel: No SQL\nCe sont les grandes entreprises du web qui ont été les premières confrontées aux limitations intrinsèques des SGBD relationnels traditionnels. Ces systèmes fondés sur une application stricte des propriétés ACID et généralement conçus pour fonctionner sur des ordinateurs uniques ont rapidement posé des problèmes d’extensibilité.\n\nAfin de répondre à ces limites, ces entreprises ont commencé à développer leurs propres systèmes de gestion de bases de données pouvant fonctionner sur des architectures matérielles distribuées et permettant de traiter des volumes de données importants.\n\n\nLes systèmes propriétaires qui en ont résulté, Google (BigTable), Amazon (Dynamo (en)), LinkedIn (Voldemort), Facebook (Cassandra puis HBase), SourceForge.net (MongoDB), Ubuntu One (CouchDB), Baidu (Hypertable) ont été les précurseurs du modèle NoSQL."
  },
  {
    "objectID": "slides/BD_intro.html#lire-plus",
    "href": "slides/BD_intro.html#lire-plus",
    "title": "BD I: Introduction aux SGBD",
    "section": "Lire plus",
    "text": "Lire plus\nGuy Harrison. Next Generation Databases. NoSQL, NewSQL, Big Data"
  },
  {
    "objectID": "slides/DF_norm_3.html#résultat-de-la-séance-précédente",
    "href": "slides/DF_norm_3.html#résultat-de-la-séance-précédente",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Résultat de la séance précédente\n",
    "text": "Résultat de la séance précédente\n\n\n\n\n\n\n\nImportant\n\n\nOn peut décomposer une relation \\(\\mathcal{A}\\) relativement à un ensemble de DF \\(\\Sigma\\) de façon à obtenir une décomposition :\n\ndont tous les membres sont en FNBC relativement à \\(\\Sigma\\)\nSPI\n\n\n\n\n\n Ce résultat ne fournit pas toujours une solution complètement satisfaisante"
  },
  {
    "objectID": "slides/DF_norm_3.html#projection-dun-ensemble-de-df",
    "href": "slides/DF_norm_3.html#projection-dun-ensemble-de-df",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Projection d’un ensemble de DF",
    "text": "Projection d’un ensemble de DF\nSoientt \\(\\mathcal{A}\\) un schéma de relation (\\(\\mathcal{A}\\) est un ensemble d’attributs) et \\(\\Sigma\\) un ensemble de DF sur \\(\\mathcal{A}\\)\nSoit \\(\\mathcal{A}_1\\subset  \\mathcal{A}\\) un sous-ensemble d’attributs\n\n\n\n\n\n\nDéfinition\n\n\n\\[\\pi_{\\mathcal{A}_1}(\\Sigma)=\\left\\{ X\\to Y \\mid \\Sigma\\models X\\to Y \\text{ et } X,Y\\subset \\mathcal{A}_1\\right\\}\\]\n\n\n\n\n\n\n\n\n\n\nCaractérisation\n\n\nSi \\(X\\subset {\\mathcal{A}}_1\\) on a l’équivalence \\[X\\to Y \\in \\pi_{{\\mathcal{A}}_1}(\\Sigma) \\iff Y\\subset\\left\\{X\\right\\}^+∩{\\mathcal{A}}_1\\]\n\n\n\n\n\\(\\pi_{\\mathcal{A}_1}(\\Sigma)\\) est l’ensemble des DF de la forme \\(X\\to Y\\) impliquées par \\(\\Sigma\\) et telles que \\(X\\subset \\mathcal{A}_1\\) et \\(Y\\subset \\mathcal{A}_1\\)"
  },
  {
    "objectID": "slides/DF_norm_3.html#exemple",
    "href": "slides/DF_norm_3.html#exemple",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Exemple",
    "text": "Exemple\n\n\\({\\mathcal{A}}=\\left\\{A,B,C\\right\\}\\) et \\(\\Sigma=\\left\\{A\\to B, B\\to C, C\\to A\\right\\}\\)\n\\(\\pi^{}_{\\left\\{A,B\\right\\}}(\\Sigma)\\) est équivalent à \\(\\left\\{A\\to B, B\\to A\\right\\}\\)"
  },
  {
    "objectID": "slides/DF_norm_3.html#calcul-de-pi_mathcala_1sigma",
    "href": "slides/DF_norm_3.html#calcul-de-pi_mathcala_1sigma",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Calcul de \\(\\pi_{{\\mathcal{A}}_1}(\\Sigma)\\)\n",
    "text": "Calcul de \\(\\pi_{{\\mathcal{A}}_1}(\\Sigma)\\)\n\nOn calcule un ensemble de DF équivalent à \\(\\pi_{\\mathcal{A}_1}(\\Sigma)\\)\n\n\n\\begin{algorithm} \\caption{Projection de DF} \\begin{algorithmic} \\Procedure{Projection}{$\\mathcal{A}_1, Σ$} \\State P ← ∅ \\For{$X ⊂ \\mathcal{A}_1$, $X ≠ ∅$, $X ≠ \\mathcal{A}_1$} \\State Y ← $X^+ ∩ \\mathcal{A}_1$ \\State P ← P ∪ $\\{ X → Y\\}$ \\EndFor \\Return P \\EndProcedure \\end{algorithmic} \\end{algorithm}\n\n\n\n\nL’ensemble de DF obtenu est équivalent à \\(\\pi_{{\\mathcal{A}}_1}(\\Sigma)\\)Très coûteux ! Le nombre de sous-ensembles \\(X\\) considérés est \\(2^{\\#{\\mathcal{A}}_1}-2\\)"
  },
  {
    "objectID": "slides/DF_norm_3.html#exemple-1",
    "href": "slides/DF_norm_3.html#exemple-1",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Exemple",
    "text": "Exemple\n\n\n\\({\\mathcal{A}}=\\left\\{A,B,C,D,E\\right\\}\\) et \\(\\Sigma=\\left\\{A\\to C, BC\\to D, AD\\to E\\right\\}\\)\n\n\n\n\n\n\\(\\pi_{AC}(\\Sigma)\\) est équivalent à \\(\\left\\{A\\to C\\right\\}\\) car\\(\\left\\{A\\right\\}^+=\\left\\{A,C\\right\\}\\) et \\(\\left\\{C\\right\\}^+=\\left\\{C\\right\\}\\)\n\n\n\n\n\n\n\\(\\pi_{ABD}(\\Sigma)\\) est équivalent à \\(\\left\\{AB\\to D\\right\\}\\) car\\(\\left\\{A\\right\\}^+=\\left\\{A,C\\right\\}\\), \\(\\left\\{B\\right\\}^+=\\left\\{D\\right\\}\\), \\(\\left\\{D\\right\\}^+=\\left\\{D\\right\\}\\),\\(\\left\\{A,B\\right\\}^+=\\left\\{A,B,C,D,E\\right\\}\\), \\(\\left\\{A,D\\right\\}^+=\\left\\{A,D,C,E\\right\\}\\), \\(\\left\\{B,D\\right\\}^+=\\left\\{B,D\\right\\}\\)\n\n\n\n\n\n\n\\(\\pi_{ABCE}(\\Sigma)\\) est équivalent à \\(\\left\\{A\\to C, AB \\to CE, AE\\to C, ABC\\to E, ABE\\to C\\right\\}\\)\\(A^+=AC \\quad B^+=B \\quad C^+=C \\quad E^+=E\\)\\(AB^+=ABCDE \\quad AC^+=AC \\quad AE^+=AEC\\)\\(BC^+=BCD \\quad BE^+=BE \\quad CE^+=CE\\)\\(ABC^+=ABCDE \\quad ABE^+=ABECD\\)\\(BCE^+=BCED \\quad ACE^+=ACE\\)\n\n\n\n\n\nSimplification : \\(\\pi_{ABCE}(\\Sigma)\\) équivaut à \\(\\left\\{A\\to C, AB\\to E\\right\\}\\)"
  },
  {
    "objectID": "slides/DF_norm_3.html#préservation-de-dépendances-fonctionnelles",
    "href": "slides/DF_norm_3.html#préservation-de-dépendances-fonctionnelles",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Préservation de dépendances fonctionnelles",
    "text": "Préservation de dépendances fonctionnelles\n\n\n\n\n\n\nDéfinition\n\n\nSoit \\(\\mathcal{A}\\) un schéma de relation et \\(\\Sigma\\) un ensemble de DF sur \\(\\mathcal{A}\\).\nSoit \\(\\left\\{ \\mathcal{A}_1,\\dots, \\mathcal{A}_k\\right\\}\\) une décomposition du schéma \\(\\mathcal{A}\\) (\\(\\mathcal{A}_i\\neq \\emptyset, 1\\leq i\\leq k\\) et \\(\\mathcal{A}= \\bigcup_{i=1}^k \\mathcal{A}_i\\))\nLa décomposition \\(\\left\\{\\mathcal{A}_1,\\dots, \\mathcal{A}_k\\right\\}\\) préserve \\(\\Sigma\\) si l’ensemble des dépendances fonctionnelles locales \\(\\bigcup_{i=1}^k \\pi_{\\mathcal{A}_i}(\\Sigma)\\) est équivalent à \\(\\Sigma\\)\n\n\n\n\n\nPuisque \\(\\Sigma ⊧ \\bigcup_{i=1}^k \\pi_{\\mathcal{A}_i}(\\Sigma)\\), la décomposition préserve \\(\\Sigma\\) si et seulement si toutes les DF de \\(\\Sigma\\) sont impliquées par les DF locales"
  },
  {
    "objectID": "slides/DF_norm_3.html#algorithme-pour-tester-si-bigcup_i1k-pi_mathcala_isigma-models-x-rightarrow-y",
    "href": "slides/DF_norm_3.html#algorithme-pour-tester-si-bigcup_i1k-pi_mathcala_isigma-models-x-rightarrow-y",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Algorithme pour tester si \\(\\bigcup_{i=1}^k \\pi_{\\mathcal{A}_i}(\\Sigma) \\models X \\rightarrow Y\\)\n",
    "text": "Algorithme pour tester si \\(\\bigcup_{i=1}^k \\pi_{\\mathcal{A}_i}(\\Sigma) \\models X \\rightarrow Y\\)\n\n\n\n\\begin{algorithm} \\caption{X → Y est-elle impliquée par les dépendances projetées?} \\begin{algorithmic} \\Procedure{Implique}{$\\left\\{ \\mathcal{A}_1,\\dots, \\mathcal{A}_k\\right\\}, Σ, X, Y$} \\State Z ← X \\State continuer ← \\True \\While{continuer} \\State $W ← Z$ \\For{i ∈ 1, ..., k} \\State $W ← W ∪ \\bigl((W ∩ \\mathcal{A}_i)^+ ∩ \\mathcal{A}_i\\bigr)$ \\EndFor \\If{W ≠ Z} \\State Z ← W \\Else \\State continuer ← \\False \\EndIf \\EndWhile \\If{Y ⊆ Z} \\Return \\True \\Else \\Return \\False \\EndIf \\EndProcedure \\end{algorithmic} \\end{algorithm}"
  },
  {
    "objectID": "slides/DF_norm_3.html#exemple-i",
    "href": "slides/DF_norm_3.html#exemple-i",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Exemple I",
    "text": "Exemple I\n\n\\(\\mathcal{A}=\\left\\{A,B,C,D\\right\\}\\),\n\\(\\mathcal{A}_1=\\left\\{A,B\\right\\}\\), \\(\\mathcal{A}_2=\\left\\{B,C\\right\\}\\), \\(\\mathcal{A}_3=\\left\\{C,D\\right\\}\\)\n\\(\\Sigma=\\left\\{A\\to B, B\\to C, C\\to D, D\\to A\\right\\}\\)\nEst-ce que la décomposition \\(\\left\\{\\mathcal{A}_1,\\mathcal{A}_2,\\mathcal{A}_3\\right\\}\\) préserve \\(\\Sigma\\) ?\n\n\n\nLes DF locales impliquent \\(A\\to B\\), \\(B\\to C\\), \\(C\\to D\\) (ce sont DF locales)\n\n\n\n\nEst-ce que les DF locales impliquent \\(D\\to A\\) ?\n\n\n\nCommencer avec \\(Z ← \\{D\\}\\)\n\n\\((\\{D\\}∩\\{CD\\})^+ ∩ \\{CD\\}=\\{D\\}^+ ∩\\{CD\\}=\\{DABC\\} ∩ \\{CD\\}=\\{CD\\}\\), ajouter \\(C\\)\n\\((\\{DC\\}∩ \\{BC\\})^+ ∩ \\{BC\\}=\\{C\\}^+ ∩ \\{BC\\}=\\{CDAB\\}∩ \\{BC=B\\}\\), ajouter \\(B\\)\n\\((\\{DCB\\}∩ \\{AB\\})^+ ∩ \\{AB\\}=\\{B\\}^+ ∩ \\{AB\\}=\\{BCDA\\} ∩ \\{AB\\}\\), ajouter \\(A\\)\n\\(\\{DCBA\\}\\) contient \\(A\\) donc \\(D\\to A\\) est préservée"
  },
  {
    "objectID": "slides/DF_norm_3.html#exemple-ii",
    "href": "slides/DF_norm_3.html#exemple-ii",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Exemple II",
    "text": "Exemple II\n\n\\(\\mathcal{A}=\\) {Ville, CP, Rue, Numero}\n\\(\\Sigma=\\) { CP →  Ville, {Ville, Rue, Numero} → CP}\n\\(\\mathcal{A}_1=\\) {Ville, CP} \\(\\mathcal{A}_2=\\) {Rue, Numero, CP}\nEst-ce que la décomposition \\(\\{\\mathcal{A}_1, \\mathcal{A}_2 \\}\\) préserve \\(\\Sigma\\) ?\n\n\n\n\nCP →  Ville est préservée car elle est locale à \\(\\mathcal{A}_1\\)\n\n\n\n\n\nEst-ce que {Ville, Rue, Numero} → CP est préservée par \\(\\mathcal{A}_1, \\mathcal{A}_2\\) ?\n\n\n\nZ ← {Ville, Rue, Numero}\n\n\\((\\texttt{Z} ∩ \\texttt{{Ville, CP}})^+\\) ∩ {Ville, CP} = {Ville} rien à ajouter\n\\((\\texttt{Z} ∩ \\texttt{{Rue, Numero, CP}})^+\\) ∩ {Rue, Numero, CP} = {Rue, Numero}, rien à ajouter\n\n\n\nDonc Ville, Rue, Numero → CP n’est pas préservée"
  },
  {
    "objectID": "slides/DF_norm_3.html#rappels-séance-précédente-bis",
    "href": "slides/DF_norm_3.html#rappels-séance-précédente-bis",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Rappels séance précédente (bis)",
    "text": "Rappels séance précédente (bis)\n\n\n\n\n\n\nDéfinition\n\n\nUn schéma \\(\\mathcal{A}\\) est en FNBC par rapport à un ensemble de dépendances fonctionnelles \\(\\Sigma\\) sur \\(\\mathcal{A}\\)\nsi\npour toute DF \\(X\\rightarrow Y\\) impliquée par \\(\\Sigma\\) avec \\(Y\\not\\subset X\\), \\(X\\) est une super-clef"
  },
  {
    "objectID": "slides/DF_norm_3.html#algorithme",
    "href": "slides/DF_norm_3.html#algorithme",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Algorithme",
    "text": "Algorithme\n\n\n\\begin{algorithm} \\caption{Decomposition FN3} \\begin{algorithmic} \\Procedure{DecompositionFN3}{$\\mathcal{A}, Σ$} \\State \\Comment{Initialisation de la décomposition} \\State $D ← ∅$ \\State \\Comment{Mise en forme des courverture minimale de Σ} \\State Σ' ← \\Call{MinCover}{$Σ$} \\State \\For{Each distinct determinant $X$ amongst FDs in Σ'} \\State $Y ← \\{y : X → y ∈ Σ'\\}$ \\State $D ← D \\cup \\{X \\cup Y\\}$ \\Comment{ Ajouter $X \\cup Y$ à $D$} \\EndFor \\State \\State $\\mathcal{B} ← $ Attributes in $\\mathcal{A}$ that do not occur in $D$ \\State $D ← D \\cup \\{\\mathcal{B}\\}$ \\State \\If{No component of $D$ includes a key for $\\mathcal{A}, Σ$} \\State $D ← D \\cup $ some key for $\\mathcal{A}, Σ$ \\EndIf \\State \\Return $D$ \\EndProcedure \\end{algorithmic} \\end{algorithm}"
  },
  {
    "objectID": "slides/DF_norm_3.html#limites-de-la-décomposition-fnbc",
    "href": "slides/DF_norm_3.html#limites-de-la-décomposition-fnbc",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Limites de la décomposition FNBC",
    "text": "Limites de la décomposition FNBC\n\n\n\n\n\n\nNote\n\n\nIl existe des couples schéma/Ensemble de DFs (\\(\\mathcal{A}, \\Sigma\\)) pour lesquels toute décomposition FNBC entraine une perte de dépendances fonctionnelles"
  },
  {
    "objectID": "slides/DF_norm_3.html#section",
    "href": "slides/DF_norm_3.html#section",
    "title": "Normalisation II : Décomposition FN3",
    "section": "",
    "text": "\\(\\mathcal{A} =\\) {Ville, Rue, Numéro, #Bureau_vote}\nΣ = { Ville, Nom, Rue → #Bureau_vote,  #Bureau_vote  →  Ville }\n\nDeux clés Ville, Nom, Rue et #Bureau_vote, Nom, Rue\n\n\n#Bureau_vote  →  Ville ne satisfait pas le critère FNBC\n\n\nL’algorithme de décomposition en FNBC conduit à la décomposition {#Bureau_vote,Ville} et {#Bureau_vote, Nom, Rue}\nLa DF Ville, Nom, Rue → #Bureau_vote n’est pas préservée\nLa décomposition préserve l’information (SPI) mais pas les dépendances fonctionnelles."
  },
  {
    "objectID": "slides/DF_norm_3.html#limites-de-la-décomposition-fnbc-suite",
    "href": "slides/DF_norm_3.html#limites-de-la-décomposition-fnbc-suite",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Limites de la décomposition FNBC (suite)",
    "text": "Limites de la décomposition FNBC (suite)\n\n\n\n\n\n\n\nÀ noter\n\n\nOn peut vérifier qu’aucune décomposition FNBC de \\(\\mathcal{A}\\) ne préserve toutes les dépendances fonctionnelles."
  },
  {
    "objectID": "slides/DF_norm_3.html#un-nouvel-objectif",
    "href": "slides/DF_norm_3.html#un-nouvel-objectif",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Un nouvel objectif",
    "text": "Un nouvel objectif\n\n\n\n\n\n\n\nConstruire\n\n\nUne décomposition :\n\nSans Perte d’Information (SPI)\nSans perte de Dépendances Fonctionnelles\nDont les éléments sont en FN3 par rapports aux dépendances projetées"
  },
  {
    "objectID": "slides/DF_norm_3.html#pour-réaliser-cet-objectif",
    "href": "slides/DF_norm_3.html#pour-réaliser-cet-objectif",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Pour réaliser cet objectif",
    "text": "Pour réaliser cet objectif\nUne étape cruciale : réécrire l’ensemble de DFs"
  },
  {
    "objectID": "slides/DF_norm_3.html#algorithme-de-construction-de-couverture-irredondante",
    "href": "slides/DF_norm_3.html#algorithme-de-construction-de-couverture-irredondante",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Algorithme de construction de couverture irredondante",
    "text": "Algorithme de construction de couverture irredondante\n\n\n\\begin{algorithm} \\caption{Couverture irredondante} \\begin{algorithmic} \\Procedure{MinCover}{$Σ$} \\State Σ' ← ∅ \\State \\Comment{Normaliser les éléments de Σ} \\For{$(X → Y) ∈ Σ$} \\For{$y ∈ Y$} \\State Σ' ← Σ' ∪ {X → y} \\EndFor \\EndFor \\State \\Comment{Éliminer les dépendances redondantes dans Σ'} \\State \\Comment{Miniser les dépendances dans Σ'} \\Return Σ' \\EndProcedure \\end{algorithmic} \\end{algorithm}"
  },
  {
    "objectID": "slides/DF_norm_3.html#détails",
    "href": "slides/DF_norm_3.html#détails",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Détails",
    "text": "Détails\n\n\n\n\n\\begin{algorithm} \\caption{Éliminer les dépendances redondantes dans Σ' (détail)} \\begin{algorithmic} \\Repeat \\State s ← \\True \\For{$(X → y) ∈ Σ'$} \\If{$Σ' \\setminus {X → y} ⊧ X → y$} \\State $Σ' ← Σ' \\setminus {X → y}$ \\State s ← \\False \\EndIf \\EndFor \\Until{s} \\end{algorithmic} \\end{algorithm}\n\n\n\n\n\n\\begin{algorithm} \\caption{Miniser les dépendances dans Σ' (détail)} \\begin{algorithmic} \\Repeat \\State s ← \\True \\For{$(X → y) ∈ Σ'$} \\For{$x ∈ X$} \\If{$Σ' \\setminus {X → y} ⊧ X \\setminus {x} → y$} \\State $Σ' ← (Σ' \\setminus {X → y}) ∪ X \\setminus {x} → y$ \\State s ← \\False \\Break \\EndIf \\EndFor \\EndFor \\Until{s} \\end{algorithmic} \\end{algorithm}"
  },
  {
    "objectID": "slides/DF_norm_3.html#définition-forme-normale-3-fn3",
    "href": "slides/DF_norm_3.html#définition-forme-normale-3-fn3",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Définition : forme normale 3 (FN3)",
    "text": "Définition : forme normale 3 (FN3)\n\n\n\n\n\n\nImportant\n\n\nUn schéma relationnel \\(\\mathcal{A}\\) est en forme normale 3 (FN3) relativement à un ensemble de DF Σ ssi pour toute dépendance non triviale X → Yde Σ, on a\n\nle membre gauche X est une super-clé ou\n\nle membre droit Y fait partie d’une clé\n\n\n\n\n\n\nLe schéma \\(\\mathcal{A} =\\) {Ville, Rue, Numéro, #Bureau_vote} est en FN3 relativement à Σ = { Ville, Nom, Rue → #Bureau_vote,  #Bureau_vote  →  Ville }\nMais ce schéma n’est pas en FNBC."
  },
  {
    "objectID": "slides/DF_norm_3.html#pourquoi-deux-notions-de-forme-normale",
    "href": "slides/DF_norm_3.html#pourquoi-deux-notions-de-forme-normale",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Pourquoi deux notions de forme normale ?",
    "text": "Pourquoi deux notions de forme normale ?\n\n\n\n\n\n\nProposition\n\n\nSi un schéma \\(\\mathcal{A}\\) est en forme normale Boyce-Codd (FNBC) relativement à un ensemble de DF Σ, alors \\(\\mathcal{A}\\) est en forme normale 3 (FN3) relativement à Σ\n\n\n\n\n\nLa réciproque est fausse"
  },
  {
    "objectID": "slides/DF_norm_3.html#exercice",
    "href": "slides/DF_norm_3.html#exercice",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Exercice",
    "text": "Exercice\n\\(\\mathcal{A}=\\) (A, B, C, D, E) et Σ={A → C, BC → D, AD → E}\n\nQuelles sont les clés ?\nLe schéma est-il en FN3 ?"
  },
  {
    "objectID": "slides/DF_norm_3.html#intérêt-de-la-forme-normale-3-fn3",
    "href": "slides/DF_norm_3.html#intérêt-de-la-forme-normale-3-fn3",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Intérêt de la forme normale 3 (FN3)",
    "text": "Intérêt de la forme normale 3 (FN3)\nRedondance limitée\n\nPossibilité de décomposition SPI et sans perte de Dépendances Fonctionnelles"
  },
  {
    "objectID": "slides/DF_norm_3.html#algorithme-1",
    "href": "slides/DF_norm_3.html#algorithme-1",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Algorithme",
    "text": "Algorithme\n\n\n\\begin{algorithm} \\caption{Décomposition FNBC} \\begin{algorithmic} \\Procedure{DecompositionFNBC}{$\\mathcal{A}, Σ$} \\State \\Comment{Initialisation de la décomposition} \\State $D ← \\{\\mathcal{A}\\}$ \\State \\While{$\\exists \\mathcal{B} \\in D$ not in BCNF w.r.t. $\\Sigma \\models X → X^+ \\cap \\mathcal{B}$, $X \\subsetneq \\mathcal{B}$} \\State $Y \\leftarrow X^+ \\cap \\mathcal{B} \\setminus X\\qquad$ \\Comment{DF non triviale! $Y \\neq \\emptyset$} \\State $D \\leftarrow D \\setminus \\{\\mathcal{B}\\} \\cup \\{ X \\cup Y, \\mathcal{B} \\setminus Y \\}$ \\EndWhile \\State \\Return $D$ \\EndProcedure \\end{algorithmic} \\end{algorithm}"
  },
  {
    "objectID": "slides/DF_norm_3.html#preuves",
    "href": "slides/DF_norm_3.html#preuves",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Preuves",
    "text": "Preuves\nTerminaison \n\nFN3 \n\nSPI \n\nSPDF"
  },
  {
    "objectID": "slides/LDD_1.html#problème",
    "href": "slides/LDD_1.html#problème",
    "title": "BD : Contraintes",
    "section": "Problème",
    "text": "Problème\n\nLa définition d’un schéma de base ne s’arrête pas à la définition des tables, des colonnes et des types des colonnes\n\n\n\nLes contraintes décrivent des propriétés que devront vérifier toutes les mises en oeuvre (instances) du schéma durant toute sa durée de vie\n\n\n Pour spécifier une contrainte, il suffit de préciser que le résultat d’une certaine requête doit toujours être vide"
  },
  {
    "objectID": "slides/LDD_1.html#famille-de-contraintes",
    "href": "slides/LDD_1.html#famille-de-contraintes",
    "title": "BD : Contraintes",
    "section": "Famille de contraintes",
    "text": "Famille de contraintes\n\n\nContraintes d’attribut\n\nContrainte de type\n\nContrainte de non-nullité\n\n\n\n\n\n\n\nContraintes de tupe\n\nContrainte de vérification"
  },
  {
    "objectID": "slides/LDD_1.html#contrainte-de-type",
    "href": "slides/LDD_1.html#contrainte-de-type",
    "title": "BD : Contraintes",
    "section": "Contrainte de type",
    "text": "Contrainte de type\nUne contrainte de type spécifie le type/domaine d’une colonne\nLes contrainte de type sont les plus simples à mettre en oeuvre.\n\nAu delà des types de base varchar, integer, ... PostgreSQL propose des types sophistiqués pour :\n\n\ndates,\n\nles estampilles avec ou sans fuseau horaire,\ndes types intervalles (rangetype),\n\ndes types énumérés,\n\ndes types tableaux,\netc"
  },
  {
    "objectID": "slides/LDD_1.html#consulter-la-liste-des-types",
    "href": "slides/LDD_1.html#consulter-la-liste-des-types",
    "title": "BD : Contraintes",
    "section": "Consulter la liste des types",
    "text": "Consulter la liste des types\nhttps://docs.postgresql.fr/docs/current/datatype.html\n\n\n\n\n\n\nConseil\n\n\nIl faut essayer d’utiliser autant que possible ces types pour préciser les contenus des colonnes\nCela permet de contraindre les contenus\nCela permet d’utiliser une foule de fonctions de manipulation très pratiques, notamment pour l’arithmétique du temps\n\n\n\n\n\n\n\n\n\n\nMise en garde\n\n\nLes types disponibles diffèrent d’un SGBD à l’autre (Mysql, Postgres, Oracle, SQL Server, …)"
  },
  {
    "objectID": "slides/LDD_1.html#contraintes-de-tuple",
    "href": "slides/LDD_1.html#contraintes-de-tuple",
    "title": "BD : Contraintes",
    "section": "Contraintes de tuple",
    "text": "Contraintes de tuple\nUne contrainte de tuple peut être vérifiée tuple par tuple (ligne par ligne)\n\nLors d’une insertion ou d’une modification de tuple, il suffit de vérifier que la contrainte est respectée par le nouveau tuple"
  },
  {
    "objectID": "slides/LDD_1.html#exemple",
    "href": "slides/LDD_1.html#exemple",
    "title": "BD : Contraintes",
    "section": "Exemple",
    "text": "Exemple\nDans un tuple de Piece, on devrait toujours avoir une valeur du prix positive.\nOn peut imposer cela en ajoutant au schéma de la table Piece une contrainte de type CHECK\n\nCREATE TABLE piece(\n    nomp VARCHAR(20),\n    prix MONEY CHECK (prix&gt;= 0::money), \n    couleur VARCHAR(15)\n);\n\n\n\n\n\n\n\n\nNote\n\n\nHave a look at PostGres Monetary type"
  },
  {
    "objectID": "slides/LDD_1.html#exemple-world.country",
    "href": "slides/LDD_1.html#exemple-world.country",
    "title": "BD : Contraintes",
    "section": "Exemple world.country\n",
    "text": "Exemple world.country\n\nDans un tuple de country, les colonnes numériques ne devraient pas prendre de valeur négative\n\n\nCREATE TABLE world.country (\n    countrycode BPCHAR(3) NOT NULL,\n    name_country TEXT NOT NULL,\n    continent TEXT NOT NULL,\n    region TEXT NOT NULL,\n    surfacearea FLOAT4 CHECK (surfacearea&gt;= 0) NOT NULL, \n    indepyear INT2 NULL,\n    population_country INT4 NOT NULL,\n    lifeexpectancy FLOAT4 CHECK (lifeexpectancy&gt;= 0) NULL, \n    gnp NUMERIC(10, 2) NULL,    \n    gnpold NUMERIC(10, 2) NULL,  \n    localname TEXT NOT NULL,\n    governmentform TEXT NOT NULL,\n    headofstate TEXT NULL,\n    capital INT4 NULL,\n    code2 BPCHAR(2) NOT NULL,\n    CONSTRAINT country_continent_check CHECK (\n        ((continent = 'Asia'::text) OR (continent = 'Europe'::text) OR \n         (continent = 'North America'::text) OR (continent = 'Africa'::text) OR \n         (continent = 'Oceania'::text) OR (continent = 'Antarctica'::text) OR \n         (continent = 'South America'::text))),\n    CONSTRAINT country_pkey PRIMARY KEY (countrycode)\n);"
  },
  {
    "objectID": "slides/LDD_1.html#contrainte-de-vérification---exemple-suite",
    "href": "slides/LDD_1.html#contrainte-de-vérification---exemple-suite",
    "title": "BD : Contraintes",
    "section": "Contrainte de vérification - Exemple (suite)",
    "text": "Contrainte de vérification - Exemple (suite)\n\nCREATE TABLE piece(\n    nomp VARCHAR(20),\n    prix moNey CHECK (prix&gt;= 0::money),  \n    prix_promo MONEY CHECK (prix_promo &gt;= 0::MONEY), \n    couleur VARCHAR(15),\n    CHECK(prix &gt; prix_promo) \n); \n\n\nINSERT INTO piece \n  VALUES\n  ('x21', 1.51, 1.61,'rouge');\nERROR:  new row for relation \"piece\" violates check constraint piece_check \n\n\nINSERT INTO piece VALUES('x21', 1.51, null,'rouge');\nest accepté"
  },
  {
    "objectID": "slides/LDD_1.html#valeurs-nulles-et-contraintes-de-tuple",
    "href": "slides/LDD_1.html#valeurs-nulles-et-contraintes-de-tuple",
    "title": "BD : Contraintes",
    "section": "\n Valeurs nulles et contraintes de tuple",
    "text": "Valeurs nulles et contraintes de tuple\nLes contraintes CHECK sont satisfaites si l’expression associée vaut TRUE ou UNKNOWN\n\nComme une expression composée vaut parfois UNKNOWN si l’un des opérandes vaut lui-même NULL, les contraintes CHECK ne suffisent pas à prévenir l’insertion de valeurs nulles\n\n\n\n\n\n\n\n\nAstuce\n\n\nIl faut compléter les contraintes de tuple avec des contraintes de non-nullité"
  },
  {
    "objectID": "slides/LDD_1.html#pourquoi-imposer-quune-colonne-soit-toujours-renseignée",
    "href": "slides/LDD_1.html#pourquoi-imposer-quune-colonne-soit-toujours-renseignée",
    "title": "BD : Contraintes",
    "section": "Pourquoi imposer qu’une colonne soit toujours renseignée ?",
    "text": "Pourquoi imposer qu’une colonne soit toujours renseignée ?\n\n\n\n\n\n\nImportant\n\n\nLa présence possible des valeurs nulles rend beaucoup d’opérations complexes\nIl faut avoir en tête que en SQL,\n\non utilise une logique trivalente : TRUE, FALSE et UNKNOWN,\nle fait qu’une expression ne vaille pas FALSE ne veut pas dire qu’elle vaut TRUE …\n\n\n\n\n\nPour imposer qu’une colonne soit renseignée :\n\npréciser après le type : NOT NULL"
  },
  {
    "objectID": "slides/LDD_1.html#contrainte-de-non-nullité-exemple",
    "href": "slides/LDD_1.html#contrainte-de-non-nullité-exemple",
    "title": "BD : Contraintes",
    "section": "Contrainte de non-nullité (Exemple)",
    "text": "Contrainte de non-nullité (Exemple)\n\nCREATE TABLE piece(\n    nomp VARCHAR(20) NOT NULL,\n    prix MONEY CHECK (prix&gt;= 0::MONEY),  \n    prix_promo MONEY CHECK (prix_promo &gt;= 0::MONEY),  \n    couleur VARCHAR(15),\n    CHECK (prix &gt; prix_promo)   \n);"
  },
  {
    "objectID": "slides/LDD_1.html#contrainte-dunicité-1",
    "href": "slides/LDD_1.html#contrainte-dunicité-1",
    "title": "BD : Contraintes",
    "section": "Contrainte d’unicité",
    "text": "Contrainte d’unicité\n\nLes contraintes d’unicité garantissent l’unicité des données contenues dans une colonne ou un groupe de colonnes par rapport à toutes les lignes de la table\nC’est une contrainte de table puisqu’elle fait intervenir tous les tuples de la table"
  },
  {
    "objectID": "slides/LDD_1.html#exemple-de-contrainte-dunicité",
    "href": "slides/LDD_1.html#exemple-de-contrainte-dunicité",
    "title": "BD : Contraintes",
    "section": "Exemple de contrainte d’unicité",
    "text": "Exemple de contrainte d’unicité\n\nCREATE TABLE piece(\n    nomp VARCHAR(20) NOT NULL UNIQUE,  \n    prix money CHECK (prix&gt;= 0::money),\n    prix_promo MONEY CHECK (prix_promo &gt;= 0::MONEY),\n    couleur VARCHAR(15),\n    CHECK (prix &gt; prix_promo)\n);"
  },
  {
    "objectID": "slides/LDD_1.html#contrainte-dunicité-2",
    "href": "slides/LDD_1.html#contrainte-dunicité-2",
    "title": "BD : Contraintes",
    "section": "Contrainte d’unicité",
    "text": "Contrainte d’unicité\n\n\n\n\n\n\nNote\n\n\nLa contrainte d’unicité peut porter sur un groupe de colonnes\n\n\n\n\nCREATE TABLE fournisseur(\n    nomf VARCHAR(20) NOT NULL,\n    villef VARCHAR(20) NOT NULL,\n    UNIQUE(nomf, villef)  \n);\n\n\n\n Il ne peut pas y avoir deux lignes identiques dans la table fournisseur"
  },
  {
    "objectID": "slides/LDD_1.html#clef-primaire-primary-key",
    "href": "slides/LDD_1.html#clef-primaire-primary-key",
    "title": "BD : Contraintes",
    "section": "Clef primaire : PRIMARY KEY\n",
    "text": "Clef primaire : PRIMARY KEY\n\n\n\n\n\n\n\nDéfinition\n\n\nUne contrainte de type clef primaire indique qu’une colonne, ou un groupe de colonnes, peut être utilisée comme identifiant unique de ligne pour cette table.\n Une table a au plus une clef primaire\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nCeci nécessite que les valeurs soient à la fois uniques et NON NULL.\n\n\n\n\n\nLes définitions de table suivantes acceptent de ce fait les mêmes données :\n\n\nCREATE TABLE fournisseur(\n    nomf VARCHAR(20) NOT NULL,\n    villef VARCHAR(20) NOT NULL,\n    UNIQUE(nomf, villef)  \n);\n\nCREATE TABLE fournisseur(\n    nomf VARCHAR(20),\n    villef VARCHAR(20),\n    PRIMARY KEY (nomf, villef)  \n);"
  },
  {
    "objectID": "slides/LDD_1.html#clef-étrangère-1",
    "href": "slides/LDD_1.html#clef-étrangère-1",
    "title": "BD : Contraintes",
    "section": "Clef étrangère",
    "text": "Clef étrangère\n\nUne contrainte de clef étrangère stipule que les valeurs d’une colonne (ou d’un groupe de colonnes) doivent correspondre aux valeurs qui apparaissent dans les lignes d’une autre table.\nOn dit que cela maintient l’intégrité référentielle entre les deux tables.\n\nSoit les deux tables suivantes :\n\n\nCREATE TABLE fournisseur(\n    idf INT PRIMARY KEY,\n    nomf VARCHAR(20),\n    villef VARCHAR(20)\n);\n\nCREATE TABLE piece(\n    nomp VARCHAR(20) PRIMARY KEY,\n    prix MONEY CHECK (prix&gt;= 0::MONEY),\n    prix_promo MONEY CHECK (prix_promo &gt;= 0::MONEY),\n    couleur VARCHAR(15),\n    CHECK (prix &gt; prix_promo)\n);"
  },
  {
    "objectID": "slides/LDD_1.html#clef-étrangère-references",
    "href": "slides/LDD_1.html#clef-étrangère-references",
    "title": "BD : Contraintes",
    "section": "Clef étrangère : REFERENCES",
    "text": "Clef étrangère : REFERENCES\nSupposons également une table livraison qui stocke les livraisons de ces pièces.\nIl est important de s’assurer que la table livraison ne contient que des références de pièces et de fournisseurs qui existent dans la base.\nPour cela, deux contraintes de clef étrangère sont émises par la table des livraisons :\n\nUne contrainte référentielle vers la table piece.\nUne contrainte référentielle vers la table fournisseur.\n\n\nCREATE TABLE livraison(\n    numliv INT PRIMARY KEY,\n    idf INT REFERENCES fournisseur,   \n    nomp VARCHAR(20) REFERENCES piece,  \n    dateLiv DATE DEFAULT NOW(),\n    quantite INT DEFAULT 1 CHECK (quantite&gt;=0)\n);"
  },
  {
    "objectID": "slides/LDD_1.html#définition-de-world.countrylanguage",
    "href": "slides/LDD_1.html#définition-de-world.countrylanguage",
    "title": "BD : Contraintes",
    "section": "Définition de world.countrylanguage\n",
    "text": "Définition de world.countrylanguage\n\n+-------------+--------------+-------------+\n| Column      | Type         | Modifiers   |\n|-------------+--------------+-------------|\n| countrycode | character(3) |  not null   |\n| language    | text         |  not null   |\n| isofficial  | boolean      |  not null   |\n| percentage  | real         |  not null   |\n+-------------+--------------+-------------+\nIndexes:\n    \"countrylanguage_pkey\" PRIMARY KEY, btree (countrycode, language)"
  },
  {
    "objectID": "slides/LDD_1.html#définition-de-world.country",
    "href": "slides/LDD_1.html#définition-de-world.country",
    "title": "BD : Contraintes",
    "section": "Définition de world.country\n",
    "text": "Définition de world.country\n\n\n\n+--------------------+---------------+-------------+\n| Column             | Type          | Modifiers   |\n|--------------------+---------------+-------------|\n| countrycode        | character(3)  |  not null   |\n| name_country       | text          |  not null   |\n| continent          | text          |  not null   |\n| region             | text          |  not null   |\n| surfacearea        | real          |  not null   |\n| indepyear          | smallint      |             |\n| population_country | integer       |  not null   |\n| lifeexpectancy     | real          |             |\n| gnp                | numeric(10,2) |             |\n| gnpold             | numeric(10,2) |             |\n| localname          | text          |  not null   |\n| governmentform     | text          |  not null   |\n| headofstate        | text          |             |\n| capital            | integer       |             |\n| code2              | character(2)  |  not null   |\n+--------------------+---------------+-------------+\n\nIndexes:\n    \"country_pkey\" PRIMARY KEY, btree (countrycode)\nCheck constraints:\n    \"country_continent_check\" CHECK\n    (continent = 'Asia'::text OR \n      continent = 'Europe'::text OR \n      continent = 'North America'::text OR \n      continent = 'Africa'::text OR \n      continent = 'Oceania'::text OR \n      continent = 'Antarctica'::text OR \n      continent = 'South America'::text)\nForeign-key constraints:\n    \"country_capital_fkey\" \n        FOREIGN KEY (capital) \n        REFERENCES world.city(id)  \nReferenced by:\n    TABLE \"world.countrylanguage\"\n    CONSTRAINT \"countrylanguage_countrycode_fkey\" \n        FOREIGN KEY (countrycode)\n        REFERENCES country(countrycode)"
  },
  {
    "objectID": "slides/LDD_1.html#foreign-keys-emitted-by-world.country",
    "href": "slides/LDD_1.html#foreign-keys-emitted-by-world.country",
    "title": "BD : Contraintes",
    "section": "Foreign keys emitted by world.country\n",
    "text": "Foreign keys emitted by world.country\n\nALTER TABLE world.country ADD \n    CONSTRAINT country_capital_fkey \n        FOREIGN KEY (capital)  \n        REFERENCES world.city(id);"
  },
  {
    "objectID": "slides/Modelisation_1.html#pourquoi",
    "href": "slides/Modelisation_1.html#pourquoi",
    "title": "Modélisation I : Entité/Association",
    "section": "Pourquoi ?",
    "text": "Pourquoi ?\nPour construire/concevoir des bases de données utiles, il n’est pas facile d’utiliser immédiatement le Langage de Définition de Données (partie de SQL)\n\nIl est plus raisonnable de s’appuyer sur\n\n\n\nUn formalisme pour décrire les informations à intégrer dans une base\nUn formalisme pour décrire les liens entre ses informations\nUn formalisme lisible par les humains\nUn formalisme traduisible dans un Langage de Définition de Données, c’est-à-dire dans un langage où tout doit se décrire à l’aide de tables et de contraintes"
  },
  {
    "objectID": "slides/Modelisation_1.html#comment",
    "href": "slides/Modelisation_1.html#comment",
    "title": "Modélisation I : Entité/Association",
    "section": "Comment ?",
    "text": "Comment ?\nDepuis les temps originels des Bases de Données, on a multiplié les formalismes, les méthodes de conception\nLes différents formalismes sont presque toujours des variations autour du modèle dit Entité-Association proposé par Chen en 1976"
  },
  {
    "objectID": "slides/Modelisation_1.html#modèle-entité-association-eaer",
    "href": "slides/Modelisation_1.html#modèle-entité-association-eaer",
    "title": "Modélisation I : Entité/Association",
    "section": "Modèle Entité-Association (EA/ER)",
    "text": "Modèle Entité-Association (EA/ER)\nPeter Chen, the father of ER modeling écrivait dans le texte fondateur:\n\nThe entity-relationship model adopts the more natural view that the real world consists of entities and relationships. It incorporates some of the important semantic information about the real world.\n\nDans l’article de 1976, Chen distingue explicitement les diagrammes entité–associations des techniques de modélisation par record:\n\nThe data structure diagram is a representation of the organization of records and is not an exact representation of entities and relationships.\n\n\n\nVoir La Sémantique selon wikipedia"
  },
  {
    "objectID": "slides/Modelisation_1.html#entités-1",
    "href": "slides/Modelisation_1.html#entités-1",
    "title": "Modélisation I : Entité/Association",
    "section": "Entités",
    "text": "Entités\n\n\n\n\n\n\nDéfinition\n\n\nDans la modélisation EA, on repère d’abord les ensembles d’objets (concrets ou abstraits) répondant à un même prototype, c’est-à-dire ayant des propriétés communes. Ils sont nommés entités.\n\nentité (Modèle EA) \\(\\longleftrightarrow\\) ensemble (théorie des ensembles).\ninstance (Modèle EA) \\(\\longleftrightarrow\\) élément (théorie des ensembles).\n\n\n\n\n\n\n\n\n\n\nReprésentation\n\n\nDans les diagrammes EA, les entités sont représentées par des rectangles. Le nom de l’entité est inscrit au centre du rectangle."
  },
  {
    "objectID": "slides/Modelisation_1.html#exemple-dentités-world",
    "href": "slides/Modelisation_1.html#exemple-dentités-world",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemple d’entités : world",
    "text": "Exemple d’entités : world\nPour la constitution de la base de données de géographie politique world, la modélisation choisirait les entités :\n\ncountry: les pays/territoires\ncity: les villes de population urbaine supérieure à un seuil donné lors de la constitution de la base\nlanguage: les langues parlées lors de la constitution de la base"
  },
  {
    "objectID": "slides/Modelisation_1.html#exemple-dentités-nycflights",
    "href": "slides/Modelisation_1.html#exemple-dentités-nycflights",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemple d’entités (nycflights)",
    "text": "Exemple d’entités (nycflights)\nPour la modélisation du traffic aérien civil aux États-Unis, on peut considérer les entités suivantes\n\nairports: les aéroports (civils, sur le sol des États-Unis)\nairlines: les compagnies aériennes\nplanes : les avions (aéronefs)"
  },
  {
    "objectID": "slides/Modelisation_1.html#les-noms-dentités",
    "href": "slides/Modelisation_1.html#les-noms-dentités",
    "title": "Modélisation I : Entité/Association",
    "section": "Les noms d’entités",
    "text": "Les noms d’entités\nLes entités sont généralement associées à des noms (substantifs). Une entité est en effet une collection d’objets apparentés (avec des propriétés communes).\n\n\n\n\n\n\nNote\n\n\nTout ensemble d’objets n’est pas nécessairement considéré comme une entité.\nC’est la décision de l’équipe de modélisation qui constitue les entités."
  },
  {
    "objectID": "slides/Modelisation_1.html#instances-et-entités",
    "href": "slides/Modelisation_1.html#instances-et-entités",
    "title": "Modélisation I : Entité/Association",
    "section": "Instances et Entités",
    "text": "Instances et Entités\n\n\n\n\n\n\nDéfinition\n\n\nUne instance ou occurence est un élément d’une entité.\n\n\n\n\nDans word, le pays Luxemburg est une instance de country.\nLes instances d’une entité sont discernables (pas d’éléments dupliqués).\n\n\n\n\n\n\nNote\n\n\nLe jargon de la modélisation EA renomme des notions déjà présentes dans la théorie des ensembles utilisée en Mathématiques."
  },
  {
    "objectID": "slides/Modelisation_1.html#attributs",
    "href": "slides/Modelisation_1.html#attributs",
    "title": "Modélisation I : Entité/Association",
    "section": "Attributs",
    "text": "Attributs\n\n\n\n\n\n\nDéfinition\n\n\nAprès avoir choisi les entités, on recherche les propriétés qui les caractérisent. Elles sont nommées attributs.\n\nattribut (Modèle EA) \\(\\longleftrightarrow\\) fonction qui envoie une entité dans un domaine (ensemble de valeurs, type)\n\n\n\n\n\nDans world, l’attribut name envoie country vers l’ensemble des chaînes de caractères. Dans l’égalité name(Luxemburg) = \"Luxemburg\", à gauche Luxemburg désigne le pays, à droite, \"Luxemburg\" est une chaîne de caractères.\nL’attribut population envoie country vers les entiers (positifs).\n\n\n\n\n\n\n\n\nReprésentation\n\n\nDans les diagrammes EA, on peut utiliser deux styles de représentation :\n\nstyle 1 : les attributs sont représentés par des ellipses avec le nom de l’attribut à l’intérieur. Une arête relie l’ellipse attribut au rectangle entité.\nstyle 2 : les attributs sont représentés comme une liste dans le rectangle de l’entité, sous un trait horizontal."
  },
  {
    "objectID": "slides/Modelisation_1.html#attributs-représentation-style-1",
    "href": "slides/Modelisation_1.html#attributs-représentation-style-1",
    "title": "Modélisation I : Entité/Association",
    "section": "Attributs (représentation style 1)",
    "text": "Attributs (représentation style 1)\n\n\n\n\n\n\nER\n\n\n\ncountry\n\ncountry\n\n\n\ncity\n\ncity\n\n\n\nname1\n\nname\n\n\n\ncity--name1\n\n\n\n\nlanguage\n\nlanguage\n\n\n\nname2\n\nname\n\n\n\nlanguage--name2\n\n\n\n\nname0\n\nname\n\n\n\nname0--country\n\n\n\n\npopulation\n\npopulation\n\n\n\npopulation--country\n\n\n\n\ngovernmentForm\n\ngovernmentForm\n\n\n\ngovernmentForm--country\n\n\n\n\nheadOfState\n\nheadOfState\n\n\n\nheadOfState--country"
  },
  {
    "objectID": "slides/Modelisation_1.html#attributs-représentation-style-2",
    "href": "slides/Modelisation_1.html#attributs-représentation-style-2",
    "title": "Modélisation I : Entité/Association",
    "section": "Attributs (représentation style 2)",
    "text": "Attributs (représentation style 2)"
  },
  {
    "objectID": "slides/Modelisation_1.html#identifiant",
    "href": "slides/Modelisation_1.html#identifiant",
    "title": "Modélisation I : Entité/Association",
    "section": "Identifiant",
    "text": "Identifiant\n\n\n\n\n\n\nDéfinition\n\n\nPour une entité, un identifiant est un attribut qui identifie de manière unique chaque instance.\n\nidentifiant (Modèle EA) \\(\\longleftrightarrow\\) fonction injective qui envoie une entité dans un domaine (ensemble de valeurs, type).\n\n\n\n\n\n\n\n\n\n\nRègle\n\n\nIl faut définir ou créer un identifiant pour chaque entité.\n\n\n\n\n\n\n\n\n\nReprésentation\n\n\nDans un schéma EA, on représente un identifiant comme un attribut dont on souligne le nom.\nDans le style 2, on le souligne et on le place en tête de liste.\nL’identifiant d’une entité n’est pas le nom de l’entité (contrairement à la terminologie des langages de programmation)."
  },
  {
    "objectID": "slides/Modelisation_1.html#identifiant-exemple",
    "href": "slides/Modelisation_1.html#identifiant-exemple",
    "title": "Modélisation I : Entité/Association",
    "section": "Identifiant (exemple)",
    "text": "Identifiant (exemple)\nLa norme ISO-3166 associe à chaque pays un code en deux lettres (alpha-2). Pour le Luxemburg, il s’agit de LU\nLa norme ISO-3166 associe à chaque pays un code en trois lettres (alpha-3). Pour le Luxemburg, il s’agit de LUX"
  },
  {
    "objectID": "slides/Modelisation_1.html#identifiant-représentation-style-2",
    "href": "slides/Modelisation_1.html#identifiant-représentation-style-2",
    "title": "Modélisation I : Entité/Association",
    "section": "Identifiant (représentation style 2)",
    "text": "Identifiant (représentation style 2)\n\n\n\n\n\n\nNote\n\n\nOn distingue les identifiants en les soulignant et en les plaçant en tête."
  },
  {
    "objectID": "slides/Modelisation_1.html#attributs-dassociation",
    "href": "slides/Modelisation_1.html#attributs-dassociation",
    "title": "Modélisation I : Entité/Association",
    "section": "Attributs d’association",
    "text": "Attributs d’association\nUne association peut posséder des attributs qui sont des fonctions de l’association vers un domaine/type.\n\n\n\n\n\n\nExemple\n\n\nDans world, l’association is-spoken-in peut être munie\n\nd’un attribut official qui précise si une langue donnée est officielle dans un territoire donné,\nd’un attribut percentage qui précise le poucentage de la population qui parle cette langue dans un territoire donné."
  },
  {
    "objectID": "slides/Modelisation_1.html#représentation-graphique",
    "href": "slides/Modelisation_1.html#représentation-graphique",
    "title": "Modélisation I : Entité/Association",
    "section": "Représentation graphique",
    "text": "Représentation graphique\nDans un diagramme EA, deux styles de représentation :\n\nstyle 1 : une association est représentée par un losange. Le nom de l’association est inscrit au centre du losange.\nstyle 2 : une association est représentée par un rectangle aux coins nettement arrondis. Le nom de l’association est inscrit en haut, séparé des noms d’attributs par un trait horizontal.\nL’association est reliée aux entités participantes par des arêtes.\n\nLes attributs d’association sont représentés comme les attributs d’entité selon le style choisi.\n\n\n\n\n\n\n\nAvertissement\n\n\nIl n’est pas toujours évident de lire sur le graphique le rôle joué par les différentes entités participantes dans une association. Bien nommer aide."
  },
  {
    "objectID": "slides/Modelisation_1.html#mcd-style-1-du-schéma-world",
    "href": "slides/Modelisation_1.html#mcd-style-1-du-schéma-world",
    "title": "Modélisation I : Entité/Association",
    "section": "MCD style 1 du schéma world",
    "text": "MCD style 1 du schéma world\n\n\n\n\n\n\nER\n\n\n\ncountry\n\ncountry\n\n\n\niso\n\niso3\n\n\n\ncountry--iso\n\n\n\n\ncity\n\ncity\n\n\n\nname1\n\nname\n\n\n\ncity--name1\n\n\n\n\nid\n\nid\n\n\n\ncity--id\n\n\n\n\nis-in\n\nis-in\n\n\n\ncity--is-in\n\n\n\n\nis-capital\n\nis-capital\n\n\n\ncity--is-capital\n\n\n\n\nlanguage\n\nlanguage\n\n\n\nname2\n\nname\n\n\n\nlanguage--name2\n\n\n\n\nisol\n\niso\n\n\n\nlanguage--isol\n\n\n\n\nis-spoken-in\n\nis-spoken-in\n\n\n\nlanguage--is-spoken-in\n\n\n\n\nofficial\n\nofficial\n\n\n\nname0\n\nname\n\n\n\nname0--country\n\n\n\n\npopulation\n\npopulation\n\n\n\npopulation--country\n\n\n\n\ngovernmentForm\n\ngovernmentForm\n\n\n\ngovernmentForm--country\n\n\n\n\nheadOfState\n\nheadOfState\n\n\n\nheadOfState--country\n\n\n\n\nis-in--country\n\n\n\n\nis-spoken-in--country\n\n\n\n\nis-spoken-in--official\n\n\n\n\nis-capital--country"
  },
  {
    "objectID": "slides/Modelisation_1.html#mcd-style-2-du-schéma-world",
    "href": "slides/Modelisation_1.html#mcd-style-2-du-schéma-world",
    "title": "Modélisation I : Entité/Association",
    "section": "MCD style 2 du schéma world",
    "text": "MCD style 2 du schéma world"
  },
  {
    "objectID": "slides/Modelisation_1.html#partipations-multiples-à-une-association",
    "href": "slides/Modelisation_1.html#partipations-multiples-à-une-association",
    "title": "Modélisation I : Entité/Association",
    "section": "Partipations multiples à une association",
    "text": "Partipations multiples à une association\n Une même entité peut participer plusieurs fois à une même association.\nOn distingue ces participations grâce à des rôles qui étiquettent les arêtes qui relient le rectangle entité au losange association."
  },
  {
    "objectID": "slides/Modelisation_1.html#exemples-de-rôle-dans-une-association-réflexive",
    "href": "slides/Modelisation_1.html#exemples-de-rôle-dans-une-association-réflexive",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemples de rôle dans une association réflexive",
    "text": "Exemples de rôle dans une association réflexive\nDans une base de donnée généalogique, on part d’une entité individu. On définit une auto-association est-mère-de qui relie l’entité individu avec elle-même.\n\nCette auto-association n’est pas symétrique: quand on écrit qu’Elizabeth est-mère-de Charles, Elisabeth et Charles ne jouent pas le même rôle.\n\n\nDans une instance \\((x,y)\\) de l’association est-mère-de, \\(x\\) joue le rôle de la mère, \\(y\\) de l’enfant.\n\n\nOn peut rendre compte de ces rôles en marquant les arêtes qui lient l’entité individu à l’association est-mère-de."
  },
  {
    "objectID": "slides/Modelisation_1.html#une-association-darité-supérireure-à-2",
    "href": "slides/Modelisation_1.html#une-association-darité-supérireure-à-2",
    "title": "Modélisation I : Entité/Association",
    "section": "Une association d’arité supérireure à 2",
    "text": "Une association d’arité supérireure à 2\nPour construire un modèle des vols aériens (comme dans nycflights13), on définit des entités airline plane, airport et une association quaternaire flight.\n\nL’association flight est quaternaire: une instance de flight associe un aéroport d’origine à un aéroport de destination (2 arêtes entre airport et flight), elle associe aussi une instance de plane et une instance de airline.\n\n\nOn distingue les deux participations de airport à flight par des rôles."
  },
  {
    "objectID": "slides/Modelisation_1.html#définition-6",
    "href": "slides/Modelisation_1.html#définition-6",
    "title": "Modélisation I : Entité/Association",
    "section": "Définition",
    "text": "Définition\nDans une association entre plusieurs entités, les instances d’une entité peuvent participer a priori à 0, 1, ou un nombre illimité de fois aux instances de l’association.\nPour traduire les associations dans le langage des tables et des contraintes (LDD), il est très utile d’encadrer le plus précisément possible le nombre de participations d’une instance d’une entité aux instances d’une associations.\n\n\n\n\n\n\nDéfinition\n\n\nOn appelle cardinalités de l’association \\(A\\) pour l’entité \\(E\\) le couple \\((n_{min},n_{max})\\) noté \\(n_{min} \\text{:} n_{max}\\) où :\n\n\\(n_{min}\\) = nombre minimal d’instances de \\(A\\) dans lesquelles une instance de \\(E\\) peut être présente.\n\\(n_{max}\\) = nombre maximal d’instances de \\(A\\) dans lesquelles une instance de \\(E\\) peut être présente.\n\nOn évalue en général les cardinalités par 0, 1 ou “plusieurs” noté \\(n\\).\n\n\n\n\n\n\n\n\n\nNote\n\n\nLes cardinalités sont notées sur les arêtes qui relient entités et associations."
  },
  {
    "objectID": "slides/Modelisation_1.html#cas-des-relations-binaires-2-entités",
    "href": "slides/Modelisation_1.html#cas-des-relations-binaires-2-entités",
    "title": "Modélisation I : Entité/Association",
    "section": "Cas des relations binaires (2 entités)",
    "text": "Cas des relations binaires (2 entités)"
  },
  {
    "objectID": "slides/Modelisation_1.html#exemple-11-dans-le-modèle-world",
    "href": "slides/Modelisation_1.html#exemple-11-dans-le-modèle-world",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemple 1:1 dans le modèle world",
    "text": "Exemple 1:1 dans le modèle world\n\nune instance de city apparaît 1 et 1 seule fois dans l’association is-in. On dira que is-in est de cardinalité 1:1 du côté de city. Une ville se situe sur le territoire d’un pays (et d’un seul)."
  },
  {
    "objectID": "slides/Modelisation_1.html#exemples-0n-dans-le-modèle-world",
    "href": "slides/Modelisation_1.html#exemples-0n-dans-le-modèle-world",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemples 0:n dans le modèle world",
    "text": "Exemples 0:n dans le modèle world\n\nune instance de country peut apparaître une nombre arbitraire de fois dans l’association ‘is-in’. On dira que is-in est de cardinalité 0:n du côté de country. Un territoire peut ne comporter aucune ville de population supérieure à un seuil. Il n’y a pas de borne a priori sur le nombre de grandes villes situées sur un territoire.\nune instance de language peut apparaître une nombre arbitraire de fois dans l’association is-spoken-in. On dira que is-spoken-in est de cardinalité 0:n du côté de language.\nune instance de country peut apparaître une nombre arbitraire de fois dans l’association ‘is-spoken-in’. On dira que is-spoken-in est de cardinalité 0:n du côté de country."
  },
  {
    "objectID": "slides/Modelisation_1.html#représentation-graphique-des-cardinalités-world",
    "href": "slides/Modelisation_1.html#représentation-graphique-des-cardinalités-world",
    "title": "Modélisation I : Entité/Association",
    "section": "Représentation graphique des cardinalités (world)",
    "text": "Représentation graphique des cardinalités (world)"
  },
  {
    "objectID": "slides/Modelisation_1.html#représentation-graphique-des-cardinalités-nycflights13",
    "href": "slides/Modelisation_1.html#représentation-graphique-des-cardinalités-nycflights13",
    "title": "Modélisation I : Entité/Association",
    "section": "Représentation graphique des cardinalités (nycflights13)",
    "text": "Représentation graphique des cardinalités (nycflights13)\nLes cardinalités du MCD des vols.\n\n\n\n\n\n\nER\n\n\n\nairport\n\nairport\n\n\n\nflight\n\nflight\n\n\n\nairport--flight\n\norig\n0:n\n\n\n\nplane\n\nplane\n\n\n\nairline\n\nairline\n\n\n\nflight--airport\n\ndest\n0:n\n\n\n\nflight--plane\n\n0:n\n\n\n\nflight--airline\n\n0:n"
  },
  {
    "objectID": "slides/Modelisation_1.html#entités-faibles-1",
    "href": "slides/Modelisation_1.html#entités-faibles-1",
    "title": "Modélisation I : Entité/Association",
    "section": "Entités faibles",
    "text": "Entités faibles\n\n\n\n\n\n\nDéfinition\n\n\nSi les instances d’une entité \\(E\\) ne sont identifiables que par rapport aux instances d’une autre entité \\(F\\), on dit que \\(E\\) est une entité faible associée à l’entité forte \\(F\\).\n\n\n\n\n\n\n\n\n\nIdentifiant d’entité faible\n\n\nL’association faible entre l’entité faible \\(E\\) et l’entité forte de référence est identifiante.\nL’identifiant de l’entité faible \\(E\\) est construit en accord avec l’association faible identifiante par concaténation de l’identifiant de \\(F\\) et d’un identifiant relatif qui distingue les différentes instances de \\(E\\) associées à la même instance de \\(F\\)."
  },
  {
    "objectID": "slides/Modelisation_1.html#associations-faibles",
    "href": "slides/Modelisation_1.html#associations-faibles",
    "title": "Modélisation I : Entité/Association",
    "section": "Associations faibles",
    "text": "Associations faibles\n\n\n\n\n\n\nDéfinition\n\n\nL’association qui lie l’entité faible \\(E\\) à son entité de référence \\(F\\) est dite faible.\nEn effet, les instances de l’association sont déjà donné par l’identifiant de l’entité faible.\n\n\n\n\n\n\n\n\n\nCardinalités des associations faibles\n\n\nUne association faible a pour cardinalités :\n\ndu côté de l’entité faible 1:1, car elle n’existe que par référence à l’entité forte.\ndu côté de l’entité forte, en général 0:n, car elle existe indépendamment de l’entité faible."
  },
  {
    "objectID": "slides/Modelisation_1.html#exemple-1",
    "href": "slides/Modelisation_1.html#exemple-1",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemple",
    "text": "Exemple\nDans le système d’information de l’université Paris-Cité, si on considère les salles et les bâtiments :\n\nBâtiment est une entité forte,\nSalle est une entité faible.\n\nEn effet, les salles sont toujours identifiées en référence au bâtiment dans lesquelles elles se trouvent, par exemple ‘SG 2005’, ‘HaF 13E’.\n\n\n\n\n\n\nChoisir de définir une entité comme faible\n\n\nUne même entité peut être définie comme faible ou non selon les choix du système d’information. La principale question à se poser est : comment est déterminé l’identidiant ? Si il est formé par concaténation à partir de l’identifiant d’une autre entité, on a affaire à une entité faible."
  },
  {
    "objectID": "slides/Modelisation_1.html#diagrammes-pour-les-entités-faibles",
    "href": "slides/Modelisation_1.html#diagrammes-pour-les-entités-faibles",
    "title": "Modélisation I : Entité/Association",
    "section": "Diagrammes pour les entités faibles",
    "text": "Diagrammes pour les entités faibles\nOn distingue les entités et les associations faibles en doublant le trait extérieur.\n\n\n\n\n\n\nER\n\n\n\nBâtiment\n\nBâtiment\n\n\n\nis-in\n\n\nis-in\n\n\n\nBâtiment--is-in\n\n0:n\n\n\n\nSalle\n\n\nSalle\n\n\n\nis-in--Salle\n\n1:1"
  },
  {
    "objectID": "slides/Modelisation_1.html#association-darité-quelconque-en-associations-binaires",
    "href": "slides/Modelisation_1.html#association-darité-quelconque-en-associations-binaires",
    "title": "Modélisation I : Entité/Association",
    "section": "Association d’arité quelconque en associations binaires",
    "text": "Association d’arité quelconque en associations binaires\nPour simplifier la compléxité des calculs à faire par le SGDB, on décompose systématiquement les associations d’arité \\(k \\geqslant 4\\) en une entité faible et \\(k\\) associations binaires.\nC’est possible mais pas indispensable pour les associations ternaires.\n\n\n\n\n\n\nProcédé de décomposition\n\n\nSoit \\(A\\) une association d’arité \\(k\\) qui associe les k entités \\(E_1\\), \\(\\dots\\) , \\(E_k\\)\n\nOn définit une nouvelle entité \\(F\\) qui remplace l’association \\(A\\). On lui donne le nom de l’association.\nOn définit \\(k\\) associations binaires \\(A_k\\) entre \\(F\\) et chacune des entités \\(E_k\\).\n\n\n\n\n\n\n\n\n\n\nCardinalités\n\n\nPour chaque association \\(A_k\\) :\n\nL’entité faible \\(F\\) a une cardinalité 1:1.\nL’entité \\(E_k\\) conserve la cardinalité qu’elle avait pour l’association \\(A\\)."
  },
  {
    "objectID": "slides/Modelisation_1.html#transformation-du-diagramme-des-vols-nycflights",
    "href": "slides/Modelisation_1.html#transformation-du-diagramme-des-vols-nycflights",
    "title": "Modélisation I : Entité/Association",
    "section": "Transformation du diagramme des vols nycflights",
    "text": "Transformation du diagramme des vols nycflights\nOn décompose l’association quaternaire flight en une entité faible flight, et quatre associations faibles dest, orig, operates, uses.\n\n\n\n\n\n\n\nER\n\n\n\nairport\n\nairport\n\n\n\norig\n\n\norig\n\n\n\nairport--orig\n\n0:n\n\n\n\ndest\n\n\ndest\n\n\n\nairport--dest\n\n0:n\n\n\n\nplane\n\nplane\n\n\n\nairline\n\nairline\n\n\n\nflight\n\n\nflight\n\n\n\noperates\n\n\noperates\n\n\n\nflight--operates\n\n1:1\n\n\n\nuses\n\n\nuses\n\n\n\nflight--uses\n\n1:1\n\n\n\norig--flight\n\n1:1\n\n\n\ndest--flight\n\n1:1\n\n\n\noperates--airline\n\n0:n\n\n\n\nuses--plane\n\n0:n"
  },
  {
    "objectID": "slides/Modelisation_1.html#entités-faibles---entités-fortes",
    "href": "slides/Modelisation_1.html#entités-faibles---entités-fortes",
    "title": "Modélisation I : Entité/Association",
    "section": "Entités faibles -> entités fortes",
    "text": "Entités faibles -&gt; entités fortes\nUne entité faible issue de la décomposition d’une association d’arité \\(\\geqslant 3\\) peut être transformée en forte ainsi que les associations créées.\nEn effet, il peut être intéressant d’identifier l’entité faible de manière indépendante."
  },
  {
    "objectID": "slides/Modelisation_1.html#associations-est-un",
    "href": "slides/Modelisation_1.html#associations-est-un",
    "title": "Modélisation I : Entité/Association",
    "section": "Associations est-un",
    "text": "Associations est-un\n\n\n\n\n\n\nDéfinition\n\n\nUne association est-un (is-a) entre une entité \\(E\\) et une entité \\(F\\) indique que toute instance de \\(E\\) est aussi instance de \\(F\\) (autrement dit en langage ensembliste que \\(E \\subseteq F\\)).\nOn dit que \\(E\\) est une spécialisation de \\(F\\) ou que \\(F\\) est une généralisation de \\(E\\).\n\n\n\n\n\n\n\n\n\n\nRemarques\n\n\n\nUne association est-un est binaire,\nUne entité peut participer à plusieurs associations est-un."
  },
  {
    "objectID": "slides/Modelisation_1.html#cardinalités-2",
    "href": "slides/Modelisation_1.html#cardinalités-2",
    "title": "Modélisation I : Entité/Association",
    "section": "Cardinalités",
    "text": "Cardinalités\nPour les associations est-un, il n’est pas nécessaire de préciser les cardinalités car on a la propriété suivante.\n\n\n\n\n\n\nCardinalités des associations est-un\n\n\n\n1:1 du côté de l’entité spécialisée\n0:1 du côté de l’entité générale.\n\nRemarque : si la cardinalité minimale est également 1 du côté de l’entité générale, il y a un problème de conseption : l’existence de deux entités distinctes pose question et il n’y a pas de notion de spécialisation.\n\n\n\n\n\n\n\n\n\nNote\n\n\nL’association est identifiante : une instance de l’entité spécialisée hérite de l’identifiant de l’entité générale."
  },
  {
    "objectID": "slides/Modelisation_1.html#exemple-2",
    "href": "slides/Modelisation_1.html#exemple-2",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemple",
    "text": "Exemple\nDans le système d’information d’une assurance, un assuré peut être une entreprise, peut être un particulier :\n\nEntités : ASSURE, ENTREPRISE, PARTICULIER,\nPropriétés d’un assuré : N°Assuré, Nom, Adresse, type et tél,\nUn particulier a en plus une profession,\nUne entreprise a en plus un N°SIREN et une forme juridique."
  },
  {
    "objectID": "slides/Modelisation_1.html#représentation-graphique-de-la-spécialisation-style-1",
    "href": "slides/Modelisation_1.html#représentation-graphique-de-la-spécialisation-style-1",
    "title": "Modélisation I : Entité/Association",
    "section": "Représentation graphique de la spécialisation (style 1)",
    "text": "Représentation graphique de la spécialisation (style 1)\nDans le style 1, on note graphiquement les associations est-un avec un symbole spécial : un triangle (c.a.d. une demi-association) dont la pointe est du côté de l’entité générale.\n\n\n\n\n\n\nER\n\n\n\nASSURE\n\nASSURE\n\n\n\nN°Assuré\n\n\"N°Assuré\"\n\n\n\nASSURE--N°Assuré\n\n\n\n\nENTREPRISE\n\nENTREPRISE\n\n\n\nis-a-2\n\nest-un\n\n\n\nENTREPRISE--is-a-2\n\n\n\n\nPARTICULIER\n\nPARTICULIER\n\n\n\nis-a-1\n\nest-un\n\n\n\nPARTICULIER--is-a-1\n\n\n\n\nis-a-1--ASSURE\n\n\n\n\nis-a-2--ASSURE\n\n\n\n\nN°SIREN\n\nN°SIREN\n\n\n\nN°SIREN--ENTREPRISE\n\n\n\n\nprofession\n\nprofession\n\n\n\nprofession--PARTICULIER"
  },
  {
    "objectID": "slides/Modelisation_1.html#représentation-de-la-spécialisation-style-2",
    "href": "slides/Modelisation_1.html#représentation-de-la-spécialisation-style-2",
    "title": "Modélisation I : Entité/Association",
    "section": "Représentation de la spécialisation (style 2)",
    "text": "Représentation de la spécialisation (style 2)\nDans le style 2, on relie toutes les spécialisations à un seul symbole, ce qui permet de représenter plus simplement les contraintes de spécialisation (cf. chap. suivant).\n\n\n\n\n\n\nAvertissement\n\n\nCela ne représente plus une association is-a."
  },
  {
    "objectID": "slides/Modelisation_1.html#restructuration-des-spécialisations",
    "href": "slides/Modelisation_1.html#restructuration-des-spécialisations",
    "title": "Modélisation I : Entité/Association",
    "section": "Restructuration des spécialisations",
    "text": "Restructuration des spécialisations\nPour simplifier le MCD (et le futur MLD, donc la base de données)\n\nÉliminer les entités mères (spécialisation totale avec peu d’attributs propres à l’entié mère)\n\nOU\n\nÉliminer les entités filles (entités filles ont peu d’attributs propres, participent à peu d’associations)\n\nOU\n\nSimuler la spécialisation avec une association faible (les entités filles sont vues comme des entités faibles)"
  },
  {
    "objectID": "slides/Modelisation_1.html#compléter-le-schéma",
    "href": "slides/Modelisation_1.html#compléter-le-schéma",
    "title": "Modélisation I : Entité/Association",
    "section": "Compléter le schéma",
    "text": "Compléter le schéma\nLe diagramme E/A à ce stade ne restitue pas toujours intégralement les informations récoltées pendant la phase de définition du système d’information.\nLes contraintes de cardinalité ne sont pas les seules possibles."
  },
  {
    "objectID": "slides/Modelisation_1.html#types-de-contraintes",
    "href": "slides/Modelisation_1.html#types-de-contraintes",
    "title": "Modélisation I : Entité/Association",
    "section": "Types de contraintes",
    "text": "Types de contraintes\n\nContraintes de spécialisation\nContraintes intra-associations\nContraintes inter-associations"
  },
  {
    "objectID": "slides/Modelisation_1.html#contraintes-de-spécialisation",
    "href": "slides/Modelisation_1.html#contraintes-de-spécialisation",
    "title": "Modélisation I : Entité/Association",
    "section": "Contraintes de spécialisation",
    "text": "Contraintes de spécialisation\nLes différentes spécialisations d’une entité peuvent vérifiées :\n\nune contrainte de spécialisation disjointe ou exclusive : une instance appartient à au plus une spécialisation.\nOn note X dans la représentation de la spécialisation.\nune contrainte de spécialisation totale : une instance appartient à au moins une spécialisation.\nOn note T dans la représentation de la spécialisation.\nune contrainte de spécialisation disjointe et totale : une instance appartient à exactement une spécialisation. Les spécialisations forment alors une partition de l’entité mère.\nOn note XT dans la représentation de la spécialisation."
  },
  {
    "objectID": "slides/Modelisation_1.html#exemples-de-contraintes-de-spécialisation",
    "href": "slides/Modelisation_1.html#exemples-de-contraintes-de-spécialisation",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemples de contraintes de spécialisation",
    "text": "Exemples de contraintes de spécialisation\nEn reprenant l’exemple du chapitre précédent, on note \\(E\\) l’ensemble des assurés, \\(E_p\\) l’ensemble des particuliers, \\(E_e\\) l’ensemble des entreprises.\n\nSi \\(E_p \\cap E_e = \\emptyset\\), alors on a une contrainte de spécialisation exclusive. Un assuré ne peut pas être à la fois un particulier et une entreprise mais peut être ni l’un l’autre.\nSi \\(E_p \\cup E_e = E\\), alors on a une contrainte de spécialisation totale.\nUn assuré peut être à la fois un particulier et une entreprise mais ne peut pas être ni l’un l’autre.\nSi \\(E_p \\cup E_e = E\\) et \\(E_p \\cap E_e = \\emptyset\\), alors on a une contrainte de spécialisation exclusive et totale. Un assuré ne peut pas être à la fois un particulier et une entreprise et ne peut pas être ni l’un l’autre."
  },
  {
    "objectID": "slides/Modelisation_1.html#contraintes-intra-association-cif",
    "href": "slides/Modelisation_1.html#contraintes-intra-association-cif",
    "title": "Modélisation I : Entité/Association",
    "section": "Contraintes intra-association : CIF",
    "text": "Contraintes intra-association : CIF\nPour les associations ternaires, les cardinalités ne suffisent pas à définir toutes les contraintes interne à l’association.\n\n\n\n\n\n\nDéfinition\n\n\nSoit \\(A\\) une association ternaire entre des entités \\(E_1\\), \\(E_2\\) et \\(E_3\\), on appelle contrainte d’intégrité fonctionnelle (CIF) de \\(E_2\\) vers \\(E_3\\) par rapport à \\(A\\), la contrainte suivante :\nUne occurence de \\(E_2\\) est associée par \\(A\\) à au plus une occurence de \\(E_3\\)\n\n\n\nAutrement dit, il y a une dépendance fonctionnelle dans l’ensemble des occurences de l’association \\(A\\) entre l’entité \\(E_2\\) et l’entité \\(E_3\\).\n\n\n\n\n\n\nAvertissement\n\n\n\nCette contrainte ne concerne que les cas où la cardinalité maximale du coté de \\(E_2\\) et \\(E_3\\) est \\(n\\).\nElle ne concerne pas les associations binaires car dans ce cas, les cardinalités définissent déjà les CIF."
  },
  {
    "objectID": "slides/Modelisation_1.html#exemple-de-cif",
    "href": "slides/Modelisation_1.html#exemple-de-cif",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemple de CIF",
    "text": "Exemple de CIF\nOn représente le système d’information d’un syndic de copropriété qui imppose la règle suivante :\n\nLes entreprises qui signent un contrat d’entretien pour une copropriété ne peuvent le faire que pour un seul type de travaux."
  },
  {
    "objectID": "slides/Modelisation_1.html#contraintes-inter-association",
    "href": "slides/Modelisation_1.html#contraintes-inter-association",
    "title": "Modélisation I : Entité/Association",
    "section": "Contraintes inter-association",
    "text": "Contraintes inter-association\nExpriment des contraintes entre 2 ou plusieurs associations. On s’intéresse à la participation des occurences d’une entité \\(E\\) aux occurences de plusieurs associations \\(A_1\\), \\(A_2\\), \\(\\dots\\)\nOn note \\(E_1\\), respectivement \\(E_2\\) l’ensemble des instances de \\(E\\) qui participent à l’association \\(A_1\\), respectivement \\(A_2\\).\n\n\n\n\n\n\n\nAvertissement\n\n\nCes contraintes ne concerne que les cas où la cardinalité minimal du côté de \\(E\\) est \\(0\\).\n\n\n\n\n\n\n\n\n\n\n\nAvertissement\n\n\n\nElles doivent intervenir rarement, dans des cas où la modélisation est difficile.\nElles invitent à s’interroger sur la modélisation choisie car elle signifie une forme de redondance qu’il faut tenter d’éviter."
  },
  {
    "objectID": "slides/Modelisation_1.html#exclusivité-de-participation-x",
    "href": "slides/Modelisation_1.html#exclusivité-de-participation-x",
    "title": "Modélisation I : Entité/Association",
    "section": "Exclusivité de participation : X",
    "text": "Exclusivité de participation : X\n\\(E_1 \\cap E_2 = \\emptyset \\quad\\) autrement dit, si une occurence de \\(E\\) participe à une occurence de \\(A_1\\), alors elle ne participe pas à une occurence de \\(A_2\\) et vice-versa.\n\n\n\n\n\n\n\nExemple\n\n\nUn article peut être acheté chez des fournisseurs ou approvisionné par une unité de production de l’entreprise, mais pas à la fois acheté et approvisionné en interne."
  },
  {
    "objectID": "slides/Modelisation_1.html#simultanéité-de-participation-à-plusieurs-associations-s",
    "href": "slides/Modelisation_1.html#simultanéité-de-participation-à-plusieurs-associations-s",
    "title": "Modélisation I : Entité/Association",
    "section": "Simultanéité de participation à plusieurs associations : S",
    "text": "Simultanéité de participation à plusieurs associations : S\n\\(E_1 = E_2 \\quad\\) autrement dit, une occurence de \\(E\\) participe à une occurence de \\(A_1\\) si et seulement si elle participe à une occurence de \\(A_2\\).\n\n\n\n\n\n\n\nExemple\n\n\nUne commande portant sur des articles est obligatoirement passée par un client et réciproquement."
  },
  {
    "objectID": "slides/Modelisation_1.html#totalité-de-participation-t",
    "href": "slides/Modelisation_1.html#totalité-de-participation-t",
    "title": "Modélisation I : Entité/Association",
    "section": "Totalité de participation : T",
    "text": "Totalité de participation : T\n\\(E_1 \\cup E_2 = \\emptyset \\quad\\) autrement dit, si une occurence de \\(E\\) ne participe pas à une occurence de \\(A_1\\), alors elle participe à une occurence de \\(A_2\\).\n\n\n\n\n\n\n\nExemple\n\n\nDans le SI d’une assurance, tout véhicule est présent dans la base parce qu’il est relié soit à un contrat par l’association “couvrir”, soit à un sinistre par l’association “est-impliqué”, soit les deux."
  },
  {
    "objectID": "slides/Modelisation_1.html#exclusivité-et-totalité-de-participation-xt",
    "href": "slides/Modelisation_1.html#exclusivité-et-totalité-de-participation-xt",
    "title": "Modélisation I : Entité/Association",
    "section": "Exclusivité et totalité de participation : XT",
    "text": "Exclusivité et totalité de participation : XT\n\\(E_1 \\cup E_2 = E \\text{ et } E_1 \\cap E_2 = \\emptyset \\quad\\) autrement dit, une occurence de \\(E\\) participe soit à une occurence de \\(A_1\\), soit à une occurence de \\(A_2\\) mais jamais aux deux.\n\n\n\n\n\n\n\nExemple\n\n\nToute commande est soit passée par un client soit provient d’un service."
  },
  {
    "objectID": "slides/Modelisation_1.html#inclusion-i",
    "href": "slides/Modelisation_1.html#inclusion-i",
    "title": "Modélisation I : Entité/Association",
    "section": "Inclusion : I",
    "text": "Inclusion : I\n\\(E_1 \\subseteq E_2 \\quad\\) autrement dit, si une occurence de \\(E\\) participe à une occurence de \\(A_1\\), alors elle participe à une occurence de \\(A_2\\).\n\n\n\n\n\n\n\nExemple\n\n\nUne personne qui effectue un prêt doit avoir souscrit un abonnement."
  },
  {
    "objectID": "slides/Modelisation_1.html#sites-et-livres",
    "href": "slides/Modelisation_1.html#sites-et-livres",
    "title": "Modélisation I : Entité/Association",
    "section": "Sites et Livres",
    "text": "Sites et Livres\n\nGarcia-Molina, H., Ullman, J. D., & Widom, J. (2002). Database systems-the complete book (International Ed.). Prenctice Hall, Upper Saddle River.\nChen, P. P. S. (1976). The entity-relationship model—toward a unified view of data. ACM transactions on database systems (TODS), 1(1), 9-36.\nSilberschatz, A., Korth, H. F., & Sudarshan, S. (2011). Database system concepts."
  },
  {
    "objectID": "slides/SQL_0.html#un-peu-de-formalisation",
    "href": "slides/SQL_0.html#un-peu-de-formalisation",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Un peu de formalisation",
    "text": "Un peu de formalisation\nRappel sur la notion de relation (au sens classique).\n\n\n\n\n\n\nDefinition : Domaine\n\n\nUn ensemble d’éléments.\n\n\n\n\nExemples : entiers \\(\\mathbb{Z}\\), flottants, chaines de caractères \\(\\mathcal{A}^*\\), date, …\nLes types d’un langage de programmation comme C, Java, …"
  },
  {
    "objectID": "slides/SQL_0.html#remarque",
    "href": "slides/SQL_0.html#remarque",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Remarque",
    "text": "Remarque\nUn domaine peut se définir :\n\nen extension (en donnant la liste de toutes les valeurs possibles) ou\nen intention (en donnant une propriété caractéristique)."
  },
  {
    "objectID": "slides/SQL_0.html#produit-cartésien",
    "href": "slides/SQL_0.html#produit-cartésien",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Produit cartésien",
    "text": "Produit cartésien\n\n\n\n\n\n\nDéfinition : Produit cartésien d’ensembles/domaines\n\n\nLe Produit cartésien d’une liste de domaines \\(D_1, D_2, \\dots, D_k\\), noté\n\\[D_1 \\times D_2 \\times \\dots \\times D_k\\]\nest l’ensemble\n\\[\\Bigl\\{(t_1,t_2,\\dots,t_k);\\ t_i\\in D_i \\text{ pour } i=1,\\dots,k\\Bigr\\}\\]\nUn élément \\(t=(t_1,t_2,\\dots,t_k)\\in D_1 \\times D_2 \\times \\dots \\times  D_k\\) est appelé \\(k\\)-uplet."
  },
  {
    "objectID": "slides/SQL_0.html#exemple",
    "href": "slides/SQL_0.html#exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Exemple",
    "text": "Exemple\n\n\nDeux domaines\n\\[D_1=\\left\\{1,2,5\\right\\} \\quad\\text{et}\\quad D_2=\\left\\{2,4\\right\\}\\]\nUn produit cartésien\n\\[D_1 \\times D_2 = \\left\\{(1,2),(1,4),(2,2),(2,4),(5,2),(5,4)\\right\\}\\]\nUne relation\n\\[R =\\left\\{(1,2),(1,4),(5,2),(5,4)\\right\\}\\]\nUne relation est un (sous-) ensemble (d’un produit cartésien)\n\nOn peut représenter \\(R\\) par le tableau :\n\n\n\n\\(X_1\\)\n\\(X_2\\)\n\n\n\n1\n2\n\n\n1\n4\n\n\n5\n2\n\n\n5\n4\n\n\n\n\nChaque ligne de la table correspond à un élément de la relation \\(R\\)"
  },
  {
    "objectID": "slides/SQL_0.html#relations-classiques",
    "href": "slides/SQL_0.html#relations-classiques",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Relations (classiques)",
    "text": "Relations (classiques)\nDans ce cours, toutes les relations ont un nombre fini d’éléments !\n\n\n\n\n\n\nDéfinition : Cardinalité de la relation \\(R\\): \\(|R|\\)\n\n\nOn appelle cardinalité d’une relation \\(R\\), notée \\(|R|\\), le nombre d’éléments de \\(R\\).\n\n\n\n\n\n\n\n\n\n\nDéfinition : Arité de la relation \\(R\\)\n\n\nSoit \\(R\\subset D_1\\times D_2\\times \\cdots \\times D_k\\), l’entier \\(k\\) est appelé arité de \\(R\\).\n\n\n\n\n\nOn parle parfois aussi de degré d’une relation.\n\n\nUne relation binaire est une relation d’arité \\(2\\)"
  },
  {
    "objectID": "slides/SQL_0.html#relations-et-schémas",
    "href": "slides/SQL_0.html#relations-et-schémas",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Relations et schémas",
    "text": "Relations et schémas\n\nUne relation (classique) peut se voir comme une table à deux dimensions :\n\nchaque ligne correspond alors à un \\(k\\)-uplet (si la relation est d’arité \\(k\\)),\nchaque élément d’une colonne est à valeur dans un domaine.\nUn domaine peut apparaître plusieurs fois dans la définition d’une relation."
  },
  {
    "objectID": "slides/SQL_0.html#schéma-dune-relation",
    "href": "slides/SQL_0.html#schéma-dune-relation",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Schéma d’une relation",
    "text": "Schéma d’une relation\n\n\n\n\n\n\nDéfinition : schéma\n\n\nLe Schéma d’une relation \\(R\\) est la donnée des attributs et domaines de la relation.\n\n\n\nLe schéma peut se noter\n\\[R(A_1\\! :\\! D_1,A_2\\! :\\! D_2,\\dots,A_k\\! :\\! D_k)\\]\noù \\(A_i\\) : attribut et \\(D_i\\) : domaine."
  },
  {
    "objectID": "slides/SQL_0.html#exemple-de-schéma-table-bebes-dans-babynames",
    "href": "slides/SQL_0.html#exemple-de-schéma-table-bebes-dans-babynames",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Exemple de schéma : table bebes dans babynames\n",
    "text": "Exemple de schéma : table bebes dans babynames\n\n\n\n\nbd_2023-24&gt; \\d bebes\n+--------+------------------------+-----------+\n| Column | Type                   | Modifiers |\n|--------+------------------------+-----------|\n| sexe   | integer                |           |\n| prenom | character varying(500) |           |\n| annee  | integer                |           |\n| nombre | integer                |           |\n+--------+------------------------+-----------+\nLa relation bebes a donc pour schéma : \\(\\left((\\textsf{sexe}, \\mathbb{Z}), (\\textsf{prenom}, \\texttt{string}), (\\texttt{annee}, \\mathbb{Z}), (\\texttt{nombre}, \\mathbb{Z})\\right)\\)\n\nDonnées INSEE. Une ligne de la table bebes nous informe qu’en France (héxagone?), pendant une annee, le nombre de naissances de sexe sexe, ayant reçu le prénom prenom est donnée par la colonne nombre.\nbd_2023-24&gt; SELECT * \nFROM bebes \nWHERE sexe=1 AND annee=2000 AND prenom='THÉO' ;\n\n+------+--------+-------+--------+\n| sexe | prenom | annee | nombre |\n|------+--------+-------+--------|\n| 1    | THÉO   | 2000  | 7961   |\n+------+--------+-------+--------+\nL’arité de bebes est \\(4\\), sa cardinalité est \\(648 614\\)."
  },
  {
    "objectID": "slides/SQL_0.html#particularité-de-la-définition-orientée-bdd-dune-relation",
    "href": "slides/SQL_0.html#particularité-de-la-définition-orientée-bdd-dune-relation",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Particularité de la définition orientée BDD d’une relation \n",
    "text": "Particularité de la définition orientée BDD d’une relation \n\nEn BD, l’ordre des colonnes n’a pas d’importance car on désigne chaque composante d’un \\(k\\)-uplet par son nom d’attribut et non par sa position/rang."
  },
  {
    "objectID": "slides/SQL_0.html#résumé-informel",
    "href": "slides/SQL_0.html#résumé-informel",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Résumé informel",
    "text": "Résumé informel\n\nRELATION ↔︎ TABLE À DEUX DIMENSIONS\n(NOM DE) COLONNE ↔︎ ATTRIBUT\nEN-TÊTE DU TABLEAU ↔︎ SCHEMA DE LA RELATION\nLIGNE ↔︎ TUPLE\nENSEMBLE DES LIGNES ↔︎ CONTENU DE LA RELATION"
  },
  {
    "objectID": "slides/SQL_0.html#langage-de-manipulation-de-données",
    "href": "slides/SQL_0.html#langage-de-manipulation-de-données",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Langage de manipulation de données",
    "text": "Langage de manipulation de données\nL’algèbre relationnelle est un système de calcul sur des tables.\nElle est formée d’une collection d’opérateurs qui prennent en argument des tables et retournent des tables.\n\n\n\n\n\n\nRemarque :\n\n\nLes opérateurs prennent en général des arguments supplémentaires qui ne sont pas des tables. La notion d’algèbre relationnelle est inspirée par les structures algébriques comme les groupes, les anneaux, les corps où des opérations internes opèrent sur un ensemble (par exemple \\((\\mathbb{R}, +, \\times)\\)), mais elle ne rentre pas exactement dans le cadre.\n\n\n\n\nL’algèbre n’est pas aussi expressive qu’un langage de programmation classique (comme Python). C’est cela qui rend ce modèle de calcul intéressant : il permet de faire des choses pas triviales, mais il est plus facile à utiliser qu’un langage de programmation."
  },
  {
    "objectID": "slides/SQL_0.html#opérateurs-de-base",
    "href": "slides/SQL_0.html#opérateurs-de-base",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Opérateurs de base",
    "text": "Opérateurs de base\n\n\n\n\n\n\nListe des opérateurs\n\n\nL’algèbre relationnelle est d’abord un Langage de Manipulation de Données (LMD).\n\nUnion: \\(\\Large{\\cup}\\)\nIntersection: \\(\\Large{\\cap}\\)\nDifférence: \\(\\Large{\\backslash}\\)\nProjection: \\(\\Large{\\Pi}\\)\nSélection: \\(\\Large{\\sigma}\\)\nProduit cartésien: \\(\\Large{\\times}\\)\nRenommage: \\(\\Large{\\rho}\\)\n\nCes opérateurs s’appliquent à des relations pour produire d’autres relations (le résultat)."
  },
  {
    "objectID": "slides/SQL_0.html#union-cup-et-intersection-cap",
    "href": "slides/SQL_0.html#union-cup-et-intersection-cap",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Union \\(\\cup\\) et intersection \\(\\cap\\)\n",
    "text": "Union \\(\\cup\\) et intersection \\(\\cap\\)\n\n\n\n\n\n\n\nDéfinition\n\n\n\nL’union et l’intersection sont des opérations portant sur deux relations \\(R_1\\) et \\(R_2\\) de même schéma,\n\\(T=R_1\\cup R_2\\) est constituée des tuples appartenant à \\(R_1\\) ou à \\(R_2\\),\n\\(T=R_1\\cap R_2\\) est constituée des tuples appartenant à \\(R_1\\) et à \\(R_2\\).\nLes schémas de \\(R_1\\cup R_2\\), \\(R_1\\cap R_2\\) sont les mêmes que ceux de \\(R_1\\) et \\(R_2\\)."
  },
  {
    "objectID": "slides/SQL_0.html#union-exemple",
    "href": "slides/SQL_0.html#union-exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Union : exemple",
    "text": "Union : exemple\n\n\n\n-- THEO_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n| 1    | THEOPHANE | 1900  | 3      |\n+------+-----------+-------+--------+\n\n-- THEO_2000\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEO      | 2000  | 6      |\n| 1    | THAO      | 2000  | 4      |\n| 1    | THÉO      | 2000  | 7961   |\n| 1    | THÉO-PAUL | 2000  | 3      |\n| 1    | THEODOR   | 2000  | 3      |\n| 1    | THEOPHANE | 2000  | 47     |\n| 1    | THEODORE  | 2000  | 149    |\n| 1    | THEOPHILE | 2000  | 336    |\n| 1    | THEOPHYLE | 2000  | 4      |\n| 1    | THEOS     | 2000  | 3      |\n| 1    | THEOTIM   | 2000  | 4       |\n| 1    | THEOTIME  | 2000  | 73     |\n+------+-----------+-------+--------+\n\nTHEO_1900 ∪ THEO_2000\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEODOR   | 2000  | 3      |\n| 1    | THAO      | 2000  | 4      |\n| 1    | THÉO      | 2000  | 7961   |\n| 1    | THÉO-PAUL | 2000  | 3      |\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEO      | 2000  | 6      |\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n| 1    | THEODORE  | 2000  | 149    |\n| 1    | THEOPHANE | 1900  | 3      |\n| 1    | THEOPHANE | 2000  | 47     |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEOTIME  | 2000  | 73     |\n| 1    | THEOPHILE | 2000  | 336    |\n| 1    | THEOPHYLE | 2000  | 4      |\n| 1    | THEOS     | 2000  | 3      |\n| 1    | THEOTIM   | 2000  | 4      |\n+------+-----------+-------+--------+"
  },
  {
    "objectID": "slides/SQL_0.html#intersection-exemple",
    "href": "slides/SQL_0.html#intersection-exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Intersection : exemple",
    "text": "Intersection : exemple\n\n\n-- THEO_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n| 1    | THEOPHANE | 1900  | 3      |\n+------+-----------+-------+--------+\n\n-- THEOD_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n+------+-----------+-------+--------+\n\nTHEO_1900 ∩ THEOD_1900\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n+------+-----------+-------+--------+\ncar THEOD_1900 ⊂ THEO_1900"
  },
  {
    "objectID": "slides/SQL_0.html#différence",
    "href": "slides/SQL_0.html#différence",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Différence",
    "text": "Différence\n\n\n\n\n\n\nDéfinition\n\n\n\nLa différence de deux relations \\(R_1\\) et \\(R_2\\) (de même schéma) est une relation \\(T\\),\nde même schéma que \\(R_1\\) et \\(R_2\\),\nconstituée des tuples appartenant à \\(R_1\\) et n’appartenant pas à \\(R_2\\).\nOn note \\(T = R_1 - R_2\\) ou \\(T = R_1 \\setminus R_2\\).\n\n\n\n\n\n\n\n\n\n\n\nOpération non commutative !\n\n\n\\(R_1 - R_2\\neq  R_2 - R_1\\) (en général)."
  },
  {
    "objectID": "slides/SQL_0.html#différence-exemple",
    "href": "slides/SQL_0.html#différence-exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Différence : exemple",
    "text": "Différence : exemple\n\n\n-- THEO_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n| 1    | THEOPHANE | 1900  | 3      |\n+------+-----------+-------+--------+\n\n-- THEOD_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n+------+-----------+-------+--------+\n\nTHEO_1900 ∖ THEOD_1900\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEOPHANE | 1900  | 3      |\n+------+-----------+-------+--------+"
  },
  {
    "objectID": "slides/SQL_0.html#produit-cartésien-1",
    "href": "slides/SQL_0.html#produit-cartésien-1",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Produit Cartésien",
    "text": "Produit Cartésien\n\n\n\n\n\n\nDéfinition\n\n\nSoient \\(R_1\\) et \\(R_2\\) dont les schémas \\(R_1(A_1,A_2,...,A_k)\\) et \\(R_2(B_1,B_2,...,B_\\ell)\\) n’ont pas d’attributs communs.\n\nDans le contexte “classique” : \\(R_1 \\times R_2= \\{(e_1,e_2): e_1\\in R_1, e_2\\in R_2\\}\\).\nDans le contexte BDD, \\(R_1 \\times R_2\\) contient tous les tuples formés par concaténation d’un tuple de \\(R_1\\) et d’un tuple de \\(R_2\\).\nLe schéma de \\(R=R_1 \\times R_2\\) est \\(R(A_1,A_2,...,A_k,B_1,B_2,...,B_\\ell)\\) obtenu par concaténation des schémas de \\(R_1\\) et \\(R_2\\).\n\n\nLa condition sur les schémas est indispensable pour que le schéma du résultat n’ait pas deux attributs identiques. On peut contourner ce problème avec un renommage (voir plus loin).\n\n\n\n\n\n\n\n\n\n\nAttention\n\n\nEn algèbre relationnelle, on ne tient pas compte de l’ordre des attributs dans le schéma d’une relation puisque que les attributs ont des noms deux à deux distincts. De ce fait, le produit cartésien est commutatif ( \\(R_1\\times R_2 = R_2\\times R_1\\) ce qui n’est pas vrai classiquement) et associatif."
  },
  {
    "objectID": "slides/SQL_0.html#produit-cartésien-2",
    "href": "slides/SQL_0.html#produit-cartésien-2",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Produit cartésien",
    "text": "Produit cartésien\n\n\n\n\n\n\nDéfinition formelle\n\n\n\\(R=R_1\\times R_2\\) est la relation de schéma \\(R(A_1,A_2,...,A_k,B_1,B_2,...,B_\\ell)\\) vérifiant :\n\nPour tout \\(t\\in R\\), il existe \\(t_1\\in R_1\\), \\(t_2\\in R_2\\) tels que :\n\n\\[t.A_1=t_1.A_1, \\ldots, t.A_k=t_1.A_k,\\quad t.B_1=t_2.B_1, \\ldots, t.B_\\ell=t_2.B_\\ell\\]\n\nRéciproquement, pour tout \\(t_1\\in R_1\\), \\(t_2\\in R_2\\) , il existe \\(t\\in R\\) tels que :\n\n\\[t.A_1=t_1.A_1, \\ldots, t.A_k=t_1.A_k,\\quad \\text{et}\\quad t.B_1=t_2.B_1, \\ldots, t.B_\\ell=t_2.B_\\ell\\quad \\text{et}\\]\n\\[$\\forall t_1 \\in R_1, \\forall t_2 \\in R_2, \\exists t \\in R, \\qquad  t.A_1=t_1.A_1, \\ldots, t.A_k=t_1.A_k,\\quad \\text{et} \\quad t.B_1=t_2.B_1, \\ldots, t.B_\\ell=t_2.B_\\ell \\qquad\\qquad\\qquad\\]"
  },
  {
    "objectID": "slides/SQL_0.html#projection-largepi",
    "href": "slides/SQL_0.html#projection-largepi",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Projection ( \\(\\Large{\\pi}\\) )",
    "text": "Projection ( \\(\\Large{\\pi}\\) )\n\n\n\n\n\n\nDéfinition\n\n\n\nLa projection d’une relation \\(R\\) de schéma \\(R(A_1,\\dots, A_k)\\) sur les attributs \\(A_{i_1}, \\dots, A_{i_p}\\), avec \\(i_1,..., i_p\\in \\{1,...,k\\}\\), est la relation \\(S\\)\n\nde schéma \\(S(A_{i_1}, \\dots,A_{i_p})\\)\n\ndont les tuples sont obtenus par élimination des attributs non mentionnés dans \\(A_{i_1}, \\dots, A_{i_p}\\) (et par élimination des doublons).\nOn note \\(S = \\pi_{A_{i_1}, \\dots, A_{i_p}} (R)\\).\n\n\nDéfinition formelle : \\(s\\in S\\quad  \\iff \\quad \\exists t\\in R, \\forall k\\in\\left\\{1,\\dots,p\\right\\}\\qquad s.A_{i_k}=t.A_{i_k}\\)\n\n\n\n\n\n\n\n\n\n\n\n\nRemarque\n\n\nImplicitement, on a élimination des doublons car une projection peut produire plusieurs fois le même tuple. Or une relation est un ensemble de tuples, et un ensemble ne peut pas contenir plusieurs fois le même élément."
  },
  {
    "objectID": "slides/SQL_0.html#projection-exemple",
    "href": "slides/SQL_0.html#projection-exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Projection : Exemple",
    "text": "Projection : Exemple\nPROJECTION(THEOD_1900, prenom, nombre)\n+-----------+---------+\n| prenom    |  nombre |\n|-----------+---------+\n| THEODORE  |  227    |\n| THEODOSE  |  3      |\n| THEODULE  |  39     |\n+-----------+---------+\nIci, aucune éliminitation de doublons n’a été nécessaire"
  },
  {
    "objectID": "slides/SQL_0.html#sélection-largesigma",
    "href": "slides/SQL_0.html#sélection-largesigma",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Sélection ( \\(\\Large{\\sigma}\\) )",
    "text": "Sélection ( \\(\\Large{\\sigma}\\) )\n\n\n\n\n\n\nDéfinition\n\n\n\n\nLa sélection d’une relation \\(R\\) par une condition \\(C\\) est une relation \\(S\\) :\n\nde même schéma que \\(R\\),\ndont les tuples sont ceux de \\(R\\) qui satisfont la condition \\(C\\).\nOn note \\(S = \\sigma_C (R)\\).\n\n\n\nLa condition \\(C\\) :\n\ns’exprime à l’aide des noms d’attributs de la relation et de constantes (pour les opérandes),\non peut utiliser des opérateurs arithmétiques de comparaison ( \\(=, \\neq, \\leq, \\geq, &lt;, &gt;\\) ) ainsi que des connecteurs logiques ( \\(\\lnot, \\land, \\lor\\) ).\n\n\n\n\n\n\n\n\n\n\n\n\n\nMise en garde\n\n\nOn peut utiliser le terme Restriction à la place de Sélection."
  },
  {
    "objectID": "slides/SQL_0.html#sélection-exemple",
    "href": "slides/SQL_0.html#sélection-exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Sélection : Exemple",
    "text": "Sélection : Exemple\nSELECTION(THEO_1900, ¬ prenom LIKE ‘THEOD%’)\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEOPHANE | 1900  | 3      |\n+------+-----------+-------+--------+"
  },
  {
    "objectID": "slides/SQL_0.html#renommage",
    "href": "slides/SQL_0.html#renommage",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Renommage",
    "text": "Renommage\n\n\n\n\n\n\nDéfinition\n\n\n\nSoit \\(R\\) de schéma \\(R(A_1,\\dots, A_k)\\), le renommage d’un attribut \\(A_i\\), \\(i\\leq k\\), en \\(B\\) est une relation \\(S\\) :\n\nde même contenu (mêmes lignes)\nde schéma \\(S(A_1,...,A_{i-1},B,A_{i+1},..., A_k)\\)\n\nOn le note \\(S=\\rho_{A_i\\mapsto B}(R)\\)"
  },
  {
    "objectID": "slides/SQL_0.html#renommage-exemple",
    "href": "slides/SQL_0.html#renommage-exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Renommage : Exemple",
    "text": "Renommage : Exemple\n-- THEOD_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n+------+-----------+-------+--------+\nρ(THEOD_1900, sexe→sex, prenom→name, annee→year, nombre→count)\n-- THEOD_1900\n\n+------+-----------+-------+--------+\n| sex  | name      | year  | count  |\n|------+-----------+-------+--------|\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n+------+-----------+-------+--------+\nUtilité : le renommage permet d’étendre certains opérateurs à des relations de schémas non-disjoints (c.a.d. ayant des noms d’attributs communs), par exemple le produit cartésien."
  },
  {
    "objectID": "slides/SQL_0.html#algèbre-relationnelle",
    "href": "slides/SQL_0.html#algèbre-relationnelle",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Algèbre relationnelle",
    "text": "Algèbre relationnelle\nPour interroger une BD, on compose les opérateurs :\n\nOpérations ensemblistes classiques : \\(\\cup\\), \\(\\cap\\), \\(\\setminus\\), \\(\\times\\).\nProjection : élimine des colonnes,\nSélection : élimine des lignes."
  },
  {
    "objectID": "slides/SQL_0.html#exemple-1",
    "href": "slides/SQL_0.html#exemple-1",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Exemple",
    "text": "Exemple\nπ(σ(THEO_1900, prenom LIKE ‘THEOD%’), prenom, nombre)\n\nρ(π(σ(THEO_1900, prenom LIKE ‘THEOD%’), prenom, nombre), prenom→name, nombre→count)"
  },
  {
    "objectID": "slides/SQL_0.html#de-la-composition-aux-tuyaux-pipelines",
    "href": "slides/SQL_0.html#de-la-composition-aux-tuyaux-pipelines",
    "title": "BD I: Algèbre Relationnelle",
    "section": "De la composition aux tuyaux (pipelines)",
    "text": "De la composition aux tuyaux (pipelines)\nOn peut rendre la composition de fonctions plus lisible (pour l’humain) en reprenant un mécanisme d’Unix : le pipe (tuyau) |&gt; (notation de )\nPlutôt qu’écrire \\(g(f(x,y), z, t)\\), on convient d’écrire f(x,y) |&gt; g(z, t) voire x |&gt; f(y) |&gt; g(z,t)\nEt pour rendre l’expression encore plus lisible on peut écrire\nx |&gt; \n  f(y) |&gt; \n  g(z,t)"
  },
  {
    "objectID": "slides/SQL_0.html#de-la-composition-aux-tuyaux-suite",
    "href": "slides/SQL_0.html#de-la-composition-aux-tuyaux-suite",
    "title": "BD I: Algèbre Relationnelle",
    "section": "De la composition aux tuyaux (suite)",
    "text": "De la composition aux tuyaux (suite)\nOn peut ainsi réécrire\nρ(π(σ(THEO_1900, prenom LIKE ‘THEOD%’), prenom, nombre), prenom→name, nombre→count)\nen\nTHEO_1900  |&gt;\n  σ(prenom LIKE 'THEOD%') |&gt;\n  π(prenom, nombre) |&gt;\n  ρ(prenom→name, nombre→count)\n\n\nDans le langage  (&gt; 4.x), le pipe s’écrit |&gt;"
  },
  {
    "objectID": "slides/SQL_0.html#les-jointures",
    "href": "slides/SQL_0.html#les-jointures",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Les jointures",
    "text": "Les jointures\nOn va définir des opérations pratiques pour la manipulation de données : les jointures\n\nJointure\nJointure naturelle\n\\(\\theta\\)-jointure et équi-jointure"
  },
  {
    "objectID": "slides/SQL_0.html#jointure",
    "href": "slides/SQL_0.html#jointure",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Jointure",
    "text": "Jointure\n\n\n\n\n\n\nDéfinition\n\n\nConsidérons deux relations \\(R_1\\) et \\(R_2\\) de schémas disjoints.\nLa jointure de \\(R_1\\) et \\(R_2\\) sous la condition \\(C\\) est la relation \\(T\\) :\n\nde schéma la concaténation des schémas de \\(R_1\\) et \\(R_2\\),\nformée des tuples du produit cartésien \\(R_1  \\times R_2\\) qui satisfont la condition \\(C\\),\non note \\(T=R_1\\bowtie_C R_2\\).\n\nRègles de formation de la condition de jointure : comme pour la sélection.\n\n\n\n\n\n\n\n\n\n\nDéfinition formelle\n\n\n\\[R_1 \\bowtie_C R_2 = \\sigma_C(R_1\\times R_2)\\]"
  },
  {
    "objectID": "slides/SQL_0.html#exemple-sur-le-schéma-world",
    "href": "slides/SQL_0.html#exemple-sur-le-schéma-world",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Exemple sur le schéma world\n",
    "text": "Exemple sur le schéma world\n\n\n\n\n\nLier les pays (les lignes de country) à leur capitale, c’est à dire les couples de lignes de country et de city qui satisfont capital = id"
  },
  {
    "objectID": "slides/SQL_0.html#exemple-sur-le-schéma-world-suite",
    "href": "slides/SQL_0.html#exemple-sur-le-schéma-world-suite",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Exemple sur le schéma world (suite)",
    "text": "Exemple sur le schéma world (suite)\nT =  JOINTURE(country, city, country.capital = city.id)\nS =  PROJECTION(T, name_country, name)\n\n+----------------------+------------------+\n| name_country         | name             |\n|----------------------+------------------|\n| Afghanistan          | Kabul            |\n| Netherlands          | Amsterdam        |\n| Netherlands Antilles | Willemstad       |\n| Albania              | Tirana           |\n| Algeria              | Alger            |\n...\n+----------------------+------------------+\n\n\nOn a affiché seulement les cinq premières lignes du résultat."
  },
  {
    "objectID": "slides/SQL_0.html#différentes-variétés-de-jointures",
    "href": "slides/SQL_0.html#différentes-variétés-de-jointures",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Différentes variétés de jointures",
    "text": "Différentes variétés de jointures\nAutour de la jointure ⋈(R, S, C) on a pris l’habitude de distinguer des types de jointure selon la forme de l’expression de jointure (la condition C)\nOn distingue\n\nles équi-jointures,\nles θ-jointures,\nles jointures naturelles.\n\n\n\n\n\n\n\nNote\n\n\nCes distinctions portent sur la condition C. Elles ne sont pas de même nature que les distinctions qui portent sur la manière dont le résultat final est calculé et qui définissent les jointures internes, externes (voir plus loin)."
  },
  {
    "objectID": "slides/SQL_0.html#équi-jointure",
    "href": "slides/SQL_0.html#équi-jointure",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Équi-jointure",
    "text": "Équi-jointure\n\n\n\n\n\n\nDéfinition\n\n\nJointure où la condition est une égalité entre des attributs de types comparables\n\n\n\n\nJOINTURE(country, city, country.capital = city.id)"
  },
  {
    "objectID": "slides/SQL_0.html#thetajointure",
    "href": "slides/SQL_0.html#thetajointure",
    "title": "BD I: Algèbre Relationnelle",
    "section": "\n\\(\\theta\\)–jointure",
    "text": "\\(\\theta\\)–jointure\n\n\n\n\n\n\nDéfinition\n\n\nCondition de jointure entre attributs de types comparables et comportant au moins un opérateur différent de l’égalité, c’est-à-dire dans \\(\\left\\{&lt;,&gt;,\\leq,\\geq, \\neq\\right\\}\\).\n\n\n\n\nJOINTURE(country, city, country.capital = city.id  ∧ city.population &gt; .5 * country.population_country)"
  },
  {
    "objectID": "slides/SQL_0.html#jointure-naturelle",
    "href": "slides/SQL_0.html#jointure-naturelle",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Jointure naturelle",
    "text": "Jointure naturelle\n\n\n\n\n\n\nDéfinition\n\n\nC’est une équi-jointure où la condition portent implicitement sur tous les attributs communs (de même nom) aux schémas des deux relations.\nDans le résultat, les attributs communs n’apparaissent qu’une seule fois  puisque la relation résultat ne peut pas avoir deux attributs de même nom.\nOn note cette opération : \\(R_1 \\bowtie R_2\\).\n\n\n\nOn peut écrire la jointure naturelle comme une équi-jointure sur tous les attributs communs suivie d’une projection pour éliminer les attributs doublons."
  },
  {
    "objectID": "slides/SQL_0.html#jointure-naturelle-formalisation",
    "href": "slides/SQL_0.html#jointure-naturelle-formalisation",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Jointure naturelle (formalisation)",
    "text": "Jointure naturelle (formalisation)\nConsidérons deux relations \\(R_1(A_1,..,A_k,B_1,...,B_h)\\) et \\(R_2(A_1,..,A_k,B_{h+1},...,B_\\ell)\\) de schémas non disjoints avec :\n\n\\(A_1,..., A_k\\) : attributs communs,\n\\(\\{B_1,...,B_h\\}\\cap \\{ B_{h+1},...,B_\\ell \\}=\\emptyset\\),\n\nSoit \\(A'_1, ...., A'_k\\) des noms tels que \\(\\{A_1,..., A_k\\}\\cap \\{ A'_1, ...., A'_k \\}=\\emptyset\\).\nConsidérons la relation \\(S(A_1',..,A_k',B_{h+1},...,B_l)\\) définie par : \\(\\quad S=\\rho_{A_1\\mapsto A_1'}(\\rho_{A_2\\mapsto A_2'}(\\cdots (\\rho_{A_k\\mapsto A_k'}(R_2)\\cdots ))\\)\nLa jointure naturelle sur les relations \\(R_1\\) et \\(R_2\\) est la relation \\(R\\)\n\nde schéma \\(R(A_1,..,A_k,B_1,...,B_h, B_{h+1},...,B_\\ell)\\)\ndéfinie par : \\(\\quad R = \\pi_{A_1,..,A_k,B_1,...,B_h, B_{h+1},...,B_\\ell}(R_1\\bowtie_{C} S)\\quad\\) où \\(C\\) est \\((A_1=A_1') \\wedge (A_2=A'_2) \\wedge \\ldots \\wedge (A_k=A_k')\\)\n\n\n\n En préfixant les noms des attributs par ceux de la relation, la condition \\(C\\) s’écrit alors : \\[(R_1.A_1=R_2.A_1) \\wedge \\ldots \\wedge (R_1.A_k=R_2.A_k)\\]"
  },
  {
    "objectID": "slides/SQL_0.html#exemple-de-jointure-naturelle",
    "href": "slides/SQL_0.html#exemple-de-jointure-naturelle",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Exemple de Jointure naturelle",
    "text": "Exemple de Jointure naturelle\nAfficher la liste des langues parlées en France (schéma world).\n\n\nbd_2023-24&gt; \\d countrylanguage\n+-------------+--------------+-----------+\n| Column      | Type         | Modifiers |\n|-------------+--------------+-----------|\n| countrycode | character(3) |  not null |\n| language    | text         |  not null |\n| isofficial  | boolean      |  not null |\n| percentage  | real         |  not null |\n+-------------+--------------+-----------+\nbd_2023-24&gt; \\d city\n+-------------+--------------+-----------+\n| Column      | Type         | Modifiers |\n|-------------+--------------+-----------|\n| id          | integer      |  not null |\n| name        | text         |  not null |\n| countrycode | character(3) |  not null |\n| district    | text         |  not null |\n| population  | integer      |  not null |\n+-------------+--------------+-----------+\n\nbd_2023-24&gt; \\d country\n+--------------------+---------------+-----------+\n| Column             | Type          | Modifiers |\n|--------------------+---------------+-----------|\n| countrycode        | character(3)  |  not null |\n| name_country       | text          |  not null |\n| continent          | text          |  not null |\n| region             | text          |  not null |\n| surfacearea        | real          |  not null |\n| indepyear          | smallint      |           |\n| population_country | integer       |  not null |\n| lifeexpectancy     | real          |           |\n| gnp                | numeric(10,2) |           |\n| gnpold             | numeric(10,2) |           |\n| localname          | text          |  not null |\n| governmentform     | text          |  not null |\n| headofstate        | text          |           |\n| capital            | integer       |           |\n| code2              | character(2)  |  not null |\n+--------------------+---------------+-----------+"
  },
  {
    "objectID": "slides/SQL_0.html#exemple-de-jointure-naturelle-suite",
    "href": "slides/SQL_0.html#exemple-de-jointure-naturelle-suite",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Exemple de Jointure naturelle (suite)",
    "text": "Exemple de Jointure naturelle (suite)\n\n\nT = JOINTURE(country, countrylanguage)\nS = SELECTION(T, name_country='France')\nR = PROJECTION(S, name_country, language)\n+--------------+------------+\n| name_country | language   |\n|--------------+------------|\n| France       | French     |\n| France       | Arabic     |\n| France       | Portuguese |\n| France       | Italian    |\n| France       | Spanish    |\n| France       | Turkish    |\n+--------------+------------+\n\n\n\n\n\n\n\nNote\n\n\nDu point de la complexité des opérations à faire par le serveur, il vaut mieux faire le plus en amont possible les sélections puis les projections et enfin les jointures qui sont plus coûteuses en temps de calcul.\n\n\n\nOn écrira donc plutôt :\nS = SELECTION(country, name_country='France')\nT = JOINTURE(S, countrylanguage)\nR = PROJECTION(T, name_country, language)"
  },
  {
    "objectID": "slides/SQL_0.html#exemples-de-requêtes",
    "href": "slides/SQL_0.html#exemples-de-requêtes",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Exemples de requêtes",
    "text": "Exemples de requêtes\n\nDéterminer les noms des capitales des pays situés en Asie.\n\n\nS =  SELECTION(country, continent='Asia')\nT =  JOINTURE(S, city, S.capital=city.id)\nR =  PROJECTION(T, name)\nLe début de R est\n+-------------+\n| name        |\n|-------------+\n| Kabul       |\n| Abu Dhabi   |\n| Yerevan     | \n| al-Manama   |"
  },
  {
    "objectID": "slides/SQL_0.html#exemples-de-requêtes-suite",
    "href": "slides/SQL_0.html#exemples-de-requêtes-suite",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Exemples de requêtes (suite)",
    "text": "Exemples de requêtes (suite)\n\nDéterminer les langues parlées dans les pays d’Asie.\n\n\nS = SELECTION(country, continent='Asia')\nT = JOINTURE(R1, countrylanguage)\nR = PROJECTION(R2, language)\nLe début de R est\n+-------------+\n| name        |\n|-------------+\n| Pashto      |\n| Arabic      |\n| Armenian    | \n| Azerbaijani |"
  },
  {
    "objectID": "slides/SQL_0.html#jointure-externe",
    "href": "slides/SQL_0.html#jointure-externe",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Jointure externe",
    "text": "Jointure externe\n\n\n\n\n\n\nPerte d’information dans les jointures internes\n\n\nDans les jointures que nous avons vues, les tuples du produit cartésien ne satisfaisant pas la condition C (non appariés) disparaissent.\nOn appelle ces jointures des jointures internes.\nOn définit aussi des jointures externes qui n’adoptent pas ce comportement.\n\n\n\n\n\n\n\n\n\n\nDéfinition\n\n\nLa jointure externe entre \\(R_1\\) et \\(R_2\\) est une jointure qui produit une relation R3 à laquelle on ajoute les tuples de R1 et de R2 exclus par la jointure, en complétant avec des valeurs nulles pour les attributs de l’autre relation.\nNotation : \\(R_1 {}^+\\!\\bowtie^+ R_2\\)."
  },
  {
    "objectID": "slides/SQL_0.html#jointure-externe-gauche",
    "href": "slides/SQL_0.html#jointure-externe-gauche",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Jointure externe gauche",
    "text": "Jointure externe gauche\n\n\n\n\n\n\nDéfinition\n\n\nLa jointure externe gauche entre R1 et R2 est une jointure externe pour laquelle on ajoute seulement les tuples de R1 (c’est à dire la relation de gauche) ayant été exclus.\nSynonyme : Jointure gauche\nNotation : \\(R_1 {}^+\\!\\bowtie R_2\\)\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n Le + est du côté où on ajoute les tupes manquants."
  },
  {
    "objectID": "slides/SQL_0.html#jointure-externe-droite",
    "href": "slides/SQL_0.html#jointure-externe-droite",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Jointure externe droite",
    "text": "Jointure externe droite\n\n\n\n\n\n\nDéfinition\n\n\nLa jointure externe droite entre R1 et R2 est une jointure externe pour laquelle on ajoute seulement les tuples de R2 (c’est à dire la relation de droite) ayant été exclus.\nSynonyme : Jointure droite\nNotation : \\(R_1 \\bowtie^+ R_2\\)\n\n\n\n\n\n\n\n\n\nNote\n\n\nUne jointure externe droite peut être réécrite par une jointure externe gauche (et réciproquement) en échangeant l’ordre de R1 et R2.\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nOn peut aussi utiliser une notation fonctionnelle et nommer ces jointures par des mots par exemple OUTER JOIN, LEFT JOIN, RIGHT JOIN."
  },
  {
    "objectID": "slides/SQL_0.html#jointure-externe-exemple",
    "href": "slides/SQL_0.html#jointure-externe-exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Jointure externe (exemple)",
    "text": "Jointure externe (exemple)\nOn veut une table formée par les codes ISO, les noms des pays et (si possible) les noms des capitales. Les territoires sans capitale doivent apparaître en fin de table, avec une colonne nom de capitale nulle.\n\nObtenir la première partie de la réponse avec une jointure est facile. Pour trouver les territoires sans capitale, il faudrait faire une sélection dans country sur le critère capital IS NULL puis une UNION des deux relations.\n\nAvec une jointure droite, on peut obtenir le résultat en une opération :\n\nS = RIGHT JOIN(city, country, city.id = country.capital) \nR = PROJECTION(S, countrycode, name_country, name)"
  },
  {
    "objectID": "slides/SQL_0.html#division",
    "href": "slides/SQL_0.html#division",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Division",
    "text": "Division\n\n\n\n\n\n\nDéfinition\n\n\nLa division ou quotient\n\nd’une relation \\(R\\) de schéma \\(R(A_1,A_2,\\dots,A_k)\\)\npar une relation \\(S\\) de schéma \\(S(A_{p+1},\\dots ,A_k)\\)\n\nest la relation \\(T\\) de schéma \\(T(A_1, \\dots, A_p)\\) formée des tuples qui, complétés par chaque tuple de \\(S\\), donnent un tuple de \\(R\\).\nAutrement dit\n\\[\\begin{array}{l} t\\in T(A_1,\\dots,A_p)  \\quad \\text{ si et seulement si } \\\\\n\\forall s\\in S(A_{p+1},\\dots ,A_k) \\quad \\exists r\\in R \\quad \\begin{cases}\nt.A_1=r.A_1, \\dots, t.A_p=r.A_p\\\\ s.A_{p+1}=r.A_{p+1},\\dots, s.A_{k}=r.A_{k} \\end{cases} \\end{array}\\]\nOn note : \\(\\quad T = R \\div S\\)"
  },
  {
    "objectID": "slides/SQL_0.html#division-exemple",
    "href": "slides/SQL_0.html#division-exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Division (exemple)",
    "text": "Division (exemple)\nLa division permet de répondre à des questions du type :\n“Donner tous les X qui ont toutes les valeurs existantes d’une propriété Y”.\nExemple : lister les langues parlées sur tous les continents.\n\nJ = JOINTURE(country, countrylanguage)\nCL =  PROJECTION(J, continent, language)\nC = PROJECTION(CL, continent)\n\nCL ÷ C\n\n\nAutre possibilité sans la division\nJ = JOINTURE(country, countrylanguage)\nCL =  PROJECTION(J, continent, language)\n\nC = PROJECTION(CL, continent)\nL = PROJECTION(CL, language)\n--- LPPTC Langues Pas Parlées dans Tous les Continents\nLPPTC = PROJECTION((C × L  ∖  CL ), language)\n\nR = L  ∖  LPPTC"
  },
  {
    "objectID": "slides/SQL_0.html#interdéfinissabilité-des-opérateurs",
    "href": "slides/SQL_0.html#interdéfinissabilité-des-opérateurs",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Interdéfinissabilité des opérateurs",
    "text": "Interdéfinissabilité des opérateurs\n\nL’union, la différence, le produit cartésien, la sélection et la projection et le renommage sont suffisants pour définir tous les opérateurs que l’on a vus.\nMais avoir un panier plus large d’opérateurs simplifie l’écriture des requêtes."
  },
  {
    "objectID": "slides/SQL_0.html#définitions-des-autres-opérateurs-à-partir-de-cet-ensemble-minimal",
    "href": "slides/SQL_0.html#définitions-des-autres-opérateurs-à-partir-de-cet-ensemble-minimal",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Définitions des autres opérateurs à partir de cet ensemble minimal",
    "text": "Définitions des autres opérateurs à partir de cet ensemble minimal\n\n\nPour la jointure : \\(R \\bowtie_C S = \\sigma_C (R \\times S)\\)\n\n\n\n\n\nPour l’intersection : \\(A \\cap B = A \\cup B - ((B - A) \\cup (A - B))\\)\n\n\n\n\n\nPour la division :\n\nsoient \\(R(A_1,A_2,\\dots,A_k)\\) et \\(S(A_{p+1},\\dots ,A_k)\\),\n\\(T= R ÷ S\\quad\\) a pour schéma \\(\\quad T(A_1, \\dots, A_p)\\) et\n\\[T = {\\Pi}(R, A) \\setminus {\\Pi}\\left(\\left(\\left({\\Pi}\\left(R, A\\right) × S\\right) \\setminus R\\right), A\\right)\\]\noù \\(A = (A_1, \\dots, A_p)\\)."
  },
  {
    "objectID": "slides/SQL_0.html#depuis-wikipedia",
    "href": "slides/SQL_0.html#depuis-wikipedia",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Depuis Wikipedia",
    "text": "Depuis Wikipedia\n\nIn the 1960s and 1970s he [Codd] worked out his theories of data arrangement, issuing his paper “A Relational Model of Data for Large Shared Data Banks” in 1970.[ To his disappointment, IBM proved slow to exploit his suggestions until commercial rivals started implementing them.\n\n\nInitially, IBM refused to implement the relational model to preserve revenue from IMS/DB. Codd then showed IBM customers the potential of the implementation of its model, and they in turn pressured IBM. Then IBM included in its Future Systems project a System R subproject – but put in charge of it developers who were not thoroughly familiar with Codd’s ideas, and isolated the team from Codd. As a result, they did not use Codd’s own Alpha language but created a non-relational one, SEQUEL. Even so, SEQUEL was so superior to pre-relational systems that it was copied, in 1979, based on pre-launch papers presented at conferences, by Larry Ellison, of Relational Software Inc, in his Oracle Database, which actually reached market before SQL/DS – because of the then-already proprietary status of the original name, SEQUEL had been renamed SQL.\n\n\nCodd continued to develop and extend his relational model, sometimes in collaboration with Christopher J. Date. One of the normalised forms, the Boyce–Codd normal form, is named after him.\n\n\nCodd’s theorem, a result proven in his seminal work on the relational model, equates the expressive power of relational algebra and relational calculus."
  },
  {
    "objectID": "slides/SQL_2.html#opérateurs-ensemblistes-propriétés-requises",
    "href": "slides/SQL_2.html#opérateurs-ensemblistes-propriétés-requises",
    "title": "BD II: SQL II",
    "section": "Opérateurs ensemblistes: propriétés requises",
    "text": "Opérateurs ensemblistes: propriétés requises\nLe résultat d’une requête SQL est un ensemble de tuples… donc une relation.\nLes opérateurs ensemblistes (\\(\\cap\\), \\(\\cup\\), \\(\\setminus\\)) permettent de combiner les résultats de deux requêtes (ou plus).\n\n\n\n\n\n\nImportant\n\n\nLes requêtes combinées doivent avoir des schémas compatibles :\n\nmême nombre de colonnes,\nmême type de données pour les colonnes de même position."
  },
  {
    "objectID": "slides/SQL_2.html#intersect-union-except",
    "href": "slides/SQL_2.html#intersect-union-except",
    "title": "BD II: SQL II",
    "section": "INTERSECT, UNION, EXCEPT",
    "text": "INTERSECT, UNION, EXCEPT\n\nINTERSECT : tuples de l’intersection des résultats des requêtes.\n&lt;requete1&gt; \nINTERSECT \n&lt;requete2&gt;\nUNION : tuples de l’union des résultats des requêtes.\n&lt;requete1&gt; \nUNION \n&lt;requete2&gt;\nEXCEPT : tuples de la différence ensembliste des résultats des requêtes\n&lt;requete1&gt; \nEXCEPT \n&lt;requete2&gt;\n\n\n\n\n\n\n\n\nNote\n\n\nUNION ne conserve pas les tuples doublons entre les deux requêtes.\nPour les conserver, il faut utiliser l’opérateur UNION ALL."
  },
  {
    "objectID": "slides/SQL_2.html#exemple-pour-except",
    "href": "slides/SQL_2.html#exemple-pour-except",
    "title": "BD II: SQL II",
    "section": "Exemple pour EXCEPT",
    "text": "Exemple pour EXCEPT\nConsidérons les tables de schémas suivants :\n`Fournisseur (NomF : varchar, VilleF : varchar, AdresseF : varchar)` \n\n`Piece(NomP : varchar, Prix : money, Couleur : varchar)`\n\n`Livraison(NumLiv : integer, NomP : varchar, NomF : varchar, DateLiv : date, Quantite : numeric)`\nFournisseurs qui ont livré la pièce x22 mais pas la pièce x21\n\nSELECT NomF \nFROM Livraison \nWHERE NomP='x22'\n\nEXCEPT \n\nSELECT NomF\nFROM Livraison \nWHERE NomP='x21';"
  },
  {
    "objectID": "slides/SQL_2.html#sous-requête-dans-la-clause-where",
    "href": "slides/SQL_2.html#sous-requête-dans-la-clause-where",
    "title": "BD II: SQL II",
    "section": "Sous-requête dans la clause WHERE",
    "text": "Sous-requête dans la clause WHERE\n\nDans la clause WHERE d’une requête, on peut utiliser une autre requête, appelée sous-requête ou requête imbriquée.\nLa sous-requête est exécutée pour chaque tuple formé par la clause FROM. Ce tuple sera sélectionné en fonction du test effectué sur le résultat de la sous-requête.\nDans une sous-requête, on peut se référer aux tables nommées dans la clause FROM de la requête de niveau supérieur."
  },
  {
    "objectID": "slides/SQL_2.html#opérateurs-de-sous-requête",
    "href": "slides/SQL_2.html#opérateurs-de-sous-requête",
    "title": "BD II: SQL II",
    "section": "Opérateurs de sous-requête",
    "text": "Opérateurs de sous-requête\n\nIN, EXISTS, ALL, ANY sont des fonctions (ou opérations) qui prennent en argument une sous-requête.\nElles effectuent des tests sur l’ensemble des résultats d’une sous-requête.\n\n\n\n\n\n\n\nMise en garde\n\n\nAttention au comportement de chaque opérateur si le résultat de la sous-requête est vide ou s’il contient la valeur NULL : il faut appliquer la logique trivalente à l’évaluation de l’opérateur."
  },
  {
    "objectID": "slides/SQL_2.html#opérateur-in",
    "href": "slides/SQL_2.html#opérateur-in",
    "title": "BD II: SQL II",
    "section": "Opérateur IN",
    "text": "Opérateur IN\nL’opérateur IN permet de tester si une valeur est présente dans le résultat d’une sous-requête.\n&lt;attribut&gt; [NOT] IN (&lt;sous-requete&gt;)\nEvaluée à vraie si &lt;attribut&gt; appartient au résultat de la sous-requête.\n\n\n\n\n\n\nMise en garde\n\n\nSi le résultat de la sous-requête est vide, IN renvoie faux, NOT IN renvoie vrai.\nSi &lt;attribut&gt; vaut NULL, IN et NOT IN renvoient UNKNOWN.\nL’évaluation de IN s’effectue par un OU entre des tests \\(=\\). Pour les valeurs NULL du résultat de la sous-requête, le test d’égalité retourne UNKNOWN. Donc si &lt;attribut&gt; est présent dans le résultat, IN retourne True sinon UNKNOWN.\nL’évaluation de NOTIN s’effectue par un ET entre des tests \\(\\neq\\). Donc si le résultat de la sous-requête contient au moins une valeur NULL, NOT IN retourne UNKNOWN."
  },
  {
    "objectID": "slides/SQL_2.html#exemple-1-de-sous-requête-avec-in",
    "href": "slides/SQL_2.html#exemple-1-de-sous-requête-avec-in",
    "title": "BD II: SQL II",
    "section": "Exemple 1 de sous-requête avec IN",
    "text": "Exemple 1 de sous-requête avec IN\nLister les villes de fournisseurs qui ont livré la pièce ‘x21’.\n\n\n\nSELECT DISTINCT VilleF \n\nFROM Fournisseur \n\nWHERE NomF IN ( \n  SELECT NomF  \n  FROM Livraison \n  WHERE NomP = 'x21'\n) ;  \n\nest équivalente à :\nSELECT DISTINCT F.VilleF \n\nFROM Fournisseur F, Livraison L \n\nWHERE (F.NomF = L.NomF) AND \n  (L.NomP = 'x21');"
  },
  {
    "objectID": "slides/SQL_2.html#exemple-2-de-sous-requête-avec-in",
    "href": "slides/SQL_2.html#exemple-2-de-sous-requête-avec-in",
    "title": "BD II: SQL II",
    "section": "Exemple 2 de sous-requête avec IN",
    "text": "Exemple 2 de sous-requête avec IN\n\n\n\n\n\n\n\nNote\n\n\nPratique à utiliser sous la forme NOT IN pour coder l’opération de différence.\n\n\n\nLister les noms de pièces pour lesquelles il n’y a jamais eu de livraison.\n\nSELECT NomP\nFROM Piece P \nWHERE NomP NOT IN  (\n  SELECT NomP\n  FROM  Livraison\n);\n\n\nEquivalence en algèbre relationnelle :\n\\[\\pi_{\\text{NomP}}(\\text{Piece}) - \\pi_{\\text{NomP}}(\\text{Livraison})\\]"
  },
  {
    "objectID": "slides/SQL_2.html#exemple-3-de-sous-requête-avec-in",
    "href": "slides/SQL_2.html#exemple-3-de-sous-requête-avec-in",
    "title": "BD II: SQL II",
    "section": "Exemple 3 de sous-requête avec IN",
    "text": "Exemple 3 de sous-requête avec IN\nLes capitales dont la population est plus grande que la moitié de la population du pays.\n\nSELECT name FROM city\nWHERE id IN (\n  SELECT capital \n  FROM country\n  WHERE population&gt;=population_country*.5\n);\n\n\nest équivalente à :\nSELECT name \nFROM country JOIN city \n  ON capital=id\nWHERE population&gt;=population_country*.5;"
  },
  {
    "objectID": "slides/SQL_2.html#opérateur-all-et-any-any-all",
    "href": "slides/SQL_2.html#opérateur-all-et-any-any-all",
    "title": "BD II: SQL II",
    "section": "Opérateur ALL et ANY : ANY, ALL",
    "text": "Opérateur ALL et ANY : ANY, ALL\nCe sont des quantificateurs qui s’utilisent dans des tests.\n\nANY : évalué à vrai si au moins un résultat de la sous-requête vérifie le test.\n\n&lt;attributs&gt; =|&lt;&gt;|&lt;=|&lt;|&gt;|=&gt; ANY (&lt;sous-requete&gt;)\n\n\nALL : évalué à vraie si tous les résultats de la sous-requête vérifient le test.\n\n&lt;attributs&gt; =|&lt;&gt;|&lt;=|&lt;|&gt;|=&gt; ALL (&lt;sous-requete&gt;)\n\n\n\n\n\n\n\n\nNote\n\n\n&lt;attributs&gt;: peut être une liste d’attributs"
  },
  {
    "objectID": "slides/SQL_2.html#exemple-de-sous-requête-avec-any",
    "href": "slides/SQL_2.html#exemple-de-sous-requête-avec-any",
    "title": "BD II: SQL II",
    "section": "Exemple de sous-requête avec ANY",
    "text": "Exemple de sous-requête avec ANY\nAlternative au IN.\nLister les noms de fournisseurs qui ont livré la pièce ‘x21’.\nSELECT NomF\nFROM Fournisseur\nWHERE NomF = ANY (\n    SELECT NomF\n    FROM Livraison\n    WHERE NomP = 'x21' \n);\n\n\n\n\n\n\nMise en garde\n\n\nSi le résultat de la sous-requête est vide, ANY renvoie False.\nSi l’attribut NomF vaut NULL, le résultat de la comparaison avec ANY est UNKNOWN.\nL’évaluation de ANY s’effectue par un OU entre des tests =|&lt;&gt;|&lt;=|&lt;|&gt;|=&gt;. Pour les valeurs NULL du résultat de la sous-requête, le test retourne UNKNOWN. Donc si le test est vrai pour un tuple du résultat, ANY retourne True sinon UNKNOWN."
  },
  {
    "objectID": "slides/SQL_2.html#exemple-1-de-sous-requête-avec-all",
    "href": "slides/SQL_2.html#exemple-1-de-sous-requête-avec-all",
    "title": "BD II: SQL II",
    "section": "Exemple 1 de sous-requête avec ALL",
    "text": "Exemple 1 de sous-requête avec ALL\nLa ville la plus peuplée de chaque pays.\nSELECT c1.name \nFROM city as c1\nWHERE population &gt;= ALL (\n  SELECT c2.population \n  FROM city as c2\n  WHERE c1.countrycode=c2.countrycode\n);\n\n\n\n\n\n\nMise en garde\n\n\nSi le résultat de la sous-requête est vide, ALL renvoie True.\nSi l’attribut population vaut NULL, le résultat de la comparaison avec ALL est UNKNOWN.\nL’évaluation de ALL s’effectue par un ET entre des tests =|&lt;&gt;|&lt;=|&lt;|&gt;|=&gt;. Pour les valeurs NULL du résultat de la sous-requête, le test retourne UNKNOWN. Donc si le résultat de la sous-requête contient au moins une valeur NULL, ALL retourne UNKNOWN."
  },
  {
    "objectID": "slides/SQL_2.html#exemple-2-de-sous-requête-avec-all",
    "href": "slides/SQL_2.html#exemple-2-de-sous-requête-avec-all",
    "title": "BD II: SQL II",
    "section": "Exemple 2 de sous-requête avec ALL",
    "text": "Exemple 2 de sous-requête avec ALL\nLes pays dont toutes les villes ont plus de 1 000 000 habitants.\nLa requête :\nSELECT co.name_country\nFROM country co\nWHERE 1000000 &lt;= ALL (\n  SELECT ci.population \n  FROM city ci\n  WHERE ci.countrycode=co.countrycode\n)\nrenvoie également les pays qui n’ont pas de ville !\nOn peut corriger en ajoutant un opérateur EXISTS sur la sous-requête.\nMais la meilleure solution est d’utiliser les fonctions d’agrégation que nous verrons plus tard."
  },
  {
    "objectID": "slides/SQL_2.html#opérateur-exists",
    "href": "slides/SQL_2.html#opérateur-exists",
    "title": "BD II: SQL II",
    "section": "Opérateur EXISTS",
    "text": "Opérateur EXISTS\nC’est un quantificateur qui retourne un booléen.\nEXISTS retourne vrai si le résultat de la sous-requête n’est pas vide.\n[NOT] EXISTS (&lt;sous-requete&gt;)\n\n\n\n\n\n\nMise en garde\n\n\nSi le résultat de la sous-requête ne contient que la valeur NULL, EXISTS renvoie vrai car le résultat de la sous-requête contient au moins un tuple."
  },
  {
    "objectID": "slides/SQL_2.html#exemple-1-de-sous-requête-avec-exists",
    "href": "slides/SQL_2.html#exemple-1-de-sous-requête-avec-exists",
    "title": "BD II: SQL II",
    "section": "Exemple 1 de sous-requête avec EXISTS",
    "text": "Exemple 1 de sous-requête avec EXISTS\nPays qui n’ont pas de ville\nSELECT co.name_country\nFROM country co\nWHERE NOT EXISTS(\n  SELECT * \n  FROM city ci\n  WHERE ci.countrycode=co.countrycode\n);\néquivalent à\nSELECT name_country\nFROM country\nEXCEPT\nSELECT name_country\nFROM country natural join city;\n\n\n\n\n\n\nNote\n\n\nNOT EXISTS permet souvent d’écrire une alternative à EXCEPT."
  },
  {
    "objectID": "slides/SQL_2.html#exemple-2-de-sous-requête-avec-exists",
    "href": "slides/SQL_2.html#exemple-2-de-sous-requête-avec-exists",
    "title": "BD II: SQL II",
    "section": "Exemple 2 de sous-requête avec EXISTS",
    "text": "Exemple 2 de sous-requête avec EXISTS\nNom des Fournisseurs ayant livré la pièce x21 mais qui n’ont jamais livré la pièce a22.\nSELECT DISTINCT NomF \nFROM Livraison L1 \nWHERE L1.NomP='x21' AND \n  NOT EXISTS (\n    SELECT * \n    FROM Livraison L2 \n    WHERE L2.NomP='a22' AND L2.NomF=L1.NomF\n  );"
  },
  {
    "objectID": "slides/SQL_2.html#exemple-3-de-sous-requête-avec-exists",
    "href": "slides/SQL_2.html#exemple-3-de-sous-requête-avec-exists",
    "title": "BD II: SQL II",
    "section": "Exemple 3 de sous-requête avec EXISTS",
    "text": "Exemple 3 de sous-requête avec EXISTS\nLes régions qui ont au moins une langue officielle :\nSELECT DISTINCT region \nFROM country AS co\nWHERE EXISTS (\n  SELECT * \n  FROM countrylanguage AS cl\n  WHERE co.countrycode = cl.countrycode  AND cl.isofficial\n);\néquivalent à\nSELECT DISTINCT region \nFROM country AS co join world.countrylanguage as cl \non co.countrycode = cl.countrycode and cl.isofficial;"
  },
  {
    "objectID": "slides/SQL_2.html#sous-requête-scalaire",
    "href": "slides/SQL_2.html#sous-requête-scalaire",
    "title": "BD II: SQL II",
    "section": "Sous-requête scalaire",
    "text": "Sous-requête scalaire\n\nRenvoie un tuple unique avec une colonne unique (un scalaire).\nLe plus souvent écrite avec une fonction d’agrégation (SUM, AVG, COUNT, MAX, MIN, …) que nous étudierons dans la suite du cours.\nUtilisation possible dans une clause WHERE.\n\nExemple : lister les noms de pays dont la densité est inférieure à la densité mondiale.\n\nSELECT name_country , population_country / surfacearea as population_density\nFROM country\nWHERE population_country / surfacearea &lt;= (\n  SELECT sum(population_country) / sum(surfacearea)\n  FROM country\n)\norder by name_country;\n\n\n\n\n\n\nNote\n\n\nNe pas confondre la densité mondiale moyenne (environ \\(40\\ \\text{h/km}^2\\) d’après la BDD world, en fait \\(55\\ \\text{h/km}^2\\) en 2025) avec la densité moyenne des pays (environ \\(400\\ \\text{h/km}^2\\))."
  },
  {
    "objectID": "slides/SQL_2.html#tables-dérivés",
    "href": "slides/SQL_2.html#tables-dérivés",
    "title": "BD II: SQL II",
    "section": "Tables dérivés",
    "text": "Tables dérivés\nDans une clause FROM, on peut écrire une sous-requête qui renvoie une table nommée avec un alias : on parle de table dérivée, dans le sens qu’elle dérive des tables existantes.\n\n\n\n\n\n\nNote\n\n\nIl s’agit d’une composition de requêtes."
  },
  {
    "objectID": "slides/SQL_2.html#exemple-de-sous-requête-dans-la-clause-from",
    "href": "slides/SQL_2.html#exemple-de-sous-requête-dans-la-clause-from",
    "title": "BD II: SQL II",
    "section": "Exemple de sous-requête dans la clause FROM",
    "text": "Exemple de sous-requête dans la clause FROM\nLister les pays (code, nom, espérance de vie) dont le PNB a progressé de 10% et dont la population de la capitale est supérieure à 2 millions.\nSELECT bo.countrycode, name_country, lifeexpectancy\nFROM \n  (\n    SELECT countrycode, name_country, lifeexpectancy, capital\n    FROM country\n    WHERE gnpold &gt;0 AND gnp / gnpold &gt; 1.1  -- test gnpold &gt;0 pour gérer les valeurs nulles\n  ) AS bo \n  JOIN \n  (\n    SELECT id, countrycode\n    FROM city \n    WHERE population &gt; 2000000\n  ) AS bc  \n  ON bc.id=bo.capital ;"
  },
  {
    "objectID": "slides/SQL_2.html#opérateur-lateral",
    "href": "slides/SQL_2.html#opérateur-lateral",
    "title": "BD II: SQL II",
    "section": "Opérateur LATERAL",
    "text": "Opérateur LATERAL\n\n\n\n\n\n\nNote\n\n\nDans l’exemple précédent, chaque table dérivée est calculée indépendemment puis la jointure est effectuée.\n\n\n\nAvec l’opérateur LATERAL, on peut faire dépendre le calcul d’une table dérivée du résultat des tables précédentes du FROM."
  },
  {
    "objectID": "slides/SQL_2.html#evaluation-de-lateral",
    "href": "slides/SQL_2.html#evaluation-de-lateral",
    "title": "BD II: SQL II",
    "section": "Evaluation de LATERAL",
    "text": "Evaluation de LATERAL\nLa table dérivée est calculée pour chaque tuple \\(u\\) obtenu par les opérations précédentes du FROM.\nPuis chaque tuple \\(v\\) la table dérivée est concaténé à \\(u\\) par produit cartésien.\nOn peut aussi concaténer \\(u\\) et \\(v\\) avec une jointure."
  },
  {
    "objectID": "slides/SQL_2.html#exemple-1-avec-lateral",
    "href": "slides/SQL_2.html#exemple-1-avec-lateral",
    "title": "BD II: SQL II",
    "section": "Exemple 1 avec LATERAL",
    "text": "Exemple 1 avec LATERAL\nPour chaque pays, donner la liste des villes de son térritoire.\nSolution avec LATERAL\nSELECT co.name_country, sr.name \nFROM country co, LATERAL (  \n  SELECT name       \n  FROM city  ci            \n  WHERE ci.countrycode=co.countrycode\n) sr;\néquivalent à\n\n\nAvec jointure sur une table dérivée\nSELECT co.name_country, sr.name \nFROM country co NATURAL JOIN (  \n  SELECT countrycode, name       \n  FROM city\n) sr  \n\nou bien sans table dérivée\nSELECT name_country, name \nFROM country co JOIN city ci ON ci.countrycode=co.countrycode\nORDER BY name_country;"
  },
  {
    "objectID": "slides/SQL_2.html#exemple-2-avec-lateral",
    "href": "slides/SQL_2.html#exemple-2-avec-lateral",
    "title": "BD II: SQL II",
    "section": "Exemple 2 avec LATERAL",
    "text": "Exemple 2 avec LATERAL\nPlus intéressant : pour chaque pays, donner la ville la plus peuplée.\nSELECT co.name_country, sr.name \nFROM country co, LATERAL (  \n  SELECT name       \n  FROM city ci            \n  WHERE ci.countrycode=co.countrycode\n  ORDER BY ci.population DESC\n  LIMIT 1\n) sr\nORDER BY co.name_country;\nEvaluation : si la table dérivée est vide, le tuple \\(u\\) de la table country n’est pas retenu car \\(\\lbrace u\\rbrace \\times \\emptyset = \\emptyset\\).\nDonc les pays sans ville ne sont pas affichés."
  },
  {
    "objectID": "slides/SQL_2.html#clause-with",
    "href": "slides/SQL_2.html#clause-with",
    "title": "BD II: SQL II",
    "section": "Clause WITH",
    "text": "Clause WITH\nUne clause WITH permet d’écrire des requêtes intermédiaires et d’alléger l’écriture d’une requête complexe.\nWITH r AS (\n  SELECT ...\n  FROM ...\n  WHERE ...\n), s AS (\n  SELECT ...\n  FROM ...\n  WHERE ...    -- références possibles à r \n)\nSELECT ...\nFROM   ...     -- références possibles à r \nWHERE ...\n\n\n\n\n\n\nNote\n\n\nCes expressions/requêtes sont appelées Common Table Expressions ou CTEs ou ETCs en français.\nLes CTEs peuvent être des requêtes SELECT, mais aussi des expressions de manipulation (mise à jour, insertion, suppression) de données.\nLes CTEs permettent de coller plus fidèlement à l’algèbre relationnelle que les requêtes imbriquées."
  },
  {
    "objectID": "slides/SQL_2.html#avantages-des-ctes",
    "href": "slides/SQL_2.html#avantages-des-ctes",
    "title": "BD II: SQL II",
    "section": "Avantages des CTEs",
    "text": "Avantages des CTEs\n\n\n\n\n\n\nNote\n\n\nLes CTEs permettent de composer des requêtes de même que les requêtes imbriquées dans les clauses WHERE et FROM.\nPar rapport à ces deux autres techniques, les avantages sont :\n\namélioration de la lisibilité et de la maintenance des requêtes complexes.\nune ETC peut être utilisée plusieurs fois dans une même requête."
  },
  {
    "objectID": "slides/SQL_2.html#exemple-de-requête-avec-with",
    "href": "slides/SQL_2.html#exemple-de-requête-avec-with",
    "title": "BD II: SQL II",
    "section": "Exemple de requête avec WITH",
    "text": "Exemple de requête avec WITH\nLister les pays (code, nom, espérance de vie) dont le PNB a progressé de 10% et dont la population de la capitale est supérieure à 2 millions.\nWITH better_off AS (\n  SELECT countrycode, name_country, lifeexpectancy, capital\n  FROM country\n  WHERE gnpold &gt;0 AND gnp / gnpold &gt; 1.1  -- gnpold &gt;0 pour gérer les valeurs nulles\n),\nbig_capital AS (\n  SELECT id, countrycode\n  FROM city \n  WHERE population &gt; 2000000\n)\nSELECT bo.countrycode, name_country, lifeexpectancy\nFROM better_off bo JOIN big_capital bc ON\n  bc.id=bo.capital ;"
  },
  {
    "objectID": "slides/SQL_4.html#pourquoi",
    "href": "slides/SQL_4.html#pourquoi",
    "title": "Fonctions SQL et Vues",
    "section": "Pourquoi ?",
    "text": "Pourquoi ?\nLorsqu’une collection de requêtes de même forme est utilisée sur une base de données, il est pertinent de préparer ces requêtes\nLes objectifs de cette préparation sont divers:\n\néviter de coder de façon répétitive\npermettre une planification en amont des requêtes\néviter de recalculer des jointures coûteuses\n…\n\n\n\nOn cherche à suivre le principe DRY (Don’t Repeat Yourself) plutôt que la routine WET (Write Everything Twice ou We Enjoy Typing)"
  },
  {
    "objectID": "slides/SQL_4.html#comment",
    "href": "slides/SQL_4.html#comment",
    "title": "Fonctions SQL et Vues",
    "section": "Comment ?",
    "text": "Comment ?\nLes SGBD relationnels offrent une gamme d’outils pour combler ces besoins\n\nLes PREPARED STATEMENT\nLes fonctions\nLes vues"
  },
  {
    "objectID": "slides/SQL_4.html#syntaxe-générale-des-fonctions",
    "href": "slides/SQL_4.html#syntaxe-générale-des-fonctions",
    "title": "Fonctions SQL et Vues",
    "section": "Syntaxe générale des fonctions",
    "text": "Syntaxe générale des fonctions\nCREATE OR REPLACE FUNCTION \n  func_name(arg1 arg1_datatype DEFAULT arg1_default)\n\nRETURNS some type | set of some type | TABLE (..) AS\n$$\n\nBODY of function\n\n$$\nLANGUAGE language_of_function\n\n\nlangage_of_function peut prendre différentes valeurs :\n\n\nSQL (Trusted)\n\nPL/pgSQL (Trusted)\nC\n\nPL/Python (Untrusted)\n…\n\n\nSELECT lanname \nFROM pg_language;\nlanname |\n--------+\ninternal|\nc       |\nsql     |\nplpgsql |"
  },
  {
    "objectID": "slides/SQL_4.html#signature-de-la-fonction",
    "href": "slides/SQL_4.html#signature-de-la-fonction",
    "title": "Fonctions SQL et Vues",
    "section": "Signature de la fonction",
    "text": "Signature de la fonction\nCREATE OR REPLACE FUNCTION \n  &lt;func_name&gt;(&lt;arg1&gt; &lt;arg1_datatype&gt; [DEFAULT &lt;arg1_default&gt;])\n\nRETURNS &lt;some type&gt; | SETOF &lt;some type&gt; | TABLE (..)\nLa signature d’une fonction est formée par:\n\nle nom de la fonction &lt;func_name&gt;\n\nla liste des arguments (nom &lt;arg1&gt; et type attendu )\n\nle type du résultat retourné par la fonction"
  },
  {
    "objectID": "slides/SQL_4.html#signature-de-la-fonction-suite",
    "href": "slides/SQL_4.html#signature-de-la-fonction-suite",
    "title": "Fonctions SQL et Vues",
    "section": "Signature de la fonction (suite)",
    "text": "Signature de la fonction (suite)\n\n\n&lt;arg1_datatype&gt;:\n\ntype prédéfini ou non, voir CREATE TYPE ...\n\ntype de colonne d’une table : country.countrycode%TYPE\n\ntype des tuples d’une table : country%ROWTYPE…\n\n\n&lt;arg1_default&gt;: litéral ou expression\n\nType du résultat:\n\ntype prédéfini ou non\n\nSETOF ... (table)\nTABLE (...)\n\n\n\n\n\nChaque schéma de table définit (implicitement) un type"
  },
  {
    "objectID": "slides/SQL_4.html#types-définis-par-lusager",
    "href": "slides/SQL_4.html#types-définis-par-lusager",
    "title": "Fonctions SQL et Vues",
    "section": "Types définis par l’usager",
    "text": "Types définis par l’usager\nCREATE TYPE  type_utilisateur AS (\n  &lt;identifiant&gt; &lt;type défini&gt;\n  [, &lt;identifiant&gt; &lt;type défini&gt;]*\n);\nUsage pour une création de table\nCREATE TABLE &lt;nom de table&gt; OF \n  type_utilisateur\n  (CONSTRAINT &lt;nom de contrainte&gt; PRIMARY KEY  (&lt;nom de colonne&gt;));\nPratique pour créer des tables de même schéma\n\n\n\n\n\n\nNote\n\n\nquand on crée une table, PostgreSQL crée automatiquement un type associé (bis)"
  },
  {
    "objectID": "slides/SQL_4.html#exemple",
    "href": "slides/SQL_4.html#exemple",
    "title": "Fonctions SQL et Vues",
    "section": "Exemple",
    "text": "Exemple\n\nDéfinition d’un type\n\nCREATE TYPE basic_user AS (\n  user_name varchar(50), \n  pwd varchar(10)\n);\n\nUsage du type défini par usager\n\nCREATE TABLE super_users OF basic_user \n  (CONSTRAINT pk_su PRIMARY KEY  (user_name));"
  },
  {
    "objectID": "slides/SQL_4.html#annotations",
    "href": "slides/SQL_4.html#annotations",
    "title": "Fonctions SQL et Vues",
    "section": "Annotations",
    "text": "Annotations\nLes définitions de fonctions comportent parfois des qualifications supplémentaires\n\nVOLATILITY: IMMUTABLE, STABLE, VOLATILE (default)\nSECURITY : SECURITY DEFINER, SECURITY INVOKER"
  },
  {
    "objectID": "slides/SQL_4.html#les-fonctions-écrites-en-langage-sql",
    "href": "slides/SQL_4.html#les-fonctions-écrites-en-langage-sql",
    "title": "Fonctions SQL et Vues",
    "section": "Les fonctions écrites en langage SQL",
    "text": "Les fonctions écrites en langage SQL\nSQL est d’abord un langage permettant d’émettre des requêtes, il peut aussi être utilisé pour écrire des fonctions\nDans PostgreSQL, l’utilisation d’un morceau de SQL existant est facile :\n\nprenez vos instructions SQL existantes (éventuellement plusieurs)\najoutez un en-tête et une conclusion fonctionnels\n\net … vous avez terminé"
  },
  {
    "objectID": "slides/SQL_4.html#les-fonctions-écrites-en-langage-sql-suite",
    "href": "slides/SQL_4.html#les-fonctions-écrites-en-langage-sql-suite",
    "title": "Fonctions SQL et Vues",
    "section": "Les fonctions écrites en langage SQL (suite)",
    "text": "Les fonctions écrites en langage SQL (suite)\nMais cette facilité a un prix \nVous ne pouvez pas :\n\nutiliser des structures de contrôle (boucles, alternatives) ou des définitions de variables locales\nexécuter des instructions SQL dynamiques que vous assemblez à la volée en utilisant les arguments passés dans la fonction\n\n\nMais, tout de même\n\nle planificateur de requêtes peut examiner une fonction SQL et en optimiser l’exécution"
  },
  {
    "objectID": "slides/SQL_4.html#corps-de-la-fonction",
    "href": "slides/SQL_4.html#corps-de-la-fonction",
    "title": "Fonctions SQL et Vues",
    "section": "Corps de la fonction",
    "text": "Corps de la fonction\n La syntaxe du corps de la fonction dépend du language_of_function\nDans le cas où language_of_function est SQL\n$$\n\nBODY of function\n\n$$"
  },
  {
    "objectID": "slides/SQL_4.html#références-aux-argument",
    "href": "slides/SQL_4.html#références-aux-argument",
    "title": "Fonctions SQL et Vues",
    "section": "Références aux argument",
    "text": "Références aux argument\nOn peut faire références aux arguments en les nommant dans le corps de la fonction\nSi les arguments ne sont pas nommés, vous faites référence aux arguments par leur position dans la signature : $1, $2, $3, etc\n Si vous nommez les arguments, vous pouvez utiliser la notation\nbig_elephant(name =&gt; 'Wooly', ear_size =&gt; 1.2)\nlors des appels à la fonction"
  },
  {
    "objectID": "slides/SQL_4.html#exemple-1",
    "href": "slides/SQL_4.html#exemple-1",
    "title": "Fonctions SQL et Vues",
    "section": "Exemple",
    "text": "Exemple\nCREATE OR REPLACE FUNCTION \n  write_to_log(param_user_name varchar,\n               param_description text)\nRETURNS integer AS\n$$\nINSERT INTO logs\n   (user_name, description) \n   VALUES($1, $2)\nRETURNING log_id;\n$$\nLANGUAGE 'sql' VOLATILE;\n\nInvocation\nSELECT write_to_log('alex', \n    'Logged in at 11:59 AM.') AS new_id;"
  },
  {
    "objectID": "slides/SQL_4.html#exemple-de-fonction-retournant-un-type-simple",
    "href": "slides/SQL_4.html#exemple-de-fonction-retournant-un-type-simple",
    "title": "Fonctions SQL et Vues",
    "section": "Exemple de fonction retournant un type simple",
    "text": "Exemple de fonction retournant un type simple\nDans le schéma world, on veut écrire une fonction qui prend en argument une région et renvoie la population maximale parmi les capitales de la région\nCREATE OR REPLACE \n  FUNCTION username.taille_max_capitale_region(p_region text)\n  RETURNS INTEGER \n  LANGUAGE SQL AS\n$$\nSELECT MAX(population) AS max_pop\nFROM world.country c \n  JOIN world.city cc ON (c.capital=cc.id)\nWHERE c.region=p_region AND\n cc.population IS NOT NULL;\n$$ ;"
  },
  {
    "objectID": "slides/SQL_4.html#fonctions-qui-retournent-un-type-composé-défini-par-les-lignes-dune-table",
    "href": "slides/SQL_4.html#fonctions-qui-retournent-un-type-composé-défini-par-les-lignes-dune-table",
    "title": "Fonctions SQL et Vues",
    "section": "Fonctions qui retournent un type composé défini par les lignes d’une table",
    "text": "Fonctions qui retournent un type composé défini par les lignes d’une table\nDans le schéma world, on veut écrire une fonction qui prend en argument une région et renvoie la description de la capitale la plus peuplée de cette région\nOn se contente de nommer la table pour indiquer que le résultat doit avoir même structure qu’une ligne de la table\n  CREATE OR REPLACE FUNCTION username.capitale(p_region text)\n  RETURNS world.city  \n  LANGUAGE SQL AS\n  $$\n  WITH r AS(\n    SELECT cc.*, RANK() OVER (PARTITION BY c.region ORDER BY cc.population DESC) AS rnk\n    FROM world.country c JOIN world.city cc ON (c.capital=cc.id)\n    WHERE c.region=p_region)\n  SELECT r.id, r.name, r.countrycode, r.district, r.population\n  FROM r \n  WHERE r.rnk = 1 ;\n  $$ ;"
  },
  {
    "objectID": "slides/SQL_4.html#fonctions-qui-retournent-une-table",
    "href": "slides/SQL_4.html#fonctions-qui-retournent-une-table",
    "title": "Fonctions SQL et Vues",
    "section": "Fonctions qui retournent une table",
    "text": "Fonctions qui retournent une table\nDans le schéma world, on veut écrire une fonction qui prend en argument une région et renvoie la table des capitales de la région"
  },
  {
    "objectID": "slides/SQL_4.html#table-de-schéma-explicite",
    "href": "slides/SQL_4.html#table-de-schéma-explicite",
    "title": "Fonctions SQL et Vues",
    "section": "Table de schéma explicite",
    "text": "Table de schéma explicite\nOn se contente d’abord de renvoyer le nom de la capitale.\nOn explicite le schéma de la table résultat\nCREATE OR REPLACE FUNCTION username.capitales_region(p_region text)\nRETURNS TABLE (name_capital text) \nLANGUAGE SQL AS\n$$\nSELECT cc.name \nFROM world.country c JOIN world.city cc ON (c.capital=cc.id)\nWHERE c.region=p_region ;\n$$ ;"
  },
  {
    "objectID": "slides/SQL_4.html#table-de-même-schéma-quune-autre-table",
    "href": "slides/SQL_4.html#table-de-même-schéma-quune-autre-table",
    "title": "Fonctions SQL et Vues",
    "section": "Table de même schéma qu’une autre table",
    "text": "Table de même schéma qu’une autre table\nhttps://www.postgresql.org/docs/15/xfunc-sql.html\nOn veut maintenant récupérer une table de même schéma que city.\nLa solution est très simple.\nOn profite de ce qu’à chaque table correspond un type de même nom et on utilise le mot-clé SETOF.\nCREATE OR REPLACE FUNCTION username.capitales_region_large(p_region text)\nRETURNS SETOF world.city  \nLANGUAGE SQL AS\n$$\nSELECT cc.* \nFROM world.country c JOIN world.city cc ON (c.capital=cc.id)\nWHERE c.region=p_region ;\n$$ ;"
  },
  {
    "objectID": "slides/SQL_4.html#autres-langages",
    "href": "slides/SQL_4.html#autres-langages",
    "title": "Fonctions SQL et Vues",
    "section": "Autres langages",
    "text": "Autres langages\n\nPL/pgSQL\nC\nPL/Python\nPL/R\n…"
  },
  {
    "objectID": "slides/SQL_4.html#fonction-reprise-depuis-pagila",
    "href": "slides/SQL_4.html#fonction-reprise-depuis-pagila",
    "title": "Fonctions SQL et Vues",
    "section": "Fonction reprise depuis pagila\n",
    "text": "Fonction reprise depuis pagila\n\nCREATE OR REPLACE FUNCTION user.inventory_held_by_customer(\n    p_inventory_id integer,\n    OUT customer_id int2) AS \n$$\n  SELECT customer_id \n  FROM pagila.rental\n  WHERE return_date IS NULL AND inventory_id = p_inventory_id ;\n$$ LANGUAGE 'sql' ;"
  },
  {
    "objectID": "slides/SQL_4.html#fonctions-de-pagila",
    "href": "slides/SQL_4.html#fonctions-de-pagila",
    "title": "Fonctions SQL et Vues",
    "section": "Fonctions de pagila\n",
    "text": "Fonctions de pagila\n\nCREATE OR REPLACE FUNCTION uname.film_in_stock(\n  p_film_id integer, \n  p_store_id integer, \n  OUT p_film_count integer)\n RETURNS SETOF integer\nAS $$\n     SELECT inventory_id\n     FROM pagila.inventory\n     WHERE film_id = $1\n     AND store_id = $2\n     AND pagila.inventory_in_stock(inventory_id);\n$$ LANGUAGE sql ;"
  },
  {
    "objectID": "slides/SQL_4.html#invocation",
    "href": "slides/SQL_4.html#invocation",
    "title": "Fonctions SQL et Vues",
    "section": "Invocation",
    "text": "Invocation\nSELECT * \nFROM pagila.film_in_stock(12, 1) ;\n\n\np_film_count\n\n\n\n60\n\n\n61\n\n\n62"
  },
  {
    "objectID": "slides/SQL_4.html#section-1",
    "href": "slides/SQL_4.html#section-1",
    "title": "Fonctions SQL et Vues",
    "section": "",
    "text": "Presque tous les SGBD relationnels proposent des vues comme niveau d’abstraction des tables. Dans une vue, vous pouvez interroger plusieurs tables et présenter des colonnes dérivées supplémentaires basées sur des calculs complexes.\n\n\nLes vues sont généralement en lecture seule, mais PostgreSQL vous permet de mettre à jour les données sous-jacentes en mettant à jour la vue, à condition que la vue provienne d’une seule table.\n\n\nPour mettre à jour des données à partir de vues qui joignent plusieurs tables, vous devez créer une gachette contre la vue.\n\n\nLes vues matérialisées mettent en cache les données afin d’accélérer les requêtes les plus courantes, au détriment des données les plus récentes."
  },
  {
    "objectID": "slides/SQL_4.html#motivation",
    "href": "slides/SQL_4.html#motivation",
    "title": "Fonctions SQL et Vues",
    "section": "Motivation",
    "text": "Motivation\n\n\n\n\n\n\nAstuce\n\n\nSi vous vous retrouvez à écrire tous les jours la même requête, créer une vue !\n\n\n\nUne vue n’est rien d’autre qu’une requête stockée de façon persistante"
  },
  {
    "objectID": "slides/SQL_4.html#vues-sur-une-seule-table",
    "href": "slides/SQL_4.html#vues-sur-une-seule-table",
    "title": "Fonctions SQL et Vues",
    "section": "Vues sur une seule table",
    "text": "Vues sur une seule table\nCREATE OR REPLACE VIEW co_asia AS\nSELECT * \nFROM world.country \nWHERE continent = 'Asia' ;"
  },
  {
    "objectID": "slides/SQL_4.html#interroger-une-vue",
    "href": "slides/SQL_4.html#interroger-une-vue",
    "title": "Fonctions SQL et Vues",
    "section": "Interroger une vue",
    "text": "Interroger une vue\nUne vue s’interroge comme une table :\nSELECT region, sum(population_country) AS pop \nFROM co_asia \nGROUP BY region \nORDER BY pop DESC ;\nregion                   |pop       |\n-------------------------+----------+\nEastern Asia             |1507328000|\nSouthern and Central Asia|1490776000|\nSoutheast Asia           | 518541000|\nMiddle East              | 188380700|"
  },
  {
    "objectID": "slides/SQL_4.html#vues-et-manipulation-de-données",
    "href": "slides/SQL_4.html#vues-et-manipulation-de-données",
    "title": "Fonctions SQL et Vues",
    "section": "Vues et manipulation de données",
    "text": "Vues et manipulation de données\nSi\n\nla vue (VIEW) provient d’une table unique\nla vue contient la clé primaire de la table d’origine\n\nAlors\non peut modifier la table au travers de la vue. On peut\n\ninsérer\nsupprimer\nmettre à jour\n\n\n\n\n\n\n\nExemple\n\n\n\nLa vue co_asia provient d’une unique table : world.country\n\nLa vue co_asia contient la clé primaire countrycode de la table world.country"
  },
  {
    "objectID": "slides/SQL_4.html#section-2",
    "href": "slides/SQL_4.html#section-2",
    "title": "Fonctions SQL et Vues",
    "section": "",
    "text": "Cette instruction :\nUPDATE co_asia\n  SET continent='Antarctica';\n… est légale !\n–\nMais, après exécution :\n\nla vue co_asia est vide \nles pays d’Asie de country sont délocalisés en Antarctique"
  },
  {
    "objectID": "slides/SQL_4.html#pour-éviter-ca-with-check-option",
    "href": "slides/SQL_4.html#pour-éviter-ca-with-check-option",
    "title": "Fonctions SQL et Vues",
    "section": "Pour éviter ca : WITH CHECK OPTION\n",
    "text": "Pour éviter ca : WITH CHECK OPTION\n\n\nCREATE OR REPLACE VIEW boucheron.co_asia AS\n  SELECT * \n  FROM world.country \n  WHERE continent = 'Asia' \n\nWITH CHECK OPTION ;\n\nAjouter cette modification lors de la création de la vue et PostgreSQL s’opposera à une tentative d’insertion hors de la vue ou à une tentative de mise à jour qui placerait des tuples hors de la vue"
  },
  {
    "objectID": "slides/SQL_4.html#section-3",
    "href": "slides/SQL_4.html#section-3",
    "title": "Fonctions SQL et Vues",
    "section": "",
    "text": "CREATE OR REPLACE VIEW pagila.actor_info\nAS SELECT a.actor_id,\n    a.first_name,\n    a.last_name,\n    pagila.group_concat(DISTINCT (c.name::text || ': '::text) || \n        (( SELECT pagila.group_concat(f.title::text) AS group_concat\n           FROM pagila.film f\n             JOIN pagila.film_category fc_1 ON f.film_id = fc_1.film_id\n             JOIN pagila.film_actor fa_1 ON f.film_id = fa_1.film_id\n          WHERE fc_1.category_id = c.category_id AND fa_1.actor_id = a.actor_id\n          GROUP BY fa_1.actor_id))\n        ) AS film_info\n   FROM pagila.actor a\n     LEFT JOIN pagila.film_actor fa ON a.actor_id = fa.actor_id\n     LEFT JOIN pagila.film_category fc ON fa.film_id = fc.film_id\n     LEFT JOIN pagila.category c ON fc.category_id = c.category_id\n  GROUP BY a.actor_id, a.first_name, a.last_name;"
  },
  {
    "objectID": "slides/SQL_4.html#vues-multi-tables-exemple-de-vue-sur-world",
    "href": "slides/SQL_4.html#vues-multi-tables-exemple-de-vue-sur-world",
    "title": "Fonctions SQL et Vues",
    "section": "Vues multi-tables : exemple de vue sur world\n",
    "text": "Vues multi-tables : exemple de vue sur world\n\nCREATE OR REPLACE VIEW country_info AS\n\n  SELECT\n    cn.countrycode, \n    cn.name_country, \n    cn.region,\n    string_agg(DISTINCT ci.name::text , ', '::text) AS cities\n\n  FROM world.country cn LEFT JOIN \n       world.city ci \n       ON (cn.countrycode = ci.countrycode)\n\n  GROUP BY cn.countrycode, cn.name_country, cn.region;\nStackoverflow"
  },
  {
    "objectID": "slides/SQL_4.html#insertionmise-à-joursuppression-sur-les-vues-multi-tables",
    "href": "slides/SQL_4.html#insertionmise-à-joursuppression-sur-les-vues-multi-tables",
    "title": "Fonctions SQL et Vues",
    "section": "Insertion/Mise à jour/Suppression sur les vues multi-tables",
    "text": "Insertion/Mise à jour/Suppression sur les vues multi-tables\nProblème : quelles tables doivent être modifiées ?\nDELETE \nFROM boucheron.country_info\nWHERE countrycode = 'FRA' ;\n\nsupprimer les lignes de country ?\nsupprimer les lignes de city ?\n\nDatabase abstraction"
  },
  {
    "objectID": "slides/SQL_4.html#vues-matérialisées",
    "href": "slides/SQL_4.html#vues-matérialisées",
    "title": "Fonctions SQL et Vues",
    "section": "Vues matérialisées",
    "text": "Vues matérialisées\nLes vue matérialisées cachent les données récupérées\nCela se produit\n\nlors de la création de la vue et\nlorsque on exécute REFRESH MATERIALIZED VIEW ..."
  },
  {
    "objectID": "td-listings.html",
    "href": "td-listings.html",
    "title": "Feuilles d’exercices",
    "section": "",
    "text": "Note\n\n\n\nLes feuilles d’exercice forment le matériau de base des TDS et TPS. Vous êtes invités à les lire avant la séance et à réfléchir par vous-même. Les corrections seront disponibles sur Moodle.\n\n\n\n\n   \n    \n    \n      Order By\n      Default\n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Titre\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\n\nTitre\n\n\n\nDescription\n\n\n\n\n\n\n\n\nSep 26, 2025\n\n\nTD 1 : Algèbre relationnelle\n\n\nLogistique et Algèbre relationnelle\n\n\n\n\n\n\nOct 3, 2025\n\n\nTD 2 : SQL\n\n\nSQL Interrogation de données\n\n\n\n\n\n\nOct 10, 2025\n\n\nTD 3 : SQL\n\n\nSQL Interrogation de données, requêtes complexes\n\n\n\n\n\n\nOct 17, 2025\n\n\nTD 4 : SQL\n\n\nAggrégations, Partitions, Fenêtres\n\n\n\n\n\n\nOct 24, 2025\n\n\nTD 5 : SQL\n\n\nFenêtres et fonctions SQL\n\n\n\n\n\n\nNov 7, 2025\n\n\nTD 6 : Contraintes\n\n\nDéfinition de données Contraintes\n\n\n\n\n\n\nNov 14, 2025\n\n\nTD 7 : Modélisation\n\n\nModèle Conceptuel des Données\n\n\n\n\n\n\nNov 21, 2025\n\n\nTD 8 : Modélisation\n\n\nModélisation conceptuelle avancée\n\n\n\n\n\n\nNov 28, 2025\n\n\nTD 9 : Modèle relationnel des données\n\n\nConversion d’un modèle E/A en un modèle relationnel\n\n\n\n\n\n\nDec 5, 2025\n\n\nTD 10 : Normalisation\n\n\nNormalisation, Perte de DF, Perte d’Information, FNBC, FN3\n\n\n\n\n\n\nDec 12, 2025\n\n\nTD 11 : Normalisation et dépendances\n\n\nNormalisation et dépendances\n\n\n\n\n\n\nDec 19, 2025\n\n\nTD Récapitulatif SQL\n\n\nTD révision générale\n\n\n\n\n\n\nNo matching items\n\n\n\n\n\n\n\nTipConseil\n\n\n\nAvant de travailler sur un exercice, assurez vous que vous maîtrisez/comprenez le schéma relationnel concerné.",
    "crumbs": [
      "Exercices"
    ]
  },
  {
    "objectID": "workshops/td8.html",
    "href": "workshops/td8.html",
    "title": "TD 8 : Modélisation",
    "section": "",
    "text": "WarningAvec solutions"
  },
  {
    "objectID": "workshops/td8.html#exercice-supermarché-modèle-miniature",
    "href": "workshops/td8.html#exercice-supermarché-modèle-miniature",
    "title": "TD 8 : Modélisation",
    "section": "Exercice (Supermarché : modèle miniature)",
    "text": "Exercice (Supermarché : modèle miniature)\nOn étudie une partie du SI d’un supermarché concernant la mise en rayon des produits et on a collecté les informations suivantes :\n\nChaque produit a un nom et un prix et appartient à une catégorie.\nLe supermarché a plusieurs rayons, un rayon étant caractérisé par un étage et un numéro de rangée.\nLes produits d’une même catégorie sont placés dans le même rayon, mais un rayon peut contenir des produits de plusieurs catégories.\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nConcevoir un diagramme E/A de ce SI. Vérifier que ce diagramme modélise toutes les informations fournies.\n\n\n\nSolution\nOn distingue les entités :\n\nPRODUIT : nom, prix.\nRAYON : étage, numéro-rangée.\nCATEGORIE.\n\nPuis les associations :\n\nappartient entre PRODUIT et CATEGORIE.\nest-placé entre CATEGORIE et RAYON.\n\nLes cardinalités qui sont bien décrites par l’énoncé :\n\n1:1 pour appartient du côté de PRODUIT.\nmax n pour appartient du côté de CATEGORIE.\nmax 1 pour est-placé du côté de CATEGORIE.\nmax n pour est-placé du côté de RAYON.\n\nLes cardinalités qui ne sont pas décrites par l’énoncé :\n\nmin 0 ou 1 pour appartient du côté de CATEGORIE.\nmin 0 ou 1 pour est-placé du côté de CATEGORIE.\nmin 0 ou 1 pour est-placé du côté de RAYON.\n\nUn MCD possible avec cardinalité est :\n\n\n\n\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nFaut-il compléter le diagramme E/A ?\n\n\n\n\nSolution\nLe MCD proposé traduit complètement les spécifications de l’énoncé."
  },
  {
    "objectID": "workshops/td8.html#exercice-tournois",
    "href": "workshops/td8.html#exercice-tournois",
    "title": "TD 8 : Modélisation",
    "section": "Exercice (Tournois)",
    "text": "Exercice (Tournois)\nLors du dernier TP, vous avez étudié un SI portant sur des tournois.\nLe diagramme E/A proposé est le suivant :\n\n\n\n\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nIl est décidé d’utiliser pour les identifiants des matchs la méthode suivante : pour un tournoi et un type de match (simple F, simple H, etc.) le match n°1 est la finale, les n°2 et 3 sont les demi-finales, etc.\nComment faut-il modifier le modèle ?\n\n\n\nSolution\nIl faut faire les modifications suivantes :\n\nMATCH devient une entité faible,\nappartient est une association faible identifiante entre TOURNOI (entité forte) et MATCH,\nde type est une association faible identifiante entre TYPE (entité forte) et MATCH,\nl’identifiant de MATCH devient : numéro_tournoi+type+numéro_match.\nles cardinalités sont inchangées ainsi que les autres associations auxquelles participent MATCH.\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nY-a-t-il des contraintes d’intégrité fonctionnelle (CIF) ?\nPour rappel, les CIF concernent les liaisons de cardinalité maximale \\(n\\) dans les associations ternaires.\n\nsi parmi les occurences de l’association \\(A\\), on a une dépendance fonctionnelle \\(E_1 \\rightarrow E_2\\), on dit qu’on a une CIF \\(E_1 \\rightarrow E_2\\) par rapport à \\(A\\).\nsi parmi les occurences de l’association \\(A\\), on a une dépendance fonctionnelle \\((E_1, E_2) \\rightarrow E_3\\), on dit qu’on a une CIF \\((E_1,E_2) \\rightarrow E_3\\) par rapport à \\(A\\).\n\nPar exemple, si on supposait qu’un joueur ne peut pas avoir deux entraineurs en même temps (ce qui n’est pas dit dans l’énoncé), on aurait une CIF (JOUEUR, DATE) \\(\\rightarrow\\) ENTRAINEUR par rapport à l’association “est entrainé par”.\nEn reprenant la représentation du cours, on écrit :\n\n\n\n\n\nMais pour les CIF du type \\((E_1, E_2) \\rightarrow E_3\\), le formalisme suivant est lisible :\n\n\n\n\n\nCette CIF dit la chose suivante : deux entraineurs différents ne peuvent pas commencer à entrainer un même joueur à la même date.\nEst-ce que cette CIF suffit à décrire la totalité de la contrainte ? Que faut-il vérifier au-delà ?\n\n\n\n\nSolution\nDans le dernier exemple de la question, la CIF ne suffit à traduire toute la contrainte car il faut vérifier que les périodes pendant lesquelles deux entrainteurs différents entraînent un même joueur sont disjointes, tandis que la CIF impose seulement que les débuts de ces deux périodes sont différents.\nPour le MCD de tournoi, il n’y a pas de CIF à ajouter. On les recherche sur les associations non binaires :\n\nest entrainé par : pas de CIF.\nrecevoir gain : pas de CIF.\nde nationalité : on pourrait imaginer une CIF (JOUEUR, DATE) \\(\\rightarrow\\) PAYS mais un joueur peut avoir simultanément plusieurs nationalités.\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nPour la composition des matchs, on pouvait envisager trois solutions :\n\nPremière solution : Une association «participer» indique les compositions des matches. Une association «gagner» indique le ou les gagnants (double).\nSeconde solution : une association «participer» portant une propriété prenant la valeur vrai ou faux selon que le joueur a gagné ou non.\nTroisième solution : deux associations «gagner» et «perdre».\n\nSi on choisit la première ou la troisième solution, quelle contrainte faut-il ajouter ?\nParmi les trois solutions, lesquelles permettent de décrire complètement le SI ?\nPourquoi a-t-on choisi la deuxième solution ?\n\n\n\n\nSolution\nIl faut ajouter des contraintes inter-associations :\n\nPremière solution : une contrainte d’inclusion entre gagner et participer.\n\nTroisième solution : une contrainte d’exlusion entre gagner et perdre.\n\nDans la deuxième solution, ces deux contraintes sont respectées sans ajout au modèle E/A. Cette solution est donc plus simple à implémenter.\nMais dans tous les cas, cela ne suffit pas à décrire toutes les contraintes du SI :\n\ndans un match simple, il y a exactement 1 gagnant et 1 perdant.\ndans un match double, il y a exactement 2 gagnants et 2 perdants.\n\nCes contraintes ne peuvent pas être décrites dans le modèle E/A étendu."
  },
  {
    "objectID": "workshops/td8.html#exercice-location-de-voitures",
    "href": "workshops/td8.html#exercice-location-de-voitures",
    "title": "TD 8 : Modélisation",
    "section": "Exercice (Location de voitures)",
    "text": "Exercice (Location de voitures)\nOn étudie une partie du SI d’une société de location de véhicules.\nLa société gère un parc de voiture. On a reccueilli les informations suivantes :\n\nChaque véhicule a une plaque d’immatriculation, une couleur, une marque et un modèle.\nUn modèle a un nom, une marque, un nombre de sièges, un volume de chargement.\nChaque véhicule appartient obligatoirement à une et une seule catégorie qui détermine le tarif de la location.\nTous les véhicules du même modèle appartiennent à la même catégorie.\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nEcrire le diagramme des dépendances fonctionnelles de ce SI (Voir la correction du TP précédent)\n\n\n\nSolution\nOn a les dépéndances fonctionnelles suivantes :\n\n\n\n\n\nOn n’a pas représenté les dépendances indirectes indiquées dans l’énoncé qui se déduisent du diagramme par transitivité :\n\nid véhicules \\(\\rightarrow\\) marque.\nid véhicules \\(\\rightarrow\\) catégorie.\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nA l’aide du diagramme précédent, écrire le diagramme E/A de ce SI.\n\n\n\n\nSolution\nOn déduit du diagramme des dépendances fonctionnelles le MCD suivant :\n\n\n\n\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nOn veut maintenant distinguer les véhicules disponibles des véhicules en location :\n\nPour les véhicules disponibles, on enregistre l’agence où le véhicule est disponible. Une agence a un numéro, une adresse, un numéro de téléphone, un email…\nPour les véhicules en location, on enregistre le client, la date et la durée de la location. Un client a un numéro, une adresse, un numéro de téléphone, un email…\n\nCompléter le diagramme E/A pour modéliser cette partie du SI.\nFaut-il ajouter des contraintes ?\n\n\n\n\nSolution\nOn ajoute 2 entités :\n\nAGENCE : attributs nunméro (identifiant), adresse, téléphone, email.\nCLIENT : attributs numéro (identifiant), adresse, téléphone, email.\n\nEt 2 associations :\n\nest disponible entre VEHICULE et AGENCE.\nest loué entre VEHICULE et CLIENT : attributs date, durée.\n\nSi on considère que le SI ne conserve pas l’historique des locations et des disponibilités, ou qu’on choisit de le faire par d’autres associations, on a les cardinalités 0:1 du côté de VEHICULE pour les deux associations.\nOn a alors aussi une contrainte de partitionnement entre les véhicules disponibles et les véhicules loués que l’on peut représenter complètement par une contrainte inter-association de totalité et d’exclusion entre les deux associations du côté de VEHICULE.\n\n\n\n\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nMaintenant, on s’intéresse à l’entretien des véhicules :\n\ncertains véhicules sont possédés par la société et sont entretenus chacun par un unique garage. Chaque garage a un numéro, un n°SIRET, une adresse, un IBAN, etc. On ne conserve pas l’historique des garages qui ont entretenu le véhicule.\nles autres véhicules sont en leasing auprès de sociétés spécialisées dans ce type de location. Chaque société a un numéro, un n°SIRET, une adresse, un IBAN, etc.\n\ncertains de ces véhicules sont entretenus par la société de leasing.\nles autres sont entretenus par la société de location dont on étudie le SI, selon le même principe que pour les véhicules qui lui appartiennent.\n\n\nOn essaie de modéliser cette partie du SI uniquement avec les entités VEHICULE, GARAGE, SOCIETE DE LEASING.\nProposer une ou des modélisations E/A et utiliser des contraintes pour décrire complètement le SI décrit.\n\n\n\n\nSolution\nIl faut essayer de traduire au mieux et le plus simplement possible la partition de l’ensemble des véhicules en 3 groupes :\n\nles véhicules possédés en propre qui doivent être entretenus par un garage.\nles véhicules en leasing sans entretien inclus qui doivent être entretenus par un garage.\nles véhicules en leasing avec entretien inclus qui ne doivent pas être entretenus par un garage.\n\n\nSolution avec 2 associations binaires\n\nentretient entre GARAGE et VEHICULE.\nloue entre SOC LEASING et VEHICULE avec un attribut booléen pour enregistrer si l’entretien est inclus dans la location.\n\n\n\n\n\n\nCette solution a l’avantage de la simplicité et est proche de la pratique des utilisateurs (l’entretien par un garage est une option du leasing) mais le partitionnement n’est pas vérifiable facilement.\nOn peut représenter une contrainte de totalité entre les 2 associations par rapport à VEHICULE, mais on ne peut représenter la contrainte de partitionnement.\n\n\nSolution avec 3 associations\n\nentretient entre GARAGE et VEHICULE.\nloue sans entretien entre SOC LEASING et VEHICULE pour le leasing sans entretien inclus.\nloue avec entretien entre SOC LEASING et VEHICULE pour le leasing avec entretien inclus.\n\n\n\n\n\n\nCette solution reste proche de la pratique des utilisateurs et permet de représenter fidèlement la contrainte de partitionnement mais les 3 contraintes sont complexes à vérifier.\nConclusion : on peut inventer d’autres solutions mais aucune n’est bien satifsfaisante.\n\n\n\n\n\n\nNoteQuestion\n\n\n\nComme les solutions précédentes ne sont pas très satisfaisante, on décide d’utiliser des spécialisations de l’entité VEHICULE.\nProposer un nouveau modèle E/A et compléter le pour décrire complètement le SI.\n\n\n\n\n\nSolution\nAvec des spécialisations, on peut représenter le SI de manière plus satisfaisante.\n\n\n\n\n\nLa traduction en MRD ne justifie pas la création d’une table pour chaque spécialisation si elles ne contiennent pas d’attributs propres.\nOn traduira le MCD en MRD ainsi :\n\najout à VEHICULE de 2 attributs booléens : entretien et leasing.\nLa contrainte de partitionnement entre les spécialisations est équivalente à la contrainte (entretien ou leasing) = VRAI pour chaque ligne de la table. Elle est facile à coder en SQL et peu couteûse en calculs.\nLes 2 associations entretient de type 1 à plusieurs sont codées par l’ajout dans la table VEHICULE d’une seule clé étrangère garage qui référence le numéro du garage qui effectue l’entretien. Il faut coder la contrainte entretien \\(\\Leftrightarrow\\) garage IS NOT NULL.\nLes 2 associations loue de type 1 à plusieurs sont codées par l’ajout dans la table VEHICULE d’une seule clé étrangère soc leasing qui référence le numéro de la société qui effectue le leasing. Il faut coder la contrainte leasing \\(\\Leftrightarrow\\) soc leasing IS NOT NULL.\n\nC’est finalement un modèle relationnel proche ou identique à celui obtenu par conversion du premier MCD de la question précédente avec 2 associations. Mais il représente mieux le SI et permet un meilleur travail."
  },
  {
    "objectID": "workshops/td9.html",
    "href": "workshops/td9.html",
    "title": "TD 9 : Modèle relationnel des données",
    "section": "",
    "text": "WarningAvec solutions"
  },
  {
    "objectID": "workshops/td10.html",
    "href": "workshops/td10.html",
    "title": "TD 10 : Normalisation",
    "section": "",
    "text": "L3 MIASHS\n\n\nUniversité Paris Cité\n\n\nAnnée 2025\n\n\nCourse Homepage\n\n\nMoodle\n\n\n\n\n\n\n\n\n\n\nExercice\nSoit \\(\\mathcal{A}=\\left\\{A,B,C,D,E\\right\\}\\) un schéma et soit \\(\\mathcal{A}_1=\\left\\{A,B,C\\right\\}\\). Pour chaque ensemble \\(\\Sigma\\) de dépendances fonctionnelles ci-dessous, déterminer un ensemble de DF équivalent à \\(\\pi_{\\mathcal{A}_1}(\\Sigma)\\).\n\n\\(\\Sigma=\\left\\{AB\\to DE, C\\to E, D\\to C, E\\to A\\right\\}\\)\n\\(\\Sigma=\\left\\{A\\to D, BD\\to E, AC\\to E, DE\\to B\\right\\}\\)\n\\(\\Sigma=\\left\\{AB\\to D, AC\\to E, BC\\to D, D\\to A, E\\to B\\right\\}\\)\n\\(\\Sigma=\\left\\{A\\to B, B\\to C, C\\to D, D\\to E, E\\to A\\right\\}\\)\n\n\n\nExercice\nSoit \\(\\mathcal{A}=\\left\\{A,B,C,D,E\\right\\}\\) un schéma et soit la décomposition \\(\\left\\{\\mathcal{A}_1,\\mathcal{A}_2,\\mathcal{A}_3\\right\\}\\) où \\[\\mathcal{A}_1=\\left\\{A,B,C\\right\\}\\quad \\mathcal{A}_2=\\left\\{B,C,D\\right\\}\\quad \\mathcal{A}_3=\\left\\{A,C,E\\right\\}\\] Pour chaque ensemble \\(\\Sigma\\) de dépendances fonctionnelles ci-dessous, déterminer quelles dépendances sont préservées par cette décomposition, c’est-à-dire quelles DF de \\(\\Sigma\\) sont impliquées par \\(\\bigcup_{i=1}^3 \\pi_{\\mathcal{A}_i}(\\Sigma)\\).\n\n\\(\\Sigma=\\left\\{b\\rightarrow E, CE\\rightarrow A\\right\\}\\)\n\\(\\Sigma=\\left\\{aC\\rightarrow E, BC\\to D\\right\\}\\)\n\\(\\Sigma=\\left\\{a\\rightarrow D, D\\to E, B\\to D\\right\\}\\)\n\\(\\Sigma=\\left\\{a\\rightarrow D, CD\\to E, E\\to D\\right\\}\\)\n\n\n\nExercice\nOn considère le schéma de relation suivant concernant la gestion de rendez-vous d’un service d’intervention hospitaliers. \\[\n\\mathcal{A}=\\left\\{\\texttt{IdM,NomM,PrenomM,DateRV,HeureRV,IdP,NomP,PrenomP,IdInterV}\\right\\}\n\\]\nChaque rendez-vous implique un médecin et un patient. Chaque médecin est identifié par un numéro, IdM, un nom NomM et un prénom PrenomM. Le rendez-vous est à une date, DateRV, et à une heure, HeureRV données. Chaque patient est identifié par un numéro, IdP, un nom NomP et un prénom PrenomP. Chaque rv est programmé pour un type d’intervention médical, IdInterV. On suppose que chaque jour, un médecin ne peut pratiquer qu’un seul type d’intervention médicale (consultation, type de chirurgie donnée).\nOn a les dépendances fonctionnelles \\(\\Sigma\\) suivantes:\nIdM, DateRV,HeureRV, IdInterV → IdP\nIdM, DateRV →  IdInterV\nIdM → NomM, PrenomM\nIdP → NomP, PrenomP\nIdP,DateRV,HeureRV → IdInterV\nIdP,DateRV,HeureRV →  IdM,NomM\n\nQuels sont les inconvénients d’une telle modélisation par une seule table en terme d’anomalies d’insertion ou de suppression ?\n\n\nCalculer \\([\\texttt{IdM}]^+_{\\Sigma}\\)\n\n\nProposez un ensemble d’attributs formant une clé de la relation.\n\n\nDonner un ensemble de dépendances fonctionnelles \\(\\Sigma'\\) équivalent à \\(\\Sigma\\) qui soit minimal (i.e. sans règles redondantes, notamment). Justifiez\n\nOn se donne la décomposition de \\(\\mathcal{A}\\) suivante~: \\[\n\\begin{array}{l}\n    \\mathcal{A}_1=\\left\\{\\texttt{IdM,HeureRV,DateRV,IdP,NomP,PrenomP}\\right\\},\\\\\n     \\mathcal{A}_2=\\left\\{\\texttt{IdM,DateRV,IdInterV}\\right\\},\\\\\n     \\mathcal{A}_3=\\left\\{\\texttt{IdM,NomM,PrenomM}\\right\\}\n\\end{array}\n\\]\n\nToutes les dépendances fonctionnelles sont-elles préservées par cette décomposition ?\nEst-elle sans perte d’information ?\nPour \\(i=1,2,3\\), déterminer si \\(\\mathcal{A}_i\\) est en forme normale de Boyce-Codd.\n\n\nMêmes questions pour la décomposition :\n\n\\[\n\\begin{array}{rl}\n\\mathcal{A}_1 &=\\left\\{\\texttt{IdM,HeureRV,DateRV,IdP}\\right\\}\\\\\n\\mathcal{A}_2 &=\\left\\{\\texttt{IdP,NomP,PrenomP}\\right\\}, \\\\\n\\mathcal{A}_3 &=\\left\\{\\texttt{IdM,DateRV,IdInterV}\\right\\},\\\\\n\\mathcal{A}_4 &=\\left\\{\\texttt{IdM,NomM,PrenomM}\\right\\}\n\\end{array}\n\\]\n\n\nExercice\nSoit une relation concernant des personnes résidant en France avec les attributs suivants:\nNom, Numéro de sécurité sociale, Commune, Département, Code postal, Numéro de téléphone\navec l’ensemble \\(\\Sigma\\) de DF suivantes~:\nNuméro de sécurité sociale → Nom, Commune, Département, Code postal, Numéro de téléphone \nCommune → Département \nCode postal → Commune, Département\n\nCe schéma est-il en forme normale de Boyce-Codd ?\n\nSoit la décomposition \\[\\mathcal{A}_1=\\left\\{\\texttt{Code postal}, \\texttt{Commune}, \\texttt{Département}\\right\\}\\] et \\[\\mathcal{A}_2=\\left\\{\\texttt{Numéro de sécurité sociale}, \\texttt{Nom}, \\texttt{Code postal},\\texttt{Numéro de téléphone}\\right\\}\\]\n\nChaque \\(\\mathcal{A}_i\\) est-elle en forme normale de Boyce-Codd ?\nCette décomposition préserve-t-elle les dépendances fonctionnelles ?\nCette décomposition est-elle sans perte d’information ?\nMêmes questions pour la décomposition \\[\\mathcal{A}_1=\\left\\{\\texttt{Commune}, \\texttt{Département}\\right\\}\\]\n\n\\[\\mathcal{A}_2=\\left\\{\\texttt{Numéro de sécurité sociale}, \\texttt{Nom}, \\texttt{Commune}, \\texttt{Code postal},\\texttt{Numéro de téléphone}\\right\\}\\]\n\n\nExercice\nSoit un schéma d’attributs \\(A_1, A_2,\\dots A_n\\) et un ensemble de dépendances fonctionnelles. Calculer le nombre de super-clefs (en fonction de \\(n\\)) dans les cas suivants~:\n\nLa seule clef est \\(\\left\\{A_1\\right\\}\\).\nLes seules clefs sont \\(\\left\\{A_1\\right\\}\\) et \\(\\left\\{A_2\\right\\}\\).\nLes seules clefs sont \\(\\left\\{A_1,A_2\\right\\}\\) et \\(\\left\\{A_3,A_4\\right\\}\\).\nLes seules clefs sont \\(\\left\\{A_1,A_2\\right\\}\\) et \\(\\left\\{A_1,A_3\\right\\}\\).\n\n\n\nExercice\nSoit le schéma \\(\\mathcal{A}=\\{A,B,C,D\\}\\) et l’ensemble de dépendances fonctionnelles \\[\\Sigma = \\{ A \\to B, B \\to C\\} \\]\n\nQuelle est la fermeture \\(\\{A\\}^+\\) de \\(\\{A\\}\\) ?\n\n\nQuelles sont les super-clés ? Les clés ?\n\n\n\nExercice\nSoit le schéma \\(\\mathcal{A}=\\{A,B,C,D,E,F\\}\\) et l’ensemble de dépendances fonctionnelles \\[\\Sigma = \\Bigl\\{ \\left\\{A,B\\right\\}\\to C, \\left\\{B,C\\right\\}\\to \\left\\{A,D\\right\\}, D\\to E, \\left\\{C,F\\right\\}\\to B \\Bigr\\}\\]\n\nCalculer la fermeture \\(\\left\\{A,B\\right\\}^+\\) de \\(\\left\\{A,B\\right\\}\\).\nEst-ce que \\(\\Sigma\\) implique la dépendance fonctionnelle \\(\\left\\{A,B\\right\\}\\to D\\)~?\nEst-ce que \\(\\Sigma\\) implique la dépendance fonctionnelle \\(D\\to A\\)~?\n\n\n\n\nExercice\nOn considère une schéma \\(\\mathcal{A}\\) avec les attributs\nPropriétaire, Occupant, Adresse, Noapt, Nbpièces, Nbpersonnes\nUn nuplet/tuple (p, o, a, n, nb1, nb2) ayant la signification suivante : La personne o habite avec nb2 personnes l’appartement de numéro n ayant nb1 pièces dont le propriétaire est p.\nUne analyse de cette relation nous fournit un ensemble initial \\(\\Sigma\\) de dépendances fonctionnelles\nOccupant → Adresse\nOccupant → Noapt\nOccupant → Nbpersonnes\nAdresse, Noapt → Proprietaire\nAdresse, Noapt → Occupant\nAdresse, Noapt → Nbpieces\n\nDéterminer les clés du schémas\nLes schéma est-il en FN3 ?\nSi la réponse est Non, décomposer sans perte d’information et sans perte de dépendances fonctionnelles.\n\n\n\nExercice\n\nSoit le schéma \\[\\mathcal{A}=\\{\\texttt{IdLivre, Titre, Langue, Pays, IdTraducteur, Nom, Date}\\}\\] et l’ensemble de DF\nIdLivre → Titre \nLangue → Pays \nIdTraducteur → Nom \nIdLivre, IdTraducteur, Langue → Date\nIdLivre, IdTraducteur → Langue\nAppliquer l’algorithme de décomposition vu en cours pour obtenir une décomposition de \\(\\mathcal{A}\\) qui respecte la FNBC et est sans perte d’information. Déterminer quelles DF sont préservées.\n\n\nExercice\nSoit le schéma \\[\\mathcal{A}=\\left\\{\\texttt{A,B,C,D,E,F,G,H}\\right\\}\\] et l’ensemble de DF\nBE → AC  \nB → H  \nF → CD  \nD → G\n\nAppliquer l’algorithme de décomposition vu en cours pour obtenir une décomposition de \\(\\mathcal{A}\\) qui respecte la FNBC et est sans perte d’information. Déterminer quelles DF sont préservées.\nPeut-on, en ajoutant un sous-schéma à la décomposition, obtenir une décomposition FNBC sans perte d’information et sans perte de DF ?\n\n\n\nExercice\nReprendre les questions de l’exercice précédent pour le schéma \\[\\mathcal{A}=\\left\\{\\texttt{A,B,C,D,E,F,G,H}\\right\\}\\] et l’ensemble de DF\nBE → AC  \nB → H\nF → CD\nD → G\nA→ E"
  },
  {
    "objectID": "workshops/td11.html",
    "href": "workshops/td11.html",
    "title": "TD 11 : Normalisation et dépendances",
    "section": "",
    "text": "L3 MIASHS\n\n\nUniversité Paris Cité\n\n\nAnnée 2025\n\n\nCourse Homepage\n\n\nMoodle\n\n\n\n\n\n\n\n\n\n\nExercice\nSoit le schéma \\[\\mathcal{A}=\\left\\{\\texttt{A,B,C,D,E,F,G,H}\\right\\}\\] et l’ensemble de DF\nBE → AC  \nB → H  \nF → CD  \nD → G\n\nAppliquer l’algorithme de décomposition vu en cours pour obtenir une décomposition de \\(\\mathcal{A}\\) qui respecte la FNBC et est sans perte d’information. Déterminer quelles DF sont préservées.\nPeut-on, en ajoutant un sous-schéma à la décomposition, obtenir une décomposition FNBC sans perte d’information et sans perte de DF ?\n\n\n\nExercice\nReprendre les questions de l’exercice précédent pour le schéma \\[\\mathcal{A}=\\left\\{\\texttt{A,B,C,D,E,F,G,H}\\right\\}\\] et l’ensemble de DF\nBE → AC  \nB → H\nF → CD\nD → G\nA→ E"
  },
  {
    "objectID": "exams/ct-2024-06-19.html",
    "href": "exams/ct-2024-06-19.html",
    "title": "MA15E045 - Automne 2025",
    "section": "",
    "text": "L3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2023-2024\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\n\n\n\n\n\n\nLes requêtes portent sur le schéma nycflights légèrement nettoyé.\n\n\n\n\n\n\nNYCFlights en relationel à pattes de corbeau\n\n\n\n\n\nDéfinition du schéma en SQL\n\n\n\nCREATE TABLE airlines (\n    carrier text NOT NULL,\n    \"name\" text NULL,\n    CONSTRAINT airlines_pk \n        PRIMARY KEY (carrier),\n    CONSTRAINT airlines_un \n        UNIQUE (name)\n);\nCREATE TABLE airports (\n    faa text NOT NULL,\n    \"name\" text NULL,\n    lat float8 NULL,\n    lon float8 NULL,\n    alt float8 NULL,\n    tz float8 NULL,\n    dst text NULL,\n    tzone text NULL,\n    CONSTRAINT airports_pk \n        PRIMARY KEY (faa),\n    CONSTRAINT airports_un \n        UNIQUE (name),\n    CONSTRAINT airports_un_ll \n        UNIQUE (lat, lon)\n);\n\n\nCREATE TABLE weather (\n    origin text NOT NULL,\n    \"year\" int4 NULL,\n    \"month\" int4 NULL,\n    \"day\" int4 NULL,\n    \"hour\" int4 NULL,\n    \"temp\" float8 NULL,\n    dewp float8 NULL,\n    humid float8 NULL,\n    wind_dir float8 NULL,\n    wind_speed float8 NULL,\n    wind_gust float8 NULL,\n    precip float8 NULL,\n    pressure float8 NULL,\n    visib float8 NULL,\n    time_hour timestamptz NOT NULL,\n    CONSTRAINT weather_pk \n        PRIMARY KEY (origin, time_hour)\n);\nALTER TABLE weather ADD \n    CONSTRAINT weather_fk \n    FOREIGN KEY (origin) \n    REFERENCES airports(faa) \n    ON DELETE CASCADE \n    ON UPDATE CASCADE;\n\n\n\nCREATE TABLE planes (\n    tailnum text NOT NULL,\n    \"year\" int4 NULL,\n    \"type\" text NULL,\n    manufacturer text NULL,\n    model text NULL,\n    engines int4 NULL,\n    seats int4 NULL,\n    speed int4 NULL,\n    engine text NULL,\n    CONSTRAINT planes_pk   PRIMARY KEY (tailnum)\n);\n\n\n\nCREATE TABLE flights (\n    \"year\" int4 NULL,\n    \"month\" int4 NULL,\n    \"day\" int4 NULL,\n    dep_time int4 NULL,\n    sched_dep_time int4 NULL,\n    dep_delay float8 NULL,\n    arr_time int4 NULL,\n    sched_arr_time int4 NULL,\n    arr_delay float8 NULL,\n    carrier text NULL,\n    flight int4 NULL,\n    tailnum text NOT NULL,\n    origin text NOT NULL,\n    dest text NULL,\n    air_time float8 NULL,\n    distance float8 NULL,\n    \"hour\" float8 NULL,\n    \"minute\" float8 NULL,\n    time_hour timestamptz NOT NULL,\n    CONSTRAINT flights_pk \n        PRIMARY KEY (\n            tailnum, origin, time_hour)\n);\n\n\nALTER TABLE flights ADD \n    CONSTRAINT flights_fk \n    FOREIGN KEY (carrier) \n    REFERENCES airlines(carrier) \n    ON DELETE SET NULL \n    ON UPDATE CASCADE;\nALTER TABLE flights ADD \n    CONSTRAINT flights_fk_dest \n    FOREIGN KEY (dest) \n    REFERENCES airports(faa) \n    ON DELETE SET NULL \n    ON UPDATE CASCADE;\nALTER TABLE flights ADD \n    CONSTRAINT flights_fk_origin \n    FOREIGN KEY (origin) \n    REFERENCES airports(faa) \n    ON DELETE SET NULL \n    ON UPDATE CASCADE;\nALTER TABLE flights ADD \n    CONSTRAINT flights_fk_planes \n    FOREIGN KEY (tailnum) \n    REFERENCES planes(tailnum) \n    ON DELETE SET NULL \n    ON UPDATE CASCADE;\n\n\n\nDans le schéma nycflights, on a aussi les dépendances fonctionnelles suivantes:\nTable airports\n\nfaa, name, et (lon, lat) sont des clés.\n\nTable airlines\n\ncarrier et name sont des clés\n\nTable weather\n\norigin, time_hour est une clé\ntime_hour → year, month, day, hour\nyear, month, day, hour  → time_hour\n\nTable planes\n\ntailnum est une clé\nmodel → manufacturer, engines, engine, type\n\nTable flights\n\ntailnum, time_hour → carrier\ntime_hour → sched_dep_time\nsched_dep_time, dep_time → dep_delay\nsched_arr_time, arr_time → arr_delay\norigin, dest, dep_time, arr_time → airtime\ntime_hour → year, month, day, hour, minute\nyear, month, day, hour, minute → time_hour\norigin, dest → distance\n(tailnum, origin, time_hour) est une clé\n(flight, dest, origin, year, month, day) est une clé\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\n\n\n\n\n\nNoteExercice : Requêtes (schéma nycflights)\n\n\n\n\n\n\n\n\n\n\n\n\nNoteRequête 1\n\n\n\n\n\nPour chaque couple origine/destination, lister les caractéristiques de l’avion le plus rapide sur la liaison.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH R As (\n  SELECT f.origin, f.dest, f.tailnum, RANK() OVER w AS rnk\n  FROM flights AS f\n  WHERE f.airtime IS NOT NULL\n  WINDOW w AS (PARTITION BY f.origin, f.dest ORDER by f.airtime DESC)\n) \n\nSELECT R.origin, R.dest, p.* \nFROM (SELECT * FROM R WHERE R.rnk=1) AS S \n  JOIN planes as p \n  ON (R.tailnum=p.tailnum) ;\nWITH R As (\n  SELECT f.origin, f.dest, min(f.airtime) as min_time\n  FROM flights AS f\n  WHERE f.airtime IS NOT NULL\n  GROUP BY f.origin, f.dest \n), S AS (\n  SELECT f.origin, f.dest, f.tailnum\n  FROM flights AS f NATURAL JOIN R \n  WHERE f.airtime = R.min_time\n)\n\nSELECT S.origin, S.dest, p.* \nFROM S  \n  JOIN planes as p \n  ON (S.tailnum=p.tailnum) ;\n\n\n\n\n\n\n\n\nNoteRequête 2\n\n\n\n\n\n\nPour chaque aéroport d’origine, déterminer pour chaque heure de la jourńee, les températures maximales et minimales\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH o AS (\n  SELECT DISTINCT f.origin\n  FROM flights as f \n)\nSELECT w.origin, w.hour, MAX(w.temp), MIN(w.temp)\nFROM o NATURAL JOIN weather w \nGROUP BY w.hour ;\n\n\n\n\n\n\n\n\nNoteRequête 3\n\n\n\n\nPour chaque aéroport d’origine, pour chaque température enregistrée en début d’heure, arrondie à l’entier le plus proche, indiquer la proportion de vols avec un retard supérieur à 30 mn au décollage.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH R AS (\n  SELECT f.origin, f.year. f.month, f.day, f.hour, f.flight, f.dep_delay, ROUND(w.temp, 0) as t\n  FROM flights f JOIN weater w ON\n    (f.origin=w.origin AND \n     f.year=w.year AND \n     f.month=w.month AND\n     f.day=w.day AND \n     f.hour=w.hour)\n)\n\nSELECT f.origin, f.t, SUM(f.dep_delay &gt; 30)/COUNT(*) AS p\nFROM R AS f \nGROUP BY f.origin, f.t ;\n\n\n\n\n\n\n\n\nNoteRequête 4\n\n\n\n\n\nPour chaque aéroport de destination, lister les modèles d’avion qui ont atterri au moins une fois dans cet aéroport.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT DISTINCT(f.dest, p.models)\nFROM flights f JOIN planes p ON (f.tailnum=p.tailnum) ;\n\n\n\n\n\n\n\n\nNoteRequête 5\n\n\n\n\n\nPour chaque modèle d’avion, lister pour chaque semaine, le nombre de vols efectivement réalisés.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT p.model, DATE_PART('week', f.time_hour) AS semaine, COUNT(*) AS n\nFROM flights f JOIN planes p ON (f.tailnum=p.tailnum)\nWHERE f.dep_time IS NOT NULL \nGROUP BY p.model, DATE_PART('week', f.time_hour) AS semaine ; \n\n\n\n\n\n\n\n\nNoteRequête 6\n\n\n\n\n\nQuelles sont les destinations qui ne sont pas desservies le jeudi ?\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH R AS (\n  SELECT DISTINCT f.dest\n  FROM flights f\n  WHERE DATE_PART('week', f.time_hour) = 'Thursday'\n), S AS (\n  SELECT DISTINCT f.dest\n  FROM flights f\n)\n\nSELECT * FROM S\n\nEXCEPT\n\nSELECT * FROM R; \n\n\n\n\n\n\n\n\nNoteRequête 7\n\n\n\n\nQuelles sont les villes desservies par une seule compagnie le dimanche ?\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT f.dest\nFROM flights f\nWHERE DATE_PART('week', f.time_hour) = 'Sunday'\nGROUP BY f.dest\nHAVING COUNT(DISTINCT f.carrier) = 1 ;\n L’utilisation d’une clause WITH (Common Table Expression) plutôt que d’une requête imbriquée rend le code plus lisible.\n Dans la réponse, nous donnons plus que ce qui était demandé. On aurait pu se contenter de ;\n...\n\n\n\n\n\n\n\n\n\nNoteRequête 8\n\n\n\n\n\nQuelles sont les compagnies pour lesquelles le retard médian au décollage est supérieur à 15 minutes ?\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT f.carrier\nFROM flights f\nWHERE f.dep_delay IS NOT NULL\nGROUP BY f.carrier\nHAVING MEDIAN(f.dep_delay) &gt; 15 ;\n\n\n\n\n\n\n\n\nNoteRequête 9\n\n\n\n\n\nQuelles sont les destinations qui sont desservies quotidiennement par une compagnie ?\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\n\n\n\n\n\nNoteRequête 10\n\n\n\n\n\nQuelles sont les compagnies qui exploitent des avions de tous les constructeurs ?\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\n\n\n\n\n\nTipQuelques conseils\n\n\n\n\nPréférez les clauses WITH et les jointures aux requêtes imbriquées sauf si la requête imbriquée est très simple. C’est une question de lisibilité et donc souvent de correction.\nNe mélangez pas les fonctions fenêtres et les clauses GROUP BY ...\n\nSELECT ..., FOO() OVER w\nFROM R\nWINDOW w AS (PARTITION BY ... ORDER BY ...)\nGROUP BY ... ;  \nest tout simplement incorrect.\n\nLorsque vous effectuez un partitionnement par GROUP BY ..., la clause SELECT ... est sévèrement contrainte, vous n’y trouverez que\n\nles colonnes qui ont servi dans la clause GROUP BY ..., normalement elles devraient toutes y figurer\ndes fonctions d’aggrégation, comme COUNT(...), SUM(...), VAR(...)"
  },
  {
    "objectID": "exams/ct-2025-01-06.html",
    "href": "exams/ct-2025-01-06.html",
    "title": "MA15E045 - Automne 2025",
    "section": "",
    "text": "L3 MIASHS/Ingémath/METIS\nUniversité Paris Cité\nAnnée 2024-2025\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRaoul Taburin, vélociste (marchand-réparateur de bicyclettes), a décidé de s’équiper d’un système d’information. Il a fait réaliser une analyse par un cabinet de conseil réputé.\n\nLe vélociste vend des produits (dérailleurs, jantes, freins, selles, guidons, …). Chaque produit est identifié par un numéro de catalogue (product_id). Un produit est vendu par un fabricant connu par son nom (Campagnolo, Shimano, Simplex,…). Un produit possède une description (texte). Un produit relève d’une catégorie identifiée par un numéro (cat_id) et munie d’une description (pédalier, freins à | disque, tige de selle télescopique, …). Un produit relève aussi d’une gamme (Ultegra, 105, Tiagra, …).\nUn produit possède un prix unitaire.\n\nÀ chaque produit du catalogue correspond une entrée dans l’inventaire. Dans cette entrée on reporte le numéro du produit, le nombre d’exemplaires en stock (en_stock) et le nombre d’exemplaires déjà vendus (vendus).\n\n\n\nPour chaque produit, le vélociste est amené à effectuer des réapprovisionnements (commandes). Chaque commande concerne un produit, elle est efféctuée à une date notée date_com. La commande porte sur une quantité notée qte. La commande est livrée au vélociste (si tout se passe bien) à la date date_liv. Pour une commande qui n’a pas encore été livrée, date_liv est réputée NULL.\nLe vélociste possède des fidèles clients. Chaque fidèle client est identifié par un numéro (client_id), possède un nom, une adresse (texte), un numéro de téléphone. Sur chaque client, le vélociste possède des renseignements démographiques (année de naissance, sexe, profession, taille).\nLorsqu’un fidèle client effectue un achat, le vélociste émet une facture identifiée par un numéro de facture fact_id. La facture comporte le numéro du client, une date et un montant global (montant).\nUne facture se compose de lignes. Chaque ligne comporte une référence à un produit désigné par son numéro de catalogue, une quantité (qte) et un montant (calculé à partir de qte et du prix unitaire du produit). Chaque ligne de facture est identifiée par un numéro de ligne num_ligne (relativement à la facture).\n\n\n\n\n\n\nNoteQuestion 1 (4pts)\n\n\n\nProposer un diagrammme entité-association (EA) correspondant à cette modélisation.\n\n\n\n\n\n\n\n\nTipConseils\n\n\n\n\nDistinguer entités fortes et faibles\nDistinguer associations fortes et faibles\nPour chaque entité préciser l’identifiant (éventuellement relatif)\nPréciser les cardinalités pour chaque participation à une association\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\n\n\nER\n\n\n\nclient\n\nclient\n\n\n\npaye\n\npaye\n\n\n\nclient--paye\n\n0:n\n\n\n\nfacture\n\nfacture\n\n\n\ndans\n\n\ndans\n\n\n\nfacture--dans\n\n0:n\n\n\n\nproduit\n\nproduit\n\n\n\nrelève_de\n\nrelève_de\n\n\n\nproduit--relève_de\n\n1:1\n\n\n\ndemande\n\n\ndemande\n\n\n\nproduit--demande\n\n1:n\n\n\n\ncatégorie\n\ncatégorie\n\n\n\ndesc2\n\ndescription\n\n\n\ncatégorie--desc2\n\n\n\n\ncat_id\n\ncat_id\n\n\n\ncatégorie--cat_id\n\n\n\n\nnom\n\nnom\n\n\n\nnom--client\n\n\n\n\nadresse\n\nadresse\n\n\n\nadresse--client\n\n\n\n\nsexe\n\nsexe\n\n\n\nsexe--client\n\n\n\n\nprofession\n\nprofession\n\n\n\nprofession--client\n\n\n\n\nprix\n\nprix\n\n\n\nprix--produit\n\n\n\n\nmontant\n\nmontant\n\n\n\nmontant--facture\n\n\n\n\ndate_liv\n\ndate_liv\n\n\n\nfabricant\n\nfabricant\n\n\n\nfabricant--produit\n\n\n\n\ngamme\n\ngamme\n\n\n\ngamme--produit\n\n\n\n\ndesc1\n\ndescription\n\n\n\ndesc1--produit\n\n\n\n\nqte1\n\nqté\n\n\n\nligne\n\n\nligne\n\n\n\nqte1--ligne\n\n\n\n\nqte2\n\nqté\n\n\n\nréappro\n\n\nréappro\n\n\n\nqte2--réappro\n\n\n\n\nclient_id\n\nclient_id\n\n\n\nclient_id--client\n\n\n\n\nproduit_id\n\nproduit_id\n\n\n\nproduit_id--produit\n\n\n\n\nfacture_id\n\nfacture_id\n\n\n\nfacture_id--facture\n\n\n\n\nnum_ligne\n\nnum_ligne\n\n\n\nnum_ligne--ligne\n\n\n\n\ndate_reappro\n\ndate\n\n\n\ndate_reappro--réappro\n\n\n\n\npaye--facture\n\n1:1\n\n\n\nconcerne\n\nconcerne\n\n\n\nconcerne--produit\n\n0:n\n\n\n\nrelève_de--catégorie\n\n0:n\n\n\n\ninventaire\n\n\ninventaire\n\n\n\nfictif\n\n\n\n\n\ninventaire--fictif\n\n1:1\n\n\n\nréappro--date_liv\n\n\n\n\nligne--concerne\n\n1:1\n\n\n\ndemande--réappro\n\n1:1\n\n\n\ndans--ligne\n\n1:1\n\n\n\nfictif--produit\n\n1:1\n\n\n\nvendus\n\n\nvendus\n\n\n\nvendus--inventaire\n\n\n\n\nqte_en_stock\n\n\nqte_en_stock\n\n\n\nqte_en_stock--inventaire\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteRemarque\n\n\n\n\nNous n’avons pas décrit tous les attributs, pour ne pas surcharger un schéma déjà chargé.\nDéfinir inventaire comme une entité faible subordonnée à l’entité produit est un choix discutable. Comme l’inventaire n’est pas historicisé (c’est l’inventaire à l’instant courant), on peut aussi bien ajouter à l’entité produit les attributs de l’entité inventaire.\n\nUn réapprovisionnement est identifié par le produit et la date de commande. Il s’agit d’une entité faible associée à produit par une association faible demande\n\nligne est une entitée faible identifiée par l’identifiant relatif num_ligne et l’identifiant de l’entité forte associée facture\nL’association entre ligne et produit n’est pas identifiante.\n\n\n\n\n\n\n\n\n\nNoteAvec Chat-GPT 3.5\n\n\n\n\nVoici une proposition pour un schéma entité-association (EA) basé sur votre description du système du vélociste :\n\n\nLa notation des cardinalités n’est pas exactement celle du cours. Les entités et associations faibles ne sont pas mises en évidence, mais le gros, l’essentiel du travail est effectué.\n\n\nProduit\n\nAttributs : product_id (PK), nom_produit, description, cat_id, nom_gamme, prix_unitaire\nAssociation :\n\nRelié à Inventaire (1,1) → (product_id)\nRelié à Commande (1,n) → (product_id)\nRelié à LigneFacture (1,n) → (product_id)\n\n\nCatégorie\n\nAttributs : cat_id (PK), description\n\nInventaire\n\nAttributs : product_id (FK, PK), en_stock, vendus\nAssociation : Relié à Produit (1,1)\n\nCommande\n\nAttributs : commande_id (PK), product_id (FK), date_com, qte, date_liv\nAssociation : Relié à Produit (n,1)\n\nClient\n\nAttributs : client_id (PK), nom, adresse, telephone, annee_naissance, sexe, profession, taille\nAssociation :\n\nRelié à Facture (1,n)\n\n\nFacture\n\nAttributs : fact_id (PK), client_id (FK), date_fact, montant\nAssociation :\n\nRelié à Client (n,1)\nRelié à LigneFacture (1,n)\n\n\nLigneFacture\n\nAttributs : fact_id (FK), num_ligne (PK relatif), product_id (FK), qte, montant\nAssociation :\n\nRelié à Facture (n,1)\nRelié à Produit (n,1)\n\n\n\n\nAssociations principales\n\nChaque produit appartient à une catégorie.\nUn produit a des entrées associées dans l’inventaire et des commandes de réapprovisionnement.\nLes clients peuvent avoir plusieurs factures, chaque facture pouvant contenir plusieurs lignes relatives à un ou plusieurs produits.\n\n\n\n\n\n\n\n\n\n\n\nER\n\n\n\nclient\n\nclient\n\n\n\npaye\n\npaye\n\n\n\nclient--paye\n\n0:n\n\n\n\nfacture\n\nfacture\n\n\n\ndans\n\n\ndans\n\n\n\nfacture--dans\n\n0:n\n\n\n\nproduit\n\nproduit\n\n\n\nrelève_de\n\nrelève_de\n\n\n\nproduit--relève_de\n\n1:1\n\n\n\ndemande\n\n\ndemande\n\n\n\nproduit--demande\n\n1:n\n\n\n\ncatégorie\n\ncatégorie\n\n\n\ndesc2\n\ndescription\n\n\n\ncatégorie--desc2\n\n\n\n\ncat_id\n\ncat_id\n\n\n\ncatégorie--cat_id\n\n\n\n\nnom\n\nnom\n\n\n\nnom--client\n\n\n\n\nadresse\n\nadresse\n\n\n\nadresse--client\n\n\n\n\nsexe\n\nsexe\n\n\n\nsexe--client\n\n\n\n\nprofession\n\nprofession\n\n\n\nprofession--client\n\n\n\n\nprix\n\nprix\n\n\n\nprix--produit\n\n\n\n\nmontant\n\nmontant\n\n\n\nmontant--facture\n\n\n\n\nvendus\n\nvendus\n\n\n\nvendus--produit\n\n\n\n\nqte_en_stock\n\nqte_en_stock\n\n\n\nqte_en_stock--produit\n\n\n\n\ngamme\n\ngamme\n\n\n\ngamme--produit\n\n\n\n\nfabricant\n\nfabricant\n\n\n\nfabricant--produit\n\n\n\n\ndate_liv\n\ndate_liv\n\n\n\ndesc1\n\ndescription\n\n\n\ndesc1--produit\n\n\n\n\nqte1\n\nqté\n\n\n\nligne\n\n\nligne\n\n\n\nqte1--ligne\n\n\n\n\nqte2\n\nqté\n\n\n\nréappro\n\n\nréappro\n\n\n\nqte2--réappro\n\n\n\n\nclient_id\n\nclient_id\n\n\n\nclient_id--client\n\n\n\n\nproduit_id\n\nproduit_id\n\n\n\nproduit_id--produit\n\n\n\n\nfacture_id\n\nfacture_id\n\n\n\nfacture_id--facture\n\n\n\n\nnum_ligne\n\nnum_ligne\n\n\n\nnum_ligne--ligne\n\n\n\n\ndate_reappro\n\ndate\n\n\n\ndate_reappro--réappro\n\n\n\n\npaye--facture\n\n1:1\n\n\n\nconcerne\n\nconcerne\n\n\n\nconcerne--produit\n\n0:n\n\n\n\nrelève_de--catégorie\n\n0:n\n\n\n\nréappro--date_liv\n\n\n\n\nligne--concerne\n\n1:1\n\n\n\ndemande--réappro\n\n1:1\n\n\n\ndans--ligne\n\n1:1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteQuestion 2 (2pts)\n\n\n\nSi besoin, transformez votre schéme de façon à ce qu’il ne comporte plus d’associations d’arité supérieure ou égale à 3, ou d’associations plusieurs-plusieurs (0:n pour plusieurs entités participantes).\n\n\n\n\n\n\n\n\nNotre schéma ne comporte ni associations plusieurs-plusieurs, ni association d’arité supérieure à 2. Il n’y a donc pas de réécriture à effectuer. Nous pouvons immédiatement proécéder à la traduction en pattes de corbeau.\n\n\n\n\n\n\n\n\n\nNoteQuestion 3 (2pts)\n\n\n\nProposer une traduction en pattes de corbeau du diagramme EA proposé en réponse\nà la première question.\n\n\n\n\n\n\n\n\nTipConseil\n\n\n\nAidez-vous aussi de votre réponse à la deuxième question.\nPrécisez\n\nune clé primaire pour chaque table,\nles tables dites intermédiaires,\npour les liens matérialisant les contraintes référentielles, préciser s’ils sont identifiant ou non.\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\nerDiagram\n    INVENTAIRE ||--|| PRODUIT : produit_id \n    COMMANDE }o--|| PRODUIT  : produit_id\n    PRODUIT }o..|| CATEGORIE : categorie_id \n    FACTURE }o..|| CLIENT :client_id\n    LIGNE }o--|| FACTURE :facture_num\n    LIGNE }o..|| PRODUIT : produit_id \n\n  INVENTAIRE {\n    num produit_id  PK, FK\n    num en_stock  \n    num vendus   \n  }\n\n  CATEGORIE {\n    num categorie_id  PK\n    text nom \n  }\n\n  PRODUIT {\n    num produit_id PK\n    text description \n    num categorie_id FK\n    text gamme \n    text fabricant \n  }\n\n\n  COMMANDE {\n    num produit_id  PK, FK\n    date date_com  PK\n    num qte \n    date date_liv  \n  }\n\n  FACTURE {\n    num facture_num  PK\n    num client_id   FK\n    date date_fac\n    num montant  \n  }\n\n  LIGNE {\n    num facture_num PK, FK\n    num num_lign PK\n    num produit_id  FK\n    num qte \n  }\n\n  CLIENT {\n    num client_id PK\n    text nom\n    text adresse\n    text tel\n    num taille\n    num adn\n    text sexe\n    text profession\n  }\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteRemarque\n\n\n\n\n\n\n\nerDiagram\n    %% INVENTAIRE ||--|| PRODUIT : produit_id \n    COMMANDE }o--|| PRODUIT  : produit_id\n    PRODUIT }o..|| CATEGORIE : categorie_id \n    FACTURE }o..|| CLIENT :client_id\n    LIGNE }o--|| FACTURE :facture_num\n    LIGNE }o..|| PRODUIT : produit_id \n\n  %% INVENTAIRE {\n  %%   num produit_id  PK, FK\n  %% }\n\n  CATEGORIE {\n    num categorie_id  PK\n    text nom \n  }\n\n  PRODUIT {\n    num produit_id PK\n    text description \n    num categorie_id FK\n    text gamme \n    text fabricant \n    num en_stock  \n    num vendus   \n\n  }\n\n\n  COMMANDE {\n    num produit_id  PK, FK\n    date date_com  PK\n    num qte \n    date date_liv  \n  }\n\n  FACTURE {\n    num facture_num  PK\n    num client_id   FK\n    date date_fac\n    num montant  \n  }\n\n  LIGNE {\n    num facture_num PK, FK\n    num num_lign PK\n    num produit_id  FK\n    num qte \n  }\n\n  CLIENT {\n    num client_id PK\n    text nom\n    text adresse\n    text tel\n    num taille\n    num adn\n    text sexe\n    text profession\n  }\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteProposition Chat-GPT 3.5\n\n\n\nLe lien entre inventaire et produit n’est pas décoré correctement, car il n’y a pas d’historicisation. Les liens sont tous présentés comme identifiants. Cela ne devrait pas être le cas. En dehors de cela c’est bon.\n\n\n\n\nerDiagram\n    Produit {\n        int product_id PK\n        string nom_produit\n        string description\n        int cat_id FK\n        string nom_gamme\n        float prix_unitaire\n    }\n    Categorie {\n        int cat_id PK\n        string description\n    }\n    Inventaire {\n        int product_id PK, FK\n        int en_stock\n        int vendus\n    }\n    Commande {\n        int commande_id PK\n        int product_id FK\n        date date_com\n        int qte\n        date date_liv\n    }\n    Client {\n        int client_id PK\n        string nom\n        string adresse\n        string telephone\n        int annee_naissance\n        string sexe\n        string profession\n        float taille\n    }\n    Facture {\n        int fact_id PK\n        int client_id FK\n        date date_fact\n        float montant\n    }\n    LigneFacture {\n        int fact_id FK\n        int num_ligne PK\n        int product_id FK\n        int qte\n        float montant\n    }\n\n    Produit ||--o{ Inventaire : \"est référencé dans\"\n    Produit ||--o{ Commande : \"est commandé dans\"\n    Produit ||--o{ LigneFacture : \"est lié à\"\n    Produit }o--|| Categorie : \"appartient à\"\n    Client ||--o{ Facture : \"émet\"\n    Facture ||--o{ LigneFacture : \"contient\"\n\n\n\n\n\n\n\n\nLe vélociste a explicité les contraintes suivantes:\n\nPour un même produit, les intervalles de temps [date_com, date_liv) correspondant à deux commandes différentes ne peuvent se recouvrir,\nUne gamme de produits appartient à un seul fabricant (Ultegra est une gamme de Shimano, Campagnolo et autres ne peuvent pas utiliser ce nom),\nDans une gamme donnée, un fabricant propose au plus un produit de catégorie donnée.\n\n\n\n\n\n\n\nNoteQuestion 4 (1pt)\n\n\n\n\nPréciser parmi ces contraintes, celles qui sont des dépendances fonctionnelles\nProposer un mécanisme pour mettre en place ces contraintes en SQL (langage de définition de données)\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\nLa contrainte de recouvrement est une contrainte d’exclusion (EXCLUDE). Ce n’est pas un dépendance fonctionnelle.\n\nALTER TABLE reappro \n  ADD CONSTRAINT xcl_prod \n  EXCLUDE USING gist (\n    product_id WITH =,\n    (date, date_liv) WITH && \n  ) ;\n\nLe fait qu’une gamme de produits appartient à un seul fabricant, définit une dépendance fonctionnelle gamme \\(\\rightarrow\\) fabricant. Cette contrainte peut aussi s’exprimer à l’aide d’une contrainte EXCLUDE\n\nALTER TABLE produit \n  ADD CONSTRAINT xcl_gamme_fabriquant \n  EXCLUDE USING gist (\n    gamme WITH =,\n    fabriquant WITH &lt;&gt; \n  ) ;\n\nLe fait que pour une gamme, un fabricant ne propose au plus un produit d’une catégorie donnée définit une contrainte gamme, fabricant, cat_id \\(\\rightarrow\\) produit_id. Cette contrainte est une dépendance fonctionnelle. Comme on a par ailleurs gamme \\(\\rightarrow\\) fabricant, on peut la simplifier en gamme, cat_id \\(\\rightarrow\\) produit_id.\n\nLà encore on peut utiliser la construction\nALTER TABLE produit \n  ADD CONSTRAINT xcl_gamme_cat_prod \n  EXCLUDE USING gist (\n    gamme WITH =,\n    cat_id WITH =,\n    produit_id WITH &lt;&gt; \n  ) ;\n\n\nOn suppose que le schéma est muni des dépendances fonctionnelles déduites de la question précédente et de celles qui se déduisent des contraintes de clé primaire. On note cet ensemble de dépendances fonctionnelles \\(\\Sigma\\).\n\n\n\n\n\n\nNoteQuestion 5 (2pts)\n\n\n\n\nPréciser pour chaque table si elle est en FNBC par rapport à \\(\\Sigma\\)\nSi un ou plusieurs tables ne sont pas en FNBC, proposer une décomposition sans perte d’information (SPI) telle que toutes les tables soient en FNBC.\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nLes tables qui ne possèdent pas de DF en dehors de celle impliquées par la donnée de la clé primaire sont en FNBC.\nLa table produit n’est pas en FNBC: le déterminant de gamme \\(\\rightarrow\\) fabricant n’est pas une super-clé. Les clés de produit sont product_id, et gamme, cat_id.\n\n\n\n\n\n\n\n\nNoteQuestion 6 (2pts)\n\n\n\nSoit le schéma \\(\\mathcal{A}\\) = {A, B,C, D, E,  G, H}.\nSoit Σ = {{D,E} \\(⟶\\) {F}, {H} \\(⟶\\) {B}, {B,C} \\(⟶\\) {D}, {C} \\(⟶\\) {E}, {D,F} \\(⟶\\) {H,A}} un ensemble de dépendances fonctionnelles.\nEst-ce que les dépendances fonctionnelles {B,C} \\(⟶\\) {F}, {C,H} \\(⟶\\) {D}, {B,C} \\(⟶\\) {G} sont impliquées par \\(Σ\\)? Autrement dit, a-t-on :\n\nΣ \\(⊧\\) {B,C} \\(⟶\\) {F},\nΣ \\(⊧\\) {C,H} \\(⟶\\) {D},\nΣ \\(⊧\\) {B,C} \\(⟶\\) {G} ?\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nPour répondre aux trois questions, suffit de vérifier si F et/ou G appartiennent à \\([\\{\\texttt{B,C}\\}]^+_\\Sigma\\), et si \\(D\\) appartient à \\([\\{\\texttt{C,H}\\}]^+_\\Sigma\\)\n\\[[\\{\\texttt{B,C}\\}]^+_\\Sigma = \\{\\texttt{B, C, D, E, F, H, A}\\}\\]\n\\[[\\{\\texttt{C,H}\\}]^+_\\Sigma = \\{\\texttt{C, H, B, E, D, F, A}\\}\\]\nLes réponses sont\n\nΣ \\(⊧\\) {B,C} \\(⟶\\) {F},\nΣ \\(⊧\\) {C,H} \\(⟶\\) {D},\nΣ \\(\\not\\models\\) {B,C} \\(⟶\\) {G} ?\n\n\n\n\n\n\n\n\n\n\nWarningAttention\n\n\n\nDans la suite, vous formulerez les requêtes dans le schéma relationnel défini par votre schéma en pattes de corbeau.\n : 1 point par requête\n\n\n\n\n\n\n\n\nNoteRequête 1\n\n\n\nLister pour chaque fabricant, chaque gamme, le nombre de produits proposés au catalogue.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT \n  fabricant, gamme, COUNT(produit_id) AS n_produit \nFROM \n  produit\nGROUP BY \n  fabricant, gamme ;\n\n\n\n\n\n\n\n\nNoteRequête 2\n\n\n\nLister pour chaque client, la somme des montants versés par ce client.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT \n  client_id, SUM(montant) AS somme_montants\nFROM \n  facture\nWHERE \n  montant IS NOT NULL\nGROUP BY \n  client_id ;\n\n\n\n\n\n\n\n\nNoteRequête 3\n\n\n\nOn cherche à détecter s’il existe des commandes de réapprovisionnement qui concernent un même produit et dont les intervalles de temps ([date_com, date_liv)) se chevauchent. Écrire une requête qui liste les paire de commandes qui posent problèmes. La requête donnera les numéros de commande, le produit concerné, et les dates de commande.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT \n  r1.produit_id,\n  r1.date, r1.date_liv,\n  r2.date, r2.date_liv\nFROM \n  reappro r1 JOIN\n  reappro r2 USING(produit_id)\nWHERE \n  r1.date &lt; r2.date     -- les deux commandes r1 et r2 sont distinctes ...\nAND \n  (r1.date, r1.date_liv) OVERLAPS\n  (r2.date, r2.date_liv)\n;\nIl ne faut pas oublier la condition r1.date &lt; r2.date pour\n\n\n\n\n\n\n\n\nNoteRequête 4\n\n\n\nLister les factures pour lesquelles on ne trouve aucune ligne de facture.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT DISTINCT\n  facture_id\nFROM\n  facture LEFT OUTER JOIN\n  ligne USING (facture_id)\nWHERE\n  num_ligne IS NULL;\n\n\n\n\n\n\n\n\nNoteRemarque\n\n\n\nOn pourrait aussi utiliser EXCEPT et faire la différence entre la projection de facture sur facture_id et la projection de ligne sur facture_id.\nEn revanche\nSELECT \n  facture_id\nFROM \n  ligne\nGROUP BY \n  facture_id\nHAVING COUNT(num_ligne) == 0 ;\nn’est pas une réponse correcte. Cette requête renvoie toujours un résultat vide.\n\n\n\n\n\n\n\n\nNoteRequête 5\n\n\n\nPour chaque mois, lister la catégorie de produits la plus vendue (en nombre d’articles).\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH R AS (\n  SELECT\n    EXTRACT(MONTH FROM fa.date) AS mois, pr.cat_id,\n    SUM(li.qte) AS qte_mois \n  FROM \n      facture fa\n    JOIN\n      ligne li USING (fact_id) \n    JOIN\n      produit pr USING (produit_id)\n  GROUP BY \n    EXTRACT(MONTH FROM fa.date), pr.cat_id\n)\n\nSELECT \n  r1.mois, r2.cat_id\nFROM \n  R AS r1\nWHERE \n  r1.qte &gt;= ALL (\n    SELECT \n      r2.qte\n    FROM\n      R AS r2\n    WHERE\n      r2.mois = r1.mois\n  )\n;\n\n\n\n\n\n\n\n\nNoteRequête 6\n\n\n\nLister les commandes de réapprovisionnement en cours.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT\n  produit_id, date, qte\nFROM \n  reappro \nWHERE \n  date_liv IS NULL ;\n\n\n\n\n\n\n\n\nNoteRequête 7\n\n\n\nLister les produits les plus vendus et les moins vendus dans chaque catégorie.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH R AS (\n  SELECT \n    pr.cat_id, pr.produit_id, SUM(li.qte) as tot_ventes\n  FROM \n      produit pr\n    JOIN\n      ligne li USING (product_id)\n  GROUP BY \n    cat_id, produit_id\n), S AS (\n  SELECT \n    cat_id, MAX(tot_ventes) AS max_ventes, MIN(tot_ventes) AS min_ventes\n  FROM \n    R\n  GROUP BY \n    cat_id\n)\n\nSELECT \n  r1.cat_id, r1.produit_id, r1.tot_ventes\nFROM \n  R r1\nWHERE \n  EXISTS (\n    SELECT \n      *\n    FROM\n      S s1\n    WHERE \n      s1.cat_id = r1.cat_id AND \n      r1.tot_ventes IN (s1.max_ventes, s1.min_ventes)\n  )\nORDER BY r1.cat_id ;\n\n\n\n\n\n\n\n\nNoteRequête 8\n\n\n\nLister les paires de clients qui habitent la même adresse.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT \n  c1.client_id, c2.client_id, c1.adresse\nFROM \n    client c1 \n  JOIN\n    client c2 ON (c1.client_id &lt; c2.client_id AND c1,adresse=c2.adresse)\n;\n\n\n\n\n\n\n\n\nNoteRequête 9\n\n\n\nLister pour chaque fabricant, les cinq produits les vendus.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH R AS (\n  SELECT \n    pr.produit_id, pr.fabricant, \n    RANK() OVER (PARTITION BY pr.fabricant ORDER BY SUM(li.qte) DESC) AS rnk\n  FROM\n    produit pr\n  JOIN \n    ligne li USING (produit_id)\n)\n\nSELECT \n  fabriquant, produit_id, rnk\nFROM \n  R\nWHERE \n  rnk &lt;=5\nORDER BY fabricant  ;\n\n\n\n\n\n\n\n\nNoteRequête 10\n\n\n\nLister pour chaque mois, les dix clients qui ont le plus dépensé.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH R AS (\n  SELECT\n    client_id,\n    EXTRACT(MONTH FROM fa.date) AS mois,\n    RANK() OVER (PARTITION BY EXTRACT(MONTH FROM fa.date), fa.client_id \n                 ORDER BY SUM(fa.montant) DESC)  AS rnk\n  FROM\n    facture fa\n)\n\nSELECT \n  R.mois, \n  R.client_id,\n  R.rnk\nFROM \n  R\nWHERE \n  R.rnk &lt;= 10\nORDER BY \n  R.mois, R.rnk\n;\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nLa réponse proposée au dessus est tordue. La suivante est plus pertinente.\nWITH R AS (\n  SELECT\n    client_id,\n    DATE_TRUNC('MONTH', fa.date) AS mois,\n    RANK() OVER (PARTITION BY DATE_TRUNC('MONTH', fa.date), fa.client_id \n                 ORDER BY SUM(fa.montant) DESC)  AS rnk\n  FROM\n    facture fa\n)\n\nSELECT \n  R.mois, \n  R.client_id,\n  R.rnk\nFROM \n  R\nWHERE \n  R.rnk &lt;= 10\nORDER BY \n  R.mois, R.rnk\n;\n\n\n\n\n\n\n\n\n\nEn PostgreSQL, pour définir un intervalle à l’aide de deux dates debut et fin, il suffit d’écrire (début, fin). L’intervalle ne contient pas la date de fin.\nPour tester l’intersection/le recouvrement de deux intervalles, on utilise l’opérateur OVERLAPS\nbd_2023-24=# SELECT \n  ('2025-01-03'::date, '2025-01-10'::date) OVERLAPS \n  ('2025-01-10'::date, '2025-01-15'::date)  ; \n overlaps \n----------\n false\n(1 row)\n\nbd_2023-24=# SELECT \n  ('2025-01-03'::date, '2025-01-10'::date) OVERLAPS \n  ('2025-01-09'::date, '2025-01-15'::date)  ; \n overlaps \n----------\n true\n(1 row)\n\n\n\n\n\n\n\n\n\nEn PostgreSQL, pour extraire le mois d’un objet dd de type date, vous pouvez utiliser EXTRACT(MONTH FROM dd). Le résultat est un entier entre 1 et 12, 1 pour janvier, …\npostgres=# SELECT \n  current_timestamp::date AS la_date, \n  EXTRACT( MONTH FROM current_timestamp::date) AS le_mois ;\n\n  la_date   | le_mois \n------------+---------\n 2025-01-03 |       1"
  },
  {
    "objectID": "exams/cc3-2024-12-13.html",
    "href": "exams/cc3-2024-12-13.html",
    "title": "MA15E045 - Automne 2025",
    "section": "",
    "text": "L3 MIASHS/Ingémath/METIS\nUniversité Paris Cité\nAnnée 2024-2025\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\nDans une métropole, un exploitant de vélos partagés cherche à archiver des informations concernant les vélos et les stations.\nChaque vélo est identifié par un numéro. Un vélo possède une date de mise en service, un type (électrique/mécanique). Un vélo possède éventuellement une date de retrait de service.\nUne station est identifiée par un numéro. Une station possède un nom. Une station possède une position (lattitude, longitude) et une altitude. Une station possède un nombre de fixe de bornes d’accrochages.\nUn trajet est effectué par un vélo entre un instant (timestamp) de départ et un instant d’arrivée. Un trajet part d’une station et arrive à une station (pas toujours différente).\n\n\n\n\n\n\nNoteQuestion\n\n\n\nProposer un diagrammme entité-association correspondant à cette modélisation.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\n\n\nER\n\n\n\nVelo\n\nVelo\n\n\n\ntrajet\n\ntrajet\n\n\n\nVelo--trajet\n\n0:n\n\n\n\nStation\n\nStation\n\n\n\nStation--trajet\n\n0:n  origine\n\n\n\nStation--trajet\n\n0:n  destination\n\n\n\nnum1\n\nnumero\n\n\n\nnum1--Velo\n\n\n\n\nnum2\n\nnumero\n\n\n\nnum2--Station\n\n\n\n\ntype\n\ntype\n\n\n\ntype--Velo\n\n\n\n\ndate-service\n\ndate-service\n\n\n\ndate-service--Velo\n\n\n\n\ndate-retrait\n\ndate-retrait\n\n\n\ndate-retrait--Velo\n\n\n\n\ndebut\n\ndebut\n\n\n\ndebut--trajet\n\n\n\n\nfin\n\nfin\n\n\n\nfin--trajet\n\n\n\n\nlattitude\n\nlattitude\n\n\n\nlattitude--Station\n\n\n\n\nlongitude\n\nlongitude\n\n\n\nlongitude--Station\n\n\n\n\nnom\n\nnom\n\n\n\nnom--Station\n\n\n\n\n\n\n\n\ntrajet est une association ternaire avec des cardinalités 0:n. C’est une association plusieurs-plusieurs.\n\n\n\n\n\n\n\n\nNoteRemarque(s)\n\n\n\nCe schéma ressemble beaucoup à celui des vols dans nycflights voir diapositives. Dans les deux schémas, une entité (aéroport, station) participe avec deux rôles distincts à une association\nEn science des données on parle de schéma en étoile (star schéma): un vol, une mission, un trajet est un événement (event) auquel participent des objets (vélo, avion, aéroport, station de vélib, etc). L’événement est –à première vue– une instance d’association. Cette association est dans les deux cas une association plusieurs-plusieurs et son arité est supérieure ou égale à trois.\nIl n’est pas utile de définir une entité position munie deux attributs lattitude et longitude. Pour lier position et station on est conduit à définir une association avec des cardinalités 1:1 (côté station) et 0:1 (côté position). Ce genre d’association gagne à être représenté par des attributs (rester simple, invoquer le rasoir d’Occam).\n\n\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nSi besoin, transformez votre schéme de façon à ce qu’il ne comporte plus d’associations d’arité supérieure ou égale à 3, ou d’associations plusieurs-plusieurs (0:n pour plusieurs entités participantes).\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\n\n\nER\n\n\n\nVelo\n\nVelo\n\n\n\nmany1\n\n\nutilise\n\n\n\nVelo--many1\n\n0:n\n\n\n\nStation\n\nStation\n\n\n\nmany2\n\n\norigine\n\n\n\nStation--many2\n\n0:n\n\n\n\nmany3\n\n\ndestination\n\n\n\nStation--many3\n\n0:n\n\n\n\nnum1\n\nnumero\n\n\n\nnum1--Velo\n\n\n\n\nnum2\n\nnumero\n\n\n\nnum2--Station\n\n\n\n\ntype\n\ntype\n\n\n\ntype--Velo\n\n\n\n\ndate-service\n\ndate-service\n\n\n\ndate-service--Velo\n\n\n\n\ndate-retrait\n\ndate-retrait\n\n\n\ndate-retrait--Velo\n\n\n\n\ndebut\n\ndebut\n\n\n\ntrajet\n\n\ntrajet\n\n\n\ndebut--trajet\n\n\n\n\nfin\n\nfin\n\n\n\nfin--trajet\n\n\n\n\nlattitude\n\nlattitude\n\n\n\nlattitude--Station\n\n\n\n\nlongitude\n\nlongitude\n\n\n\nlongitude--Station\n\n\n\n\nnom\n\nnom\n\n\n\nnom--Station\n\n\n\n\nmany1--trajet\n\n1:1\n\n\n\nmany2--trajet\n\n1:1\n\n\n\nmany3--trajet\n\n1:1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteRemarque\n\n\n\nConsidérer Trajet comme une entité est assez tentant. Si on le fait d’emblée, il faut se demander ce qui identifie les instances de cette entité. Beaucoup sont tentés d’introduire un identifiant artificiel trajet_id (de fait ce genre d’identifiant artificiel est facile à introduire lors de l’implémentation en PostGres, en MySQL, ou autre). On perd de vue que ce qui identifie un trajet, c’est un vélo, une station de départ et une heure de départ. Vu comme cela, Trajet apparaît comme une association ternaire plusieurs-plusieurs, qu’on se dépêche de transformer en entité faible. L’heure de départ est un identifiant relatif.\n\n\n\n\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nProposer une traduction en pattes de corbeau du diagramme EA proposé en réponse\nà la première question.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\nerDiagram\n    TRAJET }o--|| VELO : velo_num \n    TRAJET }o--|| STATION  : origin_num\n    TRAJET }o..|| STATION : dest_num \n\n  VELO {\n    integer num PK\n    text type \n    date mise_service_date\n    date retrait-date  \n  }\n\n  STATION {\n    integer num PK\n    numeric lat\n    numeric long\n    text name\n    integer docks \n  }\n\n  TRAJET {\n    integer velo_num PK, FK\n    integer origin_num PK, FK\n    integer dest_num FK\n    timestamp start PK\n    timestamp end \n  }\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteRemarque\n\n\n\nLe lien qui correspond à la contrainte référentielle entre TRAJET.dest_num et STATION.num n’est pas identifiant.\n\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nExplicitez d’éventuelles contraintes externes (si vous l’avez déjà fait en marge du diagramme entité-association, contentez-vous d’un renvoi).\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\nLa date de retrait de service d’un vélo ne peut pas précéder sa mise en service (CHECK)\nUn vélo ne peut pas être utilisé pour un trajet s’il nest pas en service (contrainte multitable, réalisable avec une fonction qui renvoie l’intervalle pendant lequel un vélo est en service et une contrainte CHECK qui vérifie que (start,end ) est inclus dans l’intervalle de service)\nLe début d’un trajet doit précéder sa fin (CHECK)\nUn même vélo ne peut pas effectuer deux trajets simultanément (EXCLUDE)\n\n\n\n\n\n\n\n\n\nNoteRemarque\n\n\n\nLes contraintes référentielles, les contraintes de clé sont déjà décrites par le diagramme. Il est inutile de les répéter. Ce ne sont pas des contraintes externes.\n\n\n\n\n\n\n\n\nWarningAttention\n\n\n\nDans la suite, vous formulerez les requêtes dans le schéma relationnel défini par votre schéma en pattes de corbeau.\n\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nPour chaque station, chaque heure de la journée, comptez le nombre de trajets partis de la station.\n\n\n\n\n\n\n\n\nPostgreSQL propose un type timestamp (qui permet de représenter les instants à la microseconde près). PostgreSQL propose une fonction fonction date_part(text, timestamp) qui permet d’extraire les différents composants d’un objet de type timestamp. date_part('month', timestamp) extrait le mois grégorien (un entier de 1 à 12), date_part('hour', timestamp) extrait l’heure du jour (un entier de 0 à 23).\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT \n  tr.origin_num, date_part('hour', start) AS heure,\n  count(*) AS n_trajet\nFROM \n  trajet tr\nGROUP BY \n  tr.origin_num, date_part('hour', start) ;\n\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nPour chaque vélo, comptez le nombre de trajets de plus d’une heure effectués.\n\n\n\n\n\n\n\n\nEn PostgreSQL, la différence de deux objets de type timestamp est un objet de type interval (durée). Pour définir une constante correspondant à une durée d’un jour, d’un mois, d’une heure, vous pouvez utiliser la syntaxe '1 day'::interval, '1 month'::interval, '1 hour'::interval.\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT\n  tr.velo_num,\n  count(*) AS nb_trajets\nFROM \n  trajet tr\nWHERE \n  (tr.end IS NOT NULL AND (tr.start - tr.end) &gt; '1 hour'::interval)   OR\n  (tr.end IS NULL AND (current_timestamp - tr.start) &gt; '1 hour'::interval)\nGROUP BY \n  tr.velo_num ;\n\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nPour chaque jour de la semaine, listez les quatre couples (station de départ, station d’arrivée) utilisés par le plus grand nombre de trajets ce jour de la semaine là.\n\n\n\n\n\n\n\n\nEn PostgreSQL, pour extraire le jour de la semaine d’un objet ts de type timestamp, vous pouvez utiliser EXTRACT(DOW FROM ts). Le résultat est un entier entre 0 et 6, 0 pour dimanche, 1 pour lundi, …, 7 pour samedi.\npostgres=# SELECT \n  current_timestamp as maintenant , \n  EXTRACT(DOW FROM current_timestamp + '1 day'::interval) as dow_demain ;\n\n          maintenant           | dow_demain \n-------------------------------+------------\n 2024-12-08 10:55:05.672936+01 |          1\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH R AS \n(\n   SELECT \n     EXTRACT(DOW FROM tr.start) AS jds, \n     tr.origin_num,  tr.dest_num, \n     COUNT(*) AS nb_trajets\n   FROM \n     trajet tr \n   GROUP BY\n     EXTRACT(DOW FROM tr.start), \n     tr.origin_num, \n     tr.dest_num\n), S AS \n(\n  SELECT \n    R.*, \n    RANK() OVER (PARTITION BY R.jds ORDER BY R.nb_trajets DESC) AS rnk\n  FROM \n    R\n)\n\nSELECT \n  S.*\nFROM \n  S\nWHERE S.rnk &lt;= 4 ;\n\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nSoit \\(\\mathcal{A} = \\{\\texttt{A, B, C, D, E, H, S, T}\\}\\) un schéma.\nSoit Σ = {{A, E} \\(⟶\\) {H}, {S, T} \\(⟶\\) {C, E}, {S} \\(⟶\\) {A}, {B} \\(⟶\\) {T}}\n\nQuelle est la fermeture de {B, S, E} ?\nQuelles sont les clés de \\(\\mathcal{A}, \\Sigma\\) ?\n\\(\\mathcal{A}, \\Sigma\\) est elle forme normale de Boyce-Codd ?\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\\(\\texttt{[B, S, E]}_{\\Sigma}^+ = \\{ \\texttt{B, S, E, T, C, A, H}\\} = \\{ \\texttt{A, B, C, E, H, S, T}\\}\\)\nToute clé contient \\(\\texttt{B, D, S}\\) qui est une super-clé \\([\\texttt{B, D, S}]^+_\\Sigma = \\{\\texttt{B, D, S, A, T, C, E, H}\\}\\). C’est la seule clé.\nLe schéma n’est pas en FNBC, toutes les DF de Σ ont un déterminant qui n’est pas une super-clé."
  },
  {
    "objectID": "exams/cc3-2022-11-13.html",
    "href": "exams/cc3-2022-11-13.html",
    "title": "MA15E045 - Automne 2025",
    "section": "",
    "text": "L3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2023-2024\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\nÉcrire une fonction SQL nommée cc_fonc_16 qui prend en argument une année p_year, un mois p_month un jour p_day et un aéroport de départ p_origin et renvoie une table de schéma\n(avg_temp float8, avg_visib float8,  avg_wind_speed float8, avg_month_temp float8)\nqui contient pour la journée définie par p_year, p_month et p_day, l’aéroport défini par p_origin, la température moyenne de la journée avg_temp, la visibilité moyenne de la journée avg_visib, la vitesse moyenne du vent avg_wind_speed de la journée, et la température moyenne du mois avg_month_temp.\nRéponse attendue pour :\nSELECT round(avg_temp::numeric, 2) AS avg_temp, \n       round(avg_visib::numeric, 2) AS avg_visib,\n       round(avg_wind_speed::numeric, 2) AS avg_wind_speed,\n       round(avg_month_temp::NUMERIC, 2) AS avg_month_temp\nFROM cc_fonc_16(2013, 2, 16, 'EWR');\n+--------+---------+--------------+--------------+\n|avg_temp|avg_visib|avg_wind_speed|avg_month_temp|\n+--------+---------+--------------+--------------+\n|   36.07|     9.71|         12.37|         34.26|\nCREATE OR REPLACE FUNCTION correction_cc3.cc_fonc_16(\n    p_year int4,  p_month int4, p_day int4, p_origin text)\n    RETURNS TABLE(avg_temp float8, avg_visib float8,  avg_wind_speed float8, avg_month_temp float8)\n    LANGUAGE sql\nAS $function$\nWITH v AS (\n    SELECT AVG(w.temp) AS avg_month_temp\n    FROM nycflights13.weather w \n    WHERE w.\"year\"=p_year AND w.\"month\"=p_month AND w.origin=p_origin\n),\nx AS (\n    SELECT AVG(w.temp) AS avg_temp,\n           AVG(w.visib) AS avg_visib,\n           AVG(w.wind_speed) AS avg_wind_speed\n    FROM nycflights13.weather w \n    WHERE w.\"year\"=p_year AND w.\"month\"=p_month AND w.\"day\"=p_day AND w.origin=p_origin\n) \nSELECT x.avg_temp, x.avg_visib, x.avg_wind_speed, v.avg_month_temp\nFROM x, v \n$function$ ;\n\nDonnées dans le schéma nycflights13.\nÉcrire une fonction SQL nommée cc_fonc_17 qui prend en argument un constructeur d’avion et qui renvoie une table de schéma\n(n_planes int8, n_carriers int8)\nchaque ligne donne pour chaque modèle vendu par le constructeur,\n\nle nombre d’avions de ce modèle qui ont circulé sur des vols domestiques partis de New York d’après la table flights\nle nombre de compagnies qui exploitent ce modèle (d’après la base nycflights13)\nle nombre de vols effectués par les exemplaires du modèle à partir de New York d’après la table flights\n\nRéponse attendue pour :\nSELECT * \nFROM cc_fonc_17('AIRBUS') \nWHERE model='A330-243' ;\n+--------+--------+----------+---------+\n|model   |n_planes|n_carriers|n_flights|\n+--------+--------+----------+---------+\n|A330-243|      14|         1|      342|\n\n\n\n\n\n\nTipsolution\n\n\n\nTODO\n\n\n\nDonnées dans le schéma nycflights13\nÉcrire une vue nommée cc_vue_18 de schéma\n(origin  text, time_hour timestamptz, flight int4, dep_delay float8, next_flight int4, next_dep_delay float8)\nPour chaque vol effectué f, la vue contient l’aéroport de départ (origin), la date et l’heure de départ programmée arrondie (time_hour), le numéro du vol flight, le retard au départ dep_delay, et aussi le numéro next_flight et le retard au départ du vol next_dep_delay, qui a décollé juste après le vol f du même aéroport de départ.\nRéponse attendue pour\nSELECT r.origin, r.time_hour::timestamp, r.flight, r.dep_time, r.dep_delay, r.next_flight, r.next_dep_delay\nFROM cc_vue_18 AS r \nWHERE  r.origin ='EWR' AND r.time_hour = to_timestamp('2013-01-01 06:00:00', 'YYYY-MM-DD HH:MI:SS') \nLIMIT 5 ;\n+------+-----------------------+------+--------+---------+-----------+--------------+\n|origin|time_hour              |flight|dep_time|dep_delay|next_flight|next_dep_delay|\n+------+-----------------------+------+--------+---------+-----------+--------------+\n|EWR   |2013-01-01 06:00:00.000|   507|     555|     -5.0|       1124|          -2.0|\n|EWR   |2013-01-01 06:00:00.000|  1124|     558|     -2.0|       1187|          -1.0|\n|EWR   |2013-01-01 06:00:00.000|  1187|     559|     -1.0|        343|           1.0|\n|EWR   |2013-01-01 06:00:00.000|   343|     601|      1.0|       1895|          -4.0|\n|EWR   |2013-01-01 06:00:00.000|  1895|     606|     -4.0|       1077|           0.0|\n\nNB: précision demandée pour la popularité 0.01\n\n\n\n\n\n\nTipsolution\n\n\n\nTODO\n\n\n\nDonnées dans le schéma nycflights13\nÉcrire une vue nommée cc_vue_19 de schéma:\n`(origin text, dest text, year int4, month int4, carrier text)\nPour chaque liaison (origin, dest), chaque mois (year, month), carrier contient le code de la compagnie du mois, celles dont le retard moyen à l’arrivée sur cette liaison, pendant ce mois est minimal.\nSELECT * \nFROM cc_vue_19 t\nWHERE t.origin='JFK' AND t.dest='ATL' \nORDER BY t.\"year\", t\"month\" \nLIMIT 5\n;\n+--------+------+------+-------+---------+\n| origin | dest | year | month | carrier |\n|--------+------+------+-------+---------|\n| JFK    | ATL  | 2013 | 1     | 9E      |\n| JFK    | ATL  | 2013 | 2     | DL      |\n| JFK    | ATL  | 2013 | 3     | DL      |\n| JFK    | ATL  | 2013 | 4     | DL      |\n| JFK    | ATL  | 2013 | 5     | DL      |\n\n\n\n\n\n\nTipsolution\n\n\n\nTODO\n\n\n\nDonnées dans le schéma babynames\nCréer une vue cc_vue_20 de schéma\n(origin TEXT, dest TEXT, flight int4, time_hour  TIMESTAMP, arr_delay , carrier TEXT, model TEXT, speedy_model TEXT, speedy_carrier TEXT)\nqui liste pour chaque vol de la table flights, l’aéroport de départ, l’aéroport de destination, la date et l’heure de départ prévues trinquée à l’heure (time_hour), le modèle (model) de l’avion, sa compagnie (carrier), son retard à l’arrivée, ainsi que pour un des vols les plus rapides sur cette liaison pendant le mois défini par time_hour, le modèle speedy_model et la compagnie speedy_carrier.\n\n\n\n\n\n\nTipsolution\n\n\n\nTODO"
  },
  {
    "objectID": "exams/cc3-2022-10-21.html",
    "href": "exams/cc3-2022-10-21.html",
    "title": "MA15E045 - Automne 2025",
    "section": "",
    "text": "L3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2023-2024\nCourse Homepage\n\nMoodle"
  },
  {
    "objectID": "exams/cc3-2022-10-21.html#popularité",
    "href": "exams/cc3-2022-10-21.html#popularité",
    "title": "MA15E045 - Automne 2025",
    "section": "Popularité",
    "text": "Popularité\n\n\n\n\n\n\nNoteQuestion\n\n\n\nÉcrire une fonction SQL nommée top_k_names_by_year qui prend en argument une année yyyy et un entier n et renvoie une table (name TEXT, sex integer, rank integer) qui contient, selon la table babynames.bebes, les k prénoms les plus populaires (attribués) de l’année yyyy pour chaque sexe.\n\n\n\n\n\n\n\n\nRéponse attendue pour SELECT * FROM top_k_names_by_year(1950, 5); :\n+----+---------+----+\n|F   |MARIE    |   1|\n|F   |MARTINE  |   2|\n|F   |FRANÇOISE|   3|\n|F   |MONIQUE  |   4|\n|F   |NICOLE   |   5|\n|H   |JEAN     |   1|\n|H   |MICHEL   |   2|\n|H   |ALAIN    |   3|\n|H   |GÉRARD   |   4|\n|H   |BERNARD  |   5|\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nPremière question posée au chatbot :\nFor every year and sex, find the 5 most popular names.\nRéponse :\nTo find the 5 most popular names for each year and sex \nin the babynames.bebes table, you can use `ROW_NUMBER()`. \nHere's a query that retrieves the top 5 names \nfor each combination of year and sex:\nWITH RankedNames AS (\n    SELECT\n        name, year, sex, count,\n        ROW_NUMBER() OVER (PARTITION BY year, sex ORDER BY count DESC) AS rank\n    FROM\n        babynames.bebes\n)\n\nSELECT\n    name, year, sex, count\nFROM\n    RankedNames\nWHERE\n    rank &lt;= 5\nORDER BY\n    year, sex, rank;\nExplanation:\n\n- The `ROW_NUMBER()` function ranks names \nwithin each `year` and `sex` partition,   \nordered by the `count` of babies in descending order.\n- The `PARTITION BY year, sex` groups the data by each year and sex.\n- The `ORDER BY count DESC` ensures that the most popular names \n(with the highest counts) are ranked first.\n- In the `WHERE` clause, we filter for the top 5 names (`rank &lt;= 5`) \nfor each year and sex.\n\nThis query will return the most popular 5 names \nfor both males and females for each year in the dataset.\n\n\n\n\n\n\n\n\nTipSolution (suite)\n\n\n\nPour définir la fonction, on peut demander de l’aide au chatbot:\nDesign a sql function that takes as input a year y and an integer k, \nand returns a table wih columns name, sex and rank \ncontaining the k most popular names in year y for each sex\nLa réponse est\nCREATE OR REPLACE FUNCTION top_k_names_by_year(y INT, k INT)\nRETURNS TABLE(name VARCHAR(500), sex INT, rank INT) AS $$\nBEGIN\n    RETURN QUERY\n    WITH RankedNames AS (\n        SELECT\n            name, sex, count,\n            ROW_NUMBER() OVER (PARTITION BY sex ORDER BY count DESC) AS rank\n        FROM\n            babynames.bebes\n        WHERE\n            year = y\n    )\n    SELECT\n        name, sex, rank\n    FROM\n        RankedNames\n    WHERE\n        rank &lt;= k\n    ORDER BY\n        sex, rank;\nEND;\n$$ LANGUAGE plpgsql;\n\n\n\n\n\n\n\n\nTipSolution (suite)\n\n\n\nEn insistant pour obtenir une fonction SQL on obtient:\nSure! If you'd prefer a **pure SQL function** (without using PL/pgSQL), \nhere's how you can implement it. In PostgreSQL, you can create \na function using SQL that performs the required query:\nCREATE OR REPLACE FUNCTION top_k_names_by_year(y INT, k INT)\nRETURNS TABLE(name VARCHAR(500), sex INT, rank INT) AS $$\n    WITH RankedNames AS (\n        SELECT\n            name, sex, count,\n            ROW_NUMBER() OVER (PARTITION BY sex ORDER BY count DESC) AS rank\n        FROM\n            babynames.bebes\n        WHERE\n            year = y\n    )\n    SELECT\n        name, sex, rank\n    FROM\n        RankedNames\n    WHERE\n        rank &lt;= k\n    ORDER BY\n        sex, rank;\n$$ LANGUAGE sql;\n\n\n\n\n\n\n\n\nTipSolution (suite)\n\n\n\n\nExplanation:\n- **Function Definition:**\n  - The function `top_k_names_by_year` accepts  \n  two parameters: `y` (year) and `k` (number of top names).\n  - It returns a table with three columns:  \n  `name` (name of the baby),  \n  `sex` (gender: 1 for male, 2 for female), and  \n  `rank` (the rank of the name by popularity).\n\n- **WITH Clause:**\n  - The `WITH RankedNames AS` clause ranks names \n  by the count of babies for each sex \n  in the specified year (`y`) using the `ROW_NUMBER()` window function. \n  It partitions by `sex` and orders by `count DESC` to assign ranks \n  starting from the most popular.\n\n- **WHERE Clause:**\n  - The main query filters for names with a rank less \n  than or equal to `k` to get only the top `k` names for each sex.\n\n- **Language:**\n  - The function is written in **pure SQL** (as specified by `LANGUAGE sql`).\n\nThis SQL function will return the top `k` names for each sex in the specified year (`y`)."
  },
  {
    "objectID": "exams/cc3-2022-10-21.html#nombre-de-naissancessex-ratio",
    "href": "exams/cc3-2022-10-21.html#nombre-de-naissancessex-ratio",
    "title": "MA15E045 - Automne 2025",
    "section": "Nombre de naissances/sex ratio",
    "text": "Nombre de naissances/sex ratio\nDonnées dans le schéma babynames.\n\n\n\n\n\n\nNoteQuestion\n\n\n\nÉcrire une fonction SQL nommée sex_ratio qui prend en argument une année yyyy et renvoie le rapport entre le nombre total de naissances féminines et le nombre total de naissances masculines cette année là selon la table babynames.bebes.\n\n\n\n\n\n\n\n\nRéponse attendue pour SELECT * FRON sex_ratio(1922);\n+-----------+\n| sex_ratio |\n+-----------+\n|   1.05    |\nNB: précision demandée : 0.1\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH R AS (\n   SELECT year, sex, SUM(\"count\") AS n \n   FROM bebes\n   GROUP BY year, sex\n)\n \nSELECT r1.\"year\", \n       (r1.n::float/r2.n::float)::decimal(3,2) AS sex_ratio\nFROM R r1 JOIN R r2 ON (\n     r1.\"year\"=r2.\"year\" AND\n     r1.sex &lt; r2.sex\n) ;\nPour calculer une ligne du résultat final, il faut combiner deux lignes concernant la même année mais deux sexes différents de la table intermédiaire R. La jointure réalise en passant une opération de pivot.\n\n\n\n\n\n\n\n\nTipSolution (suite)\n\n\n\ncreate or replace function sex_ratio(p_y INT)\n  returns DECIMAL(3,2) as \n$$\nwith R as (\n  select\n    b.sex,\n    SUM(b.\"count\") as n\n  from\n    babynames.bebes as b\n  where\n    b.\"year\" = p_y\n  group by\n    b.sex\n)\n\nselect\n  (r1.n::float / r2.n::float)::decimal(3,1) as sex_ratio\nfrom\n  R r1\njoin R r2 on\n  (r1.sex &lt; r2.sex) ;\n$$ language sql;\n\n\n\n\n\n\n\n\nTipSolution (suite)\n\n\n\nQuestion posée au chatbot :\nCan you design a pure SQL function that takes as input a year y \nand returns the sex ratio for that year ?\nRéponse:\n\nYes, I can design a pure SQL function to calculate the sex ratio \nfor a given year in the babynames.bebes table. \nThe sex ratio is typically defined as the number of males (sex = 1) \nper 100 females (sex = 2).\n\n\n\n\n\n\n\n\nTipSolution (suite)\n\n\n\nCREATE OR REPLACE FUNCTION get_sex_ratio(y INT)\nRETURNS DECIMAL(3,2) AS $$\n    SELECT \n        CASE \n            WHEN SUM(CASE WHEN sex = 2 THEN count ELSE 0 END) = 0 THEN NULL\n            ELSE \n                ((SUM(CASE WHEN sex = 1 THEN count ELSE 0 END))::float /\n                SUM(CASE WHEN sex = 2 THEN count ELSE 0 END)::float)::decimal(3,2)\n        END AS sex_ratio\n    FROM \n        babynames.bebes\n    WHERE \n        year = y;\n$$ LANGUAGE sql;\nCette solution évite un GROUP BY et une JOINTURE. L’utilisation de CASE WHEN ... THEN ... ELSE ... permet de calculer les deux agrégations et de les combiner en une seule passe sur la table filtrée."
  },
  {
    "objectID": "exams/cc3-2022-10-21.html#popularité-relative-et-rang-de-popularité",
    "href": "exams/cc3-2022-10-21.html#popularité-relative-et-rang-de-popularité",
    "title": "MA15E045 - Automne 2025",
    "section": "Popularité relative et rang de popularité",
    "text": "Popularité relative et rang de popularité\nDonnées dans le schéma babynames\n\n\n\n\n\n\nNoteQuestion\n\n\n\nÉcrire une vue nommée popularity de schema\n(sex text, name text, year integer, rank integer, popularity numeric)\nqui donne pour chaque prénom, année, sexe, la popularité relative (nombre sur nombre total de naissance de ce sexe cette année là) et le rang par popularité décroissante.\n\n\n\n\n\n\n\n\nRéponse attendue pour\nSELECT *\nFROM popularity\nWHERE name='THÉO' AND\n      sex = 1 AND\n      \"year\" &gt;1999 AND\n      \"year\" &lt; 2005;\n+----+------+-----+----+----------+\n|sex |name  | year|rank|popularity|\n+----+------+-----+----+----------+\n|1   |THÉO  | 2000|   6|     0.019|\n|1   |THÉO  | 2001|   6|     0.022|\n|1   |THÉO  | 2002|   5|     0.022|\n|1   |THÉO  | 2003|   5|     0.020|\n|1   |THÉO  | 2004|   7|     0.016|\nNB: précision demandée pour la popularité 0.01\n\n\n\n\n\n\n\n\n\nTipsolution\n\n\n\nQuestion posée au chatbot :\nCan you define a view with schema \n(sex text, name text, year integer, rank integer, popularity numeric) \nwhere popularity is the proportion of babies with given sex \nwho were named by name during year and rank is the rank of the name \nwhen ordering by decreasing popularity. \nRéponse du chatbot :\nCREATE OR REPLACE VIEW name_popularity_view AS\nWITH TotalBySexYear AS (\n    -- Calculate the total number of babies by sex and year\n    SELECT\n        sex,\n        year,\n        SUM(count) AS total_babies\n    FROM\n        babynames.bebes\n    GROUP BY\n        sex, year\n),\nRankedNames AS (\n    -- Calculate the popularity and rank the names by decreasing popularity\n    SELECT\n        CASE \n            WHEN b.sex = 1 THEN 'Male'\n            WHEN b.sex = 2 THEN 'Female'\n        END AS sex,\n        b.name,\n        b.year,\n        (b.count::numeric / t.total_babies) AS popularity,\n        ROW_NUMBER() OVER (PARTITION BY b.sex, b.year \n                           ORDER BY b.count DESC) AS rank\n    FROM\n        babynames.bebes b\n    JOIN\n        TotalBySexYear t ON b.sex = t.sex AND b.year = t.year\n)\n-- Final selection for the view\nSELECT\n    sex,\n    name,\n    year,\n    rank,\n    popularity\nFROM\n    RankedNames;"
  },
  {
    "objectID": "exams/cc3-2022-10-21.html#les-riches-et-les-pauvres-dans-world",
    "href": "exams/cc3-2022-10-21.html#les-riches-et-les-pauvres-dans-world",
    "title": "MA15E045 - Automne 2025",
    "section": "Les riches et les pauvres dans world",
    "text": "Les riches et les pauvres dans world\nDonnées dans le schéma world\n\n\n\n\n\n\nNoteQuestion\n\n\n\nÉcrire une vue nommée ricchi_e_poveri de schéma:\n(region TEXT,\n min_gnp_cap NUMERIC, poorest_country_name TEXT,\n max_gnp_per_cap NUMERIC, richest_country_name TEXT)\noù chaque ligne indique pour une région donnée, le minimum du PIB (gnp) par habitant, un des pays de la région où ce minimum est réalisé, le maximum du PIB par habitant et un des pays où ce maximum est réalisé.\n\n\n\n\n\n\n\n\nSELECT region, richest_country, poorest_country\nFROM ricchi_e_poveri\nWHERE region='Eastern Asia' ;\n+------------+---------------+---------------+\n|region      |richest_country|poorest_country|\n+------------+---------------+---------------+\n|Eastern Asia|Japan          |North Korea    |\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nQuestion posée au chatbot:\nIn the world schema, can you build a view ricchi_e_poveri \nwith schema (region TEXT,\nmin_gnp_cap NUMERIC, poorest_country_name TEXT,\nmax_gnp_per_cap NUMERIC, richest_country_name TEXT) \nwhich,  for each region, contains the minimum gnp per capita, \nthe name of the country in the region \nwith the minimum gnp per capita (poorest country), \nthe maximum gnp per capita in the region, \nthe name of the country with maximum gnp per capita \nin the region (richest country). \n\nCountries with zero or no population should not be considered.  \n\n\n\n\n\n\n\n\nTipSolution (suite)\n\n\n\nCREATE OR REPLACE VIEW world.ricchi_e_poveri AS\nWITH GnpPerCapita AS (\n    -- Calculate GNP per capita for countries with valid population and GNP\n    SELECT\n        region,\n        name_country,\n        gnp / population_country AS gnp_per_capita\n    FROM\n        world.country\n    WHERE\n        population_country &gt; 0 -- Exclude countries with zero or no population\n        AND gnp IS NOT NULL -- Exclude countries with no GNP data\n)\nSELECT\n    region,\n    MIN(gnp_per_capita) AS min_gnp_cap, -- Minimum GNP per capita for the region\n    (SELECT name_country FROM GnpPerCapita g2 \n     WHERE g2.region = g1.region \n     ORDER BY gnp_per_capita ASC LIMIT 1) AS poorest_country_name, -- Country with minimum GNP per capita\n    MAX(gnp_per_capita) AS max_gnp_per_cap, -- Maximum GNP per capita for the region\n    (SELECT name_country FROM GnpPerCapita g2 \n    WHERE g2.region = g1.region \n    ORDER BY gnp_per_capita DESC LIMIT 1) AS richest_country_name -- Country with maximum GNP per capita\nFROM\n    GnpPerCapita g1\nGROUP BY\n    region;"
  },
  {
    "objectID": "exams/cc3-2022-10-21.html#fenêtre-glissante-sur-les-bébés",
    "href": "exams/cc3-2022-10-21.html#fenêtre-glissante-sur-les-bébés",
    "title": "MA15E045 - Automne 2025",
    "section": "Fenêtre glissante sur les bébés",
    "text": "Fenêtre glissante sur les bébés\nDonnées dans le schéma babynames\n\n\n\n\n\n\nNoteQuestion\n\n\n\nCréer une vue sliding_avg_count de schéma (name    TEXT, sex TEXT, year INTEGER, avg_count NUMERIC) qui, pour chaque prénom (name), sexe (sex) et année (year), donne le nombre moyen (average count, avg_count) d’attributions du prénom aux enfants du sexe en question durant l’intervalle formé par les deux années qui précèdent et les deux années qui suivent l’année courante (incluses).\n\n\navg_count est un exemple de moyenne mobile ou glissante.\n\n\n\n\n\n\nSELECT *\nFROM sliding_avg_count\nWHERE \"name\"  ='PATRICK' AND\n      \"year\" BETWEEN 1955 AND 1960 ;\n+-------+----+-----+---------+\n|name   |sex | year|avg_count|     \n+-------+----+-----+---------+\n|PATRICK|F   | 1959|     3.00|\n|PATRICK|H   | 1955| 20381.00|\n|PATRICK|H   | 1956| 20673.80|\n|PATRICK|H   | 1957| 20532.20|\n|PATRICK|H   | 1958| 20173.80|\n|PATRICK|H   | 1959| 19443.20|\n|PATRICK|H   | 1960| 18479.60|\n\n\n\nLa manière la plus simple de répondre à cette question 10 est d’utiliser une fenêtre glissante. Les fenêtres glissantes étendent les fenêtres définies par PARTITION BY ... ORDER BY ....\nLa syntaxe de l’invocation des fonctions fenêtres est décrite dans la documentation PostgreSQL.\nL’invocation d’une fonction opérant sur une fenêtre suit la forme :\nfunction_name ([expression [, expression ... ]])\n      [ FILTER ( WHERE filter_clause ) ]\n      OVER ( window_definition )\n\n-- OU\n\nfunction_name ( * )\n      [ FILTER ( WHERE filter_clause ) ]\n      OVER ( window_definition )\nNous n’avons pas eu besoin d’utiliser la clause FILTER (WHERE filter_clause)\nLa définition de la fenêtre window definition est de la forme\n[ PARTITION BY expression [, ...] ]\n[ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]\n[ frame_clause ]\nRappel : une expression entre [] est optionnelle.\nLa dernière clause optionnelle frame_clause permet de calculer des fenêtres glissantes et d’autres types de fenêtres. Elle peut se décliner en\n{ RANGE | ROWS | GROUPS } frame_start [ frame_exclusion ]\n{ RANGE | ROWS | GROUPS } BETWEEN frame_start AND frame_end [ frame_exclusion ]\noù frame_start (début du cadre/de la fenêtre) peut prendre les formes suivantes :\nUNBOUNDED PRECEDING  -- ou\noffset PRECEDING  -- ou\nCURRENT ROW   --ou\noffset FOLLOWING  -- ou\nUNBOUNDED FOLLOWING  -- ou\nframe_end se définit de la même manière.\nSi on veut calculer le nombre cumulé d’attributions d’un prénom depuis l’origine des temps on pourra procéder ainsi:\nWITH R AS (\nSELECT \"name\", sex, \"year\", SUM(\"count\")\n      OVER (PARTITION BY \"name\"  , sex\n            ORDER BY \"year\"\n            RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)\n      as cumule\nFROM babynames.bebes\n)\n\nSELECT * FROM R\nWHERE \"name\"   IN ('PATRICK', 'MICHEL') ;  -- pour limiter la taille du résultat\n\n\n\n\n\n\nTipSolution\n\n\n\nQuestion posée au chatbot\nIn schema babynames, design a view with schema \n(name    TEXT, sex TEXT, year INTEGER, avg_count NUMERIC)  \nwhere `avg_count` represents the moving average of `count` for the given `name` and `sex` where average should be computed from the 2 years preceding and following the current `year`, including the current `year`.\n\n\n\n\n\n\n\n\nTipSolution (suite)\n\n\n\nRéponse du chatbot :\nTo design the view with schema \n`(name TEXT, sex TEXT, year INTEGER, avg_count NUMERIC)`\nthat computes a moving average of `count` for the given `name` and `sex`, including the 2 years preceding and following the current `year` (5-year window), the SQL query would look like this:\n\nSteps:\nDefine the window: The average should be computed over the 2 years before, the current year, and 2 years after (a total of 5 years).\nPartition by name and sex: This ensures that the moving average is calculated independently for each combination of name and sex.\nApply a windowing function: Use AVG() with a window frame of 2 rows preceding and 2 rows following.\n\n\n\n\n\n\n\n\nTipSolution (suite)\n\n\n\nCREATE OR REPLACE VIEW name_avg_count AS\nSELECT\n    name,\n    sex,\n    year,\n    AVG(count) OVER (\n        PARTITION BY name, sex \n        ORDER BY year \n        ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING\n    ) AS avg_count\nFROM\n    babynames;"
  },
  {
    "objectID": "exams/cc2-2024-11-15.html",
    "href": "exams/cc2-2024-11-15.html",
    "title": "MA15E045 - Automne 2025",
    "section": "",
    "text": "L3 MIASHS/Ingémath/METIS\nUniversité Paris Cité\nAnnée 2024-2025\nCourse Homepage\n\nMoodle"
  },
  {
    "objectID": "exams/cc2-2024-11-15.html#schéma-pagila",
    "href": "exams/cc2-2024-11-15.html#schéma-pagila",
    "title": "MA15E045 - Automne 2025",
    "section": "Schéma pagila ",
    "text": "Schéma pagila \n\nLister la somme des paiments encaissés par année et par magasin.\n\n\n\n\n\n\n\nEn PostgreSQL, on obtient le (numéro du) mois à partir d’une valeur de type timestamp avec la fonction EXTRACT(). On peut extraire les autres éléments de l’estampille de façon semblable, par exemple :\nSELECT \n  EXTRACT(YEAR FROM rental_date) AS annee\nFROM \n  pagila.rental;\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT \n  st.store_id,\n  EXTRACT(YEAR FROM pay.payment_date) AS annee,\n  SUM(amount) AS payments\nFROM \n  pagila.payment pay \nJOIN \n  pagila.staff st USING(staff_id)\nGROUP BY \n  st.store_id, \n  EXTRACT(YEAR FROM pay.payment_date)\n;\n\n\n\nLister l’identifiant, le nom, le prénom, de chaque employé ainsi que le total des paiements perçus par cet employé, et sa part dans le revenu de son magasin.\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT \n  st.store_id,\n  st.staff_id,\n  SUM(pay.amount) AS encaisse\nFROM  \n  pagila.staff st\nJOIN \n  pagila.payment pay USING(staff_id)\nGROUP BY ROLLUP(st.store_id, st.staff_id) ;   \n\n\n\n\nLister par catégorie de film, les cinq titres qui ont engendré le plus gros chiffre d’affaire/revenu (somme des paiements perçus)\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH film_payment AS (\n   SELECT\n     film_id, \n     fi.title,\n     SUM(amount) AS caffaires\n   FROM\n     pagila.payment pay \n   JOIN \n     pagila.rental re USING(rental_id)\n   JOIN \n     pagila.inventory inv USING(inventory_id)\n   JOIN \n     pagila.film fi USING(film_id)\n   GROUP BY \n     film_id, fi.title\n), rank_per_cat AS (\n  SELECT \n    category_id,\n    ca.name, \n    film_id,\n    title, \n    caffaires,\n    RANK() OVER win AS rnk\n  FROM \n    film_payment fp \n  JOIN  \n    pagila.film_category fc USING(film_id)\n  JOIN\n    pagila.category ca USING(category_id)\n  WINDOW win AS (PARTITION BY category_id ORDER BY caffaires DESC)\n)\n\nSELECT \n  name, \n  title, \n  caffaires, \n  rnk\nFROM rank_per_cat\nWHERE rnk &lt;= 5\nORDER BY name, rnk\n;"
  },
  {
    "objectID": "exams/cc2-2024-11-15.html#schéma-world",
    "href": "exams/cc2-2024-11-15.html#schéma-world",
    "title": "MA15E045 - Automne 2025",
    "section": "Schéma world ",
    "text": "Schéma world \n\nLister pour chaque pays, la proportion de la population qui utilise l’une des deux langues les plus populaires du pays,\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH ranking AS (\n   SELECT \n     countrycode, name_country, language, percentage,\n     RANK() OVER win AS rnk\n   FROM \n     world.country co\n   JOIN \n     world.countrylanguage cl USING(countrycode)\n   WINDOW \n     win AS (PARTITION by countrycode ORDER BY percentage DESC)\n) \n\nSELECT\n  countrycode, name_country, \n  SUM(percentage) AS prop\nFROM \n  ranking\nWHERE \n  rnk &lt;= 2\nGROUP BY countrycode, name_country \nORDER BY prop DESC;\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\n\nLister pour chaque région (attribut region de country) les 10 villes les plus peuplées.\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH R AS (\n   SELECT \n     co.countrycode, co.name_country,\n     ci.name,\n     RANK() OVER win AS rnk\n   FROM \n     world.country co\n   JOIN \n     world.city ci USING(countrycode)\n   WINDOW win AS (PARTITION BY co.countrycode ORDER BY ci.population DESC)\n )\n \nSELECT\n  name_country, \n  string_agg(name, ', ')\nFROM \n  R\nWHERE rnk &lt;= 2\nGROUP BY countrycode, name_country\n ;\n\n\n\n\nLister pour chaque langue, les deux pays où on trouve le plus grand nombre d’utilisateurs.\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH R AS (\n   SELECT \n     language, \n     name_country, \n     percentage*population_country/100.0 AS pop_loc,\n     RANK() OVER win AS rnk \n   FROM \n     world.countrylanguage cl \n   NATURAL JOIN \n     world.country\n   WHERE \n     population_country IS NOT NULL\n   WINDOW win AS (PARTITION BY language ORDER BY percentage*population_country DESC)\n)\n\nSELECT \n  language, \n  string_agg(name_country, ', ') AS pays, SUM(pop_loc) AS loc \nFROM \n  R \nWHERE rnk &lt;=  2\nGROUP BY language ;\n\n\n\nLister les pays en donnant leur rang par gnp (pnb) par habitant décroissant et leur rang par espérance de vie à la naissance (lifeexpectancy) décroissante.\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT \n  name_country, \n  lifeexpectancy , \n  RANK() OVER win_gnp AS rnk_gnppercap,\n  RANK() OVER win_life AS rnk_lifeexp\nFROM \n  world.country\nWHERE \n  gnp IS NOT NULL AND \n  population_country IS NOT NULL AND \n  lifeexpectancy IS NOT NULL\nWINDOW \n  win_gnp AS (ORDER BY gnp/population_country DESC),\n  win_life AS (ORDER BY lifeexpectancy DESC)\nORDER BY lifeexpectancy DESC ;"
  },
  {
    "objectID": "exams/cc2-2022-11-25.html",
    "href": "exams/cc2-2022-11-25.html",
    "title": "MA15E045 - Automne 2025",
    "section": "",
    "text": "L3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2022-2023\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\nSur le serveur bd_2023 hébergé par etu-pgsql, dans votre schéma personnel, créer les vues correspondant aux cinq questions suivantes.\n\nQuestion 1\nSchéma nycflights13\nCréer dans votre schéma personnel une vue nommée cc2_vue_1 de schéma (n integer) qui répond à la question : combien de vols sont arrivés avec un retard d’au moins une heure en partant à l’heure de l’aéroport JFK ?\n\n\n\n\n\n\nTipsolution\n\n\n\nCREATE OR REPLACE MATERIALZED VIEW foobar42.v_1 AS (\nWITH A as (\n    SELECT * FROM nycflights13.flights AS f\n    WHERE f.origin = 'JFK'\n    AND f.arr_delay &gt;= 60\n    AND f.dep_delay &lt;= 0\n) SELECT COUNT(*)::integer AS n\nFROM A \n);\n\n\n\nQuestion 2\nSchéma nycflights13\nCréer dans votre schéma personnel une vue nommée cc2_vue_2 de schéma (n integer) qui répond à la question : Combien de modèles différents ont été faits par la compagnie BOEING ?\n\n\n\n\n\n\nTipsolution\n\n\n\nCREATE OR REPLACE VIEW cc2_vue_2 AS (\nSELECT COUNT(distinct model)::integer  AS N\nFROM nycflights13.planes\nGROUP BY manufacturer\nHAVING manufacturer = 'BOEING'\n);\n\n\n\nQuestion 3\nSchéma babynames\nCréer dans votre schéma personnel une vue nommée cc2_vue_3 de schéma (prenom TEXT) qui répond à la question :\nQuels sont les prénoms donnés durant toutes les décennies pour lesquelles la base de données comporte des informations, sans doublon, par ordre alphabétique.\n844 lignes attendues (dont _PRENOMS_RARES)\n\n\n\n\n\n\nTipsolution\n\n\n\nWITH decennie AS (\n    SELECT COUNT(DISTINCT annee/10) AS nb F\n    ROM bebes)\nSELECT DISTINCT prenom \nFROM bebes \nGROUP BY prenom \nHAVING COUNT(DISTINCT annee/10)=(SELECT nb FROM decennie) \nORDER BY prenom ;\n\n\n\nQuestion 4\nSchéma ou babynames\nCréer dans votre schéma personnel une vue nommée cc2_vue_4 de schéma (prenom, n_feminin, n_masculin) qui contient les prénoms mixtes, c’est-à-dire les prénoms attribués plus de 5000 fois à des filles et à des garcons (MARIE a été attribué 26897 fois à des petits garcons). n_feminin représente le nombre total d’attributions du prénom à des filles et n_masculin représente le nombre total d’attributions du prénom à des garcons.\nVotre vue contiendra (entre autres) la ligne :\n+---------+---------+----------+\n|prenom   |n_feminin|n_masculin|\n+---------+---------+----------+\n| ...     | ...     | ...      |\n|MARIE    |  2232238|     26897|\n| ...     | ...     | ...      |\n| ...     | ...     | ...      |\n\nQuestion 5\nSchéma nycflights13\nCréer dans votre schéma personnel une vue nommée cc2_vue_5 de schéma (name text) qui répond à la question : Quelles sont les noms des destinations accessibles par un vol direct depuis toutes les origines ?\n\n\n\n\n\n\nTipsolution\n\n\n\nWITH r AS (\n    SELECT f.dest\n    FROM nycflights13.flights f   \n    GROUP BY f.dest \n    HAVING COUNT(DISTINCT f.origin) &gt;= ALL \n      (SELECT COUNT(DISTINCT f2.origin) \n       FROM nycflights13.flights f2 )\n)\nSELECT a.\"name\"::text \nFROM nycflights13.airports a JOIN r ON (a.faa = r.dest) ;\n\n\n42 lignes attendues"
  },
  {
    "objectID": "exams/cc1-2025-10-17-eng.html",
    "href": "exams/cc1-2025-10-17-eng.html",
    "title": "CC1 du 17 octobre 2025 - English translation",
    "section": "",
    "text": "L3 MIASHS/Ingémath/METIS\nUniversité Paris Cité\nCourse Homepage"
  },
  {
    "objectID": "exams/cc1-2025-10-17-eng.html#presentation-of-the-database",
    "href": "exams/cc1-2025-10-17-eng.html#presentation-of-the-database",
    "title": "CC1 du 17 octobre 2025 - English translation",
    "section": "Presentation of the database",
    "text": "Presentation of the database\nAll the questions concern a hotel database used by a hotel to manage its reservations.\nFor each relationship (table), we indicate its schema with the type of each attribute in the form attribute_name: type.\nBy default, NULL values are allowed, unless NOT NULL is specified.\nFor each table, the values of the numéro attribute are unique, i.e. each row is identified by the value of the numéro attribute.\n\n\nclient( \n    numéro : int (NOT NULL), \n    nom : varchar (NOT NULL), \n    prénom : varchar (NOT NULL), \n    rue : varchar, \n    ville : varchar,\n    cp : int, \n    pays : varchar, \n    tel : varchar (NOT NULL), \n    email : vachar\n)\n\nchambre( \n    numéro : int (NOT NULL), \n    étage : int (NOT NULL), \n    nblitdouble : int (NOT NULL),\n    nblitsimple : int (NOT NULL), \n    description : varchar\n)\n\nThe attributes nblitdouble and nblitsimple specify the number of double beds and single beds respectively in the room.\n\nréservation( \n    numéro : int (NOT NULL), \n    chambre : int (NOT NULL), \n    client : int (NOT NULL),\n    arrivée : date (NOT NULL),\n    départ : date (NOT NULL),\n    nbadulte : int (NOT NULL), \n    nbenfant : int (NOT NULL)\n)\n\nThe room attribute refers to the number attribute of the room table.\nThe client attribute refers to the number attribute of the client table.\nThe nadult and nchild attributes specify the number of adults and children respectively who will stay in the room.\nThe date type has the usual order relationship.\n\n\n\nHere are some examples of rows for each table:\nclient\n| numéro | nom       | prénom   | rue           | ville     | cp    | pays     |\n| 113    | 'Legrand' | 'Claire' | '12 rue d'If' | 'Orléans' | 45000 | 'France' |\n\n tel          | email                |\n '0610101010' | 'jlegrand@cecher.fr' |  \n\nchambre\n| numéro | étage | nblitdouble | nblitsimple | description                                |\n| 104    | 1     | 1           | 0           | spacieuse, ensoleillée, balcon, WC, douche |\n\nréservation\n| numéro | chambre | client | arrivée    | départ     | nbadulte | nbenfant |\n| 512    | 104     | 113    | 2025/12/15 | 2025/12/21 | 2        | 0        |\nThis row in the reservation table stores that customer 113 in the ‘customers’ table (Claire Legrand) has booked room 104 in the ‘room’ table from 2025/12/15 to 2025/12/21 for 2 adults."
  },
  {
    "objectID": "exams/cc1-2025-10-17-eng.html#questions",
    "href": "exams/cc1-2025-10-17-eng.html#questions",
    "title": "CC1 du 17 octobre 2025 - English translation",
    "section": "Questions",
    "text": "Questions\n\nWrite in relational algebra and SQL a query that lists the first and last names of customers who live in the city ‘Bordeaux’.\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\n\nWrite in relational algebra and SQL a query that lists the bookings where the number of people (adults and children) does not respect the number of beds available in the room booked.\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\n\nWrite in SQL a query that lists the numbers of customers who have no reservations on the 1st floor.\n\n\n\n\n\n\n\nTipSolution\n\n\n\nEXISTS\n\n\n\nWrite in SQL a query that lists the surnames, first names and number of bookings of the 10 customers who have made the most bookings.\nThis query looks for cases where two different bookings for the same room have at least one night in common. These are incompatible bookings.\nWrite in SQL a query which lists, for each incompatibility, the number of the room concerned and the numbers of the two reservations.\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\nWrite in SQL and without subqueries and without INTERSECT, a query that lists the numbers of customers who have at least one reservation for room 101 and at least one reservation for room 303.\n\n\n\n\n\n\n\nTipSolution\n\n\n\ndouble jointure\n\n\n\nWrite in SQL with no aggregation function and no subquery, a query that lists the numbers of the rooms that have been booked by at least two different people from the city of ‘Brest’.\nWrite in SQL with no aggregation function, a query that lists the floors for which all the rooms are reserved on the date ‘2025/12/15’.\n\n\n\n\n\n\n\nTipSolution\n\n\n\ndifférence"
  },
  {
    "objectID": "exams/cc1-2023-10-27.html",
    "href": "exams/cc1-2023-10-27.html",
    "title": "MA15E045 - Automne 2025",
    "section": "",
    "text": "L3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2023-2024\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\nToutes les questions portent sur le schéma world rappelé ci-dessous.\n\n\n\nSchéma world\n\n\n\n\n\n\n\n\nLes territoires qui sont inscrits dans la table country ne sont pas tous des pays, et pour certaines lignes, population_country, gnp, governmentform, … ne sont pas renseignés.\n\n\n\n\n\n\n\n\n\nPour chaque question, proposer une requête écrite en algèbre relationnelle ou en SQL.\n\n\n\n\nDonner pour chaque pays, chaque district, la population totale qui réside dans des villes répertoriées dans city.\n\n\n\n\n\n\n\nTipSolution\n\n\n\nUn district est une unité territoriale incluse dans un territoire. Pour la France, les district correspondent aux régions, pour l’Allemagne aux Laender, …\nSELECT DISTINCT ci.district\nFROM world.city ci\nWHERE ci.countrycode='FRA' ;\nComme on doit sommer les populations des villes situées dans un district (et donc dans un pays), il faut partitionner city par district et pays.\n2SELECT ci.countrycode, ci.district,\n3       SUM(ci.population) as pop\nFROM world.city ci \n1GROUP BY ci.countrycode, ci.district\n\n1\n\nDeux colonnes pour le partitionnement (même si countrycode est peut-être déterminé par district)\n\n2\n\nOn ne peut projeter que sur les colonnes utilisées pour partitionner et …\n\n3\n\nSur des colonnes agrégées.\n\n\nAprès partition/aggrégation, la table résultat contient une ligne pour chaque combinaison des attributs/colonnes servant au partitionnement. Sur chaque ligne du résultat, on peut faire figurer des aggrégations.\nSi on veut disposer des totaux par pays en plus, on peut utiliser la construction GROUP BY ROLLUP(...)\nSELECT ci.countrycode, ci.district, \n       SUM(ci.population) as pop    \nFROM world.city ci \nGROUP BY ROLLUP(ci.countrycode, ci.district) \nORDER BY ci.countrycode, ci.district\nLIMIT 20 ; \nOn peut chercher à imiter le résultat de GROUP BY ROLLUP avec les constructions vues en cours.\nWITH r AS (\n  SELECT ci.countrycode, ci.district, \n       SUM(ci.population) as pop  \n  FROM world.city ci \n  GROUP BY ci.countrycode, ci.district\n), s AS (\n  SELECT r.countrycode, NULL AS district, sum(r.pop_district) AS pop\n  FROM r\n  GROUP BY r.countrycode\n)\n\n(SELECT * FROM s)\nUNION \n(SELECT * FROM r) \nORDER BY countrycode, district ;\nLa construction GROUP BY ROLLUP (...) ne permet pas définir des requêtes qui seraient hors de portée de GROUP BY ..., elle permet une écriture plus concise et plus claire.\n\n\n\nDonner pour chaque pays le nombre d’habitants qui ne parlent pas une langue officielle. On suppose ici que chaque habitant ne parle qu’une seule langue.\n\n\n\n\n\n\n\nTipSolution\n\n\n\n1WITH cc_pop_not_official AS (\n  SELECT countrycode, SUM(percentage) as percentage\n  FROM world.countrylanguage\n  WHERE NOT(isofficial)\n  GROUP BY countrycode\n)\n\nSELECT name_country, (population_country * percentage / 100)::INTEGER\n2FROM world.country NATURAL JOIN cc_pop_not_official;\n\n1\n\nLa requête intermédiaire cc_pop_not_official nous donne pour chaque pays le pourcentage de locuteurs des langues non-officielles du pays\n\n2\n\nGrâce à une jounture avec country, on peut combiner ce pourcentage avec la population du pays.\n\n\nOn peut chercher à vérifier la convention avancée dans l’énoncé:\nSELECT cl.countrycode, SUM(cl.percentage) AS total_percent\nFROM world.countrylanguage cl \nGROUP BY cl.countrycode\nHAVING SUM(cl.percentage) &gt; 100\nORDER BY total_percent DESC \nLIMIT 10 ;\n\n\n\nDonner, pour chaque région ayant au moins 50 millions d’habitants, le ou les pays les moins peuplés de la région.\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH r_minpop_g50M AS (\n  SELECT region, MIN(population_country) AS population_country\n  FROM world.country\n  GROUP BY region\n  HAVING SUM(population_country) &gt;= 50000000)\n\nSELECT co.region, co.name_country\n  FROM world.country co NATURAL JOIN r_minpop_g50M ;\n\n\n\n\n\n\nNe pas confondre les régions ayant au moins 50 millions d’habitants et les régions où au moins un pays a plus de 50 millions d’habitants.\n\n\n\n\n\n\nListe des pays où la langue la plus parlée n’est pas officielle\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH r AS (\n  SELECT cl.*, \n    co.name_country, \n    rank() OVER w AS rang\n    FROM world.countrylanguage cl NATURAL JOIN \n         world.country co\n  WINDOW w AS (PARTITION BY cl.countrycode ORDER BY cl.percentage DESC) \n)\n\nSELECT DISTINCT r.name_country\nFROM r\nWHERE r.rang=1 AND NOT r.isofficial ;\nL’usage d’une fonction fenêtre est commode, mais c’est un marteau-pilon pour casser un œuf.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nAlternatives sans fonction fenêtre :\nWITH langmax AS (\n  SELECT countrycode, \n         MAX(percentage) AS percentage\n  FROM world.countrylanguage\n  GROUP BY countrycode)\n\nSELECT DISTINCT name_country\nFROM world.country NATURAL JOIN \n     world.countrylanguage NATURAL JOIN \n     langmax\nWHERE NOT(isofficial);\nSELECT DISTINCT cl.countrycode\nFROM world.countrylanguage cl\nWHERE NOT cl.isofficial AND \n      NOT EXISTS (\n        SELECT *\n        FROM world.countrylanguage cl1\n        WHERE cl1.isofficial AND \n              cl1.countrycode = cl.countrycode\n              cl1.percentage &gt; cl.percentage\n) ;\n\n\n\n\n\n\n\n\nUne erreur fréquente consiste à lister les pays où il existe une langue officielle qui est moins parlée qu’une langue non-officelle. Ce n’est pas la même chose que la liste des pays où toutes les langues officielles sont moins parlées qu’une certaine langue non-officiele\n\n\n\n\n\n\n\n\n\nTipSolution en calcul des tuples\n\n\n\n\\[\\begin{array}{rl}\\left\\{ t : \\texttt{country}(t) \\right. & \\wedge \\exists s, s \\in \\texttt{countrylanguage} \\wedge \\neg  s.\\texttt{isofficial}  \\wedge \\\\ & \\left. \\phantom{\\wedge}\\forall u \\neg \\left(\\texttt{countrylanguage}(u)  \\wedge u.\\texttt{isofficial} \\wedge u.\\texttt{percentage} &gt; s.\\texttt{percentage} \\right) \\right\\}\n\\end{array}\\]\n\n\n\n\n\n\n\n\nUne autre erreur fréquente consiste à ne lister que les pays où il existe une langue non-officielle parlée par au moins la moitié de la population:\nSELECT cl.countrycode\nFROM world.countrylanguage cl\nWHERE cl.percentage &gt; 50 AND NOT c.isofficial ; \nIl est très possible que dans un pays, aucune langue ne soit parlée par la moitié de la population, que toutes les langues soient minoritaires, et que la langue la plus parlée ne soit pas officielle.\n\n\n\n\nListe des pays où aucune ville ne compte plus \\(3\\) millions d’habitants.\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH r AS (  \n    SELECT ci.countrycode, \n           SUM(CAST (ci.population &gt; 3000000 AS INTEGER)) AS nb\n    FROM world.city ci\n    GROUP BY ci.countrycode \n1)\n\nSELECT co.name_country, co.continent\nFROM world.country co LEFT JOIN \n     r ON (co.countrycode = r.countrycode)   \nWHERE r.nb IS NULL OR r.nb = 0\n2ORDER BY co.continent, co.name_country;\n\n1\n\nLa requête r collecte les codes de pays et pour chaque pays le nombre de villes de plus de \\(3000000\\) d’habitants.\n\n2\n\nEn effectuant la jointure externe entre country et r, on récupère les territoires sans villes et les territoires où toutes les villes comptent moins de \\(3000000\\) d’habitants.\n\n\nOn a ajouté continent parmi les colonnes de projection pour rendre plus lisibles les résultats.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nAlternative utilisant EXCEPT :\nWITH cc_no_big_city AS (\n  (SELECT countrycode\n   FROM world.country)\n   EXCEPT\n  (SELECT countrycode\n   FROM world.city\n   WHERE population &gt; 3000000))\n   \nSELECT name_country, continent\nFROM world.country NATURAL JOIN cc_no_big_city\nORDER BY continent, name_country;\nCette requête donne le même résultat que la précédente.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nAlternative utilisant NOT IN :\nSELECT name_country, continent\n  FROM world.country\n WHERE countrycode NOT IN (\n     SELECT countrycode\n       FROM world.city\n      WHERE population &gt; 3000000)\n ORDER BY continent, name_country;\nCette requête donne encore le même résultat que la précédente.\n\n\n\n\n\n\n\n\nTipSolution en calcul des tuples\n\n\n\nTraduction quasi-litérale de la question en formule du calcul des tuples: \\[\\left\\{ t :\\texttt{country}(t)  \\wedge \\left(\\not \\exists s \\quad \\texttt{city}(s) \\wedge   s.\\texttt{countrycode}=t.\\texttt{countrycode} \\wedge s.\\texttt{population} &gt; 3000000 \\right)\\right\\}\\]. Cette formule se traduit presque mécaniquement avec une requête imbriquée\nSELECT co.*\nFROM world.country co\nWHERE NOT EXISTS (\n     SELECT *\n     FROM world.city ci\n     WHERE ci.countrycode=co.countrycode AND ci.population &gt; 3000000) ;\non peut aussi réécrire la formule en \\[\\texttt{country} \\setminus \\left\\{ t : \\texttt{country}(t)  \\wedge \\left( \\exists s \\quad  \\texttt{city}(s) \\wedge   s.\\texttt{countrycode}=t.\\texttt{countrycode} \\wedge s.\\texttt{population} &gt; 3000000 \\right)\\right\\}\\]\n\n\n\nListe des formes de gouvernement (governmentform) pour lesquelles dans tous les pays possédant cette forme de gouvernement, aucune langue n’est officielle.\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH r AS (\n    SELECT DISTINCT cl.countrycode\n    FROM world.countrylanguage cl \n    WHERE cl.isofficial\n), s AS (\n\n    SELECT DISTINCT co.governmentform\n    FROM world.country co \n    WHERE co.countrycode IN (\n    SELECT r.countrycode FROM r)\n)\n\nSELECT DISTINCT co.governmentform\nFROM world.country co \n\nEXCEPT \n\nSELECT s.governmentform\nFROM s  ;\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nAlternative utilisant EXCEPT :\n(SELECT governmentform\n   FROM world.country)\nEXCEPT\n(SELECT governmentform\n   FROM world.country NATURAL JOIN world.countrylanguage\n  WHERE isofficial);\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nAlternative avec partition, agrégation\nSELECT co.governmentform\nFROM world.country  co LEFT join \n     world.countrylanguage cl ON (co.countrycode=cl.countrycode)\nGROUP BY co.governmentform\nHAVING SUM(CAST(cl.isofficial AS INTEGER))=0 OR \n       SUM(CAST(cl.isofficial AS INTEGER)) IS NULL;\nSi on oublie la condition SUM(CAST(cl.isofficial AS INTEGER)) IS NULL, on ne retrouve pas Co-administrated qui concerne des territoires qui ne sont pas mentionnés dans la table countrylanguage.\n\n\n\nDonner pour chaque région, le minimum du PIB par habitant (c’est-à-dire le résultat de la division 1000000 * gnp / population_country, puisque le PIB est donné en millions) dans la région, un des pays (son countrycode) de la région où ce minimum est réalisé, le maximum du PIB par habitant et un des pays (son countrycode) où ce maximum est réalisé.\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH r AS (\n    SELECT co.region, co.countrycode, co.name_country,\n        1000000*co.gnp/co.population_country AS gnp_per_cap,\n        row_number() OVER w_max AS rang_max,\n        row_number() OVER w_min AS rang_min\n    FROM world.country co\n    WHERE co.population_country IS NOT NULL AND co.population_country &gt;0 AND co.gnp IS NOT NULL\n    WINDOW \n        w_max AS (PARTITION BY co.region ORDER BY co.gnp/co.population_country DESC),\n        w_min AS (PARTITION BY co.region ORDER BY co.gnp/co.population_country) \n), r1 AS (\n    SELECT r.*\n    FROM r\n    WHERE r.rang_max=1\n), r2 AS (\n    SELECT r.*\n    FROM r\n    WHERE r.rang_min=1\n)\n\nSELECT r1.region, r1.countrycode, r1.gnp_per_cap,\n       r2.countrycode, r2.gnp_per_cap\nFROM r1 JOIN r2 ON (r1.region=r2.region)  ;\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nAlternative sans fonction fenêtre :\nWITH cc_gpc AS (\n  SELECT countrycode, 1000000 * gnp/population_country AS gnp_per_cap\n    FROM world.country\n   WHERE population_country &gt; 0),\nregion_mingpc_maxgpc AS (\n  SELECT region, MIN(gnp_per_cap) AS mingpc, MAX(gnp_per_cap) AS maxgpc\n    FROM world.country NATURAL JOIN cc_gpc\n   GROUP BY region),\nregion_cc_mingpc AS (\n  SELECT region, MIN(c1.countrycode) AS countrycode, c1.gnp_per_cap\n    FROM world.country c NATURAL JOIN region_mingpc_maxgpc r\n         JOIN cc_gpc c1 ON c.countrycode = c1.countrycode\n                           AND r.mingpc = c1.gnp_per_cap\n   GROUP BY region, c1.gnp_per_cap),\nregion_cc_maxgpc AS (\n  SELECT region, MIN(c1.countrycode) AS countrycode, c1.gnp_per_cap\n    FROM world.country c NATURAL JOIN region_mingpc_maxgpc r\n         JOIN cc_gpc c1 ON c.countrycode = c1.countrycode\n                           AND r.maxgpc = c1.gnp_per_cap\n   GROUP BY region, c1.gnp_per_cap)\n\nSELECT *\n  FROM region_cc_mingpc JOIN region_cc_maxgpc\n       USING (region);\n\n\n\n\n\n\n\n\nCautionErreur commune\n\n\n\nAvec une table foo de schéma (col1, col2, col3, col4), la requête suivante n’est pas correcte :\nSELECT col1, col2, SUM(col4) as bar\nFROM foo\nGROUP BY col1, col3 ;\nLes colonnes qui figurent dans la clause de projection SELECT ... doivent\n\nfigurer dans la clause de partitionnement GROUP BY ..., ici col1 et col3\nreprésenter des agrégations, comme ici SUM(col4)\n\nLa colonne col2 ne peut pas figurer dans la clause de projection !\n\n\n\n\n\n\n\n\nCautionErreur commune\n\n\n\nDans une clause WHERE ou une condition de jointure, lorsqu’on compare deux colonnes, les types des deux colonnes doivent être compatibles (en général identiques).\nDes conditions comme language=isofficial ou governmentform=countrycode n’ont pas de sens."
  },
  {
    "objectID": "exams-listings.html",
    "href": "exams-listings.html",
    "title": "Annales",
    "section": "",
    "text": "Note\n\n\n\nLes annales recueillent les sujets de contrôle continu (CC) et de contrôle terminal (CT) du cours de BDD pour les L3 Miashs.\nLes sujets sont partiellement corrigés.\n\n\n\n\n   \n    \n    \n      Order By\n      Default\n      \n        Titre\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Description\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\n\nTitre\n\n\n\nDescription\n\n\n\n\n\n\n\n\nDec 2, 2025\n\n\nCC 2 2025-26\n\n\nModélisation conceptuelle, Entité-Association, Modèle relationnel, Définition de tables, Contraintes d’intégrité référentielles\n\n\n\n\n\n\nOct 17, 2025\n\n\nCC 1 2025-26\n\n\nRequêtes simples, Requêtes imbriquées, Jointure, Aggrégation\n\n\n\n\n\n\nJun 6, 2025\n\n\nCT 2 2024-25\n\n\nModélisation, Entité-Association, Pattes de corbeaux, Requêtes, Dépendances fonctionnelles, Normalisation\n\n\n\n\n\n\nJan 6, 2025\n\n\nCT 1 2024-25\n\n\nModélisation, Entité-Association, Pattes de corbeaux, Requêtes, Dépendances fonctionnelles, Normalisation\n\n\n\n\n\n\nDec 13, 2024\n\n\nCC 3 2024-25\n\n\nModélisation, Entité-Association, Pattes de corbeaux, Requêtes, Dépendances fonctionnelles\n\n\n\n\n\n\nNov 15, 2024\n\n\nCC 2 2024-25\n\n\nRequêtes, Aggrégation, Fenêtres, pagila, world\n\n\n\n\n\n\nOct 25, 2024\n\n\nCC 1 2024-25\n\n\nRequêtes simples, Aggrégation, pagila\n\n\n\n\n\n\nJun 19, 2024\n\n\nCT 2 2023-24\n\n\nRequêtes Aggrégation, Fenêtres, nycflights\n\n\n\n\n\n\nJan 8, 2024\n\n\nCT 1 2023-24\n\n\nModélisation, Normalisation, Requêtes Aggrégation, Fenêtres, nycflights\n\n\n\n\n\n\nDec 8, 2023\n\n\nCC 3 2023-24\n\n\nModélisation, Aggrégation, Fenêtres, French-Towns\n\n\n\n\n\n\nNov 24, 2023\n\n\nCC 2 2023-24\n\n\nAggrégation, Fenêtres, world\n\n\n\n\n\n\nOct 27, 2023\n\n\nCC 1 2023-24\n\n\nRequêtes, world\n\n\n\n\n\n\nNov 25, 2022\n\n\nCC 2 2022-23\n\n\nAggrégation, Fenêtres, nycflights, babynames\n\n\n\n\n\n\nNov 13, 2022\n\n\nCC 3-4 2022-23\n\n\nAggrégation, Fenêtres, nycflights\n\n\n\n\n\n\nNov 3, 2022\n\n\nCC 3-3 2022-23\n\n\nAggrégation, Fenêtres, nycflights\n\n\n\n\n\n\nOct 21, 2022\n\n\nCC 3-2 2022-23\n\n\nAggrégation, Fenêtres, babynames\n\n\n\n\n\n\nOct 14, 2022\n\n\nCC 3-1 2022-23\n\n\nAggrégation, Fenêtres, world\n\n\n\n\n\n\nNo matching items\n\n\n\n\n\n\n\nCaution\n\n\n\nLe contrôle continu 3 (CC3) de l’année 2022-23 est formé d’une suite de devoirs à réaliser à la maison entre deux séances de TD.\nLes contrôles continus 1 et 2 (CC1 et CC2) de l’année 2022-23 se déroulaient en salle de TP sur machines.\nTous les autres contrôles consistaient en épreuves sur table de 1 heure, 1 heure 30 ou 2 heures.",
    "crumbs": [
      "Annales"
    ]
  },
  {
    "objectID": "exams/cc1-2024-10-25.html",
    "href": "exams/cc1-2024-10-25.html",
    "title": "MA15E045 - Automne 2025",
    "section": "",
    "text": "L3 MIASHS/Ingémath/METIS\nUniversité Paris Cité\nAnnée 2024-2025\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\n\n\n\n\n\n\nToutes les questions portent sur le schéma pagila rappelé ci-dessous.\nPour chaque question, proposer une requête écrite en algèbre relationnelle OU en SQL.\n\n\n\n\n\n\nSchéma pagila, films\n\n\n\nDonner pour chaque film au catalogue, le titre et les prénoms des acteurs qui jouent dans ce film.\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT fi.title, string_agg(DISTINCT a.first_name, ', ') AS casting \nFROM  \n   pagila.film fi  \nJOIN  \n   pagila.film_actor fa ON (fi.film_id=fa.film_id)  \nJOIN \n   pagila.actor a ON (fa.actor_id=a.actor_id) \nGROUP BY fi.film_id;   \n Il n’est pas nécessaire d’effectuer un groupement et une aggrégation, mais c’est une occasion d’illustrer cette possibilité. string_agg() est une fonction proposée par PostgreSQL, analogue à paste() ou stringr::str_c() en R, ou à une invocation de functools.reduce() en Python:\n&gt;&gt;&gt; foo = lambda x,y : x + ', ' + y if x else y\n&gt;&gt;&gt; reduce(foo, ['Brad', 'Angelina', 'Romy', 'Ava'], '')\n'Brad, Angelina, Romy, Ava'\nDes fonctions d’aggrégations comme SUM(), MAX(), COUNT() sont de cette forme. Des fonctions d’aggrégations comme AVG(), VAR(), COUNT(DISTINCT ...) sont un peu plus compliquées à réaliser mais relève du même genre de calcul.\n\n\n\nLister les titres de films qui ne sont disponibles que dans une seule langue\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT \n3  fi.title\nFROM \n  pagila.film fi \n1GROUP BY fi.title\n2HAVING COUNT (DISTINCT fi.language_id)=1 ;\n\n1\n\nPartitionnement sur title\n\n2\n\nFiltration des classes de la partition à partir d’une condition sur l’aggrégat\n\n3\n\nProjection sur l’attribut de partitionnement (pas d’aggrégat utile ici)\n\n\nIl n’est pas indispensable de passer par un groupement/aggrégation. On peut obtenir le résultat en utilisant simplement sélection, projection, jointure, opérations ensemblistes (\\(∩, ∪, ∖\\)).\n(\n SELECT \n    DISTINCT title \n FROM \n    pagila.film\n)\nEXCEPT \n(\n SELECT \n     DISTINCT f1.title\n FROM \n     pagila.film f1 \n JOIN \n     pagila.film f2\n ON (f1.title = f2.title AND f1.language_id &lt; f2.language_id)\n)\n on est parfois tenté de choisir comme condition de jointure dans la seconde sous-requête f1.film_id = f2.film_id AND f1.language_id &lt; f2.language_id. Cela conduira a un résultat sans intérêt. L’attribut film_id est clé primaire (primary key) de film (cela fait partie du schéma, cette contrainte s’impose à toutes les instances du schéma). Quelle que soit l’instance, on ne pourra pas trouver dans la table film, deux tuples qui coïncident sur film_id et diffèrent sur language_id.\n\n\n\n\nPour chaque langue originale (original_language_id), chaque langue de diffusion (language_id), compter le nombre de titres tournés dans la langue originale et traduits dans la langue de diffusion (sans doublons).\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT \n2  original_language_id, language_id,\n3  count(title)\nFROM \n    pagila.film \nGROUP BY \n1    original_language_id, language_id\n;\n\n1\n\nPartitionnement sur le couple d’attributs original_language_id, language_id\n\n2\n\nProjection sur les attributs de partitionnement et\n\n3\n\nsur la/les aggrégations\n\n\n\n\n\n\nDonner pour chaque catégorie (de film), les noms des acteurs qui apparaissent dans le nombre maximal de films de la catégorie.\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH ActorFilmCount AS (\n    SELECT\n        c.name AS category_name,\n        a.actor_id,\n        a.first_name || ' ' || a.last_name AS actor_name,\n        COUNT(fa.film_id) AS film_count\n    FROM\n        actor a\n    JOIN\n        film_actor fa ON a.actor_id = fa.actor_id\n    JOIN\n        film f ON fa.film_id = f.film_id\n    JOIN\n        film_category fc ON f.film_id = fc.film_id\n    JOIN\n        category c ON fc.category_id = c.category_id\n    GROUP BY\n        c.name, a.actor_id, a.first_name, a.last_name\n),\n\nRankedActors AS (\n    SELECT\n        category_name,\n        actor_name,\n        film_count,\n        DENSE_RANK() OVER (PARTITION BY category_name ORDER BY film_count DESC) AS rank\n    FROM\n        ActorFilmCount\n)\nSELECT\n    category_name,\n    actor_name,\n    film_count\nFROM\n    RankedActors\nWHERE\n    rank = 1\nORDER BY\n    category_name;\n\n\nOn peut se passer des fonctions fenêtres.\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH ActorFilmCount AS (\n    SELECT\n        c.name AS category_name,\n        a.actor_id,\n        a.first_name || ' ' || a.last_name AS actor_name,\n        COUNT(fa.film_id) AS film_count\n    FROM\n        actor a\n    JOIN\n        film_actor fa ON a.actor_id = fa.actor_id\n    JOIN\n        film f ON fa.film_id = f.film_id\n    JOIN\n        film_category fc ON f.film_id = fc.film_id\n    JOIN\n        category c ON fc.category_id = c.category_id\n    GROUP BY\n        c.name, a.actor_id, a.first_name, a.last_name\n),\n\n\nMaxPerCat AS (\n    SELECT\n        category_name,\n        MAX(film_count) as m_film_count\n    FROM \n        ActorFilmCount\n    GROUP BY \n        category_name    \n),\n\n\nSELECT \n    ac.category_name,\n    ac.actor_id,\n    ac.actor_name,\n    ac.film_count\nFROM \n    ActorFilmCount  ac\nJOIN\n    MaxPerCat  mpc\nUSING(category_name)\nWHERE \n    ac.film_count=mpc.m_film_count\nORDER BY\n    ac.category_name ;\n\n\nou encore\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH ActorFilmCount AS (\n    SELECT\n        c.name AS category_name,\n        a.actor_id,\n        a.first_name || ' ' || a.last_name AS actor_name,\n        COUNT(fa.film_id) AS film_count\n    FROM\n        actor a\n    JOIN\n        film_actor fa ON a.actor_id = fa.actor_id\n    JOIN\n        film f ON fa.film_id = f.film_id\n    JOIN\n        film_category fc ON f.film_id = fc.film_id\n    JOIN\n        category c ON fc.category_id = c.category_id\n    GROUP BY\n        c.name, a.actor_id, a.first_name, a.last_name\n)\n\nSELECT\n    afc.*\nFROM \n    ActorFilmCount afc\nWHERE \n    afc.film_count &gt;= ALL (\n        SELECT \n            a.film_count\n        FROM\n            ActorFilmCount a\n        WHERE \n            a.category_name = afc.category_name\n    ) ;\n\n\n\n\nLister sans doublons les paires d’acteurs qui n’ont jamais joué dans un même film.\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH ActorPairs AS (\n    -- Generate all possible actor pairs (excluding pairing an actor with themselves)\n    SELECT\n        a1.actor_id AS actor1_id,\n        a2.actor_id AS actor2_id,\n        a1.first_name || ' ' || a1.last_name AS actor1_name,\n        a2.first_name || ' ' || a2.last_name AS actor2_name\n    FROM\n        actor a1\n    JOIN\n        actor a2 ON a1.actor_id &lt; a2.actor_id  -- Ensure actor1_id &lt; actor2_id to avoid duplicate pairs\n),\nActorsTogether AS (\n    -- Find all actor pairs who have acted together in at least one film\n    SELECT\n        fa1.actor_id AS actor1_id,\n        fa2.actor_id AS actor2_id\n    FROM\n        film_actor fa1\n    JOIN\n        film_actor fa2 ON fa1.film_id = fa2.film_id\n    WHERE\n        fa1.actor_id &lt; fa2.actor_id  -- Same condition to avoid duplicates\n),\nActorsNotTogether AS (\n    -- Left JOIN all possible pairs with the pairs that acted together\n    SELECT\n        ap.actor1_name,\n        ap.actor2_name\n    FROM\n        ActorPairs ap\n    LEFT JOIN\n        ActorsTogether at ON ap.actor1_id = at.actor1_id AND ap.actor2_id = at.actor2_id\n    WHERE\n        at.actor1_id IS NULL  -- Only return pairs that do not exist in the ActorsTogether result\n)\n-- Final result\nSELECT\n    actor1_name,\n    actor2_name\nFROM\n    ActorsNotTogether\nORDER BY\n    actor1_name, actor2_name;\n\n\n\n\nLister les acteurs (prénom, nom) qui ont joué dans des films tournés dans au moins deux langues différentes (langue de tournage : original_language_id)\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT\n    a.actor_id,\n    a.first_name || ' ' || a.last_name AS actor_name,\n    STRING_AGG(DISTINCT l.name, ', ') AS languages\nFROM\n    actor a\nJOIN\n    film_actor fa ON a.actor_id = fa.actor_id\nJOIN\n    film f ON fa.film_id = f.film_id\nJOIN\n    language l ON f.original_language_id = l.language_id\nGROUP BY\n    a.actor_id, a.first_name, a.last_name\nHAVING\n    COUNT(DISTINCT f.original_language_id) &gt; 1\nORDER BY\n    actor_name;\n\n\n\nPour chaque magasin (désigné par store_id), chaque langue, donnez le nombre de DVDs (physiques) disponibles dans cette langue, dans ce magasin.\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT\n    s.store_id,\n    l.name AS language_name,\n    COUNT(i.inventory_id) AS inventory_count\nFROM\n    store s\nJOIN\n    inventory i ON s.store_id = i.store_id\nJOIN\n    film f ON i.film_id = f.film_id\nJOIN\n    language l ON f.language_id = l.language_id\nWHERE\n    f.language_id IS NOT NULL\nGROUP BY\n    s.store_id, l.name\nORDER BY\n    s.store_id, l.name;"
  },
  {
    "objectID": "exams/cc1-2025-10-17.html",
    "href": "exams/cc1-2025-10-17.html",
    "title": "CC1 du 17 octobre 2025",
    "section": "",
    "text": "L3 MIASHS/Ingémath/METIS\nUniversité Paris Cité\nCourse Homepage"
  },
  {
    "objectID": "exams/cc1-2025-10-17.html#présentation-de-la-base-de-données-utilisée",
    "href": "exams/cc1-2025-10-17.html#présentation-de-la-base-de-données-utilisée",
    "title": "CC1 du 17 octobre 2025",
    "section": "Présentation de la base de données utilisée",
    "text": "Présentation de la base de données utilisée\nToutes les questions portent sur une base de données hotel utilisée par un hôtel pour gérer ses réservations.\nPour chaque relation (table), nous indiquons son schéma avec le type de chaque attribut sous la forme nom_attribut : type.\nPar défaut, les valeurs NULL sont autorisées, sauf si la mention NOT NULL est précisée.\nPour chaque table, les valeurs de l’attribut numéro sont uniques, autrement dit chaque ligne est identifiée par la valeur de l’attribut numéro.\n\n\nclient( \n    numéro : int (NOT NULL), \n    nom : varchar (NOT NULL), \n    prénom : varchar (NOT NULL), \n    rue : varchar, \n    ville : varchar,\n    cp : int, \n    pays : varchar, \n    tel : varchar (NOT NULL), \n    email : vachar\n)\n\nchambre( \n    numéro : int (NOT NULL), \n    étage : int (NOT NULL), \n    nblitdouble : int (NOT NULL),\n    nblitsimple : int (NOT NULL), \n    description : varchar\n)\n\nLes attributs nblitdouble et nblitsimple précisent respectivement le nombre de lits doubles et de lits simples de la chambre.\n\nréservation( \n    numéro : int (NOT NULL), \n    chambre : int (NOT NULL), \n    client : int (NOT NULL),\n    arrivée : date (NOT NULL),\n    départ : date (NOT NULL),\n    nbadulte : int (NOT NULL), \n    nbenfant : int (NOT NULL)\n)\n\nL’attribut chambre référence l’attribut numéro de la table chambre.\nL’attribut client référence l’attribut numéro de la table client.\nLes attributs nbadulte et nbenfant précisent respectivement le nombre d’adultes et d’enfants qui logeront dans la chambre.\nLe type date dispose de la relation d’ordre usuelle.\n\n\n\nVoici des exemples de lignes pour chaque table :\nclient\n| numéro | nom       | prénom   | rue           | ville     | cp    | pays     |\n| 113    | 'Legrand' | 'Claire' | '12 rue d'If' | 'Orléans' | 45000 | 'France' |\n\n tel          | email                |\n '0610101010' | 'jlegrand@cecher.fr' |  \n\nchambre\n| numéro | étage | nblitdouble | nblitsimple | description                                |\n| 104    | 1     | 1           | 0           | spacieuse, ensoleillée, balcon, WC, douche |\n\nréservation\n| numéro | chambre | client | arrivée    | départ     | nbadulte | nbenfant |\n| 512    | 104     | 113    | 2025/12/15 | 2025/12/21 | 2        | 0        |\nCette ligne de la table réservation stocke que le client 113 de la table client (Claire Legrand) a réservé la chambre 104 de la table chambre du 2025/12/15 au 2025/12/21 pour 2 adultes."
  },
  {
    "objectID": "exams/cc1-2025-10-17.html#questions",
    "href": "exams/cc1-2025-10-17.html#questions",
    "title": "CC1 du 17 octobre 2025",
    "section": "Questions",
    "text": "Questions\n\nEcrire en algèbre relationnelle et en SQL une requête qui liste les noms et prénoms des clients qui habitent la ville ‘Bordeaux’.\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\\(\\Pi \\big( {\\Large \\sigma}(\\texttt{client} , \\texttt{ ville = 'Bordeaux'}),\\texttt{ nom, prénom}\\big)\\)\nSELECT nom, prénom\nFROM client\nWHERE ville = 'Bordeaux';\n\n\n\n\nEcrire en algèbre relationnelle et en SQL une requête qui liste les réservations où le nombre de personnes (adultes et enfants) ne respectent pas le nombre de couchages disponibles dans la chambre réservée.\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\\({\\small \\Pi \\big( \\sigma (\\texttt{réservation} \\bowtie_{\\texttt{réservation.chambre=chambre.numéro}} \\texttt{chambre},}\\)\n\\({\\small \\texttt{nbadulte+nbenfant &gt; nblitdouble*2+nblitsimple}\\big), \\texttt{réservation.numéro} \\big)}\\)\nSELECT r.*\nFROM réservation r JOIN chambre ch ON r.chambre = ch.numéro\nWHERE r.nbadulte +  r.nbenfant &gt; ch.nblitdouble * 2 + ch.nblitsimple;\nUne projection SELECT r.numéro convient aussi.\n\n\n\n\nEcrire en SQL une requête qui liste les numéros des clients qui n’ont aucune réservation au 1er étage.\n\n\n\n\n\n\n\nTipSolution\n\n\n\nAvec une jointure externe et une sous-requête :\nWITH resaétage1 as\n(\n    SELECT r.*\n    FROM réservation r JOIN chambre ch ON r.chambre = ch.numéro\n    WHERE ch.étage = 1\n)\nSELECT cl.numéro\nFROM client cl LEFT JOIN resaétage1 r ON cl.numéro = r.client\nWHERE r.client IS NULL;\nOn peut écrire une version avec IN, ou bien EXISTS, et une sous-requête :\nSELECT cl.numéro\nFROM client cl\nWHERE cl.numéro NOT IN(\n    SELECT DISTINCT r.client\n    FROM réservation r JOIN chambre ch ON r.chambre = ch.numéro\n    WHERE ch.étage = 1\n    );\nUne solution équivalente avec EXCEPT et deux sous-requêtes :\n(\n    SELECT numéro\n    FROM client\n)\nEXCEPT\n(\n    SELECT DISTINCT r.client\n    FROM réservation r JOIN chambre ch ON r.chambre = ch.numéro\n    WHERE ch.étage = 1\n);\nLe distinct limite la complexité de l’opération EXCEPT.\n\n\n\nEcrire en SQL une requête qui liste les noms, prénoms et nombres de réservations des 10 clients qui ont fait le plus de réservations.\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT cl.nom, cl.prénom, COUNT(r.numéro) AS nbréservation\nFROM client cl JOIN réservation r ON cl.numéro = r.client\nGROUP BY cl.numéro, cl.nom, cl.prénom\nORDER BY nbréservation DESC\nLIMIT 10;\nIci, il faut bien grouper par numéro de client, même si cet attribut n’est pas dans la projection car c’est le seul attribut de la table client qui identifie chaque tuple. Le groupement par nom et prénom n’ajoute rien mais est nécessaire pour la projection.\n\n\n\nDans cette requête, on recherche les cas où deux réservations différentes pour une même chambre ont au moins une nuit commune. Il s’agit donc de réservations incompatibles.\nEcrire en SQL une requête qui liste, pour chaque incompatibilité, le numéro de la chambre concernée et les numéros des deux réservations.\n\n\n\n\n\n\n\nTipSolution\n\n\n\nDeux réservations sont incompatibles si le client de l’une arrive quand le client de l’autre occupe encore la chambre.\nSELECT r1.chambre, r1.numéro AS numéroreservation1, r2.numéro AS numéroreservation2\nFROM réservation r1 \n    JOIN réservation r2 ON (r1.chambre = r2.chambre AND r1.numéro &lt;&gt; r2.numéro)\nWHERE (r1.arrivée &gt;= r2.arrivée AND r1.arrivée &lt; r2.départ)\n    OR (r2.arrivée &gt;= r1.arrivée AND r2.arrivée &lt; r1.départ) ; \nAvec cette condition, chaque couple de réservations incompatibles apparaît deux fois.\nSi on veut qu’ils n’apparaissent qu’une fois :\nSELECT r1.chambre, r1.numéro AS numéroreservation1, r2.numéro AS numéroreservation2\nFROM réservation r1 \n    JOIN réservation r2 ON (r1.chambre = r2.chambre AND r1.numéro &lt;&gt; r2.numéro)\nWHERE r1.arrivée &gt;= r2.arrivée AND r1.arrivée &lt; r2.départ; \nNB : deux réservations telles que r1.arrivée = r2.départ ou r2.arrivée = r1.départ ne sont pas incompatibles.\n\n\n\nEcrire en SQL, sans sous-requête et sans INTERSECT, une requête qui liste les numéros des clients qui ont au moins une réservation pour la chambre 101 et au moins une réservation pour la chambre 303.\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT DISTINCT r1.client\nFROM réservation r1 \n    JOIN réservation r2 ON r1.client = r2.client\nWHERE r1.chambre = 101 AND r2.chambre = 303;\nNB : ce n’est pas une bonne idée d’utiliser les agrégats pour répondre à un problème du type ‘il existe au moins un’, ‘il existe au moins deux’, ‘il n’existe pas’.\nSi on voulait quand même écrire une requête avec COUNT, il fallait grouper par numéro de client et utiliser CASE WHEN pour compter en même temps les réservations de la chambre 101 et les réservations de la chambre 303 :\nSELECT client\nFROM réservation\nGROUP BY client\nHAVING COUNT(\n    CASE \n      WHEN chambre = 101 THEN numéro \n      ELSE NULL \n    END) &gt;= 1\n    AND COUNT(\n    CASE \n      WHEN chambre = 303 THEN numéro \n      ELSE NULL \n    END) &gt;= 1\n;\nParmi les solutions exclues avec sous-requêtes :\nWITH client101 AS\n(\n    SELECT DISTINCT cl.numéro\n    FROM client cl JOIN réservation r ON cl.numéro = r.client\n    WHERE r.chambre = 101\n),\nclient303 AS\n(\n    SELECT DISTINCT cl.numéro\n    FROM client cl JOIN réservation r ON cl.numéro = r.client\n    WHERE r.chambre = 303\n)\nSELECT *\nFROM client101 NATURAL JOIN client303;\nOn peut écrire deux autres versions semblables avec INTERSECT ou IN.\n\n\n\nEcrire en SQL, sans fonction d’agrégation et sans sous-requête, une requête qui liste les numéros des chambres qui ont été réservées par au moins deux personnes différentes de la ville de ‘Brest’.\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT DISTINCT ch.numéro\nFROM client cl1\n    JOIN réservation r1 ON cl1.numéro = r1.client\n    JOIN réservation r2 ON r1.chambre = r2.chambre\n    JOIN client cl2 ON r2.client = cl2.numéro\nWHERE cl1.ville = 'Brest' AND cl2.ville = 'Brest' AND cl1.numéro &lt;&gt; cl2.numéro;\n\n\n\nEcrire en SQL sans fonction d’agrégation, une requête qui liste les étages pour lesquels toutes les chambres sont réservées à la date ‘2025/12/15’.\n\n\n\n\n\n\n\nTipSolution\n\n\n\nIl faut faire la différence entre l’ensemble des étages et l’ensemble des étages ayant au moins une chambre disponible le ‘2025/12/15’.\nAvec des sous-requêtes, une jointure externe et une différence :\nWITH resa15-12-2025 AS\n(   -- réservations pour le 2025/12/15\n    SELECT *\n    FROM réservation\n    WHERE arrivée &lt;= '2025/12/15' AND départ &gt; '2025/12/15'\n) \n(\n    SELECT DISTINCT étage\n    FROM chambre\n)\nEXCEPT\n(   -- étages avec au moins une chambre dispo le 2025/12/15\n    SELECT DISTINCT ch.étage\n    FROM chambre ch LEFT JOIN resa15-12-2025 r ON ch.numéro = r.chambre\n    WHERE r.chambre IS NULL\n);\nAvec des sous-requêtes, NOT IN et une différence :\n(\n    SELECT DISTINCT étage\n    FROM chambre\n)\nEXCEPT\n(\n    SELECT DISTINCT étage -- étages avec au moins une chambre dispo le 2025/12/15\n    FROM chambre\n    WHERE numéro NOT IN\n        (   -- chambres réservées le 2025/12/15\n            SELECT chambre\n            FROM réservation\n            WHERE arrivée &lt;= '2025/12/15' AND départ &gt; '2025/12/15'\n        )\n);"
  },
  {
    "objectID": "exams/cc2-2023-11-24.html",
    "href": "exams/cc2-2023-11-24.html",
    "title": "MA15E045 - Automne 2025",
    "section": "",
    "text": "CC 2 2023-11-24 16h30-18h45\nL3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2023-2024\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\n\n\n\n\n\n\nPour chaque question, proposer une requête écrite en algèbre relationnelle ou en SQL.\n\n\n\n\n\n\n\n\n\nNoteQuestion 1\n\n\n\nDans le schéma world, lister les pays où les dix plus grandes villes ont chacune au moins 10 millions d’habitants.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT \n  ci.countrycode\nFROM \n  world.city ci \nWHERE \n  ci.population &gt; 10000000\nGROUP BY \n  ci.countrycode \nHAVING \n  COUNT(ci.id) &gt;= 10 ;\n\n\n\n\n\n\n\n\nNoteQuestion 2\n\n\n\nDans le schéma world, pour chaque pays, donner les trois langues les plus parlées.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH R AS (\n  SELECT \n    cl.countrycode, cl.language, \n    RANK() OVER w AS rnk \n  FROM \n    world.countrylanguage cl \n  WINDOW \n    w AS (PARTITION BY cl.countrycode ORDER BY cl.percentage DESC)\n)\n\nSELECT \n  R.countrycode, R.language\nFROM \n  R\nWHERE \n  R.rnk &lt;= 3 ;\n\n\n\n\n\n\n\n\nNoteQuestion 3\n\n\n\nDans le schéma world, lister les langues parlées sur tous les continents.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT\n  language\nFROM\n  country co\nNATURAL JOIN\n  countrylanguage cl\nGROUP BY\n  cl.language\nHAVING COUNT(DISTINCT co.continent) = (\n  SELECT COUNT(DISTINCT c.continent) FROM country c\n) ;\n\n\n\n\n\n\n\n\nNoteQuestion 4\n\n\n\nDans le schéma world, lister par région le nombre de langues officielles distinctes.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT \n  co.region, \n  COUNT(DISTINCT cl.language) AS n\nFROM \n  world.countrylanguage cl \nNATURAL JOIN \n  world.country co \nWHERE \n  cl.isofficial\nGROUP BY \n  co.region\n\n\n\n\n\n\n\n\nNoteQuestion 5\n\n\n\nDans le schéma world, lister pour chaque forme de gouvernement, la population des villes des pays qui subissent cette forme de gouvernement.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT \n  co.governmentform, \n  SUM(ci.population) AS pop\nFROM \n  world.country co \nJOIN \n  world.city ci  USING (countrycode)\nGROUP BY \n  co.governmentform ;\n\n\n\n\n\n\n\n\nNoteQuestion 6\n\n\n\nDans le schéma world, lister les pays où la capitale est la ville la plus peuplée.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH R AS (\n  SELECT \n    co.countrycode, co.name_country, ci. name, ci.id, ci.population,\n1    (co.capital=ci.id) AS capitale,\n2    RANK() OVER (PARTITION BY co.countrycode ORDER BY ci.population DESC) AS rnk\n  FROM \n      world.country co\n    JOIN\n      world.city ci  USING (countrycode) \n)\n\nSELECT \n  R.name_country, R. name, R.population\nFROM \n  R \nWHERE \n3  capitale AND rnk = 1\n;  \n\n1\n\nOn note les villes qui sont capitales\n\n2\n\nOn range les villes d’un pays par population décroissante\n\n3\n\nOn ne garde que les capitales qui sont aussi les villes les plus peuplées du royaume\n\n\n\n\n\n\n\n\n\n\nNoteQuestion 7\n\n\n\nDans le schéma world, lister les pays où \\(90\\%\\) de la population parle une langue officielle (il peut y avoir plusieurs langues officielles, dont la somme des locuteurs et locutrices dépasse \\(90\\%\\) de la population).\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT \n  cl.countrycode\nFROM \n  world.countrylanguage cl \nWHERE \n  cl.isofficial\nGROUP BY cl.countrycode\nHAVING SUM(cl.percentage) &gt;= 90 ;\n\n\n\nToutes les questions portent sur le schéma world.\n\n\n\nSchéma world"
  },
  {
    "objectID": "exams/cc3-2022-10-14.html",
    "href": "exams/cc3-2022-10-14.html",
    "title": "MA15E045 - Automne 2025",
    "section": "",
    "text": "L3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2023-2024\nCourse Homepage\n\nMoodle\nSur le serveur, dans votre schéma personnel, créer les fonctions SQL et vues correspondant aux cinq questions suivantes."
  },
  {
    "objectID": "exams/cc3-2022-10-14.html#les-pays-où-lon-cause-le-.",
    "href": "exams/cc3-2022-10-14.html#les-pays-où-lon-cause-le-.",
    "title": "MA15E045 - Automne 2025",
    "section": "Les pays où l’on cause le ….",
    "text": "Les pays où l’on cause le ….\nÉcrire une fonction SQL nommée cc_fonc_1 qui prend en argument une chaine de caractères censée désigner une langue et renvoie une table (name_country TEXT, pop_speakers int4) qui contient les 5 pays comportant le plus de locuteurs de la langue en question et pour chaque pays le nombre estimé de locuteurs de la langue en question\n\n\n\n\n\n\nRéponse attendue pour %French% :\n\n\n\nname_country\npop_speakers\n\n\n\n\nFrance\n55435254\n\n\nCanada\n7288398\n\n\nBelgium\n3337914\n\n\nTunisia\n2521118\n\n\nUnited States\n1948499\n\n\n\n\n\n\n\n\n\n\n\n\nTipsolution\n\n\n\nTODO"
  },
  {
    "objectID": "exams/cc3-2022-10-14.html#pays-peu-concentrés-sur-les-grandes-villes",
    "href": "exams/cc3-2022-10-14.html#pays-peu-concentrés-sur-les-grandes-villes",
    "title": "MA15E045 - Automne 2025",
    "section": "Pays peu concentrés sur les grandes villes",
    "text": "Pays peu concentrés sur les grandes villes\nCréer une vue cc_vue_2 des pays dont la population n’est pas nulle et où les cinq plus grandes villes ne rassemblent pas plus du dixième de la population. La vue aura pour schéma (countrycode, name_country, portion)\n\n\n\n\n\n\nRéponse attendue pour\nSELECT * \nFROM username.cc_vue_2 cv \nWHERE cv.countrycode  IN (\n SELECT c.countrycode \n FROM world.country c \n WHERE region='Eastern Africa'\n) ;\n\n\n\ncountrycode\nname_country\nportion\n\n\n\n\nMDG\nMadagascar\n0.07045295\n\n\nMWI\nMalawi\n0.08367222\n\n\nBDI\nBurundi\n0.04480956\n\n\nCOM\nComoros\n0.062283736\n\n\nTZA\nTanzania\n0.071704924\n\n\nMYT\nMayotte\n0.08053691\n\n\nUGA\nUganda\n0.040903665\n\n\nRWA\nRwanda\n0.036984354\n\n\nETH\nEthiopia\n0.047906272\n\n\n\n\n\n\n\n\n\n\n\n\nTipsolution\n\n\n\nTODO"
  },
  {
    "objectID": "exams/cc3-2022-10-14.html#la-cinquième-ville-la-plus-peuplée-dans-chaque-pays",
    "href": "exams/cc3-2022-10-14.html#la-cinquième-ville-la-plus-peuplée-dans-chaque-pays",
    "title": "MA15E045 - Automne 2025",
    "section": "La cinquième ville la plus peuplée dans chaque pays",
    "text": "La cinquième ville la plus peuplée dans chaque pays\nÉcrire une fonction de cc_fonc_3 langage SQL qui prend en argument une chaine de caractères censée désigner un pays par son nom et renvoie le nom de la cinquième ville la plus peuplée du pays (type de name), et la part de la population du pays qui réside dans cette ville (type float4).\n\n\n\n\n\n\nRéponse attendue pour\nSELECT name, prop \nFROM username.cc_fonc_3('Italy') ;\n\n\n\nname\nprop\n\n\n\n\nPalermo\n0.011854959\n\n\n\n\n\n\n\n\n\n\n\n\nTipsolution\n\n\n\nTODO"
  },
  {
    "objectID": "exams/cc3-2022-10-14.html#la-population-des-deux-villes-les-plus-peuplées-de-chaque-pays",
    "href": "exams/cc3-2022-10-14.html#la-population-des-deux-villes-les-plus-peuplées-de-chaque-pays",
    "title": "MA15E045 - Automne 2025",
    "section": "La population des deux villes les plus peuplées de chaque pays",
    "text": "La population des deux villes les plus peuplées de chaque pays\nCréer une vue cc_vue_4 qui liste par pays, le nombre d’habitants des deux villes les plus peuplées. La vue aura pour schéma (name_contry text, pop_two_cities int4).\n\n\n\n\n\n\nRéponse attendue pour\nSELECT * \nFROM username.cc_vue_4 \nWHERE name_country = 'France' ;\n\n\n\nname_country\npop_two_cities\n\n\n\n\nFrance\n2923676\n\n\n\n\n\n\n\n\n\n\n\n\nTipsolution\n\n\n\nTODO"
  },
  {
    "objectID": "exams/cc3-2022-10-14.html#pays-où-deux-langues-sont-parlées-par-au-moins-un-dixième-de-la-population",
    "href": "exams/cc3-2022-10-14.html#pays-où-deux-langues-sont-parlées-par-au-moins-un-dixième-de-la-population",
    "title": "MA15E045 - Automne 2025",
    "section": "Pays où deux langues sont parlées par au moins un dixième de la population",
    "text": "Pays où deux langues sont parlées par au moins un dixième de la population\nCréer une vue cc_vue_5 des pays où au moins deux langues sont (chacunes) parlées par au moins un dixieme de la population. La vue aura même schema que world.country.\n\n\n\n\n\n\nSELECT \n  countrycode, name_country  \nFROM \n  username.cc_vue_5 \nWHERE \n  region='Eastern Europe' ;\n\n\n\ncountrycode\nname_country\n\n\n\n\nCZE\nCzech Republic\n\n\nBLR\nBelarus\n\n\nMDA\nMoldova\n\n\nUKR\nUkraine\n\n\nSVK\nSlovakia\n\n\n\n\n\n\n\n\n\n\n\n\nTipsolution\n\n\n\nSELECT \n  countrycode \nFROM \n  countrylanguage\nWHERE \n  percentage &gt;= 10 \nGROUP BY countrycode\nHAVING COUNT(language) &gt;= 2;"
  },
  {
    "objectID": "exams/cc3-2022-11-03.html",
    "href": "exams/cc3-2022-11-03.html",
    "title": "MA15E045 - Automne 2025",
    "section": "",
    "text": "L3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2023-2024\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\nCréer les fonctions SQL et vues correspondant aux questions suivantes.\nLes questions portent sur le schéma nycflights13 issu de https://github.com/tidyverse/nycflights13.\nVoir Documentation package R nycflights13\nDiagramme synthétique en pattes de corbeaux :\n\n\n\nDiagramme en pattes de corbeaux\n\n\nDiagramme sur bd_2023 :\n\n\n\nDiagramme sur bd_2023\n\n\n\nExercice\n\nNombre vols retardés d’un délai minimal à l’arrivée à un aéroport donné\nDonnés sur schéma nycflights13\n\nÉcrire une fonction SQL nommée cc_fonc_11 qui prend en argument un code d’aéroport p_faa de type text, une année p_year (int4), un mois p_month (int4), un délai plancher p_delay (int4) et renvoie le nombre de vols retardés de strictement plus de p_delay minutes à l’arrivée à l’aéroport faa, pendant le mois month de l’année year.\nLa fonction retourne un entier (bigint)\n\n\n\n\n\n\nRéponse attendue pour\nSELECT * \nFROM cc_fonc_11('LAX', 2013, 3, 40) ;` \n73\n\n\n\n\n\n\n\n\n\nTipsolution\n\n\n\nCREATE OR REPLACE FUNCTION correction_cc3.cc_fonc_11(p_faa TEXT, \n            p_year int4, \n            p_month int4, \n            p_delay int4)\n    RETURNS bigint\n    LANGUAGE sql\nAS $function$\nSELECT COUNT(*) as n\nFROM nycflights13.flights f\nWHERE f.arr_delay &gt; p_delay AND \n      f.dest = p_faa AND \n      f.\"year\" = p_year AND \n      f.\"month\" = p_month;\n$function$\n\n\n\n\n\nExercice\nDonnés sur schéma nycflights.\nÉcrire une fonction SQL nommée cc_fonc_12 qui prend en argument une année p_year, un mois p_month, une compagnie aérienne p_carrier (text) et renvoie le nombre de couples aéroport d’origine origin/aéroports de destination dest distincts desservis par cette compagnie p_carrier pendant le mois p_month de l’année p_year.\nLa fonction retourne un entier (bigint)\nRéponse attendue pour SELECT * FROM cc_fonc_12('UA', 2013, 2);\n39\n\n\n\n\n\n\nTipsolution\n\n\n\nCREATE OR REPLACE FUNCTION correction_cc3.cc_fonc_12(p_carrier TEXT, p_year int4, p_month int4)\n    RETURNS bigint\n    LANGUAGE sql\nAS $function$\nSELECT COUNT(DISTINCT (origin, dest)) AS n\nFROM nycflights13.flights f\nWHERE f.carrier =p_carrier AND \n      f.year=p_year AND \n      f.month=p_month ;\n$function$\n\n\n\n\n\nExercice\nDonnées dans le schéma nycflights13\nÉcrire une vue nommée cc_vue_13 de schema (origin, dest, year, month, carrier, model, maxspeed) qui indique pour chaque couple (origin, dest), pour chaque couple (year,month), la vitesse maximale maxspeed (numeric) d’un vol reliant origin à dest pendant le mois month de l’année year, le modèle de l’avion qui a réalisé le vol le plus rapide, et la compagnie aérienne qui a assuré ce vol.\nmaxspeed sera exprimée en km/h. distance est exprimée en milles nautiques (1 mille = 1.852 km).\nÉcrire une vue nommée cc_vue_13 de schéma:\n(year INT4, month INT4, origin TEXT, dest TEXT, name TEXT, model TEXT, maxspeed numeric)\nRéponse attendue pour\nSELECT *\nFROM cc_vue_13\nWHERE dest='LAX' AND month=4 ;\n+----+-----+------+----+---------------------+--------+-----------------+\n|year|month|origin|dest|name                 |model   |maxspeed         |\n+----+-----+------+----+---------------------+--------+-----------------+\n|2013|    4|EWR   |LAX |United Air Lines Inc.|A320-232|921.6133333333335|\n|2013|    4|JFK   |LAX |United Air Lines Inc.|757-222 |951.9362068965518|\nPrécision pour maxspeed : (1 km/h)\n\n\n\n\n\n\nTipsolution\n\n\n\nCREATE MATERIALIZED VIEW correction_cc3.cc_vue_13 AS (\nWITH r AS (\n    SELECT f.year, f.month, f.origin, f.dest, max(1.852 *60*f.distance/f.air_time) as maxspeed\n    FROM nycflights13.flights f \n    where f.distance &gt; 0 and f.air_time &gt; 0 \n    GROUP BY f.year, f.month, f.origin, f.dest\n), s AS (\n    SELECT r.year, r.month, r.origin, r.dest, r.maxspeed, ff.tailnum, ff.carrier\n    FROM nycflights13.flights ff  JOIN r ON (r.\"month\"=ff.\"month\" AND r.\"year\"=ff.\"year\" AND r.origin=ff.origin AND r.dest=ff.dest)\n    WHERE ff.distance &gt; 0 and ff.air_time &gt; 0  AND (1.852 * 60* ff.distance/ff.air_time) &gt;=  r.maxspeed\n)\nSELECT s.year, s.month, s.origin, s.dest, a.name, p.model ,s.maxspeed \nFROM s  \n     JOIN nycflights13.planes p ON (s.tailnum=p.tailnum) \n     JOIN nycflights13.airlines a ON (s.carrier=a.carrier))\nWITH DATA ;\n\n\n\n\n\nExercice\nDonnés sur schéma nycflights13.\nCréer dans votre schéma, une vue nommée cc_vue_14 de schéma:\n(origin , year int4, month int4, day int4, hour int4, avg_depdelay bigint, n_cancelled bigint, n_scheduled_flights bigint)\nqui donne pour chaque aéroport d’origine origin, chaque heure yyyy:mm:dd hh:00:00, le retard moyen au départ avg_depdelay des vols qui ont (effectivement) décollé de origin pendant l’heure qui a précédé yyyy:mm:dd hh:00:00, et n_canceled le nombre de vols annulés sur cet aéroport pendant cette heure, et enfin n_scheduled_flights le nombre de vols prévus pendant cette heure.\nRéponse attendue pour :\nSELECT date_time,\n       round(avg_delay::numeric, 1) as avg_delay,\n       n_cancelled,\n       n_scheduled_flights\nFROM cc_vue_14\nWHERE origin='JFK' AND\n      n_cancelled &gt; .25 * n_scheduled_flights\nORDER BY date_time\nLIMIT 10 ;\n+-----------------------+---------+-----------+-------------------+\n|date_time              |avg_delay|n_cancelled|n_scheduled_flights|\n+-----------------------+---------+-----------+-------------------+\n|2013-01-30 20:00:00.000|     30.7|          7|                 23|\n|2013-02-08 12:00:00.000|      5.8|          5|                 11|\n|2013-02-08 15:00:00.000|     25.9|          7|                 17|\n|2013-02-08 16:00:00.000|     10.6|         17|                 24|\n|2013-02-08 17:00:00.000|      6.7|         19|                 25|\n|2013-02-08 18:00:00.000|         |         24|                 24|\n|2013-02-08 19:00:00.000|         |         24|                 24|\n|2013-02-08 20:00:00.000|         |         23|                 23|\n|2013-02-08 21:00:00.000|         |         17|                 17|\n|2013-02-08 22:00:00.000|         |          6|                  6|\n\n\n\n\n\n\nTipsolution\n\n\n\nCREATE MATERIALIZED VIEW correction_cc3.cc_vue_14 AS (\nSELECT f.origin, \n    f.\"year\", \n    f.\"month\", \n    f.\"day\", \n    f.\"hour\"+ 1 AS \"hour\", \n    AVG(dep_delay) AS avg_delay,  \n    SUM(CASE WHEN f.arr_time IS NULL THEN 1 ELSE 0 END) AS n_cancelled, \n    COUNT(*) as n_scheduled_flights\nFROM nycflights13.flights f \nGROUP  BY f.origin, f.year, f.month, f.\"day\", f.\"hour\")\nWITH DATA ;\n\n\n\n\n\nExercice\nDonnés sur schéma nycflights13.\nCréer une vue cc_vue_15 de schéma:\n(tailnum text, year int4, woy int4, cumdist numeric, model text)\nqui recense pour chaque semaine (commencant le dimanche) les avions (identifiés par tailnum) qui ont parcouru la plus grande distance durant cette semaine, la distance parcourue pendant la semaine (en milles nautiques), on indiquera aussi le modèle (model) de l’avion\nRéponse attendue pour :\nSELECT  *\nFROM cc_vue_15\nWHERE  woy&gt;=26 AND woy &lt;= 30\n+-------+----+---+-------+-------+\n|tailnum|year|woy|cumdist|model  |\n+-------+----+---+-------+-------+\n|N320AA |2013| 30|22497.0|767-223|\n|N324AA |2013| 28|22497.0|767-223|\n|N327AA |2013| 26|23697.0|767-223|\n|N327AA |2013| 27|22386.0|767-223|\n|N332AA |2013| 29|23475.0|767-223|\n\nIndications\nManipulation du temps\n\nDoc PostgreSQL : types\nDoc PostgreSQL : fonctions\n\nSELECT extract(week from now()), now(), now() + '1 week'::interval ;\n+---------+-----------------------------+-----------------------------+\n|date_part|now                          |?column?                     |\n+---------+-----------------------------+-----------------------------+\n|     46.0|2022-11-20 11:46:59.322 +0100|2022-11-27 11:46:59.322 +0100|\nVoir aussi datetime pour Python ou lubridate pour R.\n\n\n\n\n\n\nTipsolution\n\n\n\nCREATE MATERIALIZED VIEW correction_cc3.cc_vue_15 AS (\nWITH r AS (\n    SELECT f.tailnum, \n    f.year, \n    extract(week from f.time_hour)::int4 as woy, \n    sum(distance) as cumdist\n    FROM nycflights13.flights f\n    WHERE tailnum is not null\n    GROUP BY  f.year, extract(week from f.time_hour), f.tailnum\n),\ns AS (\n    SELECT DISTINCT r.tailnum, \n    r.year, \n    r.woy, \n    r.cumdist, \n    rank() OVER v AS rnk\n    FROM r \n    WINDOW v AS (PARTITION BY (r.year, r.woy) \n               ORDER BY cumdist DESC  NULLS LAST)),\nt AS (\n    SELECT s.tailnum, s.year, s.woy, s.cumdist\n    FROM s \n    WHERE rnk = 1)\n\nSELECT t.*, p.model\nFROM t JOIN nycflights13.planes p ON (t.tailnum=p.tailnum)\n)\n\nWITH DATA  ;"
  },
  {
    "objectID": "exams/cc3-2023-12-08.html",
    "href": "exams/cc3-2023-12-08.html",
    "title": "MA15E045 - Automne 2025",
    "section": "",
    "text": "L3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2023-2024\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteRappel de notation\n\n\n\nDans le formalisme Entité-Association, nous utilisons les pattes de corbeau (crowfoot) pour décrire les contraintes de cardinalités.\n\n\n\n\n\n\n\n\n\n\nerDiagram\n\nA }|..|{ B : foo\n\n\n\n\n\n\nL’entité A est reliée à l’entité B par l’association foo. Une instance de A peut apparaître de \\(1\\) à \\(n\\) fois parmi les instances de l’association foo, de même une instance de B peut apparaître de \\(1\\) à \\(n\\) fois parmi les instances de l’association foo.\n\n\n\n\n\n\n\nerDiagram\n\nA }|..o| B : bar\n\n\n\n\n\n\nL’entité A est reliée à l’entité B par l’association bar. Une instance de A peut apparaître de \\(0\\) à \\(1\\) fois parmi les instances de l’association bar, une instance de B peut apparaître de \\(1\\) à \\(n\\) fois parmi les instances de l’association bar.\n\n\n\n\n\n\n\n\n\nNotez que la contrainte portant sur le nombre de participations des instances d’une entité à une association apparaît à l’opposé de l’entité.\n\n\n\n\nUn système d’information pour l’administration\nUn pays (par exemple France) est organisé en régions (par exemple Bretagne, …). Les régions sont identifiées par leur nom. Ces régions sont-elles même divisées en départements (par exemple Finistère). Les départements sont identifiés par de numéros (par exemple 29 pour le Finistère). Les départments possèdent aussi un nom qui les distingue.\nDans chaque département, il y a des communes qui portent des noms, éventuellement précédés d’un article (par exemple Le Mans, Le Bourget, …). Pour chaque département, les communes sont numérotées à l’aide de leur rang dans l’ordre alphabétique construit sur les noms privés de l’éventuel article (dans la Sarthe, 72, Le Mans est au rang 181 entre Mamers et Mansigné).\nPour chaque commune et chaque année, on connaît le montant total perçu au titre de la taxe foncière.\nChaque année, on procède à un recensement dans chaque commune. On en connaît la population.\nChaque région a une préfecture de région, et chaque département a une préfecture de département.\nOn a cherché à modéliser cette description en formalisme Entité-Association comme suit.\n\n\n\n\n\n%%{init: { \"sequence\": { \"wrap\": true} } }%%\nerDiagram \n    DEPARTEMENT }|..|{ REGION : contient\n    DEPARTEMENT {\n        string nom\n        int departement \n    }\n    REGION ||..o| VILLE : prefecture\n    REGION {\n        string nom   \n    }\n    REGION ||..|{ VILLE : contient\n    DEPARTEMENT |o..|| VILLE : prefecture\n    VILLE {\n        string nom\n        string article\n        int numero       \n    }\n    \n    RECENSEMENT ||..|{ VILLE : concerne\n    RECENSEMENT {\n      int annee \n      int population\n    }\n    TAXE ||..|{ VILLE : rapporte\n    TAXE {\n      int annee\n      int valeur\n    }\n\n\n\n\n\n\n\n\n\n\n\n\nNoteQuestion 1\n\n\n\n\nUn certain nombre d’erreurs se sont glissées dans ce schéma Entité-Association. Corrigez-le.\nProposez un identifiant pour chaque entité.\nDésignez les entités faibles.\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\n\nerDiagram \n    REGION |o..|| VILLE : prefecture\n    REGION {\n        string nom  PK \n    }\n    REGION ||..|{ DEPARTEMENT : contient\n    DEPARTEMENT {\n        string nom\n        int departement PK \n    }\n    DEPARTEMENT ||--|{ VILLE : contient\n    DEPARTEMENT |o..|| VILLE : prefecture\n    VILLE {\n        string nom\n        string article\n        int numero PK      \n    }\n    RECENSEMENT }|--|| VILLE : concerne\n    RECENSEMENT {\n      int annee PK\n      int population\n    }\n    TAXEFONCIERE }|--|| VILLE : recoit\n    TAXEFONCIERE {\n      int annee PK\n      int montant\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTipSolution (suite)\n\n\n\nLes numéros des communes sont des identifiants relatifs. Ils apparaissent sur nos numéros de sécurité sociale (chiffres en position 4, 5, 6).\nVILLE, RECENSEMENT et TAXE sont des entités faibles.\nL’identifiant de VILLE est le couple departement, numero\nL’identifiant de TAXE est le triplet departement, numero, annee. Idem pour RECENSEMENT.\nLes associations notées en trait plein sont dites identifiantes. L’identifiant d’une entité faible est formé en assemblant l’identifiant de l’entité de cardinalité \\(0:n\\) et l’identifiant relatif de l’entité faible (cardinalité \\(1:1\\)).\n\n\n\nSoit le schéma \\(\\mathcal{A}=\\left\\{\\texttt{A},\\texttt{B},\\texttt{C},\\texttt{D},\\texttt{E},\\texttt{F}\\right\\}\\) et l’ensemble \\(\\Sigma\\) de DF\n   A,B → C\n     B → F  \n   C,E → A  \n     F → E\n\n\n\n\n\n\nNoteQuestion 2\n\n\n\nCalculer la clôture/fermeture \\(\\{\\texttt{A},\\texttt{B}\\} = [\\{\\texttt{A},\\texttt{B}\\}]_{\\Sigma}^+\\) de \\(\\{\\texttt{A},\\texttt{B}\\}\\) en utilisant l’ensemble de DF \\(\\Sigma\\).\n\n\n\n\n\n\n\n\nTipSolution 2\n\n\n\n\\(\\{\\texttt{A},\\texttt{B}\\}^+\\) contient forcément A et B. Par la DF A,B → C, elle contient aussi C. Comme B → F, elle contient F. Comme F → E, elle contient E. Donc elle contient les attributs : \\(\\{\\texttt{A},\\texttt{B}\\}^+=\\{\\texttt{A},\\texttt{B},\\texttt{C},\\texttt{E},\\texttt{F}\\}\\) (tous sauf D).\n\n\n\n\n\n\n\n\nNoteQuestion 3\n\n\n\nQuelles sont les clefs du schéma \\(\\mathcal{A}\\) en utilisant l’ensemble de DF \\(\\Sigma\\) ?\n\n\n\n\n\n\n\n\nTipSolution 3\n\n\n\nComme D n’apparaît dans aucune DF (en membre gauche, ou en membre droit), toute clé est formée de la réunion de \\(\\{\\texttt{D}\\}\\) et d’une clé pour \\(\\mathcal{A} \\setminus \\{\\texttt{D}\\}\\) muni de \\(\\Sigma\\).\nOn vient de voir que \\(\\{\\texttt{A},\\texttt{B}\\}\\) est une super-clef de \\(\\mathcal{A} \\setminus \\{\\texttt{D}\\}\\) muni de \\(\\Sigma\\). C’est aussi une clef de \\(\\mathcal{A} \\setminus \\{\\texttt{D}\\}\\) puisque \\([\\{\\texttt{A}\\}]_\\Sigma^+=\\{\\texttt{A}\\}\\) et \\([\\{\\texttt{B}\\}]_{\\Sigma}^+=\\{\\texttt{B},\\texttt{E},\\texttt{F}\\}\\) pour ses deux sous-ensembles.\nDonc \\(\\{\\texttt{A},\\texttt{B}, \\texttt{D}\\}\\) est une clé.\nCe n’est pas la seule clef : \\(\\{\\texttt{B},\\texttt{C}\\}\\) en est aussi une.\nToutes les super-clefs doivent contenir B (qui ne dépend d’aucun autre attribut), et comme \\(\\texttt{B}^+=\\{\\texttt{B},\\texttt{E},\\texttt{F}\\}\\), E et F n’apportent rien par rapport à B seul.\nLes clefs sont donc \\(\\{\\texttt{A},\\texttt{B}, \\texttt{D}\\}\\) et \\(\\{\\texttt{B},\\texttt{C}, \\texttt{D}\\}\\).\n\n\n\nOn travaillera par la suite sur le schéma relationnel villes et les tables définies par le code SQL suivant.\n\nCREATE SCHEMA villes;\n\nCREATE TABLE villes.region (\n  nom varchar NOT NULL PRIMARY KEY,\n  prefecture_num int4 NULL,\n  prefecture_dep int4 NULL\n);\n\nCREATE TABLE villes.departement (\n  nom varchar NULL UNIQUE,\n  departement int4 NOT NULL PRIMARY KEY,\n  region varchar NULL REFERENCES villes.region(nom)\n    ON DELETE SET NULL ON UPDATE CASCADE,\n  numero int4 NULL\n);\n\nCREATE TABLE villes.ville (\n  nom varchar NULL,\n  article varchar NULL,\n  departement int4 NOT NULL REFERENCES villes.departement\n    ON DELETE RESTRICT ON UPDATE CASCADE,\n  numero int4 NOT NULL,\n  CONSTRAINT ville_pkey PRIMARY KEY (departement, numero)\n);\n\nALTER TABLE villes.region ADD \n  CONSTRAINT region_prefecture_fk FOREIGN KEY (prefecture_dep,prefecture_num) \n  REFERENCES villes.ville(departement,numero) \n  ON DELETE RESTRICT ON UPDATE CASCADE;\n\nALTER TABLE villes.departement ADD \n  CONSTRAINT departement_prefecture_fk FOREIGN KEY (departement,numero) \n  REFERENCES villes.ville(departement,numero) \n  ON DELETE SET NULL ON UPDATE CASCADE;\n\nCREATE TABLE villes.recensement (\n  annee year NOT NULL,\n  departement int4 NOT NULL,\n  numero int4 NOT NULL,\n  population int4 NULL,\n  CONSTRAINT recensement_pk PRIMARY KEY (annee, departement, numero),\n  CONSTRAINT recensement_fk FOREIGN KEY (departement,numero) \n    REFERENCES villes.ville(departement,numero) \n    ON DELETE RESTRICT ON UPDATE CASCADE\n);\n\nCREATE TABLE villes.taxe (\n  annee year NOT NULL,\n  departement int4 NOT NULL,\n  numero int4 NOT NULL,\n  valeur int4 NULL,\n  CONSTRAINT taxe_pk PRIMARY KEY (annee, departement, numero),\n  CONSTRAINT taxe_fk  FOREIGN KEY (departement,numero) \n    REFERENCES villes.ville(departement,numero) \n    ON DELETE RESTRICT ON UPDATE CASCADE\n);\n\n\n\n\n\n\n\nToutes les questions qui suivent se rapportent au schéma villes.\nPour chaque question, proposer une requête écrite en algèbre relationnelle ou en SQL.\n\n\n\n\n\n\n\n\n\nNoteQuestion 4\n\n\n\nLister par région le nombre de communes.\n\n\n\n\n\n\n\n\nTipSolution 4\n\n\n\nSELECT departement.region, COUNT(*)\n  FROM villes.departement JOIN\n       villes.ville USING (departement)\n GROUP BY departement.region ;\n\n\n\n\n\n\n\n\nnom n’est pas une clé pour ville. COUNT(DISTINCT ville.nom) ne donnera pas nécessairement le résultat attendu.\n\n\n\n\n\n\n\n\n\nNoteQuestion 5\n\n\n\nQuel département contient le plus de communes ?\n\n\n\n\n\n\n\n\nTipSolution 5\n\n\n\nVersion avec &gt;= ALL :\nWITH counts AS (\n  SELECT departement, COUNT(*)\n  FROM villes.ville\n  GROUP BY departement\n)        \n\nSELECT departement\nFROM counts\nWHERE count &gt;= ALL (SELECT count FROM counts);\nVersion avec RANK() :\nWITH counts AS (\n  SELECT departement.nom, departement, COUNT(ville.numero)\n    FROM villes.departement JOIN villes.ville USING (departement)\n   GROUP BY departement),\nrangs AS (\n  SELECT nom, departement,\n         RANK() OVER (PARTITION BY departement ORDER BY count DESC)\n    FROM counts)\nSELECT nom, departement\n  FROM rangs\n WHERE rank = 1;\n\n\n\n\n\n\n\n\nNoteQuestion 6\n\n\n\nQuel département a connu la plus forte croissance démographique relative entre 2010 et 2020 ?\n\n\n\n\n\n\n\n\nTipSolution 6\n\n\n\nWITH dpop10 AS (SELECT departement, SUM(population) as pop10\n    FROM villes.ville NATURAL JOIN villes.recensement\n   WHERE annee = 2010\n   GROUP BY departement),\ndpop20 AS (SELECT departement, SUM(population) as pop20\n    FROM villes.ville NATURAL JOIN villes.recensement\n   WHERE annee = 2020\n   GROUP BY departement),\ncroissance AS (SELECT departement, (pop20 - pop10)/pop10 as delta\n    FROM dpop10 NATURAL JOIN dpop20)\nSELECT departement\n  FROM croissance\n WHERE delta &gt;= ALL (SELECT delta FROM croissance);\n\n\n\n\n\n\n\n\nNoteQuestion 7\n\n\n\nPour chaque région, quelle est la proportion de la population qui vit dans des préfectures départementales en 2020 ?\n\n\n\n\n\n\n\n\nTipSolution 7\n\n\n\nWITH totalpop AS (\n  SELECT d.region, SUM(r.population) AS total\n  FROM villes.departement d JOIN\n       villes.recensement r ON (d.departement = r.departement)\n  WHERE r.annee = '2020'\n  GROUP BY d.region),\n\n  prefpop AS (\n  SELECT d.region, SUM(population) AS pref\n  FROM villes.departement d JOIN \n       villes.recensement r ON (d.departement=r.departement AND \n                                d.numero=r.numero)\n  WHERE annee = '2020'\n  GROUP BY region.nom)\n\nSELECT region, (pref + 0.0)/total\nFROM totalpop NATURAL JOIN \n     prefpop;"
  },
  {
    "objectID": "exams/ct-2024-01-08.html",
    "href": "exams/ct-2024-01-08.html",
    "title": "MA15E045 - Automne 2025",
    "section": "",
    "text": "L3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2023-2024\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\n\n\n\n\n\n\nLes trois exercices (modélisation, normalisation, requêtes) portent sur le schéma nycflights légèrement nettoyé.\n\n\n\n\n\n\nNYCFlights en relationel à pattes de corbeau\n\n\n\n\nDéfinition du schéma en SQL\n\n\n\nCREATE TABLE airlines (\n    carrier text NOT NULL,\n    \"name\" text NULL,\n    CONSTRAINT airlines_pk \n        PRIMARY KEY (carrier),\n    CONSTRAINT airlines_un \n        UNIQUE (name)\n);\nCREATE TABLE airports (\n    faa text NOT NULL,\n    \"name\" text NULL,\n    lat float8 NULL,\n    lon float8 NULL,\n    alt float8 NULL,\n    tz float8 NULL,\n    dst text NULL,\n    tzone text NULL,\n    CONSTRAINT airports_pk \n        PRIMARY KEY (faa),\n    CONSTRAINT airports_un \n        UNIQUE (name),\n    CONSTRAINT airports_un_ll \n        UNIQUE (lat, lon)\n);\n\n\nCREATE TABLE weather (\n    origin text NOT NULL,\n    \"year\" int4 NULL,\n    \"month\" int4 NULL,\n    \"day\" int4 NULL,\n    \"hour\" int4 NULL,\n    \"temp\" float8 NULL,\n    dewp float8 NULL,\n    humid float8 NULL,\n    wind_dir float8 NULL,\n    wind_speed float8 NULL,\n    wind_gust float8 NULL,\n    precip float8 NULL,\n    pressure float8 NULL,\n    visib float8 NULL,\n    time_hour timestamptz NOT NULL,\n    CONSTRAINT weather_pk \n        PRIMARY KEY (origin, time_hour)\n);\nALTER TABLE weather ADD \n    CONSTRAINT weather_fk \n    FOREIGN KEY (origin) \n    REFERENCES airports(faa) \n    ON DELETE CASCADE \n    ON UPDATE CASCADE;\n\n\n\nCREATE TABLE planes (\n    tailnum text NOT NULL,\n    \"year\" int4 NULL,\n    \"type\" text NULL,\n    manufacturer text NULL,\n    model text NULL,\n    engines int4 NULL,\n    seats int4 NULL,\n    speed int4 NULL,\n    engine text NULL,\n    CONSTRAINT planes_pk   PRIMARY KEY (tailnum)\n);\n\n\n\nCREATE TABLE flights (\n    \"year\" int4 NULL,\n    \"month\" int4 NULL,\n    \"day\" int4 NULL,\n    dep_time int4 NULL,\n    sched_dep_time int4 NULL,\n    dep_delay float8 NULL,\n    arr_time int4 NULL,\n    sched_arr_time int4 NULL,\n    arr_delay float8 NULL,\n    carrier text NULL,\n    flight int4 NULL,\n    tailnum text NOT NULL,\n    origin text NOT NULL,\n    dest text NULL,\n    air_time float8 NULL,\n    distance float8 NULL,\n    \"hour\" float8 NULL,\n    \"minute\" float8 NULL,\n    time_hour timestamptz NOT NULL,\n    CONSTRAINT flights_pk \n        PRIMARY KEY (\n            tailnum, origin, time_hour)\n);\n\n\nALTER TABLE flights ADD \n    CONSTRAINT flights_fk \n    FOREIGN KEY (carrier) \n    REFERENCES airlines(carrier) \n    ON DELETE SET NULL \n    ON UPDATE CASCADE;\nALTER TABLE flights ADD \n    CONSTRAINT flights_fk_dest \n    FOREIGN KEY (dest) \n    REFERENCES airports(faa) \n    ON DELETE SET NULL \n    ON UPDATE CASCADE;\nALTER TABLE flights ADD \n    CONSTRAINT flights_fk_origin \n    FOREIGN KEY (origin) \n    REFERENCES airports(faa) \n    ON DELETE SET NULL \n    ON UPDATE CASCADE;\nALTER TABLE flights ADD \n    CONSTRAINT flights_fk_planes \n    FOREIGN KEY (tailnum) \n    REFERENCES planes(tailnum) \n    ON DELETE SET NULL \n    ON UPDATE CASCADE;\n\n\n\nDans le schéma nycflights, on a aussi les dépendances fonctionnelles suivantes:\nTable airports\n\nfaa, name, et (lon, lat) sont des clés.\n\nTable airlines\n\ncarrier et name sont des clés\n\nTable weather\n\norigin, time_hour est une clé\ntime_hour → year, month, day, hour\nyear, month, day, hour  → time_hour\n\nTable planes\n\ntailnum est une clé\nmodel → manufacturer, engines, engine, type\n\nTable flights\n\ntailnum, time_hour → carrier\ntime_hour → sched_dep_time\nsched_dep_time, dep_time → dep_delay\nsched_arr_time, arr_time → arr_delay\norigin, dest, dep_time, arr_time → airtime\ntime_hour → year, month, day, hour, minute\nyear, month, day, hour, minute → time_hour\norigin, dest → distance\n(tailnum, origin, time_hour) est une clé\n(flight, dest, origin, year, month, day) est une clé\n\n\n\n\n\n\n\n\n\nNoteExercice : Modélisation\n\n\n\n\nLe schéma entité-association est une tentative de rétro-ingénieurie du schéma relationnel nycflights.\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nProposez une variation de la représentation de l’entité plane où on définit une entité model (dont les instances seraient par exemple Airbus A350, Boeing 777, …), et où chaque avion/aéronef serait considéré comme une réalisation d’une instance de model).\nPréciser la nature de l’association entre plane et model et les cardinalités.\nPrécisez la répartition des attributs entre plane et model.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nAssociation est-un (is-a), avec cardinalité 1:1 côté plane et 0:n côté model\nmodel a les attributs model (à renommer), engines, type, manufacturer, engine.\nplane garde les attributs year, seats, tailnum (identifiant)\nSi les instances de plane sont identifiées par tailnum, l’association est-un n’est pas identifiante.\n\n\n\n\n\n\n\n\n\n\nNoteExercice : Normalisation\n\n\n\n\n\n\n\n\n\n\n\n\nNoteQuestion 1\n\n\n\nPour chaque table, préciser si elle est en FNBC ou non.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n airlines : en FNBC car deux colonnes\n airports : en FNBC\n planes : viole la condition FNBC par toutes les DF model → ...\n weather : deux clés (origin, time_hour) et (origin, year, month, day, hour), mais les membres gauches des DF time_hour → year, month, day, hour et year, month, day, hour  → time_hour violent la condition FNBC.\n flights viole la condition FNBC de plusieurs façons notamment via la DF origin, dest →  distance.\n\n\n\n\n\n\n\n\n\nNoteQuestion 2\n\n\n\nSi certaines tables ne sont pas en FNBC, proposer une décomposition en FNBC sans perte d’information.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\nPour planes, la décomposition (model, manufacturer, engines, engine, type), (tailnum, year, model, seats, speed) est en FNBC.\nPour weather, supprimer les colonnes year, month, day, hour qui peuvent être calculées à partir de time_hour.\nPour flights, décomposition\n\n(origin, dest, distance)\n(flight, time_hour)\n(flight, dest, origin, time_hour, dep_time, sched_arr_time, arr_time, tailnum)\n(tailnum, time_hour, carrier)\n\n\n\n\n\n\n\n\n\n\n\nNoteExercice : Requêtes (schéma nycflights)\n\n\n\n\n\n\n\n\n\n\n\n\nNoteRequête 1\n\n\n\n\n\nFor each airport of departure (denoted by origin), for each day of the year, list the codes (carrier) of the airlines that have one or more planes taking off from that airport on that day.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT DISTINCT f.origin, f.year, f.month, f.day, f.carrier\nFROM nycflights.flights f \nORDER BY f.origin, f.year, f.month, f.day;\n Il n’est pas nécessaire, ni même utile de procéder à une aggrégation (GROUP BY), il suffit de projeter sur les attributs qui identifient le jour de l’année f.year, f.month, f.day, l’aéroport de décollage (origin), et l’identifiant des compagnies aériennes carrier, et, bien sûr d’éliminer les doublons avec DISTINCT.\n Si on veut récupérer les noms complets des compagnies aériennes, plutôt que les codes, on peut effectuer une jointure naturelle avec airlines.\n Si on veut (finalement) une ligne par aéroport de départ et jour de l’année, on doit alors effectuer une aggrégation et utiliser une fonction d’aggrégation de chaine de caractères comme concat()\nWITH R AS (\n  SELECT DISTINCT f.origin, f.year, f.month, f.day, f.carrier\n  FROM nycflights.flights f \n)\n\nSELECT R.origin, R.year, R.month, R.day, concat(R.carrier) AS carriers\nFROM R \nGROUP BY R.origin, R.year, R.month, R.day\nORDER BY R.origin, R.year, R.month, R.day ;\n\n\n\n\n\n\n\n\nNoteRequête 2\n\n\n\n\n\n\nLister pour chaque aéroport d’origine, chaque jour de l’année, pour chaque compagnie aérienne, le nombre d’avions exploités par la compagnie aérienne qui décollent de cet aéroport, ce jour là.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT f.origin, f.year, f.month, f.day, f.carrier, COUNT(DISTINCT tailnum)\nFROM nycflights.flights f \nGROUP BY f.origin, f.year, f.month, f.day, f.carrier\nORDER BY f.origin, f.year, f.month, f.day, f.carrier;\n Il faut bien garder en tête que la clause GROUP BY (la clause de partitionnement) est définie par une liste de colonnes (ou plus généralement d’expressions) séparées par des virgules, ici f.origin, f.year, f.month, f.day, f.carrier. Ces colonnes sont évoquées dans pour chaque aéroport d’origine, chaque jour de l’année, pour chaque compagnie aérienne. Ces colonnes doivent aussi apparaître dans la clause SELECT (la clause de projection finale).\n Dans la clause de projection SELECT ... ne peuvent figurer que - les expressions qui apparaissent dans la clause GROUP BY ... - les expressions d’aggrégation comme COUNT(...).\n\n\n\n\n\n\n\n\nNoteRequête 3\n\n\n\n\nLister pour chaque vol exploité par la compagnie (carrier nommé dans airlines) Delta Air Lines Inc. : les conditions météorologiques (weather) à l’heure prévue du décollage (sched_dep_time).\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH delta AS (\n    SELECT al.carrier\n    FROM nycflights.airlines al\n    WHERE al.\"name\" = 'Delta Air Lines Inc.'\n),\ndelta_f AS (\n    SELECT f.origin, f.flight, f.year, f.month, f.day, f.hour \n    FROM nycflights.flights f\n    WHERE f.carrier IN (SELECT * FROM delta)\n)\n\nSELECT f.flight, w.*\nFROM  nycflights.weather w NATURAL JOIN delta_f f;\n\n\n\n\n\n\n\n\nNoteRequête 4\n\n\n\n\n\nNombre de vols au décollage par aéoroport d’origine et par compagnie aérienne (carrier).\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nSELECT f.origin, f.carrier, COUNT(*) AS n\nFROM nycflights.flights f\nGROUP BY f.origin, f.carrier \nORDER BY f.carrier, n DESC;\n\n\n\n\n\n\n\n\nNoteRequête 5\n\n\n\n\n\nLister les caractéristiques des avions (planes) exploités par au moins deux compagnies aériennes (carrier) différentes dans la base de données.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH for_hire AS (\n    SELECT f.tailnum, COUNT(DISTINCT f.carrier) AS n_carrier\n    FROM nycflights.flights f\n    GROUP BY f.tailnum \n    HAVING COUNT(DISTINCT f.carrier) &gt;=2 \n)\n\nSELECT p.*\nFROM nycflights.planes p NATURAL JOIN for_hire ;\n\n\n\n\n\n\n\n\nNoteRequête 6\n\n\n\n\n\nLister pour chaque jour et chaque aéoroport d’origine les dix avions les plus en retard au décollage (dep_delay). Ne pas prendre en compte les vols annulés (dep_time IS NULL).\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH f_delayed AS (\n  SELECT f.*, RANK() OVER w AS rnk\n  FROM nycflights.flights f\n  WHERE f.dep_time IS NOT NULL\n  WINDOW w AS (PARTITION BY f.origin, f.year, f.month, f.day ORDER BY f.dep_delay DESC)  \n)\n\nSELECT fd.origin, fd.year, fd.month, fd.day, fd.tailnum\nFROM f_delayed fd\nWHERE fd.rnk &lt;= 10;\n\n\n\n\n\n\n\n\nNoteRequête 7\n\n\n\n\n\nLister pour chaque modèle d’avion (model) le nombre de jours où un avion de ce modèle a subi le plus grand retard au décollage (dep_delay) parmi les avions qui ont décollé ce jour là du même aéroport (origin).\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH delayed_flight AS (\n  SELECT f.origin, f.year, f.month, f.day, f.tailnum, \n         RANK() OVER w AS rnk\n  FROM nycflights.flights f\n  WINDOW w AS (PARTITION BY f.origin, f.year, f.month, f.day \n               ORDER BY f.dep_delay DESC)\n), plane_of_day  AS (\n  SELECT df.origin, df.year, df.month, df.day, df.tailnum\n  FROM delayed_flight df\n  WHERE df.rnk = 1\n)\n\nSELECT p.model, COUNT(DISTINCT(df.year, df.month, df.day)) AS nb_bad_days\nFROM plane_of_day df  JOIN nycflights.planes p ON \n  (df.tailnum=p.tailnum)\nGROUP BY p.model \nORDER BY nb_bad_days DESC;\n L’utilisation d’une clause WITH (Common Table Expression) plutôt que d’une requête imbriquée rend le code plus lisible.\n Dans la réponse, nous donnons plus que ce qui était demandé. On aurait pu se contenter de ;\n...\n\nSELECT p.model\nFROM plane_of_day df  NATURAL JOIN nycflights.planes p \nGROUP BY p.model ;\n\n\n\n\n\n\n\n\nNoteRequête 8\n\n\n\n\n\nLister les aéroports de destination (dest) qui sont desservis au moins une fois à partir de chaque aéroport de départ (origin).\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH origins AS (\n  SELECT DISTINCT f.origin  -- les origines\n  FROM nycflights.flights f\n), dests AS (\n  SELECT DISTINCT f.dest  -- les destinations\n  FROM nycflights.flights f\n),\norigin_dest AS (\n  SELECT DISTINCT f.dest, f.origin \n  FROM nycflights.flights f   -- les couples realises\n  ),\norigin_cross_dest AS (\n  SELECT d.dest, o.origin  -- les couples possibles\n  FROM dests d, origins o\n), \nwhitness_orphans AS (\n  SELECT *\n  FROM origin_cross_dest\n\n  EXCEPT\n\n  SELECT *\n  FROM origin_dest  -- couples pas realises\n)\n\nSELECT dest\nFROM dests\n\nEXCEPT\n\nSELECT w.dest\nFROM whitness_orphans w ;\n Dans cette réponse, nous n’avons pas utilisé l’agrégation (GROUP BY ...). On aurait pu écrire cette requête en algèbre relationnelle. Avec l’agrégation c’est plus simple.\nWITH R AS (\n  SELECT COUNT(DISTINCT f.origin) as nb_origins\n  FROM nycflights.flights f\n)\n\nSELECT f.dest\nFROM nycflights.flights f\nGROUP BY f.dest \nHAVING COUNT(DISTINCT f.origin) &gt;= ALL (SELECT * FROM R) ;\n\n\n\n\n\n\n\n\nNoteRequête 9\n\n\n\n\n\nLister les compagnies aériennes (carrier) pour lesquelles, chaque jour, au moins un avion figure parmi les 10 avions les plus en retard au décollage (dep_delay) de son aéroport de départ (origin).\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH delayed_flight AS (\n  SELECT f.origin, f.year, f.month, f.day, f.tailnum, f.carrier,\n         RANK() OVER w AS rnk\n  FROM nycflights.flights f\n  WINDOW w AS (PARTITION BY f.origin, f.year, f.month, f.day \n               ORDER BY f.dep_delay DESC)\n), carriers_of_day  AS (\n  SELECT DISTINCT df.origin, df.year, df.month, df.day, df.carrier\n  FROM delayed_flight df\n  WHERE df.rnk &lt;= 10\n), nb_bad_days_per_carrier AS (\n  SELECT df.origin, \n         df.carrier, \n         COUNT(DISTINCT (df.year, df.month, df.day)) as nb \n  FROM carriers_of_day df  GROUP BY df.origin, df.carrier\n), nb_days AS (\n  SELECT COUNT(DISTINCT (df.year, df.month, df.day)) AS nb\n  FROM carriers_of_day df \n) \n\nSELECT a.origin, a.carrier\nFROM nb_bad_days_per_carrier a \nWHERE a.nb &gt;= ALL (SELECT nb FROM nb_days) ;\n La complexité de la réponse tient à la complexité de la question : s’il fallait écrire une formule du calcul relationnel des tuples, il faudrait introduire des quantifications alternées. Les requêtes de la clause WITH correspondent à ses alternances de quantification \\(\\forall, \\exists\\) . carriers_of_day liste pour chaque journée répertoriée dans la base, les transporteurs dont un avion figure parmi les retardataires du jour pour un aéroport donné. On détermine ensuite le nombre total de journées de la honte pour chaque transporteur, et le nombre total de journées, on sélectionne enfin les transporteurs dont le nombre de journées de la honte coïncide avec le nombre total de journées.\n\n\n\n\n\n\n\n\nNoteRequête 10\n\n\n\n\n\nPour chaque couple (origin, dest), lister les dix vols les plus rapides (airtime donne le temps de vol, distance la distance entre dest et origin).\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nWITH R AS (\n  SELECT f.origin, f.dest, f.tailnum, f.flight, RANK() OVER w AS rnk\n  FROM nycflights.flights f\n  WHERE f.airtime IS NOT NULL\n  WINDOW w AS (PARTITION BY f.origin, f.dest ORDER BY f.distance/f.airtime DESC)\n)\n\nSELECT R.*\nFROM R \nWHERE R.rnk &lt;= 10 ;\n\n\n\n\n\n\n\n\nTipQuelques conseils\n\n\n\n\nPréférez les clauses WITH et les jointures aux requêtes imbriquées sauf si la requête imbriquée est très simple. C’est une question de lisibilité et donc souvent de correction.\nNe mélangez pas les fonctions fenêtres et les clauses GROUP BY ...\n\nSELECT ..., FOO() OVER w\nFROM R\nWINDOW w AS (PARTITION BY ... ORDER BY ...)\nGROUP BY ... ;  \nest tout simplement incorrect.\n\nLorsque vous effectuez un partitionnement par GROUP BY ..., la clause SELECT ... est sévèrement contrainte, vous n’y trouverez que\n\nles colonnes qui ont servi dans la clause GROUP BY ..., normalement elles devraient toutes y figurer\ndes fonctions d’aggrégation, comme COUNT(...), SUM(...), VAR(...)"
  },
  {
    "objectID": "exams/ct-2025-06-06.html",
    "href": "exams/ct-2025-06-06.html",
    "title": "MA15E045 - Automne 2025",
    "section": "",
    "text": "L3 MIASHS/Ingémath/METIS\nUniversité Paris Cité\nAnnée 2024-2025\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Un service de vélos partagés permet aux abonnés d’utiliser des vélos mécaniques ou électriques. Chaque vélo porte un numéro. Un vélo entre en service à une date donnée, Il est retiré du service à une date donnée (pas connue à l’avance).\n Chaque abonné souscrit un abonnement pour une durée d’un an à une date donnée. Chaque abonnement possède un numéro, et un titulaire qui possède un nom, un prénom, un âge et un sexe. Un abonnement n’est pas renouvelable. Cela n’empêche pas une personne de souscrire un autre abonnement.\n Un abonné emprunte un vélo à une bornette à un instant de départ donné. Une fois le trajet effectué, l’abonné verrouille le vélo sur une bornette à l’instant d’arrivée.\n Les bornettes sont situées sur des stations. Chaque station contient un nombre \\(n\\) (qui peut varier d’une station à l’autre, mais est constant pour une station donnée) de bornettes numérotées de \\(1\\) à \\(n\\). Les stations sont numérotées, elles ont un nom et une adresse. Chaque station a une longitude et une latitude.\n\n\n\n\n\n\nNoteQuestion 1 (4pts)\n\n\n\nProposer un diagrammme entité-association (EA) correspondant à cette modélisation.\nOn attend un dessin selon les conventions du cours, pas une énumération.\n\n\n\n\n\n\n\n\nTipConseils\n\n\n\n\nDistinguer entités fortes et faibles\nDistinguer associations fortes et faibles\nPour chaque entité préciser l’identifiant (éventuellement relatif)\nPréciser les cardinalités pour chaque participation à une association\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nEntités\n\n\nAbonné\n\nAbonnéID (Identifiant)\nNom\nPrénom\nAge\nGenre\nDébutDate (de souscription)\n\nVelo\n\nVeloID (PK)\nType (Mecanique ou Electrique)\nDebutServiceDate\nFinServiceDate\n\nBornette (entité faible)\n\nBornetteID (Identifiant relatif)\n\nStation\n\nStationID (Identifiant)\nNom\nLongitude\nLatitude\nAddresse\n#bornettes\n\n\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nAssociations\n\n\nTrajet\n\nStartTime\nEndTime\n\nEntités participantes\n\nAbonné 0:n\nVélo 0:n\nBornette (rôle : Départ) 0:n\nBornette (rôle : Arrivée) 0:n\n\nStation–Bornette\nEntités participantes\n\nBornette 1:1\nStation 1:n\n\n\nC’est un lien partie de entre une entité faible (Bornette) et une entité forte (Station). Une station comporte plusieurs bornettes.\n\n\n\n\n\n\n\n\n\nER\n\n\n\nabonne\n\nabonne\n\n\n\ntrajet\n\ntrajet\n\n\n\nabonne--trajet\n\n0:n\n\n\n\nvelo\n\nvelo\n\n\n\nvelo--trajet\n\n0:n\n\n\n\nstation\n\nstation\n\n\n\nabonne_id\n\nabonne_id\n\n\n\nabonne_id--abonne\n\n\n\n\nvelo_id\n\nvelo_id\n\n\n\nvelo_id--velo\n\n\n\n\nbornette_id\n\nbornette_id\n\n\n\nbornette\n\n\nbornette\n\n\n\nbornette_id--bornette\n\n\n\n\nstation_id\n\nstation_id\n\n\n\nstation_id--station\n\n\n\n\npartie-de\n\n\npartie-de\n\n\n\npartie-de--station\n\n0:n\n\n\n\nbornette--trajet\n\n0:n depart\n\n\n\nbornette--trajet\n\n0:n arrivee\n\n\n\nbornette--partie-de\n\n1:1\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteQuestion 2 (2pts)\n\n\n\nLister les contraintes externes\n\n\n\n\n\n\n\n\n\nUn vélo ne peut pas être emprunté simultanément par deux abonnés\nLe nombre de bornettes rattachées à une station ne peut excéder la limite fixée pour la station\nUn vélo ne peut effectuer de trajets qu’entre sa date de début de service et sa date de retrait de service.\nUn abonné ne peut pas effectuer de trajet avant la date de début ou après la date de fin d’abonnement.\nUne bornette ne peut pas être occupée par deux vélos simultanément.\n\n\n\n\n\n\n\n\n\n\nNoteQuestion 3 (2pts)\n\n\n\nProposer une traduction en pattes de corbeau du diagramme EA proposé en réponse\nà la première question.\n\n\n\n\n\n\n\n\nTipConseil\n\n\n\nPrécisez\n\nune clé primaire pour chaque table,\nles tables dites intermédiaires,\npour les liens matérialisant les contraintes référentielles, préciser s’ils sont identifiant ou non.\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\nerDiagram\n    TRAJET }o..|| VELO : velo_id \n    TRAJET }o..|| ABONNE  : abonne_id\n    TRAJET }o..|| BORNETTE : bornette_depart_id \n    TRAJET }o..|| BORNETTE : bornette_arrivee_id \n    BORNETTE }o--|| STATION : station_id\n\n  VELO {\n    num velo_id PK\n    date DebutServiceDate \n    date FinServiceDate\n    text type\n  }\n\n  ABONNE {\n    num abonne_id PK\n    text nom\n    text prenom\n    num age\n    date debut\n    text genre \n  }\n\n  TRAJET {\n    num trajet_id PK\n    num velo_id  FK\n    num abonne_id   FK\n    %% date depart_ts\n    %% date arrivee_ts\n    num bornette_depart_id FK\n    num station_depart_id FK\n    num bornette_arrivee_id FK\n    num station_arrivee_id FK\n  }\n\n  BORNETTE {\n    num station_id PK, FK\n    num bornette_id PK\n  }\n\n  STATION {\n    num station_id PK\n    text nom\n    text adresse\n    num latitude\n    num longitude\n    num bornettes\n  }\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteQuestion 4 (1pt)\n\n\n\nProposer un mécanisme pour mettre en place les contraintes externes en SQL lorsque c’est possible sans utiliser les gachettes (TRIGGER).\n\n\nOn écrit ici en SQL, le schéma correspondant,\n\n\n\n\n\n\nTipSolution\n\n\n\nCREATE TABLE Abonné (\n    AbonnéId INT PRIMARY KEY,\n    Nom VARCHAR(100),\n    Prénom VARCHAR(100),\n    Age INT,\n    Genre CHAR(1),\n    DébutDate DATE\n);\nCREATE TABLE Velo (\n    VéloId INT PRIMARY KEY,\n    Type ENUM('Mecanique', 'Electrique'),\n\n);\nCREATE TABLE Station (\n    StationID INT PRIMARY KEY,\n    Nom VARCHAR(100),\n    Longitude DECIMAL(9,6),\n    Latitude DECIMAL(9,6),\n    Adresse VARCHAR(255),\n    `#Bornettes` INT\n);\nCREATE TABLE Bornette (\n  StationID INT, \n  BorneID INT, \n  PRIMARY KEY (StationID, BorneID),\n  FOREIGN KEY (StationID) REFERENCES Station.StationID\n)\nCREATE TABLE Trajet (\n    TrajetID INT PRIMARY KEY,\n    DébutTS TIMESTAMP,\n    FinTS TIMESTAMP,\n    AbonnéID INT,\n    VéloID INT,\n    BornetteDépartID INT,\n    BornetteArriveeID INT,\n    StationDepartID INT,\n    StationArriveeID INT,\n    FOREIGN KEY (AbonnéID) REFERENCES Abonné(AbonnéID),\n    FOREIGN KEY (VeloID) REFERENCES Velo(VeloID),\n    FOREIGN KEY (StationDepartID, BornetteDépartID) \n      REFERENCES Bornette(StationID, BornetteID),\n    FOREIGN KEY (StationArriveeID, BornetteArriveeID) \n      REFERENCES Bornette(StationID, BornetteID)\n);\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\nOn suppose que le schéma est muni des dépendances fonctionnelles déduites de la question précédente et de celles qui se déduisent des contraintes de clé primaire. On note cet ensemble de dépendances fonctionnelles \\(\\Sigma\\).\n\n\n\n\n\n\nNoteQuestion 5 (1pt)\n\n\n\nVotre schéma est-il en Forme Normale de Boyce-Codd ?\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteQuestion 6 (2pt)\n\n\n\nQuelles actions faut-il effectuer sur votre base pour traduire les événements suivants:\n\nSouscription d’un abonnement.\nMise en service d’un vélo.\nRetrait de service d’un vélo.\nDécrochage d’un vélo.\nAccrochage d’un vélo.\n\n On n’attend pas du code. Juste une phrase qui décrit l’opération à effectuer.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\nInsertion d’un nouveau tuple dans la table ABONNE\nInsertion d’un nouveau tuple dans la table VELO avec une date de retrait de service NULL ou 'infinity'::date\nMise à jour d’un tuple dans la table VELO, RetraitServiceDate est affecté de la date courante\nInsertion d’un nouveau tuple dans la table TRAJET. FinTS, BornetteArriveeID StationArriveeID sont NULL\nMise à jour d’un tuple dans la table TRAJET (le tuple correspondant au trajet en cours du vélo raccroché), modification de FinTS, BornetteArriveeID StationArriveeID.\n\nOn note que l’accrochage d’un vélo, supposera la recherche du trajet en cours dans la table TRAJET, puis la mise à jour du tuple concerné.\nUne partie des requêtes qui suivent sera compliquée à écrire, parce qu’avec cette modélisation, les trajets en cours sont noyés dans la table TRAJET. Pour les repérer, il faut examiner la vaneur de FinTS (NULL ou 'infinity'::timestamp).\nPour se faciliter la vie, nous allons retoucher la modélisation présentée plus haut, introduire une nouvelle table TRAJET_EN_COURS.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nCREATE TABLE Trajet (\n    TrajetID INT PRIMARY KEY,\n    DébutTS TIMESTAMP,\n    FinTS TIMESTAMP,\n    AbonnéID INT,\n    VéloID INT,\n    BornetteDépartID INT,\n    BornetteArriveeID INT,\n    StationDepartID INT,\n    StationArriveeID INT,\n    FOREIGN KEY (AbonnéID) REFERENCES Abonné(AbonnéID),\n    FOREIGN KEY (VeloID) REFERENCES Velo(VeloID),\n    FOREIGN KEY (StationDepartID, BornetteDépartID) \n      REFERENCES Bornette(StationID, BornetteID),\n    FOREIGN KEY (StationArriveeID, BornetteArriveeID) \n      REFERENCES Bornette(StationID, BornetteID)\n);\nCREATE TABLE Trajet_en_cours (\n    TrajetID INT PRIMARY KEY,\n    DébutTS TIMESTAMP,\n    AbonnéID INT UNIQUE,\n    VéloID INT  UNIQUE,\n    BornetteDépartID INT,\n    StationDepartID INT,\n    FOREIGN KEY (AbonnéID) REFERENCES Abonné(AbonnéID),\n    FOREIGN KEY (VeloID) REFERENCES Velo(VeloID),\n    FOREIGN KEY (StationDepartID, BornetteDépartID) \n      REFERENCES Bornette(StationID, BornetteID),\n);\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\nerDiagram\n    TRAJET }o..|| VELO : velo_id \n    TRAJET }o..|| ABONNE  : abonne_id\n    TRAJET }o..|| BORNETTE : bornette_depart_id \n    TRAJET_EN_COURS }o..|| VELO : velo_id \n    TRAJET_EN_COURS }o..|| ABONNE  : abonne_id\n    TRAJET_EN_COURS }o..|| BORNETTE : bornette_depart_id \n    TRAJET }o..|| BORNETTE : bornette_arrivee_id \n    BORNETTE }o--|| STATION : station_id\n\n  VELO {\n    num velo_id PK\n    date DebutServiceDate \n    date FinServiceDate\n    text type\n  }\n\n  ABONNE {\n    num abonne_id PK\n    text nom\n    text prenom\n    num age\n    date debut\n    text genre \n  }\n\n  TRAJET {\n    num trajet_id PK\n    num velo_id  FK\n    num abonne_id   FK\n    time depart_ts\n    time arrivee_ts\n    num bornette_depart_id FK\n    num station_depart_id FK\n    num bornette_arrivee_id FK\n    num station_arrivee_id FK\n  }\n\n  TRAJET_EN_COURS {\n    num trajet_id PK\n    num velo_id  FK\n    num abonne_id   FK\n    time depart_ts\n    num bornette_depart_id FK\n    num station_depart_id FK\n  }\n\n  BORNETTE {\n    num station_id PK, FK\n    num bornette_id PK\n  }\n\n  STATION {\n    num station_id PK\n    text nom\n    text adresse\n    num latitude\n    num longitude\n    num bornettes\n  }\n\n\n\n\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nCe modification du schéma, facilite la mise en place de certaines contraintes.\n\nPour les tuples de la table TRAJET_EN_COURS, les contraintes d’exclusions se réduisent à des contraintes d’unicité sur velo_id et abonne_id.\n\n\n\n\n\n\n\n\n\n\nWarningAttention\n\n\n\nDans la suite, vous formulerez les requêtes dans le schéma relationnel défini par votre schéma en pattes de corbeau.\n : 1 point par requête\n\n\n\n\n\n\n\n\nNoteRequête 1\n\n\n\nListe des trajets en cours à un instant donné\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\n\n\n\n\n\nNoteRequête 2\n\n\n\nListe des vélos en trajet depuis plus d’une heure.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\n\n\n\n\n\nNoteRequête 3\n\n\n\nNombre de trajets initiés durant chaque heure de la journée pendant le mois de juin 2024.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\n\n\n\n\n\nNoteRequête 4\n\n\n\nListe des velos qui ont participé à un trajet commencé et achevé dans la même station pendant la dernière semaine.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\n\n\n\n\n\nNoteRemarque\n\n\n\n\n\n\n\n\n\n\n\n\nNoteRequête 5\n\n\n\nLister d’éventuels couples de trajets suspects impliquant le même vélo à un même instant.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\n\n\n\n\n\nNoteRequête 6\n\n\n\nListe des stations qui ont été vides ou pleines pendant la semaine écoulée.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\n\n\n\n\n\nNoteRequête 7\n\n\n\nListe des vélos en service qui n’ont pas roulé depuis plus d’un mois.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\n\n\n\n\n\nNoteRequête 8\n\n\n\nPour chaque couple de stations, durée moyenne des trajets entre la station de départ et la station d’arrivée.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\n\n\n\n\n\nNoteRequête 9\n\n\n\nLister pour chaque station le nombre de bornettes occupées à l’instant courant.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\n\n\n\n\n\nNoteRequête 10\n\n\n\nLister les trajets suspects dont le vélo n’est pas en service.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\n\n\n\n\n\n\nEn PostgreSQL, pour définir un intervalle à l’aide de deux dates debut et fin, il suffit d’écrire (début, fin). L’intervalle ne contient pas la date de fin.\nPour tester l’intersection/le recouvrement de deux intervalles, on utilise l’opérateur OVERLAPS\nbd_2023-24=# SELECT \n  ('2025-01-03'::date, '2025-01-10'::date) OVERLAPS \n  ('2025-01-10'::date, '2025-01-15'::date)  ; \n overlaps \n----------\n false\n(1 row)\n\nSELECT \n  ('2025-01-03 20:26:00'::timestamp, '2025-01-03  21:31:01'::timestamp) OVERLAPS                                              \n  ('2025-01-03 20:50:04'::timestamp, '2025-01-03 21:45:00'::timestamp)  ; \n overlaps \n----------\n t\n(1 row)\n\n\n\n\n\n\n\n\n\nPour spécifier un intervalle semi-infini (dont la fin n’est pas connue), on peut utiliser 'infinity'::timestamp pour décrire la borne supérieure.\nbd_2023-24=#  SELECT \n  ('2025-01-03 20:26:00'::timestamp, 'infinity'::timestamp) OVERLAPS \n  ('2025-01-03 21:32:04'::timestamp, '2025-01-03 21:45:00'::timestamp)  ; \n overlaps \n----------\n t\n(1 row)\n\n\n\n\n\n\n\n\n\nEn PostgreSQL, current_timestamp s’évalue à l’instant courant (de type timestamp avec timezone).\nEn PostgreSQL, pour extraire le mois d’un objet dd de type date, vous pouvez utiliser EXTRACT(MONTH FROM dd). Le résultat est un entier entre 1 et 12, 1 pour janvier, …\npostgres=# SELECT \n  current_timestamp AS instant, \n  EXTRACT( MONTH FROM current_timestamp::date) AS le_mois ;\n            instant            | le_mois \n-------------------------------+---------\n 2025-06-05 20:26:12.556256+02 |       6\n\n\n\n\n\n\n\n\n\nPour définir un intervalle de temps, il suffit de décrire l’intervalle par une chaine de caratères et de convertir le résultat en type interval\nbd_2023-24=# select '2025-06-05 21:10:38.732237+02'::timestamp - '7 days'::interval ;\n          ?column?          \n----------------------------\n 2025-05-29 21:10:38.732237"
  },
  {
    "objectID": "workshops/td7.html",
    "href": "workshops/td7.html",
    "title": "TD 7 : Modélisation",
    "section": "",
    "text": "WarningAvec solutions"
  },
  {
    "objectID": "workshops/td7.html#exercice-1",
    "href": "workshops/td7.html#exercice-1",
    "title": "TD 7 : Modélisation",
    "section": "Exercice 1",
    "text": "Exercice 1\nVous êtes engagé au journal SportKan’AP, où vous devez établir le système d’information des tournois de tennis du Grand Chelem. Le système doit mémoriser toutes les rencontres qui se sont déroulées depuis que ces tournois existent, ainsi que leur caractéristiques.\n\nTypes de résultats attendus\n\nRestituer la composition et le score des matches d’un tournoi, une année donnée.\nRestituer la liste des arbitres ayant participé à un tournoi.\nConnaître le pays qui a le plus souvent remporté le simple aux Internationaux de France.\nRestituer les gains d’un joueur dans les tournois du Grand Chelem.\nÉtablir la liste des différents entraîneurs d’un joueur…\n\n\n\nPrécisions sur le système d’information\n\nIl y a chaque année quatre tournois du Grand Chelem. Ils se déroulent dans les pays suivants : États-Unis, France, Grande-Bretagne, Australie. Pour un pays, ils peuvent se dérouler dans des endroits différents, ainsi aux États-Unis ils se sont déroulés à Forest Hill, puis à Flushing Meadow.\nA chaque match est associé un gain, c’est celui du perdant. Par exemple au premier tour des tournois simples, à Roland-Garros en 2025, le joueur qui perd gagne 78 000 €, au deuxième tour, 117 000 €, etc. Les vainqueurs des tournois simples féminin ou masculin ont gagné le prix associé au tournoi, c’est-à-dire 2,55 millions d’euros.\nLors de ces tournois il y a neuf épreuves : simples et doubles féminins et masculins, double mixte, tennis-fauteuil simples et doubles, Quad simples et doubles.\nUn joueur peut changer de nationalité, et même être apatride. Navratilova, d’origine tchèque, fut tour à tour apatride puis américaine.\n\n\n\nPhrases du système d’information\n\nIga Świątek a battu Nadia Podoroska à Roland-Garros en 2020 en 1/2 finale du simple féminin par 6‑2/6‑1.\nMonsieur Wilkinson arbitra ce match (NB : cette information a été inventée pour l’exercice).\nLe simple féminin de Roland-Garros a été remporté trois fois par une joueuse polonaise.\nBjörn Borg a gagné 2 millions $ au cours de ses participations aux tournois du Grand-Chelem (avec 11 titres).\nLe vainqueur masculin de Roland-Garros en 2025 a gagné 2,55 millions €.\nYannick Noah a joué 4 fois en double mixte avec Hana Mandlíková.\n\n\n\nSolution\n\nDictionnaire des données\nVersion 1\n\n\n\n\n\n\n\nNom\nSignification\n\n\n\n\nnom tournoi\nNom d’un tournoi\n\n\npays\nPays d’un tournoi\n\n\nlieu\nLieu d’un tournoi\n\n\nannée\nAnnée d’un tournoi\n\n\nprix\nPrix d’un tournoi\n\n\nnom joueur\nNom d’un joueur\n\n\nsexe\nSexe d’un joueur\n\n\nnationalité\nNationalité d’un joueur\n\n\nscore\nScore d’un match\n\n\ndate\nDate d’un match\n\n\ngain perdant\nGain du perdant d’un match\n\n\ntype\nType d’un match (simple messieurs, simple dames, double dames,…)\n\n\ntour\nTour d’un match (finale, demi finale,…)\n\n\nnom arbitre\nNom de l’arbitre d’un match\n\n\nnom entraîneur\nNom de l’entraîneur d’un joueur\n\n\n\n\n\nRecherche des entités, de leurs identifiants et propriétés\nOn a les entités évidentes suivantes :\n\nEntité TOURNOI, propriétés évidentes : numéro tournoi, nom tournoi, année. Ces deux propriétés sont bien en dépendance fonctionnelle directe et complète de l’identifiant.\n\nnuméro tournoi \\(\\rightarrow\\) prix ? Cette dépendance fonctionnelle n’est pas vérifiée car le prix d’un tournoi varie en fonction du type (simple, double, etc.). On a donc la dépendance : numéro tournoi + type \\(\\rightarrow\\) prix Comme nous le verrons par la suite, cela impose de créer une entité TYPE. prix sera la propriété d’une association entre TOURNOI et TYPE.\nnuméro tournoi \\(\\rightarrow\\) lieu ?  Il est dit qu’un tournoi peut se dérouler dans des lieux différents, néanmoins l’énoncé sous-entend que pour une année donnée, le lieu est unique. Or l’entité tournoi correspond à une année donnée. On a donc bien : numéro tournoi \\(\\rightarrow\\) lieu. A priori, il est possible de faire de lieu une propriété de TOURNOI.\nnuméro tournoi \\(\\rightarrow\\) pays ?  Cette dépendance est évidente. Mais on a aussi lieu \\(\\rightarrow\\) pays, donc pays n’est pas en dépendance directe de numéro tournoi, ce n’est donc pas une propriété de TOURNOI. On doit donc créer une entité PAYS avec comme identifiant nom pays. Cet identifiant est pratique mais il posera problème si un des pays change de nom.\nLa dépendance fonctionnelle lieu \\(\\rightarrow\\) pays conduit à créer une entité LIEU. Pour cette raison, lieu n’est pas une propriété de TOURNOI.\n\nEntité JOUEUR, propriétés évidentes : numéro joueur, nom joueur, sexe. Ces deux propriétés sont bien en dépendance fonctionnelle directe et complète de l’identifiant.\n\nnuméro joueur \\(\\rightarrow\\) nationalité ?\nLa nationalité peut varier dans le temps et on veut conserver les nationalités successives d’un joueur pour calculer le nombre de victoire par pays. Il faut donc enregistrer l’historique des nationalités de chaque joueur. Il n’y a donc pas de dépendance fonctionnelle entre numéro joueur et nationalité, ce n’est pas une propriété de l’entité JOUEUR. En rangeant nationalité comme propriété de joueur on attribuerait toutes les victoires de Navratilova aux États-unis, alors que cette joueuse a été successivement tchèque, apatride, puis américaine.\nnuméro joueur \\(\\rightarrow\\) nom entraîneur ?Cette dépendance fonctionnelle n’est pas vérifiée car un joueur peut changer d’arbitre et le SI doit conserver cet historique. Il faut donc créer une entité ENTRAÎNEUR.\n\nConcernant les matchs, il peut être tentant d’en faire une association réflexive sur JOUEUR, les propriétés de cette association étant score, type, gain perdant, tour et arbitre. On obtiendrait le modèle suivant :\n\n\n\n\n\nMais une rencontre ainsi modélisée ne met en présence que deux joueurs : elle ne peut représenter que les simples ! Il faudrait donc créer une deuxième association à cinq arêtes pour les doubles. Le modèle n’est donc pas satisfaisant. De plus, on a déjà vu qu’il fallait faire de type une entité, ce n’est donc pas une propriété de l’association rencontrer car alors la même propriété serait présente deux fois dans le modèle. Cela obligerait donc à ajouter une arête vers l’entité TYPE à ces associations. On obtiendrait donc des associations à 4 et 6 arêtes (simples et doubles). On choisit donc, comme classiquement lorsqu’apparaît une association quaternaire et plus, de créer une entité MATCH, avec comme identifiant numéro match et comme propriétés évidentes score, date.\n\nnuméro match \\(\\rightarrow\\) gain perdant ? Cette dépendance fonctionnelle est vérifiée, mais elle n’est pas directe. En effet, tous les matchs d’un même type et d’un même tour offrent le même gain. On a numéro match \\(\\rightarrow\\) numéro tournoi+type+tour \\(\\rightarrow\\) gain perdant. Comme nous le verrons à propos des associations, cela oblige à créer une entité supplémentaire TOUR.\nnuméro match \\(\\rightarrow\\) nom arbitre ?\nCette dépendance fonctionnelle est vérifiée, elle est directe et complète, on peut donc faire de nom arbitre une propriété de MATCH, mais cette solution ne permet pas d’enregistrer dans la base une liste d’arbitre et des propriétés éventuelles qui leur seraient propres. Il est donc préférable de créer une entité ARBITRE.\n\n\n\n\nVersion 2 du dictionnaire des données\n\n\n\nNom\nSignification\n\n\n\n\nnuméro tournoi\nIdentifiant de TOURNOI\n\n\nnom tournoi\nNom d’un tournoi\n\n\nnom pays\nNom du pays d’un tournoi\n\n\nnom lieu\nNom du lieu d’un tournoi\n\n\nannée\nAnnée d’un tournoi\n\n\nprix\nPrix d’un tournoi\n\n\nnuméro joueur\nIdentifiant de JOUEUR\n\n\nnom joueur\nNom d’un joueur\n\n\nsexe\nSexe d’un joueur\n\n\nnuméro entraîneur\nIdentifiant de ENTRAINEUR\n\n\nnom entraîneur\nNom de l’entraîneur d’un joueur\n\n\nnuméro match\nIdentifiant de MATCH\n\n\ndate\nDate d’un match\n\n\ntour\nTour d’un match (finale, demi finale,…)\n\n\ntype\nType d’un match\n\n\nscore\nScore d’un match\n\n\ngain perdant\nGain du perdant d’un match\n\n\nnuméro arbitre\nIdentifiant de ARBITRE\n\n\nnom arbitre\nNom de l’arbitre d’un match\n\n\n\n\n\nGraphe des dépendances fonctionnelles\n\n\n\n\n\n\n\nMise en place des associations\n\nLes dépendances fonctionnelles : l’étude du graphe des dépendances fonctionnelles permet de déduire immédiatement les associations binaires qui sont des dépendances fonctionnelles :\n\nAssociation «appartient» entre MATCH et TOURNOI\nAssociation «se situe» entre LIEU et PAYS. Si lieu était une propriété de TOURNOI comme évoqué précédemment, alors cette association lierait TOURNOI à PAYS. Étant donné le graphe des dépendances fonctionnelles (numéro tournoi \\(\\rightarrow\\) nom lieu \\(\\rightarrow\\) nom pays), cette association aurait des instances redondantes, ce qui est à éviter.\nAssociation «se déroule» entre TOURNOI et LIEU pour compléter la précédente.\nAssociation «de type» entre MATCH et TYPE.\nAssociation «arbitré par» entre MATCH et ARBITRE.\nAssociation «de tour» entre MATCH et TOUR.\n\nLa nationalité : Un joueur peut avoir à une période plusieurs nationalités, une seule, ou bien encore aucune. On crée une association «de nationalité» entre JOUEUR, PAYS et DATE, l’arête sur DATE correspondant à la date d’acquisition de la nationalité. On ajoute une propriété date de fin correspondant à la date à laquelle un joueur perd une nationalité.\nLes entraîneurs : Un joueur peut avoir à une période plusieurs entraîneurs, un seul, ou bien encore aucun. On crée une association «est entraîné par» entre JOUEUR, ENTRAÎNEUR et DATE, l’arête sur DATE correspondant à la date de début de la coopération entre le joueur et l’entraîneur. On ajoute une propriété date de fin correspondant à la fin de cette coopération.\nLa composition des matchs : on peut envisager trois solutions :\n\nPremière solution : Une association «participer» indique les compositions des matches. Une association «gagner» indique le ou les gagnants (double).\nSeconde solution : une association «participer» portant une propriété prenant la valeur vrai ou faux selon que le joueur a gagné ou non.\nTroisième solution : deux associations «gagner» et «perdre».\n\nPour les solutions 1 et 3, il faut compléter le MCD par des contraintes interassociation. C’est la solution 2 qui est choisie pour des raisons de simplicité.\nLe prix d’un tournoi : d’après numéro tournoi + type \\(\\rightarrow\\) prix, on créer une association «recevoir prix» entre TOURNOI et TYPE ayant la propriété Prix tournoi.\nLe gain du perdant : d’après numéro tournoi+type+tour \\(\\rightarrow\\) gain perdant, on créer une association ternaire «recevoir gain» entre TOURNOI, TOUR et TYPE ayant la propriété Prix tournoi. Ce qui signifie que pour un tour d’un tournoi, tous les matches de même type ont la même valeur de gain perdant.\n\n\n\nMCD Complet"
  },
  {
    "objectID": "workshops/td7.html#exercice-2",
    "href": "workshops/td7.html#exercice-2",
    "title": "TD 7 : Modélisation",
    "section": "Exercice 2",
    "text": "Exercice 2\nUn grand organisme dispose de véhicules de service. Ceux-ci peuvent être prêtés aux membres du personnel pour effectuer des missions.\n\nLe système d’information à concevoir doit être en mesure de gérer l’historique des interventions sur les véhicules (réparations et entretiens périodiques).\nIl doit également permettre de connaître les principaux utilisateurs (personne et service utilisateur) de manière à pouvoir dresser des statistiques d’utilisation.\nIl sera possible de connaître à tout moment si un véhicule est disponible.\nEnfin il doit être possible de connaître la liste prévisionnelle des véhicules à envoyer à l’entretien.\n\n\nTypes de résultats attendus\n\nListe des véhicules disponibles.\nListe prévisionnelle des entretiens à effectuer.\nCoût au km des réparations pour un véhicule.\nCoût au km des entretiens pour un véhicule.\nCoût au km (tout frais confondus) pour un véhicule.\nNombre de kilomètres parcourus par une personne.\nNombre de kilomètres parcourus par l’ensemble des personnes d’un service…\n\n\n\nPhrases du système d’information\n\nMonsieur Jean-Baptiste LAGAFFE a emprunté le véhicule DJ-325-KN du 20/05/24 à 13h au 23/05/24 à 17h et a parcouru 596 km, la facture d’essence s’élevant à 60 €.\nLe garage RENÉ CETOUFER a réparé le véhicule DJ-325-KN du 12/05/24 au 15/05/24, le montant de l’intervention s’est élevé à 2200 € TTC.\nLes Renault Clio full hybrid E-Tech doivent être portées en révision aux kilométrages suivants 5 000, 10 000 puis tous les 25 000 kilomètres.\nLa voiture FV-861-GH est une Renault Clio full hybrid E-Tech achetée le 3/09/2025.\n\n\n\nPrécision sur le système d’information\n\nUne personne ne dépend que d’un service.\n\n\n\nSolution\n\nDictionnaire des données\n\n\n\n\n\n\n\nNom\nSignification\n\n\n\n\nN° immatriculation\n\n\n\nType véhicule\nModèle\n\n\nDate achat\nDate d’achat d’un véhicule par la société\n\n\nKilométrage\nKilométrage total d’un véhicule de la société\n\n\nKilométrage révision\nKilométrage pour lequel un type de véhicule doit être révisé\n\n\nNom emprunteur\nNom de membre du personnel emprunteur\n\n\nNom service\nNom de service de la société\n\n\nDate emprunt\nDate d’emprunt d’un véhicule par un membre du personnel\n\n\nHeure emprunt\nHeure d’emprunt d’un véhicule par un membre du personnel\n\n\nDate retour\nDate de retour d’un véhicule par un membre du personnel\n\n\nHeure retour\nHeure de retour d’un véhicule par un membre du personnel\n\n\nNbre kilomètres\nNombre de kilomètres parcourus lors d’un emprunt\n\n\nMontant facture essence\nMontant de la facture de carburant lors d’un emprunt\n\n\nPrix réparation\nPrix d’une réparation d’un véhicule\n\n\nDate début réparation\nDate de début de la réparation d’un véhicule\n\n\nDate fin réparation\nDate de fin de la réparation d’un véhicule\n\n\nPrix révision\nPrix d’une réparation d’un véhicule\n\n\nDate début révision\nDate de début de la révision d’un véhicule\n\n\nDate fin révision\nDate de fin de la réparation d’un véhicule\n\n\nNom garage\n\n\n\n\n\n\nRecherche des entités et de leurs identifiants\n\nEntité VÉHICULE, identifiant : N° d’immatriculation\nEntité EMPRUNTEUR, identifiant : N° emprunteur\nEntité SERVICE, identifiant : Nom service\nEntité GARAGE, identifiant : N° garage\nEntité TYPE DE VÉHICULE, identifiant : N° type. En effet, comme kilométrage révision dépend du type de véhicule, il s’agit bien d’une entité.\n\n\n\nRecherche des propriétés des entités\nOn essaie d’attribuer les propriétés restantes en vérifiant à chaque fois la règle de dépendance fonctionnelle directe et complète des propriétés par rapport à l’identifiant.\n\nDate achat : propriété de l’entité VÉHICULE, on a bien N° immatriculation \\(\\rightarrow\\) Date achat\nKilométrage : propriété de l’entité VÉHICULE, on a bien N° immatriculation \\(\\rightarrow\\) Kilométrage\nKilométrage révision ? Pour un type de véhicule, il y a plusieurs occurrences de kilométrage de révision, ce n’est donc pas une propriété de type de véhicule. Nous verrons lors de l’étude des associations comment régler ce problème.\nNom type : propriété de l’entité TYPE DE VÉHICULE, on a bien N° type \\(\\rightarrow\\) Nom type.\nNom emprunteur : propriété de l’entité EMPRUNTEUR, on a bien N° emprunteur \\(\\rightarrow\\) Nom emprunteur\nDonnées concernant un emprunt : Date emprunt, Heure emprunt, Date retour, Heure retour, Montant facture essence. Elles ne sont pas uniques, ni pour un emprunteur, ni pour un véhicule et ne sont donc pas des propriétés de ces entités.\nDonnées concernant une réparation ou une révision : Prix réparation, Date début réparation, Date fin réparation, Prix révision, Date début révision, Date fin révision. Elles ne sont pas uniques, ni pour un garage, ni pour un véhicule et ne sont donc pas des propriétés de ces entités.\nNom garage : propriété de l’entité GARAGE, on a bien N° garage \\(\\rightarrow\\) Nom de garage\n\n\n\nMise en place des associations\n\nLes dépendances fonctionnelles :\n\nAssociation «attaché» entre EMPRUNTEUR et SERVICE : tout emprunteur est attaché à un service et un seul.\nAssociation «est de» entre VÉHICULE et TYPE : tout véhicule est d’un type et un seul.\n\nRéparations : Parmi les propriétés non encore mises en place, il a Prix réparation, Date début réparation, Date fin réparation. Le prix d’une réparation est unique pour un véhicule et une date/heure. On a donc la dépendance fonctionnelle : (N° d’immatriculation, date début réparation) \\(\\rightarrow\\) Prix réparation Le prix d’une réparation est donc une propriété de l’association «réparer».\n\n\n\n\n\nNous avons ici signifié qu’un véhicule a été porté en réparation à une date/heure, il reste à représenter la date de retour du véhicule. La solution consistant à modéliser comme ci dessous est erronée :\n\n\n\n\n\nEn effet, à un moment donné dans ce système d’information certaines occurrences de l’association «réparer» sont à trois arêtes (les réparations terminées), alors que d’autres sont à deux arêtes (les réparations en cours). Ceci est interdit. De plus, l’arête (retour) sur DATE est inutile pour identifier l’association.\nNous avons donc le choix entre deux modélisations possibles.\n\nLa première consiste à créer une propriété Durée ou Date de retour dans l’association «réparer».\n\n\n\n\n\n\n\nLa seconde à créer une autre association : «revenir de réparation». Lors de l’insertion d’une occurrence de «revenir de réparation», il faut vérifier que celle-ci correspond à une occurrence de «porter à réparer». Pour cela, il faut ajouter une contrainte d’intégrité d’inclusion entre les deux associations.\n\n\n\n\n\n\nLa première solution est la meilleure car elle est plus simple.\nPour représenter le fait qu’un véhicule est porté en réparation dans un garage, on ne peut ranger «Nom garage» dans l’association car il existe déjà une entité GARAGE (une propriété se trouve à un seul endroit du modèle). Il faut alors ajouter alors une arête à l’association «réparer» qui indiquera le garage concerné par la réparation.\nLes révisions : le même raisonnement est tenu pour les associations «réviser» et «emprunter». Les propriétés «Prix révision» et «Durée révision» sont rangées dans «réviser».\n\n\n\n\n\n\n\nEmprunt : les emprunts sont modélisés par une association «emprunter» entre VÉHICULE, EMPRUNTEUR et DATE conformément à la gestion classique du temps. A noter que la date est en fait une date/heure puisque les heures sont nécessaires au SI. On pourrait introduire une entité EMPRUNT mais cela ne doit être fait que s’il existe déjà un identifiant (un numéro d’emprunt) dans la gestion de la société ou bien si la vérification des règles de normalisation nous y contraint. Les propriétés Montant facture essence, Nbre kilomètres et Durée emprunt sont rangés dans «emprunter», et une contrainte d’intégrité fonctionnelle est placée entre «emprunter» et EMPRUNTEUR, puisqu’à un moment donné pour un VÉHICULE il n’y a qu’un emprunteur.\nKilométrage révision : nous avons vu que cette donnée n’est pas une propriété d’une des entités existante car elle n’est en dépendance fonctionnelle d’aucune autre donnée élémentaire. Il faut nécessairement créer une entité LIMITE avec pour identifiant Kilométrage révision. L’association «à réviser» enregistre les kilométrages de révisions d’un type de véhicule.\n\n\n\n\n\n\n\n\nMCD Complet"
  },
  {
    "objectID": "workshops/td9.html#exercice-supermarché",
    "href": "workshops/td9.html#exercice-supermarché",
    "title": "TD 9 : Modèle relationnel des données",
    "section": "Exercice (Supermarché)",
    "text": "Exercice (Supermarché)\nL’équipe de conception a étudié le SI d’un supermarché et a fourni le MCD suivant pour la partie approvisionnement et mise en rayon.\nLa propriété “en stock chez le fournisseur” est un booléen.\n\n\n\n\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nConvertir ce diagramme E/A en un modèle relationnel.\n\n\n\nSolution\n\n\n\n\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nQuelles sont les clés étrangères sur lesquelles il faut ajouter une contrainte NOT NULL ou UNIQUE ?\n\n\n\n\nSolution\nD’après le MCD, il faut définir une contrainte NOT NULL sur les clés étrangères rayon et catégorie de la table produit pour traduire les cardinalités minimales 1 des associations mis-en-rayon et appartient du côté de PRODUIT.\n\n\n\n\n\n\nNoteQuestion\n\n\n\nEcrire en SQL la définition des données de la partie PRODUIT, CATEGORIE, RAYON, en essayant d’implémenter toutes les contraintes du diagramme E/A.\nUne cardinalité n’est pas codable par une contrainte de table ou de champ, laquelle ? Comment peut-on généraliser ?\n\n\n\n\nSolution\nCREATE TABLE RAYON(\n   id INT PRIMARY KEY,\n   etage INT NOT NULL,\n   rangee INT NOT NULL\n);\n\nCREATE TABLE CATEGORIE(\n   id INT PRIMARY KEY,\n   nom VARCHAR(50)\n);\n\nCREATE TABLE PRODUIT(\n   id INT PRIMARY KEY,\n   nom VARCHAR(50),\n   prix MONEY NOT NULL,\n   stock INT NOT NULL DEFAULT 0,\n   categorie INT NOT NULL,\n   rayon INT NOT NULL,\n   CONSTRAINT PRODUIT_categorie_fk \n      FOREIGN KEY (categorie)\n      REFERENCES CATEGORIE(id),\n   CONSTRAINT PRODUIT_rayon_fk \n      FOREIGN KEY (rayon)\n      REFERENCES RAYON(id)\n);\n\nCREATE TABLE EMPLACEMENT(\n   categorie INT,\n   rayon INT,\n   PRIMARY KEY (categorie,rayon),\n   CONSTRAINT EMPLACEMENT_categorie_fk \n      FOREIGN KEY (categorie)  \n      REFERENCES CATEGORIE(id),\n   CONSTRAINT EMPLACEMENT_rayon_fk \n      FOREIGN KEY (rayon)  \n      REFERENCES RAYON(id)\n);\n\n\n\n\n\n\nLa cardinalité minimale 1 de l’association est-placée du côté de RAYON n’est pas codable par une contrainte de table ou de champ.\nOn peut généraliser à toute cadinalité minimale 1 qui se trouve sur un côté plusieurs n’est pas codable par une contrainte de table ou de champ.\n\n\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nCe modèle E/A présente une erreur de conception, indépendamment de la connaissance du SI qu’il modélise. Laquelle ?\nComment faut-il normaliser ce modèle ?\n\n\n\n\nSolution\nD’après la cardinalité 1:1 entre les entités PRODUIT et CATEGORIE, il y a une dépendance fonctionnelle produit.id \\(\\rightarrow\\) categorie.id.\nDans la table approvisionne, on a donc la dépendance fonctionnelle produit\\(\\rightarrow\\)categorie qui contrevient aux règles de normalisation que nous allons voir en cours. L’idée est qu’il y a redondance d’information avec la table produit dans laquelle cette dépendance fonctionnelle est déjà enregistrée.\nIl faut décomposer l’association approvisionne en :\n\nune association binaire appartient qui existe déjà,\nune association binaire approvisionne entre fournisseur et produit."
  },
  {
    "objectID": "workshops/td9.html#exercice",
    "href": "workshops/td9.html#exercice",
    "title": "TD 9 : Modèle relationnel des données",
    "section": "Exercice",
    "text": "Exercice\nOn reprend un MCD élaboré dans un TD précédent :\n\n\n\n\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nConvertir ce diagramme E/A en un modèle relationnel.\n\n\n\nSolution\n\n\n\n\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nQuelles sont les clés étrangères sur lesquelles il faut ajouter une contrainte NOT NULL ou UNIQUE ?\n\n\n\n\nSolution\nLors de la définition des tables en SQL, il faudra ajouter :\n\nD’après le MCD, une contrainte NOT NULL sur la clé étrangère type de la table véhicule pour traduire la cardinalité minimale 1 de l’association est de du côté de véhicule.\nD’après le MCD, une contrainte NOT NULL sur la clé étrangère service de la table emprunteur pour traduire la cardinalité minimale 1 de l’association attaché du côté de EMPRUNTEUR.\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nEcrire en SQL la définition des données du modèle relationnel en essayant d’implémenter les contraintes du diagramme E/A.\n\n\n\n\nSolution\nCREATE TABLE TYPE (\n   numero INT PRIMARY KEY,\n   Nom VARCHAR(25) NOT NULL\n);\n\nCREATE TABLE PLAN_REVISION (\n   type INT,\n   km int,\n   PRIMARY KEY (type, km),\n   FOREIGN KEY (type) REFERENCES TYPE(numero),\n);\n\nCREATE TABLE VEHICULE (\n   id INT PRIMARY KEY,\n   immat VARCHAR(10) NOT NULL UNIQUE,\n   type INT NOT NULL,\n   date_mes DATE NOT NULL,\n   km INT NOT NULL,\n   FOREIGN KEY (type) REFERENCES TYPE(numero)\n);\n\nCREATE TABLE GARAGE (\n   numero INT PRIMARY KEY,\n   nom VARCHAR(50) NOT NULL\n);\n\nCREATE TABLE SERVICE (\n   id INT PRIMARY KEY,\n   nom VARCHAR(50) NOT NULL UNIQUE\n);\n\nCREATE TABLE EMPRUNTEUR (\n   numero INT PRIMARY KEY,\n   nom VARCHAR(50) NOT NULL,\n   service INT NOT NULL,\n   FOREIGN KEY (service) REFERENCES SERVICE(id)\n);\n\nCREATE TABLE EMPRUNT (\n   vehicule INT,\n   emprunteur INT,\n   date DATE,\n   essence MONEY,\n   km INT NOT NULL,\n   durée DATE NOT NULL,\n   PRIMARY KEY (vehicule, emprunteur, date),\n   FOREIGN KEY (vehicule) REFERENCES VEHICULE(id),\n   FOREIGN KEY (emprunteur) REFERENCES EMPRUNTEUR(numero)\n);\n\nCREATE TABLE REPARATION (\n   vehicule INT,\n   garage INT,\n   date DATE,\n   prix MONEY NOT NULL,\n   durée DATE,\n   PRIMARY KEY (vehicule, garage, date),\n   FOREIGN KEY (vehicule) REFERENCES VEHICULE(id),\n   FOREIGN KEY (garage) REFERENCES GARAGE(numero)\n);\n\nCREATE TABLE REVISION (\n   vehicule INT,\n   garage INT,\n   date DATE,\n   prix MONEY NOT NULL,\n   durée DATE,\n   PRIMARY KEY (vehicule, garage, date),\n   FOREIGN KEY (vehicule) REFERENCES VEHICULE(id),\n   FOREIGN KEY (garage) REFERENCES GARAGE(numero)\n);\nDes contraintes NOT NULL ont été ajoutées aux attributs qui ne sont pas des clés étrangères en fonction du “bon sens”.\nOn a créé des clés primaires entières pour les tables vehicule et service car il est plus sûr d’utiliser des clés primaires internes sans signification externe à la BDD. Sinon il y a un risque de modification dans le temps qui imposerait une mise à jour en cascade des clés étrangères. Une telle mise à jour aurait une complexité importante et toute requête devrait cesser pendant cette mise à jour.\nPar conséquent, les clés primaires récusées immat de vehiculeet nom de service doivent avoir les contraintes NOT NULL UNIQUE."
  },
  {
    "objectID": "exams/cc2-2025-12-02.html",
    "href": "exams/cc2-2025-12-02.html",
    "title": "CC2 du 2 décembre 2025",
    "section": "",
    "text": "L3 MIASHS/Ingémath/METIS\nUniversité Paris Cité\nCourse Homepage"
  },
  {
    "objectID": "exams/cc2-2025-12-02.html#exercice-1",
    "href": "exams/cc2-2025-12-02.html#exercice-1",
    "title": "CC2 du 2 décembre 2025",
    "section": "Exercice 1",
    "text": "Exercice 1\nOn veut concevoir une base de données pour enregistrer des opérations chirurgicales dans une clinique.\nDoivent être enregistrés dans la base :\n\nles soignants avec un numéro, un nom et un prénom.\nles patients avec un nom, un prénom et un numéro de sécurité sociale. Un nouveau patient est enregistré avant la création de l’opération qui le concerne.\n\nLa future interface de saisie d’une opération se présentera ainsi :\n\nSaisie du numéro de patient.\nSaisie de la date-heure et de la durée.\nSaisie de la liste des spécialités nécessaires avec, pour chaque spécialité le nombre d’heures x personnes nécessaires. Au moins une spécialité est requise pour chaque opération.\nLes spécialités sont choisies à chaque fois parmi une liste préalablement enregistrée dans la base de données.\n\nUne fois l’opération enregistrée dans la base de données, une deuxième interface permettra d’affecter les soignants nécessaires à chaque opération :\n\nPour chaque opération, on enregistre les soignants qui interviendront et la spécialité dans laquelle chacun interviendra avec le nombre d’heures de son intervention pour cette spécialité.\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nEcrire un diagramme E/A, avec les cardinalités, représentant la modélisation conceptuelle des données de ce SI.\nJustifier brièvement les cardinalités de chaque association (quelques lignes maximum par association).\nPas de justifications demandées pour le choix des entités et des associations.\n\n\n\nSolution\nLes cardinalités minimales 0 et les cardinalités maximales n représentent une absence de contraintes. Ce sont donc les cardinalités par défaut. Il faut justifier celles qui sont différentes (égales à 1).\n\nlors de la création d’une nouvelle opération chirurgicale dans la base, le patient doit être enregistré préalablement et le formulaire demande la saisie du numéro du client opéré donc la cardinalité minimale de est opéré est 1 du côté de OPERATION. La cardinalité maximale est 1 car le formulaire prévu ne permet d’enregistrer qu’un seul numéro de client.\nlors de la création d’une opération dans la base, au moins une spécialité est requise donc la cardinalité minimale de l’association requiert est 1 du côté OPERATION.\n\nAu contraire, l’enregistrement des soignants intervenant sur une opération est effectué après la création de l’opération dans la base, donc la cardinalité minimale de l’association intervient est 0 du côté OPERATION."
  },
  {
    "objectID": "exams/cc2-2025-12-02.html#exercice-2",
    "href": "exams/cc2-2025-12-02.html#exercice-2",
    "title": "CC2 du 2 décembre 2025",
    "section": "Exercice 2",
    "text": "Exercice 2\nOn veut créer une BDD pour enregistrer la liste des acteurs ayant joué dans les films en VO et la liste de ceux qui ont fait les voix des versions doublées. On a choisi le modèle conceptuel des données ci-dessous.\nIndications complémentaires :\n\nl’entité FILM DOUBLÉ représente les versions non originales des films.\nl’association joue enregistre les acteurs de chaque film en VO, en indiquant le nom du rôle joué.\nl’association doublure enregistre pour chaque version non originale d’un film, et chaque acteur qui y joue (rôle acteur), le nom de celui qui fait sa doublure (rôle voix).\n\n\n\n\n\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nConvertir ce diagramme E/A en un modèle relationnel.\nPas de justifications demandées.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\n\n\n\nQuelles sont les clés étrangères sur lesquelles il faudra ajouter une contrainte NOT NULL ou UNIQUE lors de la définition des tables en SQL ? Justifier.\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\nLors de la définition des tables en SQL, il faudra ajouter :\n\nD’après le MCD, une contrainte NOT NULL sur la colonne id_film_vo de la table FILM_DOUBLE pour traduire la cardinalité minimale 1 de l’association traduction du côté de FILM DOUBLÉ.\nD’après le MCD, une contrainte NOT NULL sur la colonne id_film_vo de la table FILM_DOUBLE pour traduire la cardinalité minimale 1 de l’association dans la langue du côté de FILM DOUBLÉ."
  },
  {
    "objectID": "exams/cc2-2025-12-02.html#exercice-3",
    "href": "exams/cc2-2025-12-02.html#exercice-3",
    "title": "CC2 du 2 décembre 2025",
    "section": "Exercice 3",
    "text": "Exercice 3\nVoici le modèle relationnel des données d’un SI :\n\n\n\n\n\nOn connaît de plus les contraintes suivantes :\n\nles attributs nommés numéro sont des entiers.\nun client doit avoir un nom.\nun produit doit avoir un prix qui sera de type money.\nil n’y pas de commande sans numéro de client.\nla date d’une commande est de type timestamptz, elle ne peut pas être vide et elle est définie par défaut à l’heure de création de la commande.\nla quantité d’une ligne de commande est un entier, elle ne peut pas être vide.\n\n\n\n\n\n\n\nNoteQuestion\n\n\n\nTraduire en SQL ce modèle relationnel en codant toutes les informations connues.\nPas de justifications demandées.\n\n\n\nSolution\nCREATE TABLE client(\n   numero INTEGER,\n   nom VARCHAR(50) NOT NULL,\n   CONSTRAINT client_pk PRIMARY KEY (numero)  \n);\n\nCREATE TABLE commande(\n   numero INTEGER,\n   client INTEGER NOT NULL,\n   date TIMESTAMPTZ DEFAULT now(),\n   CONSTRAINT commande_pk PRIMARY KEY (numero),\n   CONSTRAINT commande_client_fk \n      FOREIGN KEY (client)\n      REFERENCES client(numero)\n);\n\nCREATE TABLE produit(\n   numero INTEGER,\n   nom VARCHAR(50),\n   prix MONEY NOT NULL,\n   CONSTRAINT produit_pk PRIMARY KEY (numero)  \n);\n\nCREATE TABLE ligne_commande(\n   commande INTEGER,\n   produit INTEGER,\n   quantite INTEGER NOT NULL,\n   CONSTRAINT ligne_commande_pk PRIMARY KEY (commande,produit),\n   CONSTRAINT ligne_commande_commande_fk \n      FOREIGN KEY (commande)  \n      REFERENCES commande(numero),\n   CONSTRAINT ligne_commande_produit_fk \n      FOREIGN KEY (produit)  \n      REFERENCES produit(numero)\n);"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-1",
    "href": "slides/DF_norm_1.html#algorithme-1",
    "title": "Normalisation I",
    "section": "Algorithme",
    "text": "Algorithme\n\n\n\\begin{algorithm} \\caption{Décomposition FNBC} \\begin{algorithmic} \\Procedure{DecompositionFNBC}{$\\mathcal{A}, Σ$} \\State \\Comment{Initialisation de la décomposition} \\State $D ← \\{\\mathcal{A}\\}$ \\State \\While{$\\exists \\mathcal{B} \\in D$ not in BCNF w.r.t. $\\Sigma \\models X → X^+ \\cap \\mathcal{B}$, $X \\subsetneq \\mathcal{B}$} \\State $Y \\leftarrow X^+ \\cap \\mathcal{B} \\setminus X\\qquad$ \\Comment{DF non triviale! $Y \\neq \\emptyset$} \\State $D \\leftarrow D \\setminus \\{\\mathcal{B}\\} \\cup \\{ X \\cup Y, \\mathcal{B} \\setminus Y \\}$ \\EndWhile \\State \\Return $D$ \\EndProcedure \\end{algorithmic} \\end{algorithm}"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-calcul-dune-fermeture",
    "href": "slides/DF_norm_1.html#algorithme-de-calcul-dune-fermeture",
    "title": "Normalisation I",
    "section": "Algorithme de calcul d’une fermeture",
    "text": "Algorithme de calcul d’une fermeture\nSoit \\(\\Sigma\\) un ensemble de DF sur un schéma \\(\\mathcal{A}\\) et \\(X\\subset\\mathcal{A}\\)\n\nFermeture(X, Σ)\n\n    Xc =  X\n\n        while (exists Y -&gt; Z in Σ with Y ⊂ Xc and not Z ⊂ Xc)\n\n    Xc = Xc ∪ Z\n\n    return Xc"
  },
  {
    "objectID": "slides/DF_norm_1.html#projection-dun-ensemble-de-df",
    "href": "slides/DF_norm_1.html#projection-dun-ensemble-de-df",
    "title": "Normalisation I",
    "section": "Projection d’un ensemble de DF",
    "text": "Projection d’un ensemble de DF\nSoientt \\(\\mathcal{A}\\) un schéma de relation (\\(\\mathcal{A}\\) est un ensemble d’attributs) et \\(\\Sigma\\) un ensemble de DF sur \\(\\mathcal{A}\\)\nSoit \\(\\mathcal{A}_1\\subset  \\mathcal{A}\\) un sous-ensemble d’attributs\n\n\n\n\n\n\nDéfinition\n\n\n\\[\\pi_{\\mathcal{A}_1}(\\Sigma)=\\left\\{ X\\to Y \\mid \\Sigma\\models X\\to Y \\text{ et } X,Y\\subset \\mathcal{A}_1\\right\\}\\]\n\n\n\n\n\n\n\n\n\n\nCaractérisation\n\n\nSi \\(X\\subset {\\mathcal{A}}_1\\) on a l’équivalence \\[X\\to Y \\in \\pi_{{\\mathcal{A}}_1}(\\Sigma) \\iff Y\\subset\\left\\{X\\right\\}^+∩{\\mathcal{A}}_1\\]\n\n\n\n\n\\(\\pi_{\\mathcal{A}_1}(\\Sigma)\\) est l’ensemble des DF de la forme \\(X\\to Y\\) impliquées par \\(\\Sigma\\) et telles que \\(X\\subset \\mathcal{A}_1\\) et \\(Y\\subset \\mathcal{A}_1\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#exemple-4",
    "href": "slides/DF_norm_1.html#exemple-4",
    "title": "Normalisation I",
    "section": "Exemple",
    "text": "Exemple\n\n\\({\\mathcal{A}}=\\left\\{A,B,C\\right\\}\\) et \\(\\Sigma=\\left\\{A\\to B, B\\to C, C\\to A\\right\\}\\)\n\\(\\pi^{}_{\\left\\{A,B\\right\\}}(\\Sigma)\\) est équivalent à \\(\\left\\{A\\to B, B\\to A\\right\\}\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#calcul-de-pi_mathcala_1sigma",
    "href": "slides/DF_norm_1.html#calcul-de-pi_mathcala_1sigma",
    "title": "Normalisation I",
    "section": "Calcul de \\(\\pi_{{\\mathcal{A}}_1}(\\Sigma)\\)\n",
    "text": "Calcul de \\(\\pi_{{\\mathcal{A}}_1}(\\Sigma)\\)\n\nOn calcule un ensemble de DF équivalent à \\(\\pi_{\\mathcal{A}_1}(\\Sigma)\\)\n\n\n\\begin{algorithm} \\caption{Projection de DF} \\begin{algorithmic} \\Procedure{Projection}{$\\mathcal{A}_1, Σ$} \\State P ← ∅ \\For{$X ⊂ \\mathcal{A}_1$, $X ≠ ∅$, $X ≠ \\mathcal{A}_1$} \\State Y ← $X^+ ∩ \\mathcal{A}_1$ \\State P ← P ∪ $\\{ X → Y\\}$ \\EndFor \\Return P \\EndProcedure \\end{algorithmic} \\end{algorithm}\n\n\n\n\nL’ensemble de DF obtenu est équivalent à \\(\\pi_{{\\mathcal{A}}_1}(\\Sigma)\\)Très coûteux ! Le nombre de sous-ensembles \\(X\\) considérés est \\(2^{\\#{\\mathcal{A}}_1}-2\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#exemple-5",
    "href": "slides/DF_norm_1.html#exemple-5",
    "title": "Normalisation I",
    "section": "Exemple",
    "text": "Exemple\n\n\n\\({\\mathcal{A}}=\\left\\{A,B,C,D,E\\right\\}\\) et \\(\\Sigma=\\left\\{A\\to C, BC\\to D, AD\\to E\\right\\}\\)\n\n\n\n\n\n\\(\\pi_{AC}(\\Sigma)\\) est équivalent à \\(\\left\\{A\\to C\\right\\}\\) car\\(\\left\\{A\\right\\}^+=\\left\\{A,C\\right\\}\\) et \\(\\left\\{C\\right\\}^+=\\left\\{C\\right\\}\\)\n\n\n\n\n\n\n\\(\\pi_{ABD}(\\Sigma)\\) est équivalent à \\(\\left\\{AB\\to D\\right\\}\\) car\\(\\left\\{A\\right\\}^+=\\left\\{A,C\\right\\}\\), \\(\\left\\{B\\right\\}^+=\\left\\{D\\right\\}\\), \\(\\left\\{D\\right\\}^+=\\left\\{D\\right\\}\\),\\(\\left\\{A,B\\right\\}^+=\\left\\{A,B,C,D,E\\right\\}\\), \\(\\left\\{A,D\\right\\}^+=\\left\\{A,D,C,E\\right\\}\\), \\(\\left\\{B,D\\right\\}^+=\\left\\{B,D\\right\\}\\)\n\n\n\n\n\n\n\\(\\pi_{ABCE}(\\Sigma)\\) est équivalent à \\(\\left\\{A\\to C, AB \\to CE, AE\\to C, ABC\\to E, ABE\\to C\\right\\}\\)\\(A^+=AC \\quad B^+=B \\quad C^+=C \\quad E^+=E\\)\\(AB^+=ABCDE \\quad AC^+=AC \\quad AE^+=AEC\\)\\(BC^+=BCD \\quad BE^+=BE \\quad CE^+=CE\\)\\(ABC^+=ABCDE \\quad ABE^+=ABECD\\)\\(BCE^+=BCED \\quad ACE^+=ACE\\)\n\n\n\n\n\nSimplification : \\(\\pi_{ABCE}(\\Sigma)\\) équivaut à \\(\\left\\{A\\to C, AB\\to E\\right\\}\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#préservation-de-dépendances-fonctionnelles",
    "href": "slides/DF_norm_1.html#préservation-de-dépendances-fonctionnelles",
    "title": "Normalisation I",
    "section": "Préservation de dépendances fonctionnelles",
    "text": "Préservation de dépendances fonctionnelles\n\n\n\n\n\n\nDéfinition : décomposition sans perte de DF\n\n\nSoit \\(\\mathcal{A}\\) un schéma de relation et \\(\\Sigma\\) un ensemble de DF sur \\(\\mathcal{A}\\).\nSoit \\(\\left\\{ \\mathcal{A}_1,\\dots, \\mathcal{A}_k\\right\\}\\) une décomposition du schéma \\(\\mathcal{A}\\) (\\(\\mathcal{A}_i\\neq \\emptyset, 1\\leq i\\leq k\\) et \\(\\mathcal{A}= \\bigcup_{i=1}^k \\mathcal{A}_i\\))\nLa décomposition \\(\\left\\{\\mathcal{A}_1,\\dots, \\mathcal{A}_k\\right\\}\\) préserve \\(\\Sigma\\) si l’ensemble des dépendances fonctionnelles locales \\(\\bigcup_{i=1}^k \\pi_{\\mathcal{A}_i}(\\Sigma)\\) est équivalent à \\(\\Sigma\\)\n\n\n\n\n\nPuisque \\(\\Sigma ⊧ \\bigcup_{i=1}^k \\pi_{\\mathcal{A}_i}(\\Sigma)\\), la décomposition préserve \\(\\Sigma\\) si et seulement si toutes les DF de \\(\\Sigma\\) sont impliquées par les DF locales"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-pour-tester-si-bigcup_i1k-pi_mathcala_isigma-models-x-rightarrow-y",
    "href": "slides/DF_norm_1.html#algorithme-pour-tester-si-bigcup_i1k-pi_mathcala_isigma-models-x-rightarrow-y",
    "title": "Normalisation I",
    "section": "Algorithme pour tester si \\(\\bigcup_{i=1}^k \\pi_{\\mathcal{A}_i}(\\Sigma) \\models X \\rightarrow Y\\)\n",
    "text": "Algorithme pour tester si \\(\\bigcup_{i=1}^k \\pi_{\\mathcal{A}_i}(\\Sigma) \\models X \\rightarrow Y\\)\n\n\n\n\\begin{algorithm} \\caption{X → Y est-elle impliquée par les dépendances projetées?} \\begin{algorithmic} \\Procedure{Implique}{$\\left\\{ \\mathcal{A}_1,\\dots, \\mathcal{A}_k\\right\\}, Σ, X, Y$} \\State Z ← X \\State continuer ← \\True \\While{continuer} \\State $W ← Z$ \\For{i ∈ 1, ..., k} \\State $W ← W ∪ \\bigl((W ∩ \\mathcal{A}_i)^+ ∩ \\mathcal{A}_i\\bigr)$ \\EndFor \\If{W ≠ Z} \\State Z ← W \\Else \\State continuer ← \\False \\EndIf \\EndWhile \\If{Y ⊆ Z} \\Return \\True \\Else \\Return \\False \\EndIf \\EndProcedure \\end{algorithmic} \\end{algorithm}"
  },
  {
    "objectID": "slides/DF_norm_1.html#exemple-i-1",
    "href": "slides/DF_norm_1.html#exemple-i-1",
    "title": "Normalisation I",
    "section": "Exemple I",
    "text": "Exemple I\n\n\\(\\mathcal{A}=\\left\\{A,B,C,D\\right\\}\\),\n\\(\\mathcal{A}_1=\\left\\{A,B\\right\\}\\), \\(\\mathcal{A}_2=\\left\\{B,C\\right\\}\\), \\(\\mathcal{A}_3=\\left\\{C,D\\right\\}\\)\n\\(\\Sigma=\\left\\{A\\to B, B\\to C, C\\to D, D\\to A\\right\\}\\)\nEst-ce que la décomposition \\(\\left\\{\\mathcal{A}_1,\\mathcal{A}_2,\\mathcal{A}_3\\right\\}\\) préserve \\(\\Sigma\\) ?\n\n\n\nLes DF locales impliquent \\(A\\to B\\), \\(B\\to C\\), \\(C\\to D\\) (ce sont DF locales)\n\n\n\n\nEst-ce que les DF locales impliquent \\(D\\to A\\) ?\n\n\n\nCommencer avec \\(Z ← \\{D\\}\\)\n\n\\((\\{D\\}∩\\{CD\\})^+ ∩ \\{CD\\}=\\{D\\}^+ ∩\\{CD\\}=\\{DABC\\} ∩ \\{CD\\}=\\{CD\\}\\), ajouter \\(C\\)\n\\((\\{DC\\}∩ \\{BC\\})^+ ∩ \\{BC\\}=\\{C\\}^+ ∩ \\{BC\\}=\\{CDAB\\}∩ \\{BC=B\\}\\), ajouter \\(B\\)\n\\((\\{DCB\\}∩ \\{AB\\})^+ ∩ \\{AB\\}=\\{B\\}^+ ∩ \\{AB\\}=\\{BCDA\\} ∩ \\{AB\\}\\), ajouter \\(A\\)\n\\(\\{DCBA\\}\\) contient \\(A\\) donc \\(D\\to A\\) est préservée"
  },
  {
    "objectID": "slides/DF_norm_1.html#exemple-ii-1",
    "href": "slides/DF_norm_1.html#exemple-ii-1",
    "title": "Normalisation I",
    "section": "Exemple II",
    "text": "Exemple II\n\n\\(\\mathcal{A}=\\) {Ville, CP, Rue, Numero}\n\\(\\Sigma=\\) { CP →  Ville, {Ville, Rue, Numero} → CP}\n\\(\\mathcal{A}_1=\\) {Ville, CP} \\(\\mathcal{A}_2=\\) {Rue, Numero, CP}\nEst-ce que la décomposition \\(\\{\\mathcal{A}_1, \\mathcal{A}_2 \\}\\) préserve \\(\\Sigma\\) ?\n\n\n\n\nCP →  Ville est préservée car elle est locale à \\(\\mathcal{A}_1\\)\n\n\n\n\n\nEst-ce que {Ville, Rue, Numero} → CP est préservée par \\(\\mathcal{A}_1, \\mathcal{A}_2\\) ?\n\n\n\nZ ← {Ville, Rue, Numero}\n\n\\((\\texttt{Z} ∩ \\texttt{{Ville, CP}})^+\\) ∩ {Ville, CP} = {Ville} rien à ajouter\n\\((\\texttt{Z} ∩ \\texttt{{Rue, Numero, CP}})^+\\) ∩ {Rue, Numero, CP} = {Rue, Numero}, rien à ajouter\n\n\n\nDonc Ville, Rue, Numero → CP n’est pas préservée"
  },
  {
    "objectID": "slides/DF_norm_3.html#objectif",
    "href": "slides/DF_norm_3.html#objectif",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Objectif",
    "text": "Objectif\n\n\n\n\n\n\n\nConstruire\n\n\nUne décomposition :\n\nSans Perte d’Information (SPI)\nSans perte de Dépendances Fonctionnelles\nDont les éléments sont en FN3 par rapports aux dépendances projetées"
  },
  {
    "objectID": "slides/DF_norm_3.html#forme-normale-de-boyce-codd-fnbc",
    "href": "slides/DF_norm_3.html#forme-normale-de-boyce-codd-fnbc",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Forme normale de Boyce-Codd (FNBC)",
    "text": "Forme normale de Boyce-Codd (FNBC)\n\n\n\n\n\n\nDéfinition\n\n\nUn schéma \\(\\mathcal{A}\\) est en FNBC par rapport à un ensemble de dépendances fonctionnelles \\(\\Sigma\\) sur \\(\\mathcal{A}\\)\nsi\nQuelque soit la DF non triviale \\(X\\rightarrow Y\\) impliquée par \\(\\Sigma\\) (Σ ⊧ X → Y avec \\(¬ Y ⊂ X\\)), \\(X\\) est une super-clef\n\n\n\n\n\n\n \\((\\mathcal{A},\\Sigma)\\) est en FNBC si pour toute DF non triviale impliquée par \\(\\Sigma\\), le membre de gauche (le déterminant) est une super-clef"
  },
  {
    "objectID": "slides/DF_norm_3.html#fnbc-exemple-1",
    "href": "slides/DF_norm_3.html#fnbc-exemple-1",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "FNBC : exemple 1",
    "text": "FNBC : exemple 1\n\nSchéma \\(\\mathcal{A}=\\{\\texttt{V\\#, Vnom, Vville, P\\#, Pnom, Pville, Qte}\\}\\)\n\n\nEnsemble de dépendances fonctionnelles \\(\\Sigma\\) :\nV# ⟶ Vnom Vville\nP# ⟶ Pnom Pville\nV# P# ⟶ Qte\n\n\\(\\mathcal{A}\\) n’est pas en FNBC par rapport \\(\\Sigma\\).\nEn effet ni V# ni P# ne sont des super-clefs"
  },
  {
    "objectID": "slides/DF_norm_3.html#fnbc-exemple-2",
    "href": "slides/DF_norm_3.html#fnbc-exemple-2",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "FNBC : exemple 2",
    "text": "FNBC : exemple 2\nSchéma Films(titre, année, durée, genre, producteur, acteur)\n\nOn a la dépendance suivante titre, année ⟶ durée, genre, producteur\ntitre, année, acteur est la seule clef\nLa DF titre, année ⟶ durée, genre, producteur} viole la condition de FNBC"
  },
  {
    "objectID": "slides/DF_norm_3.html#fnbc-exemple-3",
    "href": "slides/DF_norm_3.html#fnbc-exemple-3",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "FNBC : exemple 3",
    "text": "FNBC : exemple 3\nTrois schémas en FNBC :\n\n\nRelation\nClef\n\n\n\nVendeur(V#, Vnom, Vville)\nV#\n\n\nProduit(P#, Pnom, Pville)\nP#\n\n\nLivraison(V#, P#, Qte)\n(V#,P#)"
  },
  {
    "objectID": "slides/DF_norm_3.html#schéma-avec-deux-attributs",
    "href": "slides/DF_norm_3.html#schéma-avec-deux-attributs",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Schéma avec deux attributs",
    "text": "Schéma avec deux attributs\n\n\n\n\n\n\nProposition\n\n\nSoit \\(\\mathcal{A}=\\{A,B\\}\\) un schéma avec deux attributs et \\(\\Sigma\\) un ensemble de DF non triviales.\n\\(\\mathcal{A}\\) est toujours en FNBC par rapport à \\(\\Sigma\\)\n\n\n\n\n\nPreuve. On distingue 4 cas\n\n\\(\\Sigma=\\emptyset\\)\n\\(\\Sigma=\\{A\\rightarrow B\\}\\)\n\\(\\Sigma=\\{B\\rightarrow A\\}\\)\n\\(\\Sigma=\\{A\\rightarrow B, B\\rightarrow A\\}\\)"
  },
  {
    "objectID": "slides/DF_norm_3.html#pourquoi-deux-notions-de-forme-normale-1",
    "href": "slides/DF_norm_3.html#pourquoi-deux-notions-de-forme-normale-1",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Pourquoi deux notions de forme normale ?",
    "text": "Pourquoi deux notions de forme normale ?\n\n\n\n\n\n\nProposition\n\n\nSi un schéma \\(\\mathcal{A}\\) est en forme normale Boyce-Codd (FNBC) relativement à un ensemble de DF Σ, alors \\(\\mathcal{A}\\) est en forme normale 3 (FN3) relativement à Σ\n\n\n\n\n\nLa réciproque est fausse"
  },
  {
    "objectID": "slides/DF_norm_3.html#exercice-1",
    "href": "slides/DF_norm_3.html#exercice-1",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Exercice",
    "text": "Exercice\n\\(\\mathcal{A}=\\) (A, B, C, D, E) et Σ={A → C, BC → D, AD → E}\n\nQuelles sont les clés ?\nLe schéma est-il en FNBC ?\nSi non, propopsez une décomposition SPI en FNBC. Est-elle sans perte de DF?\nLe schéma est-il en FN3 ?"
  },
  {
    "objectID": "slides/DF_norm_3.html#décomposition-dun-schéma-de-relation",
    "href": "slides/DF_norm_3.html#décomposition-dun-schéma-de-relation",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Décomposition d’un schéma de relation",
    "text": "Décomposition d’un schéma de relation\n\n\n\n\n\n\nDéfinition\n\n\nSoit \\(\\mathcal{A}\\) un schéma de relation\nUn décomposition de \\(\\mathcal{A}\\) est un ensemble \\(\\{\\mathcal{A}_1,..., \\mathcal{A}_k\\}\\) de sous-ensembles de \\(\\mathcal{A}\\) tel que\n\\[\\mathcal{A}_i\\not=\\emptyset, 1\\le i\\le k, \\quad \\text{ et } \\quad \\mathcal{A} = \\bigcup_{i=1}^k \\mathcal{A}_i\\]\n\n\n\n\n Une décomposition n’est pas nécessairement une partition. On n’impose pas que les \\(\\mathcal{A}_i\\) soient deux à deux disjoints."
  },
  {
    "objectID": "slides/DF_norm_3.html#exemple-de-décomposition-i",
    "href": "slides/DF_norm_3.html#exemple-de-décomposition-i",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Exemple de décomposition I",
    "text": "Exemple de décomposition I\nVendeur(V#, Vnom, Vville)\nProduit(P#, Pnom, Pville)\nLivraison(V#, P#, Qte)\nest une décomposition du schéma\nR(V#, Vnom, Vville, P#, Pnom, Pville, Qte)"
  },
  {
    "objectID": "slides/DF_norm_3.html#exemple-de-décomposition-ii",
    "href": "slides/DF_norm_3.html#exemple-de-décomposition-ii",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Exemple de décomposition II",
    "text": "Exemple de décomposition II\nSchéma :\nFilms(titre, année, durée, genre, producteur, acteur)\n\nUne décomposition :\nFilms1(titre, année, durée, genre, producteur)\nFilms2(titre, année, acteur)\n\n\nFilms1 est FNBC par rapport à \\(\\Sigma_1=\\{\\texttt{titre, année ⟶ durée, genre, producteur}\\}\\)\n\n\nFilms2 est en FNBC par rapport à \\(\\Sigma_2=\\emptyset\\)"
  },
  {
    "objectID": "slides/DF_norm_3.html#propriétés-dune-décomposition",
    "href": "slides/DF_norm_3.html#propriétés-dune-décomposition",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Propriétés d’une décomposition",
    "text": "Propriétés d’une décomposition\nOn ne peut pas décomposer arbitrairement\nToutes les décompositions ne sont pas intéressantes\n\n\n\n\n\n\n\nConditions pour une décomposition raisonnable :\n\n\n\nDécomposition sans perte d’information\nDécomposition sans perte de dépendance fonctionnelle"
  },
  {
    "objectID": "slides/DF_norm_3.html#décomposition-sans-perte-dinformation-1",
    "href": "slides/DF_norm_3.html#décomposition-sans-perte-dinformation-1",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Décomposition sans perte d’information",
    "text": "Décomposition sans perte d’information\nIdée : Si on remplace le schéma\n(V#, Vnom, Vville, P#, Pnom, Pville, Qte)\npar les trois schémas\nVendeur(V#, Vnom, Vville)\nProduit(P#, Pnom, Pville)\nLivraison(V#, P#, Qte)\nalors au lieu de stocker une relation R(V#, Vnom, Vville, P#, Pnom, Pville, Qte), on stockera ses projections:\n\\[\\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R}) \\qquad \\pi_{\\texttt{P\\#,Pnom,Pville}}(\\texttt{R}) \\qquad \\pi_{\\texttt{V\\#,P\\#,Qte}}(\\texttt{R})\\]\n Peut-on retrouver R à partir de ces trois projections ?"
  },
  {
    "objectID": "slides/DF_norm_3.html#décomposition-sans-perte-dinformation-2",
    "href": "slides/DF_norm_3.html#décomposition-sans-perte-dinformation-2",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Décomposition sans perte d’information",
    "text": "Décomposition sans perte d’information\n\nLa décomposition doit garantir que pour toute relation R, ses projections contiennent la même information que R au sens que l’on doit pouvoir reconstruire R à partir de ses projections\nComment tenter de reconstruire R à partir de ses projections ?\n\nOn considère la jointure naturelle\n\\[\\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{P\\#,Pnom,Pville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{V\\#,P\\#,Qte}}(\\texttt{R})\\]"
  },
  {
    "objectID": "slides/DF_norm_3.html#décomposition-sans-perte-dinformation-3",
    "href": "slides/DF_norm_3.html#décomposition-sans-perte-dinformation-3",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Décomposition sans perte d’information",
    "text": "Décomposition sans perte d’information\nLa propriété souhaitée s’écrit donc\n\\[R = \\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{P\\#,Pnom,Pville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{V\\#,P\\#,Qte}}(\\texttt{R})\\]\npour toute relation R(V#, Vnom, Vville, P#, Pnom, Pville, Qte) satisfaisant les DF\n\n\nEst ce vrai?\nIntuitivement, oui : à partir d’un tuple de Livraison(V#,P#,Qte)\nV# permet de récupérer toutes les informations sur le vendeur (V# ⟶ Vnom Vville)\nP# permet de récupérer toutes les informations sur le produit (P# ⟶ Pnom Pville)\n La propriété d’être sans perte d’information est liée à l’ensemble de DF considéré"
  },
  {
    "objectID": "slides/DF_norm_3.html#décomposition-sans-perte-dinformation-lossless-join",
    "href": "slides/DF_norm_3.html#décomposition-sans-perte-dinformation-lossless-join",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Décomposition sans perte d’information (lossless join)",
    "text": "Décomposition sans perte d’information (lossless join)\n\n\n\n\n\n\nDéfinition\n\n\nSoit \\(\\mathcal{A}\\) un schéma de relation et \\(\\Sigma\\) un ensemble de DF sur \\(\\mathcal{A}\\).\nUne décomposition \\(\\{\\mathcal{A}_1,..., \\mathcal{A}_k\\}\\) est sans perte d’information par rapport à \\(\\Sigma\\) si pour toute relation \\(R\\) de schéma \\(\\mathcal{A}\\) satisfaisant \\(\\Sigma\\) on a\n\\[R= \\pi_{\\mathcal{A}_1}(R) \\bowtie \\pi_{\\mathcal{A}_2}(R) \\bowtie...\\bowtie\\pi_{\\mathcal{A}_k}(R)\\]"
  },
  {
    "objectID": "slides/DF_norm_3.html#exemple-de-décomposition-avec-perte-dinformation",
    "href": "slides/DF_norm_3.html#exemple-de-décomposition-avec-perte-dinformation",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Exemple de décomposition avec perte d’information",
    "text": "Exemple de décomposition avec perte d’information\n\\(\\mathcal{A}=\\{A,B,C\\} \\quad  \\Sigma=\\{AB\\rightarrow C\\}\\)\nDécomposition \\(\\mathcal{A}_1=\\{A,B\\}  \\quad  \\mathcal{A}_2=\\{B,C\\}\\)\n\n\nSoit \\(R\\) la relation\n\n\nA\nB\nC\n\n\n\n1\n2\n3\n\n\n4\n2\n5\n\n\n\n\n\\(\\pi_{AB}(R)=\\)\n\n\nA\nB\n\n\n\n1\n2\n\n\n4\n2\n\n\n\n\n\\(\\pi_{BC}(R)=\\)\n\n\nB\nC\n\n\n\n2\n3\n\n\n2\n5\n\n\n\n\n\\(\\pi_{AB}(R) \\bowtie \\pi_{BC}(R)=\\)\n\n\nA\nB\nC\n\n\n\n1\n2\n3\n\n\n4\n2\n5\n\n\n1\n2\n5\n\n\n4\n2\n3"
  },
  {
    "objectID": "slides/DF_norm_3.html#algorithme-de-poursuite-chase-algorithm",
    "href": "slides/DF_norm_3.html#algorithme-de-poursuite-chase-algorithm",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Algorithme de poursuite (chase algorithm)",
    "text": "Algorithme de poursuite (chase algorithm)\n\nComment déterminer si une décomposition est sans perte d’information?\nSi \\(R\\) est une relation de schéma \\(\\mathcal{A}\\) on a toujours que\n\n\\[R ⊆ \\pi_{\\mathcal{A}_1}(R) \\bowtie \\pi_{\\mathcal{A}_2}(R) \\bowtie...\\bowtie\\pi_{\\mathcal{A}_k}(R)\\]\npar définition de la jointure naturelle et de la projection\n\nLe seul problème est que les jointures peuvent générer des tuples supplémentaires\nMais comme \\(R\\) est supposée vérifier les DF de \\(\\Sigma\\), l’inclusion inverse est garantie dans certains cas\n\nPour le savoir, un algorithme simple existe appelé algorithme de poursuite"
  },
  {
    "objectID": "slides/DF_norm_3.html#algorithme-de-poursuite-exemple",
    "href": "slides/DF_norm_3.html#algorithme-de-poursuite-exemple",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Algorithme de poursuite : exemple",
    "text": "Algorithme de poursuite : exemple\nSi on remplace le schéma (V#, Vnom, Vville, P#, Pnom, Pville, Qte) par\nVendeur(V#, Vnom, Vville)}\nProduit(P#, Pnom, Pville)}\nLivraison(V#, P#, Qte)\nA-t-on\n\\[\\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{P\\#,Pnom,Pville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{V\\#,P\\#,Qte}}(R) \\subset \\texttt{R} \\quad ?\\]"
  },
  {
    "objectID": "slides/DF_norm_3.html#algorithme-de-poursuite-exemple-1",
    "href": "slides/DF_norm_3.html#algorithme-de-poursuite-exemple-1",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Algorithme de poursuite : exemple",
    "text": "Algorithme de poursuite : exemple\nSoit \\(t\\) un tuple dans la jointure\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d\\)\n\\(e\\)\n\\(f\\)\n\\(g\\)\n\n\n\n\\((a, b, c)\\in \\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R})\\) donc il existe \\(e_1, f_1, g_1\\) tels que \\((a, b, c, d_1, e_1, f_1, g_1) \\in \\texttt{R}\\)\n\\((d,e,f) \\in \\pi_{\\texttt{P\\#,Pnom,Pville}}(\\texttt{R})\\) donc il existe \\(a_2, b_2, c_2, g_2\\) tels que \\((a_2, b_2, c_2, d, e, f, g_2)\\in \\texttt{R}\\)\n\\((a,d,g)\\in \\pi_{\\texttt{V\\#,P\\#,Qte}}(R)\\) donc il existe \\(b_3,c_3,e_3,f_3\\) tels que \\((a,b_3,c_3,d,e_3,f_3,g)\\in \\texttt{R}\\)\nOn peut le représenter comme ceci :\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\nVendeur\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d_1\\)\n\\(e_1\\)\n\\(f_1\\)\n\\(g_1\\)\n\n\nProduit\n\\(a_2\\)\n\\(b_2\\)\n\\(c_2\\)\n\\(d\\)\n\\(e\\)\n\\(f\\)\n\\(g_2\\)\n\n\nLivraison\n\\(a\\)\n\\(b_3\\)\n\\(c_3\\)\n\\(d\\)\n\\(e_3\\)\n\\(f_3\\)\n\\(g\\)\n\n\n\n\n\nVendeur (resp. Produit, Livraison) désigne l’ensemble des tuples de \\(R\\) qui se projettent sur \\(a,b,c\\) (resp. \\(d,e,f\\) et \\(a,d,g\\)) lorsque on projette \\(R\\) sur V#,Vnom,Vville (resp. P#, Pnom, Pville et V#, P#, Qte)"
  },
  {
    "objectID": "slides/DF_norm_3.html#algorithme-de-poursuite-exemple-2",
    "href": "slides/DF_norm_3.html#algorithme-de-poursuite-exemple-2",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Algorithme de poursuite : exemple",
    "text": "Algorithme de poursuite : exemple\n\n\n\n\n\n\n\n\n\n\n\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\nVendeur\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d_1\\)\n\\(e_1\\)\n\\(f_1\\)\n\\(g_1\\)\n\n\nProduit\n\\(a_2\\)\n\\(b_2\\)\n\\(c_2\\)\n\\(d\\)\n\\(e\\)\n\\(f\\)\n\\(g_2\\)\n\n\nLivraison\n\\(a\\)\n\\(b_3\\)\n\\(c_3\\)\n\\(d\\)\n\\(e_3\\)\n\\(f_3\\)\n\\(g\\)\n\n\n\nV# ⟶ Vnom, Vville donc \\(b_3=b\\) et \\(c_3=c\\)\n\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\nVendeur\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d_1\\)\n\\(e_1\\)\n\\(f_1\\)\n\\(g_1\\)\n\n\nProduit\n\\(a_2\\)\n\\(b_2\\)\n\\(c_2\\)\n\\(d\\)\n\\(e\\)\n\\(f\\)\n\\(g_2\\)\n\n\nLivraison\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d\\)\n\\(e_3\\)\n\\(f_3\\)\n\\(g\\)"
  },
  {
    "objectID": "slides/DF_norm_3.html#algorithme-de-poursuite-exemple-suite",
    "href": "slides/DF_norm_3.html#algorithme-de-poursuite-exemple-suite",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Algorithme de poursuite : exemple (suite)",
    "text": "Algorithme de poursuite : exemple (suite)\nP#⟶ Pnom, Pville donc \\(e_3=e\\) et \\(f_3=f\\)\n\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\nVendeur\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d_1\\)\n\\(e_1\\)\n\\(f_1\\)\n\\(g_1\\)\n\n\nProduit\n\\(a_2\\)\n\\(b_2\\)\n\\(c_2\\)\n\\(d\\)\n\\(e\\)\n\\(f\\)\n\\(g_2\\)\n\n\nLivraison\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d\\)\n\\(e\\)\n\\(f\\)\n\\(g\\)\n\n\n\nOn a obtenu une ligne égale au tuple \\(t=(a,b,c,d,e,f,g)\\) donc \\(t\\in \\texttt{R}\\) (tous les tuples qui se projettent sur \\(a,f,g\\) coïncident avec \\(t\\))\nOn en déduit que la décomposition est Sans Perte d’Information (SPI)"
  },
  {
    "objectID": "slides/DF_norm_3.html#algorithme-de-poursuite-cas-général",
    "href": "slides/DF_norm_3.html#algorithme-de-poursuite-cas-général",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Algorithme de poursuite : cas général",
    "text": "Algorithme de poursuite : cas général\n\nEntrée : un schéma \\(\\mathcal{A}\\), une décomposition \\(\\{\\mathcal{A}_1,...,\\mathcal{A}_k\\}\\) et un ensemble \\(\\Sigma\\) de DF\nPour chaque attribut de \\(\\mathcal{A}\\), choisir un symbole (par exemple \\(a\\), \\(b\\), \\(c\\),…). La correspondance doit être injective.\nConstruire un tableau dont les colonnes sont les attributs de \\(\\mathcal{A}\\)\n\nLe tableau a une ligne pour chaque \\(\\mathcal{A}_i\\)\nSur la ligne associée à \\(\\mathcal{A}_i\\), les positions correspondant à \\(\\mathcal{A}_i\\) sont remplies avec les symboles choisis.\nLes autres positions sont remplies avec les symboles indicés par \\(i\\)\n\nRépéter tant que possible : s’il existe une DF \\(X\\rightarrow Y\\) dans \\(\\Sigma\\) et deux lignes du tableau en accord sur \\(X\\), égaliser ces deux lignes sur \\(Y\\)\nSortie : Si on obtient une ligne sans valeur indicée, la décomposition est sans perte d’information, sinon il y a perte d’information"
  },
  {
    "objectID": "slides/DF_norm_3.html#commentaires-sur-lalgorithme-de-poursuite",
    "href": "slides/DF_norm_3.html#commentaires-sur-lalgorithme-de-poursuite",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Commentaires sur l’algorithme de poursuite",
    "text": "Commentaires sur l’algorithme de poursuite\nL’objectif de l’algorithme de poursuite est de vérifier que tout tuple de \\(\\pi_{\\mathcal{A}_1}(R) \\bowtie \\pi_{\\mathcal{A}_2}(R) \\bowtie...\\bowtie\\pi_{\\mathcal{A}_k}(R)\\) est aussi un tuple de \\(R\\)\nÀ l’initialisation, on part d’un tuple de \\(\\pi_{\\mathcal{A}_1}(R) \\bowtie \\pi_{\\mathcal{A}_2}(R) \\bowtie...\\bowtie\\pi_{\\mathcal{A}_k}(R)\\) qu’on note symboliquement \\((a, b, c, \\ldots)\\) avec des symboles non indicés\nPour chaque \\(i \\leq k\\), on utilise le fait que pour chaque tuple de \\(\\pi_{\\mathcal{A}_i}(R)\\) il existe un ensemble de tuples de \\(R\\) qui coïncident avec \\((a, b, c, \\ldots)\\) sur \\(\\mathcal{A}_i\\). On note génériquement ces tuples de \\(R\\) en indiçant les noms de variables par \\(i\\) pour toutes les variables qui ne sont pas dans \\(\\mathcal{A}_i\\)\nChacun des sous-ensembles de tuples indicés par \\(i \\leq k\\) définit un sous-ensemble de tuples de \\(R\\)\nOn veut se convaincre que \\((a, b, c, \\ldots)\\) appartient à l’un de ces sous-ensembles\n\nL’algorithme de poursuite utilise les DF de Σ, pour restreindre les \\(k\\) sous-ensembles"
  },
  {
    "objectID": "slides/DF_norm_3.html#commentaires-suite",
    "href": "slides/DF_norm_3.html#commentaires-suite",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Commentaires (suite)",
    "text": "Commentaires (suite)\nL’algorithme de poursuite est un algorithme de réécriture\n\nL’algorithme de poursuite est non-déterministe : à chaque étape, il est parfois possible d’invoquer plusieurs DFs pour réécrire une ou plusieurs lignes\n\n\nUn point important de l’analyse de l’algorithme de poursuite consiste à vérifier que ce non-déterminisme n’est pas un problème : l’algorithme de poursuite termine par un succès ou un échec (blocage) quelle que soit la suite des choix effectués\n\nPreuve ()."
  },
  {
    "objectID": "slides/DF_norm_3.html#algorithme-de-poursuite-exemple-2-1",
    "href": "slides/DF_norm_3.html#algorithme-de-poursuite-exemple-2-1",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Algorithme de poursuite : exemple 2",
    "text": "Algorithme de poursuite : exemple 2\nConsidérons l’exemple : \\(\\mathcal{A}=\\{A,B,C,D\\}\\) avec \\(\\mathcal{A}_1=\\{A,B\\}\\), \\(\\mathcal{A}_2=\\{B,C\\}\\) et \\(\\mathcal{A}_3=\\{C,D\\}\\)\nSoit \\(\\Sigma=\\{{C}\\rightarrow{D}; {B}\\rightarrow{A}\\}\\).\nSoit \\(t=(a,b,c,d)\\). Soit \\(t_1,t_2,t_3\\) les tuples de \\(R\\) suivants:\n\n\n\nA\nB\nC\nD\n\n\n\n\\(t_1\\)\na\nb\n\\(c_1\\)\n\\(d_1\\)\n\n\n\\(t_2\\)\n\\(a_2\\)\nb\nc\n\\(d_2\\)\n\n\n\\(t_3\\)\n\\(a_3\\)\n\\(b_3\\)\nc\nd\n\n\n\nOn a pris \\(c_1,d_1, a_2,d_2, a_3,b_3\\) comme valeurs variables et a,b,c,d comme constantes"
  },
  {
    "objectID": "slides/DF_norm_3.html#algorithme-de-poursuite---exemple-2",
    "href": "slides/DF_norm_3.html#algorithme-de-poursuite---exemple-2",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Algorithme de poursuite - exemple 2",
    "text": "Algorithme de poursuite - exemple 2\n\n\n\nA\nB\nC\nD\n\n\n\n\\(t_1\\)\na\nb\n\\(c_1\\)\n\\(d_1\\)\n\n\n\\(t_2\\)\n\\(a_2\\)\nb\nc\n\\(d_2\\)\n\n\n\\(t_3\\)\n\\(a_3\\)\n\\(b_3\\)\nc\nd\n\n\n\nPar la dépendance \\({B}\\rightarrow{A}\\), il vient :\n\n\n\nA\nB\nC\nD\n\n\n\n\\(t_1\\)\na\nb\n\\(c_1\\)\n\\(d_1\\)\n\n\n\\(t_2\\)\na\nb\nc\n\\(d_2\\)\n\n\n\\(t_3\\)\n\\(a_3\\)\n\\(b_3\\)\nc\nd"
  },
  {
    "objectID": "slides/DF_norm_3.html#algorithme-de-poursuite-exemple-2-2",
    "href": "slides/DF_norm_3.html#algorithme-de-poursuite-exemple-2-2",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Algorithme de poursuite : exemple 2",
    "text": "Algorithme de poursuite : exemple 2\nPar la dépendance \\({C}\\rightarrow{D}\\), il vient :\n\n\n\nA\nB\nC\nD\n\n\n\n\\(t_1\\)\na\nb\n\\(c_1\\)\n\\(d_1\\)\n\n\n\\(t_2\\)\na\nb\nc\nd\n\n\n\\(t_3\\)\n\\(a_3\\)\n\\(b_3\\)\nc\nd\n\n\n\nOn a bien fait apparaître \\(t\\) qui appartient donc à \\(R\\)."
  },
  {
    "objectID": "slides/DF_norm_3.html#algorithme-de-poursuite---exemple-3",
    "href": "slides/DF_norm_3.html#algorithme-de-poursuite---exemple-3",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Algorithme de poursuite - exemple 3",
    "text": "Algorithme de poursuite - exemple 3\nConsidérons toujours l’exemple : \\(\\mathcal{A}=\\{A,B,C,D\\}\\) avec\n\\(\\mathcal{A}_1=\\{A,B\\}\\), \\(\\mathcal{A}_2=\\{B,C\\}\\) et \\(\\mathcal{A}_3=\\{C,D\\}\\)\nMais avec \\(\\Sigma=\\{{B}\\rightarrow{AD}\\}\\).\n\n\nA\nB\nC\nD\n\n\n\na\nb\n\\(c_1\\)\n\\(d_1\\)\n\n\n\\(a_2\\)\nb\nc\n\\(d_2\\)\n\n\n\\(a_3\\)\n\\(b_3\\)\nc\nd\n\n\n\nDans ce cas, en utilisant la seule DF \\({B}\\rightarrow{AD}\\), on obtient \\(a_2=a\\) et \\(d_1=d_2\\) :\n\n\nA\nB\nC\nD\n\n\n\na\nb\n\\(c_1\\)\n\\(d_1\\)\n\n\na\nb\nc\n\\(d_1\\)\n\n\n\\(a_3\\)\n\\(b_3\\)\nc\nd\n\n\n\n\n\n\n\n\n\nNote\n\n\nMais on ne peut pas aller plus loin : la jointure des projections contient des tuples qui ne sont pas dans la relation originelle"
  },
  {
    "objectID": "slides/DF_norm_3.html#remarques",
    "href": "slides/DF_norm_3.html#remarques",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Remarques",
    "text": "Remarques\n\n\n\n\n\n\n\nProposition\n\n\n\nL’algorithme termine\nLes éléments de la décomposition finale sont en FNBC\nLa décomposition est Sans Perte d’Information (SPI)"
  },
  {
    "objectID": "slides/DF_norm_3.html#preuves-1",
    "href": "slides/DF_norm_3.html#preuves-1",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "Preuves \n",
    "text": "Preuves \n\n\nLa terminaison est triviale : à chaque itération le nombre de parties de \\(\\mathcal{A}\\) dans \\(D\\) augmente de \\(1\\) et ce nombre ne peut dépasser \\(\\# \\mathcal{A}\\)\nLa seconde propriété est triviale aussi\nLa propriété SPI se vérifie avec l’algorithme de poursuite (et son analyse): chaque itération de la boucle While est SPI."
  },
  {
    "objectID": "slides/DF_norm_3.html#section-1",
    "href": "slides/DF_norm_3.html#section-1",
    "title": "Normalisation II : Décompositions FN3 et FNBC",
    "section": "",
    "text": "\\(\\mathcal{A} =\\) {Ville, Rue, Numéro, #Bureau_vote}\nΣ = { Ville, Nom, Rue → #Bureau_vote,  #Bureau_vote  →  Ville }\n\nDeux clés Ville, Nom, Rue et #Bureau_vote, Nom, Rue\n\n\n#Bureau_vote  →  Ville ne satisfait pas le critère FNBC\n\n\nL’algorithme de décomposition en FNBC conduit à la décomposition {#Bureau_vote,Ville} et {#Bureau_vote, Nom, Rue}\nLa DF Ville, Nom, Rue → #Bureau_vote n’est pas préservée\nLa décomposition préserve l’information (SPI) mais pas les dépendances fonctionnelles."
  },
  {
    "objectID": "slides/DF_norm_1.html#définition-5",
    "href": "slides/DF_norm_1.html#définition-5",
    "title": "Normalisation I",
    "section": "Définition",
    "text": "Définition\nSoit \\(\\mathcal{A}\\) un schéma de relation\nUn décomposition de \\(\\mathcal{A}\\) est un ensemble \\(\\{\\mathcal{A}_1,..., \\mathcal{A}_k\\}\\) de sous-ensembles de \\(\\mathcal{A}\\) tel que\n\\[\\mathcal{A}_i\\not=\\emptyset, 1\\le i\\le k, \\quad \\text{ et } \\quad \\mathcal{A} = \\bigcup_{i=1}^k \\mathcal{A}_i\\]"
  }
]