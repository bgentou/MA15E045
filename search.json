[
  {
    "objectID": "workshops-chatgpt/td2-chatgpt.html#schéma-world-rappel",
    "href": "workshops-chatgpt/td2-chatgpt.html#schéma-world-rappel",
    "title": "TD 2: SQL",
    "section": "Schéma world (rappel)",
    "text": "Schéma world (rappel)\nUtiliser les commandes suivantes pour retrouver les schémas de tables country, countrylanguage et city.\nbd_2023&gt; \\d world.\"nom de table\"\nVue d’ensemble du schéma world"
  },
  {
    "objectID": "workshops-chatgpt/td2-chatgpt.html#informer-le-chatbot-du-schéma-utilisé",
    "href": "workshops-chatgpt/td2-chatgpt.html#informer-le-chatbot-du-schéma-utilisé",
    "title": "TD 2: SQL",
    "section": "Informer le chatbot du schéma utilisé",
    "text": "Informer le chatbot du schéma utilisé\nIci nous utilisons chatgpt 3.5 (voir https://openai.com).\nNous partons d’une description du schéma world construite par le client dbSchema. Le client dbSchema est connecté au schéma world du catalogue bd_2023-24 sur le serveur etu-pgsql. Le modèle (menu Model) est exporté (sous menu Export) au format HTML/PDF (en markdown) et sauvé dans un fichier world_schema.md.\nDans la conversation avec le chatbot, nous attachons le fichier world_schema.md et nous précisons son usage.\nThe attachment contains the definition of the world database.\n\nWrite an sql query for determining the capitals of countries from region \"Western Europe\""
  },
  {
    "objectID": "workshops-chatgpt/td2-chatgpt.html#requêtes",
    "href": "workshops-chatgpt/td2-chatgpt.html#requêtes",
    "title": "TD 2: SQL",
    "section": "Requêtes",
    "text": "Requêtes\n\nQuels sont les noms des capitales d’Europe de l’ouest? (14 lignes)\n\n\nQuels sont les noms des pays où le français est langue officielle ? (18 lignes)\n\n\nQuels sont les pays dont le gouvernement est monarchique (constitutionnelle ou pas) ? (43 lignes)\n\n\nQuelles sont les monarchies d’Europe dont la capitale compte moins d’un million d’habitants ? (8 lignes)\n\n\nQuelles sont les régions où on ne trouve pas de monarchie ? (9 lignes)\n\n\nQuelles sont les langues qui ne sont langues officielles dans aucun pays ? (355 lignes)\n\n\nQuels sont les pays qui n’ont pas de langue officielle ? (49 lignes)\n\n\nQuels sont les pays dont la seule langue officielle est le français ? (9 lignes)\n\n\nLes noms des pays où le français n’est pas la seule langue officielle. (9 lignes)\n\n\nQuelles sont les régions qui ne comportent qu’une seule forme de gouvernement ? (3 lignes)\n\n\nQuelles sont les langues officielles des pays dont la capitale compte plus de 5 000 000 d’habitants ? (12 lignes)\n\n\nQuels sont les pays où au moins trois langues sont parlées chacune par strictement plus de \\(10\\%\\) de la population ? (35 lignes)\n\n\nQuelles sont les régions où il existe deux pays dont les espérances de vie diffèrent par au moins \\(10\\) ans ? (16 lignes)\n\n\nQuels sont les pays où l’anglais et le français sont des langues officielles ? (3 lignes)\n\n\nMontrer comment calculer l’intersection de deux tables avec une jointure (sous certaines conditions)."
  },
  {
    "objectID": "workshops/td9.html",
    "href": "workshops/td9.html",
    "title": "TD 9: Normalisation et dépendances",
    "section": "",
    "text": "L3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2024-2025\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\n\nDéfinitions\nUne dépendance fonctionnelle est une expression de la forme \\[A_1,A_2,\\ldots,A_k \\rightarrow A_{k+1},\\ldots,A_n\\] où \\(A_1,A_2,\\ldots,A_k, A_{k+1},\\ldots,A_n\\) sont des attributs (colonnes) d’une base de données.\nElle signifie que deux tuples ayant la même valeur sur \\(A_1,\\ldots,A_k\\) doivent avoir la même valeur sur chaque colonnes \\(A_{k+1},\\ldots, A_n\\) (en français : \\(A_1,\\ldots,A_k\\) déterminent \\(A_{k+1},\\ldots,A_n\\). On dit que les attributs \\(A_{k+1},\\ldots, A_n\\) dépendent fonctionnellement de \\(A_1,A_2,\\ldots,A_k\\).\nLa notion de dépendance est transitive : si \\(A \\rightarrow B\\) et \\(B \\rightarrow C\\) alors \\(A \\rightarrow C\\).\nUn ensemble de dépendances fonctionnelles \\(\\mathcal{F}\\) est 1 si aucune dépendance ne peut être déduite des autres en utilisant les règles suivantes :\n\ntrivialité : si \\(Y\\subseteq X\\) alors \\(X\\rightarrow Y\\)\naugmentation : si \\(X\\rightarrow Y\\) alors \\(X,Z\\rightarrow Y,Z\\) pour toute suite d’attributs \\(Z\\).\ntransitivité : si \\(X\\rightarrow Y\\) et \\(Y\\rightarrow Z\\) alors \\(X\\rightarrow Z\\)\nunion : si \\(X\\rightarrow Y\\) et \\(X\\rightarrow Z\\) alors \\(X\\rightarrow Y,Z\\)\ndécomposition/séparation si \\(X\\rightarrow Y\\) et \\(Z\\subseteq Y\\) alors \\(X\\rightarrow Z\\)\n\nLa clôture transitive des attributs \\(A_1,\\ldots, A_k\\) pour un ensemble de dépendances fonctionnelles \\(\\mathcal F\\) est l’ensemble des attributs \\(B_1,\\ldots, B_{\\ell}\\) qui dépendent fonctionnellement de \\(A_1,\\ldots, A_k\\).\nOn la note \\[[A_1,\\ldots, A_k]^+_{\\mathcal{F}}\\] en oubliant \\(\\mathcal{F}\\) si le contexte est clair.\nUn ensemble d’attributs \\(A_1,\\ldots, A_k\\) est une super-clé pour une relation \\(R(B_1,\\ldots, B_{\\ell})\\) si ce sont des attributs de \\(R\\) et si sa clôture transitive contient \\(B_1,\\ldots, B_{\\ell}\\). C’est une clé si elle est minimale, c’est-à-dire, aucun sous-ensemble strict de cette super-clé n’est une clé.\nUn schéma est en :\n\n\\(\\text{FN}_1\\) si tout attribut est atomique.\n\\(\\text{FN}_2\\) si un attribut ne fait pas partie d’une clef, il ne peut pas dépendre d’une partie stricte d’une clef.\n\\(\\text{FN}_3\\) Pour toute dépendance fonctionnelle non triviale, le membre de gauche contient une clef ou tout attribut du membre de droit appartient à une clef.\n\nUn schéma et un ensemble de dépendances fonctionnelles peut se décomposer en une collection de schémas, dans le sens où chaque relation \\(R\\) peut se décomposer en \\(R_1,\\ldots, R_k\\) tels que \\(R_i = \\pi_i(R)\\) pour une certaine projection \\(\\pi_i\\).\nOn dit cette décomposition si toute relation \\(R\\) du schéma d’origine peut être retrouvée à partir des relations \\(R_1,\\ldots, R_k\\) : \\(R = \\pi_1(R) \\bowtie \\ldots \\bowtie \\pi_k(R)\\).\nOn dit que cette décomposition respecte les dépendances fonctionnelles si celles-ci sont toujours satisfaites par la nouvelle décomposition.\n\n\nExercice\nSoit une relation concernant des personnes en France avec les attributs suivants~:\\ Nom, Numéro de sécurité sociale, Commune, Département, Code postal, Numéro de téléphone\nQuelles sont les dépendances fonctionnelles censées être satisfaites~?\n\n\nExercice\nSoit un schéma d’attributs \\(A_1, A_2,\\dots A_n\\) et un ensemble de dépendances fonctionnelles. Calculer le nombre de super-clefs (en fonction de \\(n\\)) dans les cas suivants~:\n\nLa seule clef est \\(\\{A_1\\}\\).\nLes seules clefs sont \\(\\{A_1\\}\\) et \\(\\{A_2\\}\\).\nLes seules clefs sont \\(\\{A_1,A_2\\}\\) et \\(\\{A_3,A_4\\}\\).\nLes seules clefs sont \\(\\{A_1,A_2\\}\\) et \\(\\{A_1,A_3\\}\\).\n\n\n\nExercice\nSoit le schéma \\(\\mathcal{A}=\\{A,B,C,D\\}\\) et l’ensemble de dépendances fonctionnelles \\[\\Sigma = \\{ A \\longrightarrow B, B \\longrightarrow C\\} \\]\n\nQuelle est la fermeture \\(\\{A\\}^+\\) de \\(\\{A\\}\\) ?\n\n\nQuelles sont les super-clés ? Les clés ?\n\n\n\nExercice\nSoit le schéma \\(\\mathcal{A}=\\{A,B,C,D,E,F\\}\\) et l’ensemble de dépendances fonctionnelles \\[\\Sigma = \\Bigl\\{ \\{A,B\\}\\to C, \\{B,C\\}\\to \\{A,D\\}, D\\to E, \\{C,F\\}\\to B \\Bigr\\}\\]\n\nCalculer la fermeture \\(\\{A,B\\}^+\\) de \\(\\{A,B\\}\\).\nEst-ce que \\(\\Sigma\\) implique la dépendance fonctionnelle \\(\\{A,B\\}\\to D\\)~?\nEst-ce que \\(\\Sigma\\) implique la dépendance fonctionnelle \\(D\\to A\\)~?\n\n\n\nExercice\nMontrer que les assertions suivantes sont fausses~:\n\n\\(A\\to B\\) implique \\(B\\to A\\).\nSi \\(\\{A,B\\}\\to C\\) et \\(A\\to C\\) alors \\(B\\to C\\).\nSi \\(\\{A,B\\}\\to C\\) alors \\(A\\to C\\) ou \\(B\\to C\\).\n\n\n\nExercice\n\nSoit le schéma \\(\\mathcal{A}=\\{A, B,C, D, E, F, G, H\\}\\) et soit \\[\\Sigma = \\{AB \\longrightarrow C; \\ B \\longrightarrow D;  \\ CD \\longrightarrow E;  \\ CE \\longrightarrow GH; \\  G \\longrightarrow A\\} \\] Est-ce que les dépendances\n\\(A,B \\longrightarrow E\\)\n\\(B,G \\longrightarrow C\\)\n\\(A,B \\longrightarrow G\\)\n\nsont déductibles de \\(\\Sigma\\)~?\n\n\n\n\nSoit \\[\\Sigma_1 = \\{A \\longrightarrow B ; C,E \\longrightarrow H ; C \\longrightarrow E ; A \\longrightarrow C,H\\}\\] et \\[\\Sigma_2 = \\{A \\longrightarrow B,C ;  C \\longrightarrow E,H\\}\\] Les deux ensembles de dépendances fonctionnelles \\(\\Sigma_1\\) et \\(\\Sigma_2\\) sont-ils équivalents ?\n\n\n\nExercice : Décomposition et perte d’information\n\nOn considère le schéma de relation \\(\\mathcal{A}=\\{A,B,C\\}\\) et la dépendance fonctionnelle suivante:\n\n\\[\\Sigma=\\{  A,B \\longrightarrow C   \\}.\\]\nDéterminer si la décomposition suivante est sans perte d’information\n\\[\\mathcal{A}_1=\\{A,B\\} , \\quad \\mathcal{A}_2=\\{B,C\\}\\]\nen étudiant le cas de la table suivante :\n\n\n\n\n\nA\nB\nC\n\n\n\n\n1\n2\n3\n\n\n4\n2\n5\n\n\n\n\n\nOn considère le schéma de relation \\(\\mathcal{A}=\\{A,B,C,D,E\\}\\) et les dépendances fonctionnelles suivantes:\n\n\\[\\Sigma=\\{  A \\longrightarrow C ; B \\longrightarrow C ; C \\longrightarrow D ; D,E \\longrightarrow C ; C,E \\longrightarrow A    \\}.\\]\nAppliquer l’algorithme de poursuite pour déterminer si la décomposition suivante est sans perte d’information :\n\\[ \\mathcal{A}_1=\\{A,D\\} , \\mathcal{A}_2=\\{A,B\\}    , \\mathcal{A}_3=\\{B,E\\} , \\mathcal{A}_4=\\{C,D,E\\}, \\mathcal{A}_5=\\{A,E\\} \\]\nMême question pour la décomposition: \\[ \\mathcal{A}_1=\\{A,D\\}, \\mathcal{A}_2=\\{A,B\\}, \\mathcal{A}_3=\\{B,E\\}, \\mathcal{A}_4=\\{C,D\\}, \\mathcal{A}_5=\\{D,E\\}, \\mathcal{A}_6=\\{A,E\\} \\]\n\n\nExercice\nSoit \\(\\mathcal{A}=\\{A,B,C,D,E\\}\\) un schéma et soit la décomposition \\(\\{\\mathcal{A}_1,\\mathcal{A}_2,\\mathcal{A}_3\\}\\) où \\[\\mathcal{A}_1=\\{A,B,C\\}\\quad \\mathcal{A}_2=\\{B,C,D\\}\\quad \\mathcal{A}_3=\\{A,C,E\\}\\] Pour chaque ensemble \\(\\Sigma\\) de dépendances fonctionnelles ci-dessous, appliquer l’algorithme de poursuite pour déterminer si la décomposition est sans perte d’information. Dans le cas où il y a perte d’information, donner une relation \\(R\\) de schéma \\(\\mathcal{A}\\) satisfaisant \\(\\Sigma\\) et telle que \\[ \\pi_{\\mathcal{A}_1}(R)\\bowtie\\pi_{\\mathcal{A}_2}(R)\\bowtie\\pi_{\\mathcal{A}_3}(R)\\not\\subset R\\]\n\n\\(\\Sigma=\\{B\\rightarrow E, CE\\rightarrow A\\}\\)\n\\(\\Sigma=\\{AC\\rightarrow E, BC\\to D\\}\\)\n\\(\\Sigma=\\{A\\rightarrow D, D\\to E, B\\to D\\}\\)\n\\(\\Sigma=\\{A\\rightarrow D, CD\\to E, E\\to D\\}\\)\n\n\n\nExercice : Normalisation\nOn considère le schéma de relation R(C,T,H,S,E,N) :\nR(Cours, Enseignant, Horaire, Salle, Étudiant, Note)\net les dépendances fonctionnelles suivantes:\n\\[\\mathcal{F}=\\{  \\texttt{C} \\to \\texttt{T}; \\quad \\texttt{H,S} \\to \\texttt{C}; \\quad \\texttt{H,T} \\to \\texttt{S}; \\quad \\texttt{C,E} \\to \\texttt{N}; \\quad \\texttt{H,E} \\to S \\}. \\]\n\nCalculer une clé.\n\n\nMettre en Boyce-Codd Normal Form (BCNF), donner plusieurs résultats possibles."
  },
  {
    "objectID": "workshops/td5.html#over-partition-by",
    "href": "workshops/td5.html#over-partition-by",
    "title": "TD 5: SQL",
    "section": "OVER (PARTITION BY …)",
    "text": "OVER (PARTITION BY …)\nCette construction peut être combinée avec n’importe quelle fonction d’aggrégation.\nCette requête indique pour chaque ville, la “population moyenne” des villes de ce pays (cette moyenne n’a aucun sens).\nSELECT id, name_city, population_city, \n       avg(population_city) OVER (PARTITION BY countrycode)  AS avg_pop\nFROM world.city;  \nSans le mécanisme de fenêtrage, on pourrait obtenir le résultat au prix d’une jointure\n WITH tmp AS (\n  SELECT c.countrycode, AVG(c.population_city) AS avg_pop\n  FROM world.city c\n  GROUP BY c.countrycode\n ) \n  SELECT cc.id, cc.name_city, cc.population_city, tmp.avg_pop\n  FROM world.city cc NATURAL JOIN tmp;"
  },
  {
    "objectID": "workshops/td5.html#over-partition-by-order-by",
    "href": "workshops/td5.html#over-partition-by-order-by",
    "title": "TD 5: SQL",
    "section": "OVER (PARTITION BY … ORDER BY)",
    "text": "OVER (PARTITION BY … ORDER BY)\nOn peut partitioner et trier.\nCette construction est très pratique pour ranger les tuples d’un sous-groupe.\nDans world, si on veut ranger les langues parlées dans un pays par popularité décroissante, on peut procéder ainsi.\nSELECT countrycode, LANGUAGE, \nRANK() OVER (PARTITION BY countrycode ORDER BY percentage DESC)  AS rnk\nFROM world.countrylanguage ;"
  },
  {
    "objectID": "workshops/td5.html#rank-over",
    "href": "workshops/td5.html#rank-over",
    "title": "TD 5: SQL",
    "section": "RANK() OVER ()",
    "text": "RANK() OVER ()\nOn peut ne pas partitionner en utilisant l’expression OVER (). Par exemple, si on veut obtenir le rang des tuples d’une table sur un tri particulier.\nSELECT countrycode, name_country, \n       RANK() OVER (ORDER BY population_country DESC)  AS rnk\nFROM world.country ;"
  },
  {
    "objectID": "workshops/td5.html#autres-types-de-fenêtres",
    "href": "workshops/td5.html#autres-types-de-fenêtres",
    "title": "TD 5: SQL",
    "section": "Autres types de fenêtres",
    "text": "Autres types de fenêtres\nLa construction OVER ( ...) n’est pas utilisée exclusivement avec des partitions (peut-être triviales), on peut aussi définir des fenêtres glissantes.\nLes fonctions fenêtre ne sont autorisées que dans la liste SELECT et la clause ORDER BY de la requête. Elles sont interdites ailleurs, par exemple dans les clauses GROUP BY, HAVING et WHERE."
  },
  {
    "objectID": "workshops/td5.html#forme-générale",
    "href": "workshops/td5.html#forme-générale",
    "title": "TD 5: SQL",
    "section": "Forme générale",
    "text": "Forme générale\nCREATE OR REPLACE FUNCTION  schema_name.func_name(p_arg1 p_arg1_datatype, ..., [OUT o_arg1 o_arg1_datatype, ...])\nRETURNS some type | RECORD | SETOF some type | TABLE (..) \nLANGUAGE SQL AS\n$$\nSQL statement ;\nSQL statement ;\n...\nSQL statement ;\n$$ ;"
  },
  {
    "objectID": "workshops/td5.html#fonctions-qui-retournent-un-type-simple",
    "href": "workshops/td5.html#fonctions-qui-retournent-un-type-simple",
    "title": "TD 5: SQL",
    "section": "Fonctions qui retournent un type simple",
    "text": "Fonctions qui retournent un type simple\nDans le schéma world, on veut écrire une fonction qui prend en argument une région et renvoie la population maximale parmi les capitales de la région (voir td2 requête 1).\nCREATE OR REPLACE FUNCTION username.taille_max_capitale_region(p_region text)\nRETURNS INTEGER LANGUAGE SQL AS\n$$\nSELECT MAX(population_city) AS max_pop\nFROM world.country c JOIN world.city cc ON (c.capital=cc.id)\nWHERE c.region=p_region AND cc.population_city IS NOT NULL;\n$$ ;"
  },
  {
    "objectID": "workshops/td5.html#fonctions-qui-retournent-un-type-composé",
    "href": "workshops/td5.html#fonctions-qui-retournent-un-type-composé",
    "title": "TD 5: SQL",
    "section": "Fonctions qui retournent un type composé",
    "text": "Fonctions qui retournent un type composé\nDans le schéma world, on veut écrire une fonction qui prend en argument une région et renvoie le nom et la population de la capitale la plus peuplée de cette région (voir td2 requête 1).\nOn peut utiliser le qualifiant OUT pour désigner des paramètres de sortie.\nCREATE OR REPLACE FUNCTION username.capitale(p_region text, OUT o_name_capital TEXT, OUT o_population_capital INTEGER)\nRETURNS RECORD  LANGUAGE SQL AS\n$$\nWITH r AS(\n  SELECT cc.*, RANK() OVER (PARTITION BY c.region \n                            ORDER BY cc.population_city DESC) AS rnk\n  FROM world.country c JOIN world.city cc ON (c.capital=cc.id)\n  WHERE c.region=p_region)\nSELECT r.name_city,  r.population_city\nFROM r \nWHERE r.rnk = 1 ;\n$$ ;"
  },
  {
    "objectID": "workshops/td5.html#fonctions-qui-retournent-un-type-composé-défini-par-les-lignes-dune-table",
    "href": "workshops/td5.html#fonctions-qui-retournent-un-type-composé-défini-par-les-lignes-dune-table",
    "title": "TD 5: SQL",
    "section": "Fonctions qui retournent un type composé défini par les lignes d’une table",
    "text": "Fonctions qui retournent un type composé défini par les lignes d’une table\nDans le schéma world, on veut écrire une fonction qui prend en argument une région et renvoie la description de la capitale la plus peuplée de cette région (voir td2 requête 1).\nCREATE OR REPLACE FUNCTION username.capitale(p_region text)\nRETURNS world.city  LANGUAGE SQL AS\n$$\nWITH r AS(\n  SELECT cc.*, RANK() OVER (PARTITION BY c.region \n                            ORDER BY cc.population_city DESC) AS rnk\n  FROM world.country c JOIN world.city cc ON (c.capital=cc.id)\n  WHERE c.region=p_region\n)\nSELECT r.id, r.name_city, r.countrycode, r.district, r.population_city\nFROM r \nWHERE r.rnk = 1 ;\n$$ ;"
  },
  {
    "objectID": "workshops/td5.html#fonctions-qui-retournent-une-table",
    "href": "workshops/td5.html#fonctions-qui-retournent-une-table",
    "title": "TD 5: SQL",
    "section": "Fonctions qui retournent une table",
    "text": "Fonctions qui retournent une table\nDans le schéma world, on veut écrire une fonction qui prend en argument une région et renvoie la table des capitales de la région (voir td2 requête 1).\n\nTable de schéma explicite\nOn se contente d’abord de renvoyer le nom de la capitale. On explicite le schéma de la table résultat\nCREATE OR REPLACE FUNCTION username.capitales_region(p_region text)\nRETURNS TABLE (name_capital text) LANGUAGE SQL AS\n$$\nSELECT cc.name_city \nFROM world.country c JOIN world.city cc ON (c.capital=cc.id)\nWHERE c.region=p_region ;\n$$ ;\n\n\nTable de même schéma qu’une autre table\nDocumentation\nOn veut maintenant récupérer une table de même schéma que city.\n\n\n\n\n\n\nLa solution est très simple. On profite de ce qu’à chaque table correspond un type de même nom et on utilise le mot-clé SETOF.\n\n\n\nCREATE OR REPLACE FUNCTION username.capitales_region_large(p_region text)\nRETURNS SETOF world.city  LANGUAGE SQL AS\n$$\nSELECT cc.* \nFROM world.country c JOIN world.city cc ON (c.capital=cc.id)\nWHERE c.region=p_region ;\n$$ ;"
  },
  {
    "objectID": "workshops/td2.html#schéma-world-rappel",
    "href": "workshops/td2.html#schéma-world-rappel",
    "title": "TD 2: SQL",
    "section": "Schéma world (rappel)",
    "text": "Schéma world (rappel)\nUtiliser les commandes suivantes pour retrouver les schémas de tables country, countrylanguage et city.\nbd_2023&gt; \\d world.\"nom de table\"\nVue d’ensemble du schéma world"
  },
  {
    "objectID": "workshops/td2.html#écriture-de-requêtes",
    "href": "workshops/td2.html#écriture-de-requêtes",
    "title": "TD 2: SQL",
    "section": "Écriture de requêtes",
    "text": "Écriture de requêtes\nPour extraire des informations d’une base de données, on utilise l’algèbre relationnelle (pour la théorie) et le langage SQL (pour la pratique).\n\n\n\n\n\n\n\n\nOpération\nAlgèbre rel.\nSQL\n\n\n\n\nProjection\n\\(\\Pi_{\\text{liste d'attributs}}(R)\\)\nSELECT attributs FROM  R\n\n\nSélection\n\\({\\Large \\sigma}_{\\text{condition}}{R}\\)\nSELECT * FROM R WHERE condition\n\n\nRenommage\n\\(\\rho_{\\text{nom1} \\rightarrow \\text{nom2}}(R)\\)\nSELECT nom1 AS nom2 FROM table1 AS table2\n\n\nUnion\n\\(R \\cup S\\)\n(SELECT * FROM R) UNION (SELECT * FROM S)\n\n\nDifférence\n\\(R - S\\)\n(SELECT * FROM R) EXCEPT (SELECT * FROM S)\n\n\nProduit\n\\(R \\times S\\)\nSELECT * FROM R,S\n\n\nIntersection\n\\(R \\cap S\\)\n(SELECT * FROM R) INTERSECT (SELECT * FROM S)"
  },
  {
    "objectID": "workshops/td2.html#opérations-avancées",
    "href": "workshops/td2.html#opérations-avancées",
    "title": "TD 2: SQL",
    "section": "Opérations avancées",
    "text": "Opérations avancées\n\nJointures\nLa jointure est une opération qui permet de recoller deux relations ensemble. On la note avec le signe \\(\\bowtie_C\\) où \\(C\\) est une condition. Formellement, ce n’est qu’une sélection selon la condition \\(C\\) d’un produit cartésien, c’est-à-dire, par définition : \\[R {\\Large \\bowtie}_C S = {\\Large \\sigma}_{C}{(R \\times S)}.\\]\nCette opération est très courante dans les requêtes. Cela vient du fait que les bases de données sont conçues pour ne pas avoir d’information redondante.\nPrenons l’exemple du schéma world et des tables world.country et world.city. La table world.country possède une colonne capital qui contient le numéro d’identification d’une ville de la table world.city. Par exemple, pour la France, la colonne capital vaut 2974 et la ville numéro 2974 est Paris:\nbd_2023-24&gt; SELECT capital \nFROM world.country \nWHERE countrycode='FRA';\nbd_2023-24&gt; SELECT name \nFROM world.city \nWHERE id = 2974;\nPour lister les noms des capitales mondiales, on va avoir besoin de recoller les deux tables en prenant soin de respecter la condition d’égalité entre la capitale et le numéro d’identification de la ville. Cela peut s’écrire en SQL comme suit:\nSELECT name\nFROM world.city AS V JOIN \n     world.country AS P ON \n     V.id = P.capital;\nParfois, on veut recoller deux tables avec la condition que les colonnes qui ont le même nom doivent être égales. Cela arrive souvent si la base de données a bien été conçue. On appelle cette jointure une jointure naturelle, qu’on peut écrire avec NATURAL JOIN. La requête\nSELECT name \nFROM world.city NATURAL JOIN world.country\nWHERE continent = 'Oceania';\nrenvoie la liste des villes d’Océanie. La jointure est faite implicitement sur la condition\nworld.city.countrycode = world.country.countrycode\nla table résultante n’aura qu’une seule colonne countrycode. Si l’on souhaite ne faire la jointure naturelle que sur un sous-ensemble a1,...,ak des attributs communs, on peut utiliser JOIN ... USING (a1,...,ak).\n\n\nRequêtes nommées : utilisation de WITH\nLorsque les requêtes se compliquent, il est parfois commode de la découper en plusieurs requêtes qu’on manipulera par la suite. Par exemple, trouver le nom des capitales européennes ayant plus d’un million d’habitants peut se découper ainsi: on résout la requête CAP qui contient le nom, le continent et la population des capitales. Puis on résout la requête finale en filtrant CAP. Cela peut s’écrire avec l’opérateur WITH:\nWITH CAP AS (\n  SELECT name, continent, population\n  FROM world.city AS V JOIN \n    world.country AS P ON  V.id=P.capital\n)\n\nSELECT name\nFROM CAP\nWHERE continent = 'Europe' AND population &gt; 1000000;"
  },
  {
    "objectID": "workshops/td2.html#requêtes",
    "href": "workshops/td2.html#requêtes",
    "title": "TD 2: SQL",
    "section": "Requêtes",
    "text": "Requêtes\n\nQuels sont les noms des capitales Sud-Américaines ? (14 lignes)\n\n\nQuels sont les noms des pays où le français est langue officielle ? (18 lignes)\n\n\nQuels sont les pays dont le gouvernement est monarchique (constitutionnelle ou pas) ? (43 lignes)\n\n\nQuelles sont les monarchies d’Europe dont la capitale compte moins d’un million d’habitants ? (8 lignes)\n\n\nQuelles sont les régions où on ne trouve pas de monarchie ? (9 lignes)\n\n\nQuelles sont les langues qui ne sont langues officielles dans aucun pays ? (355 lignes)\n\n\nQuels sont les pays qui n’ont pas de langue officielle ? (49 lignes)\n\n\nQuels sont les pays dont la seule langue officielle est le français ? (9 lignes)\n\n\nLes noms des pays où le français n’est pas la seule langue officielle. (9 lignes)\n\n\nQuelles sont les régions qui ne comportent qu’une seule forme de gouvernement ? (3 lignes)\n\n\nQuelles sont les langues officielles des pays dont la capitale compte plus de 5 000 000 d’habitants ? (12 lignes)\n\n\nQuels sont les pays où au moins trois langues sont parlées chacune par strictement plus de \\(10\\%\\) de la population ? (35 lignes)\n\n\nQuelles sont les régions où il existe deux pays dont les espérances de vie diffèrent par au moins \\(10\\) ans ? (16 lignes)\n\n\nQuels sont les pays où l’anglais et le français sont des langues officielles ? (3 lignes)\n\n\nMontrer comment calculer l’intersection de deux tables avec une jointure (sous certaines conditions)."
  },
  {
    "objectID": "workshops/td10.html",
    "href": "workshops/td10.html",
    "title": "TD 10: Normalisation",
    "section": "",
    "text": "L3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2024-2025\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\n\nExercice\nSoit \\(\\mathcal{A}=\\left\\{A,B,C,D,E\\right\\}\\) un schéma et soit \\(\\mathcal{A}_1=\\left\\{A,B,C\\right\\}\\). Pour chaque ensemble \\(\\Sigma\\) de dépendances fonctionnelles ci-dessous, déterminer un ensemble de DF équivalent à \\(\\pi_{\\mathcal{A}_1}(\\Sigma)\\).\n\n\\(\\Sigma=\\left\\{AB\\to DE, C\\to E, D\\to C, E\\to A\\right\\}\\)\n\\(\\Sigma=\\left\\{A\\to D, BD\\to E, AC\\to E, DE\\to B\\right\\}\\)\n\\(\\Sigma=\\left\\{AB\\to D, AC\\to E, BC\\to D, D\\to A, E\\to B\\right\\}\\)\n\\(\\Sigma=\\left\\{A\\to B, B\\to C, C\\to D, D\\to E, E\\to A\\right\\}\\)\n\n\n\nExercice\nSoit \\(\\mathcal{A}=\\left\\{A,B,C,D,E\\right\\}\\) un schéma et soit la décomposition \\(\\left\\{\\mathcal{A}_1,\\mathcal{A}_2,\\mathcal{A}_3\\right\\}\\) où \\[\\mathcal{A}_1=\\left\\{A,B,C\\right\\}\\quad \\mathcal{A}_2=\\left\\{B,C,D\\right\\}\\quad \\mathcal{A}_3=\\left\\{A,C,E\\right\\}\\] Pour chaque ensemble \\(\\Sigma\\) de dépendances fonctionnelles ci-dessous, déterminer quelles dépendances sont préservées par cette décomposition, c’est-à-dire quelles DF de \\(\\Sigma\\) sont impliquées par \\(\\bigcup_{i=1}^3 \\pi_{\\mathcal{A}_i}(\\Sigma)\\).\n\n\\(\\Sigma=\\left\\{b\\rightarrow E, CE\\rightarrow A\\right\\}\\)\n\\(\\Sigma=\\left\\{aC\\rightarrow E, BC\\to D\\right\\}\\)\n\\(\\Sigma=\\left\\{a\\rightarrow D, D\\to E, B\\to D\\right\\}\\)\n\\(\\Sigma=\\left\\{a\\rightarrow D, CD\\to E, E\\to D\\right\\}\\)\n\n\n\nExercice\nOn considère le schéma de relation suivant concernant la gestion de rendez-vous d’un service d’intervention hospitaliers. \\[\n\\mathcal{A}=\\left\\{\\texttt{IdM,NomM,PrenomM,DateRV,HeureRV,IdP,NomP,PrenomP,IdInterV}\\right\\}\n\\]\nChaque rendez-vous implique un médecin et un patient. Chaque médecin est identifié par un numéro, IdM, un nom NomM et un prénom PrenomM. Le rendez-vous est à une date, DateRV, et à une heure, HeureRV données. Chaque patient est identifié par un numéro, IdP, un nom NomP et un prénom PrenomP. Chaque rv est programmé pour un type d’intervention médical, IdInterV. On suppose que chaque jour, un médecin ne peut pratiquer qu’un seul type d’intervention médicale (consultation, type de chirurgie donnée).\nOn a les dépendances fonctionnelles \\(\\Sigma\\) suivantes:\nIdM, DateRV,HeureRV, IdInterV → IdP\nIdM, DateRV →  IdInterV\nIdM → NomM, PrenomM\nIdP → NomP, PrenomP\nIdP,DateRV,HeureRV → IdInterV\nIdP,DateRV,HeureRV →  IdM,NomM\n\nQuels sont les inconvénients d’une telle modélisation par une seule table en terme d’anomalies d’insertion ou de suppression ?\n\n\nCalculer \\([\\texttt{IdM}]^+_{\\Sigma}\\)\n\n\nProposez un ensemble d’attributs formant une clé de la relation.\n\n\nDonner un ensemble de dépendances fonctionnelles \\(\\Sigma'\\) équivalent à \\(\\Sigma\\) qui soit minimal (i.e. sans règles redondantes, notamment). Justifiez\n\nOn se donne la décomposition de \\(\\mathcal{A}\\) suivante~: \\[\n\\begin{array}{l}\n    \\mathcal{A}_1=\\left\\{\\texttt{IdM,HeureRV,DateRV,IdP,NomP,PrenomP}\\right\\},\\\\\n     \\mathcal{A}_2=\\left\\{\\texttt{IdM,DateRV,IdInterV}\\right\\},\\\\\n     \\mathcal{A}_3=\\left\\{\\texttt{IdM,NomM,PrenomM}\\right\\}\n\\end{array}\n\\]\n\nToutes les dépendances fonctionnelles sont-elles préservées par cette décomposition ?\nEst-elle sans perte d’information ?\nPour \\(i=1,2,3\\), déterminer si \\(\\mathcal{A}_i\\) est en forme normale de Boyce-Codd.\n\n\nMêmes questions pour la décomposition :\n\n\\[\n\\begin{array}{rl}\n\\mathcal{A}_1 &=\\left\\{\\texttt{IdM,HeureRV,DateRV,IdP}\\right\\}\\\\\n\\mathcal{A}_2 &=\\left\\{\\texttt{IdP,NomP,PrenomP}\\right\\}, \\\\\n\\mathcal{A}_3 &=\\left\\{\\texttt{IdM,DateRV,IdInterV}\\right\\},\\\\\n\\mathcal{A}_4 &=\\left\\{\\texttt{IdM,NomM,PrenomM}\\right\\}\n\\end{array}\n\\]\n\n\nExercice\nSoit une relation concernant des personnes résidant en France avec les attributs suivants:\nNom, Numéro de sécurité sociale, Commune, Département, Code postal, Numéro de téléphone\navec l’ensemble \\(\\Sigma\\) de DF suivantes~:\nNuméro de sécurité sociale → Nom, Commune, Département, Code postal, Numéro de téléphone \nCommune → Département \nCode postal → Commune, Département\n\nCe schéma est-il en forme normale de Boyce-Codd ?\n\nSoit la décomposition \\[\\mathcal{A}_1=\\left\\{\\texttt{Code postal}, \\texttt{Commune}, \\texttt{Département}\\right\\}\\] et \\[\\mathcal{A}_2=\\left\\{\\texttt{Numéro de sécurité sociale}, \\texttt{Nom}, \\texttt{Code postal},\\texttt{Numéro de téléphone}\\right\\}\\]\n\nChaque \\(\\mathcal{A}_i\\) est-elle en forme normale de Boyce-Codd ?\nCette décomposition préserve-t-elle les dépendances fonctionnelles ?\nCette décomposition est-elle sans perte d’information ?\nMêmes questions pour la décomposition \\[\\mathcal{A}_1=\\left\\{\\texttt{Commune}, \\texttt{Département}\\right\\}\\]\n\n\\[\\mathcal{A}_2=\\left\\{\\texttt{Numéro de sécurité sociale}, \\texttt{Nom}, \\texttt{Commune}, \\texttt{Code postal},\\texttt{Numéro de téléphone}\\right\\}\\]\n\n\nExercice\nSoit un schéma d’attributs \\(A_1, A_2,\\dots A_n\\) et un ensemble de dépendances fonctionnelles. Calculer le nombre de super-clefs (en fonction de \\(n\\)) dans les cas suivants~:\n\nLa seule clef est \\(\\left\\{A_1\\right\\}\\).\nLes seules clefs sont \\(\\left\\{A_1\\right\\}\\) et \\(\\left\\{A_2\\right\\}\\).\nLes seules clefs sont \\(\\left\\{A_1,A_2\\right\\}\\) et \\(\\left\\{A_3,A_4\\right\\}\\).\nLes seules clefs sont \\(\\left\\{A_1,A_2\\right\\}\\) et \\(\\left\\{A_1,A_3\\right\\}\\).\n\n\n\nExercice\nSoit le schéma \\(\\mathcal{A}=\\{A,B,C,D\\}\\) et l’ensemble de dépendances fonctionnelles \\[\\Sigma = \\{ A \\to B, B \\to C\\} \\]\n\nQuelle est la fermeture \\(\\{A\\}^+\\) de \\(\\{A\\}\\) ?\n\n\nQuelles sont les super-clés ? Les clés ?\n\n\n\nExercice\nSoit le schéma \\(\\mathcal{A}=\\{A,B,C,D,E,F\\}\\) et l’ensemble de dépendances fonctionnelles \\[\\Sigma = \\Bigl\\{ \\left\\{A,B\\right\\}\\to C, \\left\\{B,C\\right\\}\\to \\left\\{A,D\\right\\}, D\\to E, \\left\\{C,F\\right\\}\\to B \\Bigr\\}\\]\n\nCalculer la fermeture \\(\\left\\{A,B\\right\\}^+\\) de \\(\\left\\{A,B\\right\\}\\).\nEst-ce que \\(\\Sigma\\) implique la dépendance fonctionnelle \\(\\left\\{A,B\\right\\}\\to D\\)~?\nEst-ce que \\(\\Sigma\\) implique la dépendance fonctionnelle \\(D\\to A\\)~?\n\n\n\n\nExercice\nOn considère une schéma \\(\\mathcal{A}\\) avec les attributs\nPropriétaire, Occupant, Adresse, Noapt, Nbpièces, Nbpersonnes\nUn nuplet/tuple (p, o, a, n, nb1, nb2) ayant la signification suivante : La personne o habite avec nb2 personnes l’appartement de numéro n ayant nb1 pièces dont le propriétaire est p.\nUne analyse de cette relation nous fournit un ensemble initial \\(\\Sigma\\) de dépendances fonctionnelles\nOccupant → Adresse\nOccupant → Noapt\nOccupant → Nbpersonnes\nAdresse, Noapt → Proprietaire\nAdresse, Noapt → Occupant\nAdresse, Noapt → Nbpieces\n\nDéterminer les clés du schémas\nLes schéma est-il en FN3 ?\nSi la réponse est Non, décomposer sans perte d’information et sans perte de dépendances fonctionnelles.\n\n\n\nExercice\n\nSoit le schéma \\[\\mathcal{A}=\\{\\texttt{IdLivre, Titre, Langue, Pays, IdTraducteur, Nom, Date}\\}\\] et l’ensemble de DF\nIdLivre → Titre \nLangue → Pays \nIdTraducteur → Nom \nIdLivre, IdTraducteur, Langue → Date\nIdLivre, IdTraducteur → Langue\nAppliquer l’algorithme de décomposition vu en cours pour obtenir une décomposition de \\(\\mathcal{A}\\) qui respecte la FNBC et est sans perte d’information. Déterminer quelles DF sont préservées.\n\n\nExercice\nSoit le schéma \\[\\mathcal{A}=\\left\\{\\texttt{A,B,C,D,E,F,G,H}\\right\\}\\] et l’ensemble de DF\nBE → AC  \nB → H  \nF → CD  \nD → G\n\nAppliquer l’algorithme de décomposition vu en cours pour obtenir une décomposition de \\(\\mathcal{A}\\) qui respecte la FNBC et est sans perte d’information. Déterminer quelles DF sont préservées.\nPeut-on, en ajoutant un sous-schéma à la décomposition, obtenir une décomposition FNBC sans perte d’information et sans perte de DF ?\n\n\n\nExercice\nReprendre les questions de l’exercice précédent pour le schéma \\[\\mathcal{A}=\\left\\{\\texttt{A,B,C,D,E,F,G,H}\\right\\}\\] et l’ensemble de DF\nBE → AC  \nB → H\nF → CD\nD → G\nA→ E"
  },
  {
    "objectID": "cours-syllabus.html",
    "href": "cours-syllabus.html",
    "title": "MA15Y030 Syllabus",
    "section": "",
    "text": "Organisation des enseignements\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJour\nHoraire\nLieu\nDébut\n\n\n\n\nCours\nVendredi\n14:00 - 15:30\nOlympe de Gouges Amphi II\n2024-09-13\n\n\nTD/TP 1 MIASHS\nVendredi\n15:45 - 18:15\nSophie Germain 2004\n2024-09-20\n\n\nTD/TP 2 MIASHS\nVendredi\n15:45 - 18:15\nSophie Germain 2005\n2024-09-20\n\n\nTD/TP 3 MIASHS\nVendredi\n15:45 - 18:15\nSophie Germain 2006\n2024-09-20\n\n\nTD/TP IngeMaths/METIS\nJeudi\n13:30 - 16:00\nSophie Germain 2006\n2024-09-26\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nObjectifs\n\n\n\nAprès avoir suivi ce cours, vous serez capable :\n\nd’interroger une base de données relationnelle\nde lire un schéma de base de données\nde concevoir une base de données\nd’améliorer une base de données\n\n\n\n\n\n\n\n\n\nUniversité Paris Cité\n\n\n\nQuelques rubriques utiles:\n\nCharte Université Paris Cité\nDémarches et accessibilité\nCentre de contact\nRelais handicap\n\n\n\n\n\n\n\n\n\nCommunication \n\n\n\nLes supports matériels du cours sont accessible à partir de s-v-b.github.io/MA15Y030\nLes annonces sont diffusées via Moodle\nInscrivez-vous au portail Moodle pour être toujours informé\n\n\n\n\n\n\n\n\nSupport informatique \n\n\n\n Côté serveur, vous utiliserez le serveur PostGres de l’UFR de Mathématiques. Pour disposer d’un identifiant ENT et d’un mot de passe  consultez la procédure sur Moodle\n Côté client, vous pourrez utiliser le logiciel qui vous convient. En salle machine, vous trouverez\n\npsql\npgcli\ndbeaver\n\nVous pouvez installer l’un de ces clients ou plusieurs sur votre machine personnelle.\n\n\n\n\n\n\n\n\nRéférences \n\n\n\n\nDatabase Systems: The Complete Book (DS:CB), by Hector Garcia-Molina, Jeff Ullman, and Jennifer Widom\nFoundations of databases. Abiteboul, Hull et Vianu\nAlice\nDocumentation PostGres\nNext Generation Databases NoSQLand Big Data, Guy Harrison\nGuy Harrison Blog\nDatabases trends and applications\nUpcoming book “Principles of Databases”, by Marcelo Arenas, Pablo Barcelo, Leonid Libkin, Wim Martens, and Andreas Pieris.\n\n\n\n\n\n\n\n\n\n\nCours magistraux et Travaux dirigés \n\n\n\nLe canevas des cours magistraux est résumé par les diapositives\nLes énoncés des exercices sont disponibles sous différents formats (html et pdf)\nLes corrections (partielles) des exercices sont disponibles sous différents formats (html et pdf)\nAssiduité. La présence en cours et en TDs n’est pas obligatoire. Aucun certificat d’assiduité ne sera délivré.\nÉvitez si possible les courriels à propos du contenu du cours. Le courriel devrait être réservé aux questions personnelles.\n\n\n\n\n\n\n\n\nContrôle des connaissances \n\n\n\n\nContrôle continu en trois épreuves sur table :\n\n\\(\\textsf{CC}_1\\) (1 heure)\n\\(\\textsf{CC}_2\\) (1 heure)\n\\(\\textsf{CC}_3\\) (1 heure)\n\nExamen\n\n\\(\\textsf{CT}\\) (2 heures)\n\nNotation\n\nLa note finale de session I est calculée selon la formule :\n\\[\\frac{1}{6}\\left\\{\\max( \\textsf{CC}_1,\\textsf{CT}) + \\max(\\textsf{CC}_2,\\textsf{CT}) + \\max(\\textsf{CC}_3,\\textsf{CT}) \\right\\} + \\frac{1}{2} \\textsf{CT}\\]\nLa note de session II (seconde chance) est égale à la note obtenue à l’épreuve sur table de seconde chance.\n\n\n\n\n\n\n\n\n Trucs\n\n\n\n\nSurvolez les diapositives avant le cours\nRéfléchissz sur les exercices avant de consulter les corrections\nVérifiez la compatibilité de vos solutions avec les corrections\nUtilisez les aides en ligne (StackOverflow, ChatGPT, copilot, …)\nDécryptez les messages d’erreur\nPosez des questions, , cela aide tout le monde (bis)\n\n\n\n\n\n\n\n\n\nIntégrité universitaire\n\n\n\nTL;DR: Pas de triche!\n\n\n\n\n\n\n\n\nSauvez les dates ! \n\n\n\n\nSeptembre 13: Début du cours\nSeptembre 20: Début des TD/TP\nOctobre 25: Contrôle continu I\nOctobre 26-Novembre 3: Pause de la Toussaint\nNovembre 8 : Reprise des cours et TD\nNovembre 15: Contrôle continu II\nDécembre 6: Fin du cours magistral\nDécembre 13: Contrôle continu III\nJanvier ??: Contrôle terminal\nJuin ??: Deuxième chance\n\nCliquer ici pour le calendrier universitaire de Université Paris Cité.\nCliquer ici pour l’emploi du temps de la Licence MIASHS",
    "crumbs": [
      "Informations générales",
      "Syllabus"
    ]
  },
  {
    "objectID": "schemas/schema-babynames.html",
    "href": "schemas/schema-babynames.html",
    "title": "Schéma : babynames",
    "section": "",
    "text": "Présentation du schéma babynames, pour l’entrainement à PostGres.\nCe jeu de données est fourni par l’INSEE https://www.insee.fr/fr/statistiques/fichier/2540004/nat2021_csv.zip permet d’étudier l’évolution des prénoms donnés en France entre 1900 et aujourd’hui.\nCe schéma ne comporte qu’une seule table."
  },
  {
    "objectID": "schemas/schema-babynames.html#table-babynames.bebes",
    "href": "schemas/schema-babynames.html#table-babynames.bebes",
    "title": "Schéma : babynames",
    "section": "Table : babynames.bebes",
    "text": "Table : babynames.bebes\n\nsex (entier)\nDescription : Représente le sexe des bébés. Valeurs :\n\n1 pour Homme\n2 pour Femme\n\n\n\nname (varchar(500))\nDescription : Le prénom des bébés nés en France. Type : Chaîne de caractères variable d’une longueur maximale de 500 caractères.\n\n\nyear (nombre entier) :\nDescription : L’année de naissance des bébés ayant reçu un certain prénom. Type : Entier\n\n\ncount (nombre entier) :\nDescription : Nombre de bébés d’un sexe donné, portant un nom particulier, nés au cours d’une année donnée."
  },
  {
    "objectID": "schemas/schema-babynames.html#exemple-de-données",
    "href": "schemas/schema-babynames.html#exemple-de-données",
    "title": "Schéma : babynames",
    "section": "Exemple de données",
    "text": "Exemple de données\n+---+------+-----+-----+\n|sex| name | year|count|\n+---+------+-----+-----+\n| 1 |Liam  | 2020| 350 |\n| 2 |Emma  | 2020| 420 |\n| 1 |Noah  | 2019| 340 |\n| 2 |Olivia| 2019| 390 |"
  },
  {
    "objectID": "schemas/schema-babynames.html#usages",
    "href": "schemas/schema-babynames.html#usages",
    "title": "Schéma : babynames",
    "section": "Usages",
    "text": "Usages\nCet ensemble de données peut être utilisé pour\n\nAnalyser les tendances de popularité : Déterminer les prénoms les plus populaires pour les garçons et les filles au fil du temps.\nSuivre l’évolution des tendances en matière de noms : Comprendre comment certains prénoms gagnent ou perdent en popularité au fil des années.\nAnalyse fondée sur le sexe : Comparer la façon dont certains noms sont spécifiques à un sexe ou partagés par les hommes et les femmes.\nRecherche historique : Explorer les tendances culturelles ou sociétales qui se reflètent dans les conventions de dénomination des bébés."
  },
  {
    "objectID": "schemas/schema-babynames.html#synthèse",
    "href": "schemas/schema-babynames.html#synthèse",
    "title": "Schéma : babynames",
    "section": "Synthèse",
    "text": "Synthèse\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑\nsex\ninteger\n\n\n* 🔑\nname\nvarchar(500)\n\n\n* 🔑\nyear\ninteger\n\n\n\ncount\ninteger"
  },
  {
    "objectID": "workshops/td8.html#exercice-supermarché",
    "href": "workshops/td8.html#exercice-supermarché",
    "title": "TD 8 : Modélisation",
    "section": "Exercice (Supermarché)",
    "text": "Exercice (Supermarché)\n\n\n\n\n\n\nQuestion\n\n\n\nProduire un schéma E/R qui décrit des informations concernant les produits d’un supermarché.\n\n\nChaque produit a un nom et un prix et appartient à une catégorie.\nLe supermarché a plusieurs rayons, un rayon étant caractérisé par un étage et un numéro de rangée. On veut maintenir l’emplacement des produits dans les rayons. Les produits d’une même catégorie sont placés dans le même rayon, mais un rayon peut contenir des produits de plusieurs catégories.\n\n\n\n\n\n\nQuestion\n\n\n\nTraduire le schéma EA dans le formalisme des pattes de corbeau\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nDéfinir le schéma relationnel correspondant en SQL"
  },
  {
    "objectID": "workshops/td8.html#exercice-location-de-voitures",
    "href": "workshops/td8.html#exercice-location-de-voitures",
    "title": "TD 8 : Modélisation",
    "section": "Exercice (Location de voitures)",
    "text": "Exercice (Location de voitures)\n\n\n\n\n\n\nQuestion\n\n\n\nProduire un schéma E/R qui décrit des informations concernant des voitures à louer.\n\n\nChaque voiture a une plaque d’immatriculation, une couleur et une marque. Le prix de la location dépend de la catégorie, où chaque catégorie est identifiée par un nom.\n\n\n\n\n\n\nQuestion\n\n\n\nModifier ensuite le schéma pour représenter les modèles de voitures.\n\n\nUn modèle a un nom, une marque et un nombre de sièges.\nToutes les voitures du même modèle doivent appartenir à la même catégorie de prix.\n\n\n\n\n\n\nQuestion\n\n\n\nDe plus, on veut distinguer les voitures disponibles des voitures en location. Pour les voitures disponibles on représente l’emplacement. Pour les voitures en location on représente la date et la durée de la location, ainsi que le nom du client.\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nTraduire le schéma EA dans le formalisme des pattes de corbeau\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nDéfinir le schéma relationnel correspondant en SQL"
  },
  {
    "objectID": "workshops/td8.html#exercice-gestion-du-personnel-dune-entreprise",
    "href": "workshops/td8.html#exercice-gestion-du-personnel-dune-entreprise",
    "title": "TD 8 : Modélisation",
    "section": "Exercice (Gestion du personnel d’une entreprise)",
    "text": "Exercice (Gestion du personnel d’une entreprise)\nDans une entreprise, chaque employé (identifié par un numéro) est attaché à un département de l’entreprise. Il occupe un bureau et participe à un ou plusieurs projets développés par l’entreprise.\nDe chaque employé, on connait : le nom, le prénom, les emplois qu’il a occupés à différentes dates et les salaires qu’il a perçus dans ces emplois.\nChaque département est identifié par un numéro, a son budget propre et est dirigé par un directeur faisant partie du personnel de l’entreprise.\nChaque bureau est identifié par un numéro, est rattaché à un département et est caractérisé par sa surface en mètres carrés. Il possède un numéro de téléphone associé.\nChaque projet est identifié par un numéro, possède un certain budget et emploie plusieurs personnes appartenant à différents départements. Chaque employé est affecté pour un certain nombre d’heures à un projet.\n\n\n\n\n\n\nQuestion\n\n\n\nDonner un modèle entité-association correspondant à la description ci-dessus.\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nModifier votre modélisation pour tenir compte de l’évolution dans le temps de la vie de l’entreprise : les projets ont des durées de vie limitées, chaque employé est affecté à un projet (mais aussi un département) pendant une certaines durée, etc\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nTraduire le schéma EA dans le formalisme des pattes de corbeau\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nDéfinir le schéma relationnel correspondant en SQL"
  },
  {
    "objectID": "workshops/td3.html",
    "href": "workshops/td3.html",
    "title": "TD 3: SQL",
    "section": "",
    "text": "Objectifs de la séance:\nEn plus du schéma world, nous allons utiliser le schéma pagila qui contient des informations utilisées par un chaîne fictive de magasins de location de DVD.\nLe schéma pagila est visible ici.\nSous psql ou pgli, vous pouvez aussi inspecter les tables comme d’habitude avec"
  },
  {
    "objectID": "workshops/td3.html#requêtes-imbriquées",
    "href": "workshops/td3.html#requêtes-imbriquées",
    "title": "TD 3: SQL",
    "section": "Requêtes imbriquées",
    "text": "Requêtes imbriquées\nLes requêtes imbriquées permettent d’utiliser le résultat d’une requête dans la clause WHERE.\nOn utilisera essentiellement les opérateurs suivants: IN, EXISTS, ALL, ANY.\nIN permet de tester la présence d’une valeur dans le résultat d’une requête.\nEXISTS renvoie True si la requête donnée est non-vide et False sinon. On peut les combiner avec NOT pour inverser leur comportement: NOT IN et NOT EXISTS. Par exemple, pour connaître les régions sans monarchie, on pourra écrire:\nSELECT DISTINCT region \nFROM world.country\nWHERE region NOT IN (\n  SELECT region\n  FROM world.country\n  WHERE governmentform like '%Monarchy%'\n);\nPour connaître les régions qui ont au moins une langue officielle, on pourra écrire:\nSELECT DISTINCT region \nFROM world.country AS co\nWHERE EXISTS (\n  SELECT *\n  FROM world.countrylanguage AS cl\n  WHERE co.countrycode = cl.countrycode AND \n    cl.isofficial\n);\nRemarquez que dans ce dernier exemple, la sous-requête fait intervenir des attributs de la requête principale, c’est pourquoi on parle de requêtes imbriquées.\nANY et ALL sont deux autres opérateurs. Par exemple\nSELECT * \nFROM table \nWHERE col &lt; ALL(\n  requete\n)\nsélectionnera les lignes de table telles que la valeur de col est plus petite que toutes les valeurs retournées par la requête requete. Ainsi, la requête\nSELECT * \nFROM world.country\nWHERE population_country &gt;= ALL(\n  SELECT population_country \n  FROM world.country\n);\nretournera la liste des pays les plus peuplés.\nSELECT * \nFROM table \nWHERE col &lt; ANY(\n  requete\n)\nsélectionnera les lignes de table telles que la valeur de col est strictement plus petite qu’au moins une des valeurs retournées par la requête requete.\nPour connaître les régions où l’on ne trouve qu’une seule forme de gouvernement, on pourra écrire:\nSELECT DISTINCT region \nFROM world.country as c1\nWHERE c1.governmentform = ALL(\n  SELECT c2.governmentform \n  FROM world.country as c2\n  WHERE c2.countrycode!=c1.countrycode AND \n    c2.region=c1.region\n);\n\n\n\n\n\n\nOn remarque que dans EXISTS ou IN on peut utiliser des attributs de notre requête globale, ce qui les rend plus puissants que\nWITH ... AS (\n  ...\n)"
  },
  {
    "objectID": "workshops/td3.html#jointure-externe",
    "href": "workshops/td3.html#jointure-externe",
    "title": "TD 3: SQL",
    "section": "Jointure externe",
    "text": "Jointure externe\nLa jointure externe est une jointure un peu particulière. On a vu la semaine dernière que lorsqu’on faisait une jointure, les lignes de la table de droit étaient recollées aux lignes de la table de gauche. Si une ligne a gauche ne pouvaient pas être recollée, elle disparaissait de la jointure. La jointure extérieure permet de garder ces lignes-là malgré tout.\nOn utilisera LEFT JOIN et RIGHT JOIN. Par exemple, la requête suivante renvoie la liste des pays et leur langages. Les pays qui ne se trouvent pas dans la table countrylanguage (il y en a, l’Antarctique par exemple) seront listés quand même et les informations manquantes seront remplies avec des valeurs NULL.\nSELECT * \nFROM world.country AS p LEFT JOIN \n  world.countrylanguage AS l ON \n  p.countrycode = l.countrycode;\nOn peut utiliser cette requête pour trouver les pays qui n’ont pas de langue officielle par exemple:\nSELECT * \nFROM world.country as p LEFT JOIN \n  world.countrylanguage AS l ON \n  p.countrycode = l.countrycode AND l.isofficial\nWHERE l.countrycode IS NULL;"
  },
  {
    "objectID": "workshops/td3.html#requêtes",
    "href": "workshops/td3.html#requêtes",
    "title": "TD 3: SQL",
    "section": "Requêtes",
    "text": "Requêtes\n\nQuels sont les langues qui ne sont officielles dans aucun pays ? (355 lignes)\n\nÉcrivez une version avec EXCEPT, une avec NOT IN et une autre avec LEFT JOIN.\n\nQuelles sont les régions où au moins deux pays ont la même forme de gouvernement ? (21 lignes)\n\n\nQuels sont les films qui n’ont jamais été loués ? (42 lignes)\n\n\n\n\n\n\n\nEn calcul relationnel\n\\[\\begin{align*}\n\\Big\\{ f.\\texttt{title} : & \\texttt{film}(f) \\wedge \\\\\n& \\neg \\big( \\exists t, t_1  \\quad \\texttt{inventory}(t)  \\wedge  \\exists t_1  \\quad \\texttt{rental}(t_1)  \\wedge\\\\\n&\\phantom{\\neg\\big(} f.\\texttt{film\\_id}=t.\\texttt{film\\_id}\\wedge t.\\texttt{inventory\\_id}=t_1.\\texttt{inventory\\_id}\\big)\\Big\\}\n\\end{align*}\\]\n\n\n\n\n\n\n\n\n\nCette question est exactement du même type que la précédente. On y répond de la même manière : pour trouver 1 les objets d’un certain type qui ne possèdent pas une propriété, on cherche dans la base tous les objets de ce type et on fait la différence avec l’ensemble des objets de ce type qui possèdent la propriété dans la base.\n\n\n\n\nQuels sont les acteurs qui ont joué dans toutes les catégories de film ? (11 lignes)\n\n\n\n\n\n\n\nCette requête réalise une opération sophistiquée de l’algèbre relationnelle la division ou \\(\\div\\). Il ne s’agit pas d’une opération primitive comme \\(\\sigma,\\pi, \\times\\).\n\\[\\pi_{\\texttt{actor\\_id},\\texttt{category\\_id}} \\left(\\texttt{film\\_actor} \\bowtie \\texttt{film\\_category}\\right)  \\div \\pi_{\\texttt{category}} (\\texttt{film\\_category})\\]\n\n\n\n\nExiste-t-il des acteurs qui ne jouent avec aucun autre acteur ? (0 ligne)\n\n\nNom, prénom des clients installés dans des villes sans magasin ? (599 lignes)\n\n\nLister les pays pour lesquels toutes les villes ont au moins un magasin. (1 ligne)\n\n\nDéterminer la liste des films disponibles dans toutes les langues.\n\nUn même dvd (inventory_id) peut bien sûr être loué plusieurs fois, mais pas simultanément. Proposer une requête qui vérifie que les dates de location d’un dvd donné sont compatibles."
  },
  {
    "objectID": "workshops/td3.html#vues",
    "href": "workshops/td3.html#vues",
    "title": "TD 3: SQL",
    "section": "Vues",
    "text": "Vues\nLes vues permettent de donner un nom à une requête afin de pouvoir l’appeler plus tard sans la réécrire à chaque fois. Une vue s’enregistre dans un schéma. Par exemple, dans le schéma World, on pourrait créer une vue VillesRepublic qui contient toutes les villes de la table city qui sont dans une république.\nOn crée une vue avec CREATE VIEW nom AS requete. Étant donné que vous ne pouvez écrire que dans votre schéma personnel, il faudra nommer vos vues entid.nom où entid est votre identifiant ENT. Ainsi\nCREATE VIEW entid.VillesRepublic AS\n  SELECT \n    B.* \n  FROM \n      world.country as A \n  NATURAL JOIN \n      world.city as B\n  WHERE \n      A.governmentform like '%Republic%';\ncrée une vue dans votre schéma personnel. Désormais, si on veut sélectionner les villes qui sont dans une république et dont la population est supérieure à \\(1000000\\), on pourra simplement écrire :\nSELECT * \nFROM \n    entid.VillesRepublic \nWHERE \n    population_city&gt;=1000000;\n\n\n\n\n\n\nRemarquez la différence entre WITH et une vue. WITH nomme une requête temporairement, seulement à l’échelle de la requête courante tandis qu’une vue est enregistrée de façon permanente. Cependant, chaque fois que vous appelez votre vue, elle est réévaluée par le système de base de données.\n\n\n\nNotez aussi que SQL n’est pas sensible à la casse. La vue entid.VillesRepublic peut être aussi désignée par entid.villesrepublic.\nPour supprimer une vue existante on utilise la commande DROP VIEW suivie du nom de la vue à supprimer. Par exemple l’instruction\nDROP VIEW entid.VillesRepublic ;\nsupprime la vue créée précédemment.\nDans votre schéma personnel (qui porte le nom de votre identifiant ENT), écrire une vue film_id_horror qui renvoie la liste des films de catégorie ‘Horror’."
  },
  {
    "objectID": "workshops/td3.html#fonctions-sql",
    "href": "workshops/td3.html#fonctions-sql",
    "title": "TD 3: SQL",
    "section": "Fonctions SQL",
    "text": "Fonctions SQL\nDans votre schéma personnel (qui porte le nom de votre identifiant ENT), écrire une fonction SQL film_id_cat qui prend en paramètre une chaîne de caractère s et renvoie la liste des films de catégorie s. On rappelle la syntaxe :\nCREATE OR REPLACE FUNCTION entid.film_id_cat(s TEXT)\nRETURNS TABLE(film_id INTEGER)\nLANGUAGE 'sql' AS\n$$\nrequete\n$$\net l’usage\nCREATE OR REPLACE FUNCTION \n  entid.film_id_cat(s text)\nRETURNS TABLE(film_id smallint) AS \n$$\n    SELECT fc.film_id \n    FROM \n        pagila.film_category fc\n  JOIN \n        pagila.category ca\n  ON (fc.category_id=ca.category_id)\n    WHERE \n    ca.name=s ;\n$$ LANGUAGE sql ;\nUtilisez votre fonction pour écrire les requêtes suivantes:\nQuels sont les acteurs qui ont déjà joué dans un film d’horreur (catégorie ‘Horror’) ?\nQuels sont les acteurs qui n’ont jamais joué dans une comédie (Comedy) ? (53 lignes)\n\n\n\n\n\n\n Attention ! Cette requête ne répond pas à la question :\n\n\n\nSELECT DISTINCT ac.*\nFROM pagila.actor ac NATURAL JOIN\n     (SELECT * FROM pagila.film_actor\n      WHERE film_id NOT IN\n        (SELECT * FROM pagila.film_id_cat('Comedy') )\n      ) as X;\nElle répond à la question : Quels sont les acteurs qui ont joué dans un film qui n’est pas une comédie ?\n\n\n\n\n\n\n\n\nEn calcul relationnel, en considérant film_id_cat('Comedy') comme une relation (ce qui est cohérent avec la définition de la fonction) cette requête s’exprime\n\\[\\begin{align*}\n  \\left\\{ a.\\texttt{last\\_name,}  \\right. & a.\\texttt{first\\_name}\n  :\n  \\texttt{actor}(a) \\wedge \\\\\n  & \\neg\n  \\left(\\exists \\mathrm{fa}\\quad \\texttt{film\\_actor}(\\mathrm{fa}) \\right.  \\wedge  \\mathrm{fa}.\\texttt{actor\\_id}=a.\\texttt{actor\\_id}  \\\\\n& \\left. \\left.   \\wedge \\texttt{film\\_id\\_cat}(\\mathrm{'Comedy'})(\\mathrm{fa}.\\texttt{film\\_id}) \\right) \\right\\}\n\\end{align*}\\]\nLe calcul relationnel traduit presque littéralement la démarche que nous suivons lorsqu’il faut construire le résultat à la main : pour trouver les actor_id des acteurs qui n’ont jamais joué dans une comédie, nous examinons toutes les valeurs \\(a\\) de actor_id présentes dans la table actor (ou film_actor), et pour chacune de ces valeurs, nous verifions qu’il n’existe pas de tuple de la table film_actor où l’attribut actor_id soit égal à \\(a\\) et où l’attribut film_id désigne un film qui apparaît dans le résultat de film_id_cat('Comedy').\nNous décrivons/explicitons ainsi les propriétés du résultat de la requête Quels sont les acteurs qui n’ont jamais joué dans une comédie (‘Comedy’) ?.\nSi maintenant nous cherchons à 1 ce résultat, nous pouvons d’abord calculer la liste des actor_id des acteurs qui ont joué dans une comédie, calculer la liste de tous les actor_id connus dans le schema et faire la différence, en algèbre relationnelle, cela se résume à\n\\[\\pi_{\\texttt{actor\\_id}}\\left(\\texttt{film\\_actor}\\right) \\setminus \\pi_{\\texttt{actor\\_id}} \\left( \\texttt{film\\_actor} \\bowtie\\texttt{film\\_id\\_cat}(\\texttt{'Comedy'}) \\right)\\]\n\n\n\nQuels sont les acteurs qui ont joué dans un film d’horreur (‘Horror’) et dans un film pour enfant (‘Children’)? (130 lignes)\n\n\n\n\n\n\nIci l’erreur la plus fréquente consiste à écrire\nSELECT \n  actor_id \nFROM \n  pagila.film_actor AS fa\nWHERE \n  fa.film_id IN (\n    SELECT * \n    FROM entid.film_id_cat('Children')\n  ) AND \n  fa.film_id IN (\n    SELECT * \n    FROM entid.film_id_cat('Horror')\n  );\nLe résultat est vide et la requête ne correspond pas à la question posée.\nElle calcule les actor_id des acteurs qui ont dans au moins un film qui relève simultanément des catégories Horror et Children (ce genre de film est assez rare).\nPour calculer un résultat correct, il faut pour chaque valeur \\(a\\) de actor_id rechercher deux tuples (pas nécessairement distincts) de film_actor où l’attribut actor_id vaut \\(a\\) et ou dans un cas film_id désigne un film pour enfants et dans l’autre un film d’horreur. En calcul relationnel, cela donne\n\\[\\begin{align*}\n  \\left\\{ a.\\texttt{last\\_name,}  \\right. & a.\\texttt{first\\_name}\n  :\n  \\texttt{actor}(a) \\wedge \\\\\n  &\n  \\left(\\exists \\mathrm{fa}\\quad \\texttt{film\\_actor}(\\mathrm{fa}) \\right.  \\wedge  \\mathrm{fa}.\\texttt{actor\\_id}=a.\\texttt{actor\\_id}  \\\\\n& \\left.   \\wedge \\texttt{film\\_id\\_cat}(\\mathrm{'Children'})(\\mathrm{fa}.\\texttt{film\\_id}) \\right) \\\\\n&  \\left(\\exists \\mathrm{fa}\\quad \\texttt{film\\_actor}(\\mathrm{fa}) \\right.  \\wedge  \\mathrm{fa}.\\texttt{actor\\_id}=a.\\texttt{actor\\_id}  \\\\\n& \\left. \\left.   \\wedge \\texttt{film\\_id\\_cat}(\\mathrm{'Horror'})(\\mathrm{fa}.\\texttt{film\\_id}) \\right)\\right\\}\n\\end{align*}\\]\nEn algèbre relationnelle\n\\[\\begin{align*}\n\\pi_{\\texttt{last\\_name,}\\texttt{first\\_name}} \\bigg( &  \\texttt{actor} \\bowtie  \\\\\n     & \\Big(\\pi_{\\texttt{actor\\_id}} \\left( \\texttt{film\\_actor} \\bowtie\n                                 \\texttt{film\\_id\\_cat}(\\texttt{'Children'}) \\right) \\bigcap\\\\\n     & \\; \\pi_{\\texttt{actor\\_id}} \\left( \\texttt{film\\_actor} \\bowtie\n                                 \\texttt{film\\_id\\_cat}(\\texttt{'Horror'}) \\right) \\Big)\n                                 \\bigg)\n\\end{align*}\\]"
  },
  {
    "objectID": "weeks/week-9.html",
    "href": "weeks/week-9.html",
    "title": "Semaine 9",
    "section": "",
    "text": "Important\n\n\n\n\nCours magistral en Amphi 2 Olympe de Gouges 14h-15h30\n TD/TP 2004-2005-2006 Étage 2 Sophie Germain 15h45-16h45\n  Contrôle continu II 17h-18h15 Amphi A2 Halle aux Farines\n Emploi du temps\n Emploi du temps",
    "crumbs": [
      "Journal",
      "Semaine 9"
    ]
  },
  {
    "objectID": "weeks/week-9.html#préparer",
    "href": "weeks/week-9.html#préparer",
    "title": "Semaine 9",
    "section": "Préparer",
    "text": "Préparer\nTD 6 TD 6",
    "crumbs": [
      "Journal",
      "Semaine 9"
    ]
  },
  {
    "objectID": "weeks/week-9.html#cours-magistral-diapositives",
    "href": "weeks/week-9.html#cours-magistral-diapositives",
    "title": "Semaine 9",
    "section": "Cours magistral : diapositives",
    "text": "Cours magistral : diapositives\nModélisation I (entité-association)\nModélisation II (pattes de corbeau)",
    "crumbs": [
      "Journal",
      "Semaine 9"
    ]
  },
  {
    "objectID": "weeks/week-9.html#exercices-td-8",
    "href": "weeks/week-9.html#exercices-td-8",
    "title": "Semaine 9",
    "section": "Exercices : TD 8",
    "text": "Exercices : TD 8\nhtml pdf",
    "crumbs": [
      "Journal",
      "Semaine 9"
    ]
  },
  {
    "objectID": "weeks/week-9.html#solutions-du-td-6",
    "href": "weeks/week-9.html#solutions-du-td-6",
    "title": "Semaine 9",
    "section": "Solutions du TD 6",
    "text": "Solutions du TD 6\nhtml pdf",
    "crumbs": [
      "Journal",
      "Semaine 9"
    ]
  },
  {
    "objectID": "weeks/week-9.html#travail-personnel",
    "href": "weeks/week-9.html#travail-personnel",
    "title": "Semaine 9",
    "section": "Travail personnel",
    "text": "Travail personnel\nExercice de modélisation dans CC3 du 8 décembre 2023\nExercice de modélisation dans CT de janvier 2024\n\n\nretour à Agenda ⏎",
    "crumbs": [
      "Journal",
      "Semaine 9"
    ]
  },
  {
    "objectID": "weeks/week-7.html",
    "href": "weeks/week-7.html",
    "title": "Semaine 7",
    "section": "",
    "text": "Important\n\n\n\n\nCours magistral en Amphi. 2 Olympe de Gouges 14h-15h30  \n TD/TP salles 2004-2005-2006 Étage 2 Sophie Germain Vendredi 15h45-16h45\n Contrôle continu I 17h-18h15 Amphi A2 Halle aux Farines\n Emploi du temps MIASHS\n Emploi du temps Ingémaths/METIS",
    "crumbs": [
      "Journal",
      "Semaine 7"
    ]
  },
  {
    "objectID": "weeks/week-7.html#préparer",
    "href": "weeks/week-7.html#préparer",
    "title": "Semaine 7",
    "section": "Préparer",
    "text": "Préparer\nFinir requêtes du TD 4",
    "crumbs": [
      "Journal",
      "Semaine 7"
    ]
  },
  {
    "objectID": "weeks/week-7.html#cours-magistral-diapositives",
    "href": "weeks/week-7.html#cours-magistral-diapositives",
    "title": "Semaine 7",
    "section": "Cours magistral : diapositives",
    "text": "Cours magistral : diapositives\nDéfinition de données\nContraintes I\nRetour sur le schema world",
    "crumbs": [
      "Journal",
      "Semaine 7"
    ]
  },
  {
    "objectID": "weeks/week-7.html#exercices-td-5",
    "href": "weeks/week-7.html#exercices-td-5",
    "title": "Semaine 7",
    "section": "Exercices : TD 5",
    "text": "Exercices : TD 5\nhtml pdf\n Construisez des vues à partir de vos requêtes",
    "crumbs": [
      "Journal",
      "Semaine 7"
    ]
  },
  {
    "objectID": "weeks/week-7.html#solutions-du-td-4-semaine-6",
    "href": "weeks/week-7.html#solutions-du-td-4-semaine-6",
    "title": "Semaine 7",
    "section": "Solutions du TD 4 (Semaine 6)",
    "text": "Solutions du TD 4 (Semaine 6)\nhtml pdf",
    "crumbs": [
      "Journal",
      "Semaine 7"
    ]
  },
  {
    "objectID": "weeks/week-7.html#contrôle-continu-i",
    "href": "weeks/week-7.html#contrôle-continu-i",
    "title": "Semaine 7",
    "section": " Contrôle continu I",
    "text": "Contrôle continu I\n\n17h-18h15 Amphi A2 Halle aux Farines\nRequêtes sur le schéma pagila (partie verte)",
    "crumbs": [
      "Journal",
      "Semaine 7"
    ]
  },
  {
    "objectID": "weeks/week-7.html#travail-personnel",
    "href": "weeks/week-7.html#travail-personnel",
    "title": "Semaine 7",
    "section": "Travail personnel",
    "text": "Travail personnel\nCC 1 2023-24\n\n\nretour à Agenda ⏎",
    "crumbs": [
      "Journal",
      "Semaine 7"
    ]
  },
  {
    "objectID": "weeks/week-5.html",
    "href": "weeks/week-5.html",
    "title": "Semaine 5",
    "section": "",
    "text": "Important\n\n\n\n\nCours magistral en Amphi 2 Olympe de Gouges 14h-15h30\nTD/TP Ingémaths/METIS salle 2006 Etage 2 Sophie Germain Jeudi 13h30-16h00\nTD/TP MIASHS salles 2004-2005-2006 Étage 2 Sophie Germain Vendredi 15h45-18h15\n Emploi du temps MIASHS\n Emploi du temps Ingémaths/METIS",
    "crumbs": [
      "Journal",
      "Semaine 5"
    ]
  },
  {
    "objectID": "weeks/week-5.html#préparer",
    "href": "weeks/week-5.html#préparer",
    "title": "Semaine 5",
    "section": "Préparer",
    "text": "Préparer\nFinir requêtes du TD 2",
    "crumbs": [
      "Journal",
      "Semaine 5"
    ]
  },
  {
    "objectID": "weeks/week-5.html#cours-magistral-diapositives",
    "href": "weeks/week-5.html#cours-magistral-diapositives",
    "title": "Semaine 5",
    "section": "Cours magistral : diapositives",
    "text": "Cours magistral : diapositives\nSQL Définition de données\nModélisation des contraintes",
    "crumbs": [
      "Journal",
      "Semaine 5"
    ]
  },
  {
    "objectID": "weeks/week-5.html#exercices-td-3",
    "href": "weeks/week-5.html#exercices-td-3",
    "title": "Semaine 5",
    "section": "Exercices : TD 3",
    "text": "Exercices : TD 3\nhtml pdf\n Construisez des vues à partir de vos requêtes",
    "crumbs": [
      "Journal",
      "Semaine 5"
    ]
  },
  {
    "objectID": "weeks/week-5.html#solutions-du-td-2-semaine-4",
    "href": "weeks/week-5.html#solutions-du-td-2-semaine-4",
    "title": "Semaine 5",
    "section": "Solutions du TD 2 (Semaine 4)",
    "text": "Solutions du TD 2 (Semaine 4)\nhtml pdf",
    "crumbs": [
      "Journal",
      "Semaine 5"
    ]
  },
  {
    "objectID": "weeks/week-5.html#travail-personnel",
    "href": "weeks/week-5.html#travail-personnel",
    "title": "Semaine 5",
    "section": "Travail personnel",
    "text": "Travail personnel\nCC 1 2023-24\n\n\nretour à Agenda ⏎",
    "crumbs": [
      "Journal",
      "Semaine 5"
    ]
  },
  {
    "objectID": "weeks/week-3.html",
    "href": "weeks/week-3.html",
    "title": "Semaine 3",
    "section": "",
    "text": "Important\n\n\n\n\nCours magistral en Amphi 2 Olympe de Gouges Vendredi 14h-15h30\nTD/TP Ingémaths/METIS salle 2006 Etage 2 Sophie Germain Jeudi 13h30-16h00\nTD/TP MIASHS salles 2004-2005-2006 Étage 2 Sophie Germain Vendredi 15h45-18h15\n Emploi du temps MIASHS\n Emploi du temps Ingémaths/METIS\nsi ce n’est pas déjà fait suivre la procéure indiquée sur moodle pour disposer d’un compte sur les machines de Sophie Germain",
    "crumbs": [
      "Journal",
      "Semaine 3"
    ]
  },
  {
    "objectID": "weeks/week-3.html#cours-magistral-diapositives",
    "href": "weeks/week-3.html#cours-magistral-diapositives",
    "title": "Semaine 3",
    "section": "Cours magistral : diapositives",
    "text": "Cours magistral : diapositives\n\n Introduction à l’algèbre relationnelle\n\n SQL requêtes élémentaires\n\nSQL requêtes imbriqués  sauf lateral",
    "crumbs": [
      "Journal",
      "Semaine 3"
    ]
  },
  {
    "objectID": "weeks/week-3.html#exercices-terminer-td-1-et-commencer-td-2",
    "href": "weeks/week-3.html#exercices-terminer-td-1-et-commencer-td-2",
    "title": "Semaine 3",
    "section": "Exercices : Terminer TD 1 et commencer TD 2",
    "text": "Exercices : Terminer TD 1 et commencer TD 2\n\nEnoncés : html pdf\nSchéma world\nSolutions :html pdf",
    "crumbs": [
      "Journal",
      "Semaine 3"
    ]
  },
  {
    "objectID": "weeks/week-3.html#solutions-du-td-1-semaine-2",
    "href": "weeks/week-3.html#solutions-du-td-1-semaine-2",
    "title": "Semaine 3",
    "section": "Solutions du TD 1 (Semaine 2)",
    "text": "Solutions du TD 1 (Semaine 2)\nhtml pdf",
    "crumbs": [
      "Journal",
      "Semaine 3"
    ]
  },
  {
    "objectID": "weeks/week-3.html#travail-personnel-optionnel",
    "href": "weeks/week-3.html#travail-personnel-optionnel",
    "title": "Semaine 3",
    "section": "Travail personnel optionnel ",
    "text": "Travail personnel optionnel \nCC 1 2023-24\n\n\nretour à Agenda ⏎",
    "crumbs": [
      "Journal",
      "Semaine 3"
    ]
  },
  {
    "objectID": "weeks/week-13.html",
    "href": "weeks/week-13.html",
    "title": "Semaine 13",
    "section": "",
    "text": "Important\n\n\n\n\nTD/TP 2004-2005-2006 Étage 2 Sophie Germain 15h45-16h45\n   Contrôle continu III 17h-18h15 Amphi A2 Halle aux Farines\n Emploi du temps MIASHS\n Emploi du temps Ingémaths/METIS",
    "crumbs": [
      "Journal",
      "Semaine 13"
    ]
  },
  {
    "objectID": "weeks/week-13.html#préparer",
    "href": "weeks/week-13.html#préparer",
    "title": "Semaine 13",
    "section": "Préparer",
    "text": "Préparer\nFinir TD 11 TD 11",
    "crumbs": [
      "Journal",
      "Semaine 13"
    ]
  },
  {
    "objectID": "weeks/week-13.html#exercices-td-12",
    "href": "weeks/week-13.html#exercices-td-12",
    "title": "Semaine 13",
    "section": "Exercices : TD 12",
    "text": "Exercices : TD 12\nhtml pdf",
    "crumbs": [
      "Journal",
      "Semaine 13"
    ]
  },
  {
    "objectID": "weeks/week-13.html#solutions-du-td-11-semaine-12",
    "href": "weeks/week-13.html#solutions-du-td-11-semaine-12",
    "title": "Semaine 13",
    "section": "Solutions du TD 11 (Semaine 12)",
    "text": "Solutions du TD 11 (Semaine 12)\nhtml pdf",
    "crumbs": [
      "Journal",
      "Semaine 13"
    ]
  },
  {
    "objectID": "weeks/week-13.html#travail-personnel",
    "href": "weeks/week-13.html#travail-personnel",
    "title": "Semaine 13",
    "section": "Travail personnel",
    "text": "Travail personnel\nCC 1 2023-24\n\n\nretour à Agenda ⏎",
    "crumbs": [
      "Journal",
      "Semaine 13"
    ]
  },
  {
    "objectID": "weeks/week-11.html",
    "href": "weeks/week-11.html",
    "title": "Semaine 11",
    "section": "",
    "text": "Important\n\n\n\n\nCours magistral en Amphi 2 Olympe de Gouges 14h-15h30\nTD/TP Ingémaths/METIS salle 2006 Etage 2 Sophie Germain Jeudi 13h30-16h00\nTD/TP MIASHS salles 2004-2005-2006 Étage 2 Sophie Germain Vendredi 15h45-18h15\n Emploi du temps MIASHS\n Emploi du temps Ingémaths/METIS",
    "crumbs": [
      "Journal",
      "Semaine 11"
    ]
  },
  {
    "objectID": "weeks/week-11.html#préparer",
    "href": "weeks/week-11.html#préparer",
    "title": "Semaine 11",
    "section": "Préparer",
    "text": "Préparer\nFinir TD 9 TD 9",
    "crumbs": [
      "Journal",
      "Semaine 11"
    ]
  },
  {
    "objectID": "weeks/week-11.html#cours-magistral-diapositives",
    "href": "weeks/week-11.html#cours-magistral-diapositives",
    "title": "Semaine 11",
    "section": "Cours magistral : diapositives",
    "text": "Cours magistral : diapositives\nNormalisation II",
    "crumbs": [
      "Journal",
      "Semaine 11"
    ]
  },
  {
    "objectID": "weeks/week-11.html#exercices-td-10",
    "href": "weeks/week-11.html#exercices-td-10",
    "title": "Semaine 11",
    "section": "Exercices : TD 10",
    "text": "Exercices : TD 10\nhtml pdf",
    "crumbs": [
      "Journal",
      "Semaine 11"
    ]
  },
  {
    "objectID": "weeks/week-11.html#solutions-du-td-9-semaine-10",
    "href": "weeks/week-11.html#solutions-du-td-9-semaine-10",
    "title": "Semaine 11",
    "section": "Solutions du TD 9 (Semaine 10)",
    "text": "Solutions du TD 9 (Semaine 10)\nhtml pdf",
    "crumbs": [
      "Journal",
      "Semaine 11"
    ]
  },
  {
    "objectID": "weeks/week-11.html#travail-personnel",
    "href": "weeks/week-11.html#travail-personnel",
    "title": "Semaine 11",
    "section": "Travail personnel",
    "text": "Travail personnel\nCC 1 2023-24\n\n\nretour à Agenda ⏎",
    "crumbs": [
      "Journal",
      "Semaine 11"
    ]
  },
  {
    "objectID": "weeks/week-1.html",
    "href": "weeks/week-1.html",
    "title": "Semaine 1",
    "section": "",
    "text": "Important\n\n\n\n\nCours magistral en Amphi 2 Olympe de Gouges\nVendredi 13 septembre 2024 de 14h à 15h30\n Emploi du temps",
    "crumbs": [
      "Journal",
      "Semaine 1"
    ]
  },
  {
    "objectID": "weeks/week-1.html#cours-magistral-diapositives",
    "href": "weeks/week-1.html#cours-magistral-diapositives",
    "title": "Semaine 1",
    "section": "Cours magistral : diapositives",
    "text": "Cours magistral : diapositives\nIntroduction aux Bases de Données\nIntroduction à l’algèbre relationnelle\n Nous sommes allés jusqu`à la sélection",
    "crumbs": [
      "Journal",
      "Semaine 1"
    ]
  },
  {
    "objectID": "weeks/week-1.html#exercices-td-1",
    "href": "weeks/week-1.html#exercices-td-1",
    "title": "Semaine 1",
    "section": "Exercices : TD 1",
    "text": "Exercices : TD 1\nVous pouvez commencer à aborder les questions de la première feuille de TD\nhtml pdf",
    "crumbs": [
      "Journal",
      "Semaine 1"
    ]
  },
  {
    "objectID": "weeks/week-1.html#logistique",
    "href": "weeks/week-1.html#logistique",
    "title": "Semaine 1",
    "section": "Logistique",
    "text": "Logistique\n Pensez à activer votre compte ENT (suivre les instructions sur Moodle). Vous en aurez besoin pour accéder au serveur PostGres utilisé en TP/TD à partir du 20 octobre.\nIl faut réaliser cette activation le plus tôt possible, idéalement avant le 17 septembre.\nSi vous le pouvez, installez sur votre machine un des clients décrits sur cette page.\n\n\nretour à Agenda ⏎",
    "crumbs": [
      "Journal",
      "Semaine 1"
    ]
  },
  {
    "objectID": "slides-listings.html",
    "href": "slides-listings.html",
    "title": "Diapositives",
    "section": "",
    "text": "Les diapositives fournissent le canevas du cours. Vous pouvez les utiliser pour vous familiariser avec le matériel du prochain cours, pour revoir les cours passés et, pour réviser.\nLes diapositives marquées par l’image  renvoient à des développements effectués en classes.\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Titre\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nDate\n\n\nTitre\n\n\nDescription\n\n\n\n\n\n\nSep 13, 2024\n\n\nBD I: Introduction aux SGBD\n\n\nBases de Données Licences MIASHS et Mathématiques\n\n\n\n\nSep 13, 2024\n\n\nBD I: Algèbre Relationnelle\n\n\nCadre formel pour la manipulation de tables\n\n\n\n\nSep 20, 2024\n\n\nBD II: SQL I\n\n\nLangage Manipulation de Données 1\n\n\n\n\nSep 27, 2024\n\n\nBD II: SQL II\n\n\nLangage Manipulation de Données 2 : requêtes imbriquées\n\n\n\n\nOct 4, 2024\n\n\nBD II: SQL LDD\n\n\nDéfinition de données\n\n\n\n\nOct 4, 2024\n\n\nBD IV: SQL III\n\n\nLangage Manipulation de Données 3 : Aggrégation/Fenêtres/Partitions\n\n\n\n\nOct 11, 2024\n\n\nBD : Contraintes\n\n\nDéfinition de données: Contraintes\n\n\n\n\nOct 18, 2024\n\n\nFonctions SQL et Vues\n\n\nFonctions SQL. Vues\n\n\n\n\nOct 25, 2024\n\n\nBD VII: Corriger le schéma World\n\n\nDéfinition de données: Contraintes/Ingénieurie\n\n\n\n\nNov 8, 2024\n\n\nModélisation I : Entité/Association\n\n\nModélisation Entité/Association (ER)\n\n\n\n\nNov 15, 2024\n\n\nModélisation II :\n\n\nTraduction des modèles ER: Pattes de corbeaux, Relationnel\n\n\n\n\nNov 22, 2024\n\n\nNormalisation I\n\n\nDépendances Fonctionnelles. Décomposition FNBC\n\n\n\n\nNov 29, 2024\n\n\nNormalisation II : Décomposition FN3\n\n\nPertes de Dépendances Fonctionnelles. Décomposition FN3\n\n\n\n\nJan 31, 2025\n\n\nBD : Fonctions et extension PlpgSQL de SQL\n\n\n \n\n\n\n\nMar 29, 2025\n\n\nBD : Transactions\n\n\n \n\n\n\n\nMar 31, 2025\n\n\nBD : dplyr une mise oeuvre de l’Algèbre Relationnelle\n\n\nBases de Données Licences MIASHS et Mathématiques\n\n\n\n\n \n\n\nBD V: Administration\n\n\n \n\n\n\n\n \n\n\nBD VII: Administration et Droits\n\n\n \n\n\n\n\n\nNo matching items\n\n\n\n\n\n\n\n\nMode d’emploi\n\n\n\nLes diapositives utilisent la bibliothèque revealjs de . Elles s’affichent dans votre navigateur. Vous pouvez accéder au mode d’emploi en tappant",
    "crumbs": [
      "Diapositives"
    ]
  },
  {
    "objectID": "schemas/schema-pagila-film.html",
    "href": "schemas/schema-pagila-film.html",
    "title": "Schéma : pagila (films)",
    "section": "",
    "text": "Présentation de la partie film du schéma pagila, pour l’entrainement à PostGres."
  },
  {
    "objectID": "schemas/schema-pagila-film.html#contexte",
    "href": "schemas/schema-pagila-film.html#contexte",
    "title": "Schéma : pagila (films)",
    "section": "Contexte",
    "text": "Contexte\nDescription de quelques tables from the pagila database, spécifiquement les tables liées au catalogue de filmss (sans considérer les tables liées au fichier client, à la gestion des locations, aux magasins).\nPagemaison de la base de données pagila.\nPagemaison de la base de données sakila"
  },
  {
    "objectID": "schemas/schema-pagila-film.html#table-pagila.actor",
    "href": "schemas/schema-pagila-film.html#table-pagila.actor",
    "title": "Schéma : pagila (films)",
    "section": "Table pagila.actor",
    "text": "Table pagila.actor\n\n\n\n\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\nactor_id\ninteger DEFAULT nextval(‘pagila.actor_actor_id_seq’::regclass)\n\n\n*\nfirst_name\nvarchar(45)\n\n\n* 🔎\nlast_name\nvarchar(45)\n\n\n*\nlast_update\ntimestamp DEFAULT now()\n\n\n\nactor_id sert de clé primaire. Noter le mécanisme de génération de nouvelles clés grâce au comportment par défaut et à l’usage de la fonction nextval() opérant sur une séquence associée à la table actor.\nLa colonne last_update sert à dater les mises à jour."
  },
  {
    "objectID": "schemas/schema-pagila-film.html#table-pagila.category",
    "href": "schemas/schema-pagila-film.html#table-pagila.category",
    "title": "Schéma : pagila (films)",
    "section": "Table pagila.category",
    "text": "Table pagila.category\n\n\n\n\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\ncategory_id\ninteger DEFAULT nextval(‘pagila.category_category_id_seq’::regclass)\n\n\n*\nname\nvarchar(25)\n\n\n*\nlast_update\ntimestamp DEFAULT now()"
  },
  {
    "objectID": "schemas/schema-pagila-film.html#table-pagila.film",
    "href": "schemas/schema-pagila-film.html#table-pagila.film",
    "title": "Schéma : pagila (films)",
    "section": "Table pagila.film",
    "text": "Table pagila.film\n\n\n\n\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\nfilm_id\ninteger DEFAULT nextval(‘pagila.film_film_id_seq’::regclass)\n\n\n* 🔎\ntitle\nvarchar(255)\n\n\n\ndescription\ntext\n\n\n\nrelease_year\nyear\n\n\n* 🔎 ⬈\nlanguage_id\nsmallint\n\n\n🔎 ⬈\noriginal_language_id\nsmallint\n\n\n*\nrental_duration\nsmallint DEFAULT 3\n\n\n*\nrental_rate\nnumeric(4,2) DEFAULT 4.99\n\n\n\nlength\nsmallint\n\n\n*\nreplacement_cost\nnumeric(5,2) DEFAULT 19.99\n\n\n\nrating\nmpaa_rating DEFAULT ‘G’::pagila.mpaa_rating\n\n\n*\nlast_update\ntimestamp DEFAULT now()\n\n\n\nspecial_features\ntext[]\n\n\n\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\n\nfilm_original_language_id_fkey\n( original_language_id ) ref pagila.language (language_id)\n\n\n\nfilm_language_id_fkey\n( language_id ) ref pagila.language (language_id)\n\n\n\nLes colonnes film_id (clé primaire), original_language_id et language_id sont utilisées pour réaliser des (équi)-jointures avec les tables film_actor, film_category, film_language\nUn film est censé n’avoir qu’une seule langue originale. L’association film a pour langue orginale la langue xxx est de un vers plusieurs. On peut la représenter à l’aide d’un attribut dans la table film."
  },
  {
    "objectID": "schemas/schema-pagila-film.html#table-pagila.film_actor",
    "href": "schemas/schema-pagila-film.html#table-pagila.film_actor",
    "title": "Schéma : pagila (films)",
    "section": "Table pagila.film_actor",
    "text": "Table pagila.film_actor\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬈\nactor_id\nsmallint\n\n\n* 🔑 ⬈\nfilm_id\nsmallint\n\n\n*\nlast_update\ntimestamp DEFAULT now()\n\n\n\nC’est une table intermédiaire qui permet de représenter/traduire l’association plusieurs à plusieurs acteur joue dans film.\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\n\nfilm_actor_film_id_fkey\n( film_id ) ref pagila.film (film_id)\n\n\n\nfilm_actor_actor_id_fkey\n( actor_id ) ref pagila.actor (actor_id)"
  },
  {
    "objectID": "schemas/schema-pagila-film.html#table-pagila.film_category",
    "href": "schemas/schema-pagila-film.html#table-pagila.film_category",
    "title": "Schéma : pagila (films)",
    "section": "Table pagila.film_category",
    "text": "Table pagila.film_category\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬈\nfilm_id\nsmallint\n\n\n* 🔑 ⬈\ncategory_id\nsmallint\n\n\n*\nlast_update\ntimestamp DEFAULT now()\n\n\n\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\n\nfilm_category_film_id_fkey\n( film_id ) ref pagila.film (film_id)\n\n\n\nfilm_category_category_id_fkey\n( category_id ) ref pagila.category (category_id)\n\n\n\nC’est une table intermédiaire qui permet de représenter/traduire l’association plusieurs à plusieurs film relève de catégorie."
  },
  {
    "objectID": "schemas/schema-pagila-film.html#table-pagila.language",
    "href": "schemas/schema-pagila-film.html#table-pagila.language",
    "title": "Schéma : pagila (films)",
    "section": "Table pagila.language",
    "text": "Table pagila.language\n\n\n\n\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\nlanguage_id\ninteger DEFAULT nextval(‘pagila.language_language_id_seq’::regclass)\n\n\n*\nname\nchar(20)\n\n\n*\nlast_update\ntimestamp DEFAULT now()"
  },
  {
    "objectID": "schemas/schema-nycflights.html",
    "href": "schemas/schema-nycflights.html",
    "title": "Schéma : nycflights",
    "section": "",
    "text": "Présentation du schéma nycflights, pour l’entrainement à PostGres.\nCe jeu de données est construit à partir du package  nycflights13."
  },
  {
    "objectID": "schemas/schema-nycflights.html#table-nycflights.airlines",
    "href": "schemas/schema-nycflights.html#table-nycflights.airlines",
    "title": "Schéma : nycflights",
    "section": "Table nycflights.airlines",
    "text": "Table nycflights.airlines\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\ncarrier\ntext\n\n\n🔍\nname\ntext"
  },
  {
    "objectID": "schemas/schema-nycflights.html#table-nycflights.airports",
    "href": "schemas/schema-nycflights.html#table-nycflights.airports",
    "title": "Schéma : nycflights",
    "section": "Table nycflights.airports",
    "text": "Table nycflights.airports\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\nfaa\ntext\n\n\n\nname\ntext\n\n\n🔍\nlat\ndouble precision\n\n\n🔍\nlon\ndouble precision\n\n\n\nalt\ndouble precision\n\n\n\ntz\ndouble precision\n\n\n\ndst\ntext\n\n\n\ntzone\ntext"
  },
  {
    "objectID": "schemas/schema-nycflights.html#table-nycflights.flights",
    "href": "schemas/schema-nycflights.html#table-nycflights.flights",
    "title": "Schéma : nycflights",
    "section": "Table nycflights.flights",
    "text": "Table nycflights.flights\n\n\n\nIdx\nName\nData Type\n\n\n\n\n🔍\nyear\ninteger\n\n\n🔍\nmonth\ninteger\n\n\n🔍\nday\ninteger\n\n\n\ndep_time\ninteger\n\n\n\nsched_dep_time\ninteger\n\n\n\ndep_delay\ndouble precision\n\n\n\narr_time\ninteger\n\n\n\nsched_arr_time\ninteger\n\n\n\narr_delay\ndouble precision\n\n\n⬈\ncarrier\ntext\n\n\n\nflight\ninteger\n\n\n🔍 ⬈\ntailnum\ntext\n\n\n* 🔍 ⬈\norigin\ntext\n\n\n🔍 ⬈\ndest\ntext\n\n\n\nair_time\ndouble precision\n\n\n\ndistance\ndouble precision\n\n\n🔍\nhour\ndouble precision\n\n\n🔍\nminute\ndouble precision\n\n\n*\ntime_hour\ntimestamptz\n\n\n\n distance est la distance orthodromique (earth distance) entre origin et dest en miles (pas en miles nautiques). On peut le vérifier avec les fonctions de l’extension earthdistance.\n le vol est effectué si dep_time n’est pas NULL\n dep_time, sched_dep_time, arr_time, sched_arr_time sont construits de la façon\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\n\nflights_fk\n( carrier ) ref nycflights.airlines (carrier)\n\n\n\nflights_fk_planes\n( tailnum ) ref nycflights.planes (tailnum)\n\n\n\nflights_fk_origin\n( origin ) ref nycflights.airports (faa)\n\n\n\nflights_fk_dest\n( dest ) ref nycflights.airports (faa)"
  },
  {
    "objectID": "schemas/schema-nycflights.html#table-nycflights.planes",
    "href": "schemas/schema-nycflights.html#table-nycflights.planes",
    "title": "Schéma : nycflights",
    "section": "Table nycflights.planes",
    "text": "Table nycflights.planes\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\ntailnum\ntext\n\n\n\nyear\ninteger\n\n\n\ntype\ntext\n\n\n\nmanufacturer\ntext\n\n\n\nmodel\ntext\n\n\n\nengines\ninteger\n\n\n\nseats\ninteger\n\n\n\nspeed\ninteger\n\n\n\nengine\ntext"
  },
  {
    "objectID": "schemas/schema-nycflights.html#table-nycflights.weather",
    "href": "schemas/schema-nycflights.html#table-nycflights.weather",
    "title": "Schéma : nycflights",
    "section": "Table nycflights.weather",
    "text": "Table nycflights.weather\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬈\norigin\ntext\n\n\n\nyear\ninteger\n\n\n\nmonth\ninteger\n\n\n\nday\ninteger\n\n\n\nhour\ninteger\n\n\n\ntemp\ndouble precision\n\n\n\ndewp\ndouble precision\n\n\n\nhumid\ndouble precision\n\n\n\nwind_dir\ndouble precision\n\n\n\nwind_speed\ndouble precision\n\n\n\nwind_gust\ndouble precision\n\n\n\nprecip\ndouble precision\n\n\n\npressure\ndouble precision\n\n\n\nvisib\ndouble precision\n\n\n* 🔑\ntime_hour\ntimestamptz\n\n\n\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\n\nweather_fk\n( origin ) ref nycflights.airports (faa)"
  },
  {
    "objectID": "project-tips-resources.html",
    "href": "project-tips-resources.html",
    "title": "Project tips + resources",
    "section": "",
    "text": "R Data Sources for Regression Analysis\nFiveThirtyEight data\nTidyTuesday\n\n\n\n\n\nWorld Health Organization\nThe National Bureau of Economic Research\nInternational Monetary Fund\nGeneral Social Survey\nUnited Nations Data\nUnited Nations Statistics Division\nU.K. Data\nU.S. Data\nU.S. Census Data\nEuropean Statistics\nStatistics Canada\nPew Research\nUNICEF\nCDC\nWorld Bank\nElection Studies"
  },
  {
    "objectID": "project-tips-resources.html#data-sources",
    "href": "project-tips-resources.html#data-sources",
    "title": "Project tips + resources",
    "section": "",
    "text": "R Data Sources for Regression Analysis\nFiveThirtyEight data\nTidyTuesday\n\n\n\n\n\nWorld Health Organization\nThe National Bureau of Economic Research\nInternational Monetary Fund\nGeneral Social Survey\nUnited Nations Data\nUnited Nations Statistics Division\nU.K. Data\nU.S. Data\nU.S. Census Data\nEuropean Statistics\nStatistics Canada\nPew Research\nUNICEF\nCDC\nWorld Bank\nElection Studies"
  },
  {
    "objectID": "project-tips-resources.html#tips",
    "href": "project-tips-resources.html#tips",
    "title": "Project tips + resources",
    "section": "Tips",
    "text": "Tips\n\nAsk questions if any of the expectations are unclear.\nCode: In your write up your code should be hidden (echo = FALSE) so that your document is neat and easy to read. However your document should include all your code such that if I re-knit your qmd file I should be able to obtain the results you presented.\n\nException: If you want to highlight something specific about a piece of code, you’re welcome to show that portion.\n\nMerge conflicts will happen, issues will arise, and that’s fine! Commit and push often, and ask questions when stuck.\nMake sure each team member is contributing, both in terms of quality and quantity of contribution (we will be reviewing commits from different team members).\nAll team members are expected to contribute equally to the completion of this assignment and group assessments will be given at its completion - anyone judged to not have sufficient contributed to the final product will have their grade penalized. While different teams members may have different backgrounds and abilities, it is the responsibility of every team member to understand how and why all code and approaches in the assignment works."
  },
  {
    "objectID": "project-tips-resources.html#formatting-communication-tips",
    "href": "project-tips-resources.html#formatting-communication-tips",
    "title": "Project tips + resources",
    "section": "Formatting + communication tips",
    "text": "Formatting + communication tips\n\nSuppress Code, Warnings, & Messages\n\nInclude the following code in a code chunk at the top of your .qmd file to suppress all code, warnings, and other messages. Use the code chunk header {r set-up, include = FALSE} to suppress this set up code.\n\n\n\nHeaders\n\nUse headers to clearly label each section.\nInspect the document outline to review your headers and sub-headers.\n\n\n\nReferences\n\nInclude all references in a section called “References” at the end of the report.\nThis course does not have specific requirements for formatting citations and references.\n\n\n\nAppendix\n\nIf you have additional work that does not fit or does not belong in the body of the report, you may put it at the end of the document in section called “Appendix”.\nThe items in the appendix should be properly labeled.\nThe appendix should only be for additional material. The reader should be able to fully understand your report without viewing content in the appendix.\n\n\n\nResize figures\nResize plots and figures, so you have more space for the narrative.\n\n\nArranging plots\nArrange plots in a grid, instead of one after the other. This is especially useful when displaying plots for exploratory data analysis and to check assumptions.\nIf you’re using ggplot2 functions, the patchwork package makes it easy to arrange plots in a grid. See the documentation and examples here.\n\n\nDo a little more to make the plot look professional!\n\nInformative title and axis labels\nFlipped coordinates to make names readable\nArranged bars based on count\nCapitalized manufacturer names\nOptional: Added color - Use a coordinated color scheme throughout paper / presentation\nOptional: Applied a theme - Use same theme throughout paper / presentation\n\n\n\nTables and model output\n\nUse the kable function from the knitr package to neatly output all tables and model output. This will also ensure all model coefficients are displayed.\n\nUse the digits argument to display only 3 or 4 significant digits.\nUse the caption argument to add captions to your table.\n\n\n\n\nGuidelines for communicating results"
  },
  {
    "objectID": "project-tips-resources.html#additional-resources",
    "href": "project-tips-resources.html#additional-resources",
    "title": "Project tips + resources",
    "section": "Additional resources",
    "text": "Additional resources\n\nR for Data Science\nQuarto Documentation"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MA15Y030: Introduction aux Bases de Données",
    "section": "",
    "text": "moodle\n  \n  \n    \n     Github\n  \n\n  \n  \n\n\nLe cours MA15Y030: Introduction aux Bases de Données\nde la Licence MIASHS (L3) de l’Université Paris Cité est une initiation à l’usage des données tabulaires. Ce cours est conçu pour des étudiantes intéressées par l’analyse de données au sens large. Cela va de l’alimentation, la maintenance de bases de données tabulaires à la statistique descriptive classique, à l’apprentissage machine et à la statistique prédictive.\n\n\n\nAu travers de ce cours, vous allez\n\nApprendre à interroger une base de données relationnelle\nApprendre à lire un schéma de base de données\nApprendre à concevoir une base de données\nApprendre à améliorer une base de données\n\n\n\n\nLe cours s’appuiera sur un serveur PostGres\n\n\n\n\nVous trouverez sur ce site information et matériel\n\nUn syllabus\nL’équipe enseignante\nLes clients utilisables\nLes diapositives du cours magistral\nLes feuilles d’exercices\nLes corrigés\nLes annales d’examen",
    "crumbs": [
      "Informations générales",
      "Aperçu"
    ]
  },
  {
    "objectID": "cours-equipe.html",
    "href": "cours-equipe.html",
    "title": "Équipe enseignante",
    "section": "",
    "text": "S. Boucheron Professeur de Mathématiques à l’Université Paris Cité/Laboratoire de Probabilités, Statistiques et Modélisatiion LPSM.",
    "crumbs": [
      "Informations générales",
      "Équipe"
    ]
  },
  {
    "objectID": "cours-equipe.html#cours",
    "href": "cours-equipe.html#cours",
    "title": "Équipe enseignante",
    "section": "",
    "text": "S. Boucheron Professeur de Mathématiques à l’Université Paris Cité/Laboratoire de Probabilités, Statistiques et Modélisatiion LPSM.",
    "crumbs": [
      "Informations générales",
      "Équipe"
    ]
  },
  {
    "objectID": "cours-equipe.html#travaux-dirigés",
    "href": "cours-equipe.html#travaux-dirigés",
    "title": "Équipe enseignante",
    "section": " Travaux dirigés",
    "text": "Travaux dirigés\n\n\n\nNom\nHoraire\nSalle\n\n\n\n\nStéphane Boucheron\nVendredi 15h45 - 18h15\n2004/5 Sophie Germain\n\n\nCristina Sirangelo\nVendredi 15h45 - 18h15\n2006 Sophie Germain\n\n\nAmine Souiri\nJeudi 13h30 - 16h00\n2006 Sophie Germain\n\n\nSylvain Schmitz\n\n\n\n\nAmélie Gheerbrant\n\n\n\n\nAnatole Dahan",
    "crumbs": [
      "Informations générales",
      "Équipe"
    ]
  },
  {
    "objectID": "computing-psql.html",
    "href": "computing-psql.html",
    "title": "Client psql",
    "section": "",
    "text": "Note\n\n\n\nQuelques possibilités si vous disposez d’une machine sur laquelle on peut installer psql et sur laquelle on peut établir des tunnels ssh\n\n\n\nInstaller\n\nGénéra\nWindows\nMacOS\nUbuntu\n\nDocumentation\n\n\nUtiliser\n\n\n\n\n\n\nÉtablissement d’un tunel SSH sur votre machine (ici sous Linux)\n\n\n\nRemplacer id_ent par votre identifiant ENT dans la suite.\nSaisissez votre mot de passe (attention : pas d’écho)\n$ ssh id_ent@etu-pgsql.math.univ-paris-diderot.fr -L 5436:localhost:5432 -N\n(id_ent@etu-pgsql.math.univ-paris-diderot.fr) Password for id_ent@etu-pgsql.math.univ-paris-diderot.fr:\n$\n\n\n\n\n\n\n\n\nConnexion au serveur PostGres, demander la liste des commandes disponibles\n\n\n\nUtilisez votre tunnel SSH pour accéder au serveur PostGres. Dans une autre fenêtre terminal, lancer psql, saisissez à nouveau votre mot de passe.\n$ psql -p 5436 -U id_ent -W -h localhost -d bd_2023-24\nPassword for id_ent: \n\nbd_2023-24=# \\?  \nVous êtes maintenant dans une session sur le serveur PostGres. Vous êtes connecté au catalogue bd_2023-24\nVous pouvez utiliser une grande partie des commandes magiques de psql\n\n\n\n\n\n\n\n\nChoisir un schéma par défaut (ici world)\n\n\n\nbd_2023-24=# SET search_path TO world ;\nSET\n\n\n\n\n\n\n\n\nLister les tables du schéma par défaut\n\n\n\nbd_2023-24=# \\d\n+--------+-----------------+-------+-----------+\n| Schema | Name            | Type  | Owner     |\n|--------+-----------------+-------+-----------|\n| world  | city            | table | boucheron |\n| world  | country         | table | boucheron |\n| world  | countrylanguage | table | boucheron |\n+--------+-----------------+-------+-----------+\n(3 rows)\n\n\n\n\n\n\n\n\nSchéma d’une table\n\n\n\nbd_2023-24=# \\d city\n \n+-------------+--------------+-----------+\n| Column      | Type         | Modifiers |\n|-------------+--------------+-----------|\n| id          | integer      |  not null |\n| name        | text         |  not null |\n| countrycode | character(3) |  not null |\n| district    | text         |  not null |\n| population  | integer      |  not null |\n+-------------+--------------+-----------+\nIndexes:\n    \"city_pkey\" PRIMARY KEY, btree (id)\nForeign-key constraints:\n    \"city_country_fk\" FOREIGN KEY (countrycode) REFERENCES country(countrycode) ON UPDATE CASCADE ON DELETE SET NULL DEFE&gt;\nReferenced by:\n    TABLE \"country\" CONSTRAINT \"country_capital_fkey\" FOREIGN KEY (capital) REFERENCES city(id)\n\n\n\n\n\n\n\n\nInformations de connexion\n\n\n\nbd_2023-24=# \\conninfo\nYou are connected to database \"bd_2023-24\" as user \"id_end\" on host \"localhost\"  (address \"127.0.0.1\") at port \"5436\".\n\n\n\n\n\n\n\n\nEditer, sauvegarder et exécuter des requêtes\n\n\n\nbd_2023-24=# \\e \n\nSelect an editor.  To change later, run 'select-editor'.\n  1. /bin/nano        &lt;---- easiest\n  2. /usr/bin/vim.basic\n  3. /usr/bin/nvim\n  4. /usr/bin/vim.tiny\n  5. /usr/bin/emacs\n  6. /usr/bin/code\n  7. /bin/ed\nChoose 1-7 [1]: 6\nSous mon éditeur préféré (vs code ici), j’edite une requête\nSELECT ci.name, co.name_country\nFROM \n  world.city ci JOIN \n  world.country co ON (\n    ci.countrycode=co.countrycode AND \n    ci.id = co.capital\n  ) \nORDER BY co.name_country;\nsauvegardée dans un fichier de chemin d’accès /tmp/psql.edit.23866.sql (construit automatiquement)\nDans ma session sur bd_2023-24, je peux maintenant inclure et exécuter cette requête.\nbd_2023-24=# \\i /tmp/psql.edit.23866.sql\n               name                |             name_country              \n-----------------------------------+---------------------------------------\n Kabul                             | Afghanistan\n Tirana                            | Albania\n Alger                             | Algeria\n Fagatogo                          | American Samoa\n Andorra la Vella                  | Andorra\n Luanda                            | Angola\n:\n...\nEntrez q pour sortir du pager\n\n\n\n\n\n\n\n\nUn fichier par TP ?\n\n\n\nIl est commode d’archiver le travail d’une séance de TP dans un fichier *.sql. On peut créer les fichiers avant la session ou en cours de session (ici dans un dialecte d’Unix)\nbd_2023-24=# \\! touch tp-x.sql\nbd_2023-24=# -- editer tp-x.sql\nbd_2023-24=# \\e tp-x.sql \nbd_2023-24=# -- charger/exécuter tp-x.sql\nbd_2023-24=# \\i tp-x.sql\n\n\n\n\nRenseignements utiles\nDocumentation psql)",
    "crumbs": [
      "Support",
      "Client psql"
    ]
  },
  {
    "objectID": "computing-pgcli.html",
    "href": "computing-pgcli.html",
    "title": "Client pgcli",
    "section": "",
    "text": "Note\n\n\n\nQuelques possibilités si vous disposez d’une machine sur laquelle on peut installer pgcli et sur laquelle on peut établir des tunnels ssh\n\n\n\nInstaller\nÀ partir de pgcli.com\n\n\nUtiliser\n\n\n\n\n\n\nÉtablissement d’un tunel SSH sur votre machine (ici sous Linux)\n\n\n\nRemplacer id_ent par votre identifiant ENT dans la suite.\nSaisissez votre mot de passe (attention : pas d’écho)\n$ ssh  id_ent@etu-pgsql.math.univ-paris-diderot.fr -L 5436:localhost:5432 -N\n(id_ent@etu-pgsql.math.univ-paris-diderot.fr) Password for id_ent@etu-pgsql.math.univ-paris-diderot.fr:\n$\n\n\n\n\n\n\n\n\nConnexion au serveur PostGres, demander la liste des commandes disponibles\n\n\n\nUtilisez votre tunnel SSH pour accéder au serveur PostGres.\nDans une autre fenêtre terminal, saisissez à nouveau votre mot de passe.\n$ pgcli -p 5436 -U id_ent -W -h localhost -d bd_2023-24\nPassword for id_ent: \nServer: PostgreSQL 13.8\nVersion: 3.5.0\nHome: http://pgcli.com\nbd_2023-24&gt; \\?  \nVous êtes maintenant dans une session sur le serveur PostGres. Vous êtes connecté au catalogue bd_2023-24\nVous pouvez utiliser une grande partie des commandes magiques de psql\n\n\n\n\n\n\n\n\nChoisir un schéma par défaut (ici world)\n\n\n\nbd_2023-24&gt; SET search_path TO world ;\nSET\nTime: 0.002s\n\n\n\n\n\n\n\n\nLister les tables du schéma par défaut\n\n\n\nbd_2023-24&gt; \\d\n+--------+-----------------+-------+-----------+\n| Schema | Name            | Type  | Owner     |\n|--------+-----------------+-------+-----------|\n| world  | city            | table | boucheron |\n| world  | country         | table | boucheron |\n| world  | countrylanguage | table | boucheron |\n+--------+-----------------+-------+-----------+\nSELECT 3\nTime: 0.013s\n\n\n\n\n\n\n\n\nSchéma d’une table\n\n\n\nbd_2023-24&gt; \\d city\n \n+-------------+--------------+-----------+\n| Column      | Type         | Modifiers |\n|-------------+--------------+-----------|\n| id          | integer      |  not null |\n| name        | text         |  not null |\n| countrycode | character(3) |  not null |\n| district    | text         |  not null |\n| population  | integer      |  not null |\n+-------------+--------------+-----------+\nIndexes:\n    \"city_pkey\" PRIMARY KEY, btree (id)\nForeign-key constraints:\n    \"city_country_fk\" FOREIGN KEY (countrycode) REFERENCES country(countrycode) ON UPDATE CASCADE ON DELETE SET NULL DEFE&gt;\nReferenced by:\n    TABLE \"country\" CONSTRAINT \"country_capital_fkey\" FOREIGN KEY (capital) REFERENCES city(id)\n\nTime: 0.025s\n\n\n\n\n\n\n\n\nInformations de connexion\n\n\n\nbd_2023-24&gt; \\conninfo\nYou are connected to database \"bd_2023-24\" as user \"id_end\" on host \"localhost\" at port \"5436\".\nTime: 0.000s\n\n\n\n\n\n\n\n\nEditer, sauvegarder et exécuter des requêtes\n\n\n\nbd_2023-24&gt; \\e \n\nSelect an editor.  To change later, run 'select-editor'.\n  1. /bin/nano        &lt;---- easiest\n  2. /usr/bin/vim.basic\n  3. /usr/bin/nvim\n  4. /usr/bin/vim.tiny\n  5. /usr/bin/emacs\n  6. /usr/bin/code\n  7. /bin/ed\nChoose 1-7 [1]: 6\nSous mon éditeur préféré (vs code ici), j’edite une requête\nSELECT *\nFROM world.city ci\nWHERE ci.countrycode='FRA' ;\nsauvegardée dans un fichier de chemin d’accès /tmp/editor-w6qw9gs0.sql\nDans ma session sur bd_2023-24, je peux maintenant inclure et exécuter cette requête.\nbd_2023-24&gt; \\i /tmp/editor-w6qw9gs0.sql\n+------+----------------------+-------------+----------------------+------------+\n| id   | name                 | countrycode | district             | population |\n|------+----------------------+-------------+----------------------+------------|\n| 2974 | Paris                | FRA         | Île-de-France        | 2125246    |\n| 2975 | Marseille            | FRA         | Provence-Alpes-Côte  | 798430     |\n| 2976 | Lyon                 | FRA         | Rhône-Alpes          | 445452     |\n| 2977 | Toulouse             | FRA         | Midi-Pyrénées        | 390350     |\n| 2978 | Nice                 | FRA         | Provence-Alpes-Côte  | 342738     |\n...\n\n\n\n\n\n\n\n\nJetez un oeil sur les named queries\n\n\n\nDocumentation\n\n\n\n\nRenseignements utiles\nDocumentation pgcli",
    "crumbs": [
      "Support",
      "Client pgcli"
    ]
  },
  {
    "objectID": "computing-access.html",
    "href": "computing-access.html",
    "title": "Moyens de calcul",
    "section": "",
    "text": "Serveur\nLe cours et les TP\n\nServeur PostGreSQL\nMachine dédiée : etu-pgsql.math.univ-paris-diderot.fr\n\n\n\nClients\nEn salle TP, vous pourrez choisir entre trois clients\n\npsql\npgcli\ndbeaver\n\npsql et pgcli sont très proches. Ce sont des applications qui fonctionnent en mode ligne de commande. pgcli est un peu plus conviviale que psql avec un système de complétion plus performant. L’ensemble des commandes spéciales proposées par pgcli est un peu moins vaste que celui proposé par psql\ndbeaver est un client graphique qui ne tombe pas dans le cliquodrome. dbeaver permet d’attaquer une grande famille de SGBDs.\nTous ces clients doivent utiliser des connexions sécurisées ssh.\n\n\nConnexions ssh (Linux/MacOS)\nPour accéder au serveur Postgres (SGBD), il faut d’abord se connecter à la machine qui héberge ce serveur etu-pgsql.math.univ-paris-diderot.fr.\nPour se connecter à etu-pgsql.math.univ-paris-diderot.fr, on utilise le protocole ssh, avec son identifiant et son mot de passe ENT.\n$ ssh username@etu-pgsql.math.univ-paris-diderot.fr\n(username@etu-pgsql.math.univ-paris-diderot.fr) Password for username@etu-pgsql.math.univ-paris-diderot.fr:\nLast login: ..................\n....\n....\nThis fortune brought to you by:\n$FreeBSD$\n[username@etu-pgsql ~]$ ...\nAttention : pas d’écho lorsque vous saisissez votre mot de passe.\nOn peut maintenant se connecter au serveur Postgres, toujours avec son identifiant et son mot de passe ENT\nIci, nous proposons d’utiliser le client pgcli exécuté sur etu-pgsql.math.univ-paris-diderot.fr :\n[username@etu-pgsql ~]$ pgcli -d bd_2023-24 \nPassword for username: \nServer: PostgreSQL 13.8\nVersion: 3.5.0\nHome: http://pgcli.com\nuserame@/tmp:bd_2023-24&gt; \n\n\n\n\n\n\nPourquoi préciser -d bd_2023-24 ?\n\n\n\nbd_2023-24 est un des catalogues hébergés par le serveur PostGres. bd_2023-24 contient les schemas sur lesquels nous travaillerons.\n\n\nNous sommes maintenant dans une session du serveur\nusername@/tmp:bd_2023-24&gt; \\conninfo\nYou are connected to database \"bd_2023-24\" as user \"username\" on socket \"/tmp\" at port \"None\".\nTime: 0.000s\nPour obtenir de l’aide, utiliser la commande \\d? et laissez vous guider.\nNous nous intéresserons en général à un ensemble de tables formant un schéma. Ici, nous choisissons comme schéma par défaut world et nous affichons les tables du schéma.\nusername@/tmp:bd_2023-24&gt; set search_path to world ;\nSET\nTime: 0.001s\nusername@/tmp:bd_2023-24&gt; \\dt\n+--------+-----------------+-------+-----------+\n| Schema | Name            | Type  | Owner     |\n|--------+-----------------+-------+-----------|\n| world  | city            | table | boucheron |\n| world  | country         | table | boucheron |\n| world  | countrylanguage | table | boucheron |\n+--------+-----------------+-------+-----------+\nSELECT 3\nTime: 0.011s\nusername@/tmp:bd_2023-24&gt; ...\n\n\n\n\n\n\nPlus pratique\n\n\n\nPour pgcli et psql, il est plus pratique d’exécuter psql et/ou pgcli sur votre machine et de communiquer avec le serveur Postgres via un tunnel ssh. Voir détails pour pgcli et détails pour psql.\n\n\n\n\nConnexions ssh sous windows\nPour accéder au serveur Postgres (SGBD), il faut d’abord se connecter à la machine qui héberge ce serveur etu-pgsql.math.univ-paris-diderot.fr.\nPour se connecter à etu-pgsql.math.univ-paris-diderot.fr, on utilise le protocole ssh, avec son identifiant et son mot de passe ENT.\nOn lance d’abord une fenêtre Powershell.\n$ ssh username@etu-pgsql.math.univ-paris-diderot.fr\n(username@etu-pgsql.math.univ-paris-diderot.fr) Password for username@etu-pgsql.math.univ-paris-diderot.fr:\nLast login: ..................\n....\n....\nThis fortune brought to you by:\n$FreeBSD$\n[username@etu-pgsql ~]$ ...\n Attention : pas d’écho lorsque vous saisissez votre mot de passe.\nOn peut maintenant se connecter au serveur Postgres, toujours avec son identifiant et son mot de passe ENT\nIci, nous proposons d’utiliser le client pgcli :\n[username@etu-pgsql ~]$ pgcli -d bd_2023-24 \nPassword for username: \nServer: PostgreSQL 13.8\nVersion: 3.5.0\nHome: http://pgcli.com\nuserame@/tmp:bd_2023-24&gt; \n\n\n\n\n\n\nPourquoi préciser -d bd_2023-24 ?\n\n\n\nbd_2023-24 est un des catalogues hébergés par le serveur PostGres. bd_2023-24 contient les schemas sur lesquels nous travaillerons.\n\n\nNous sommes maintenant dans une session du serveur\nusername@/tmp:bd_2023-24&gt; \\conninfo\nYou are connected to database \"bd_2023-24\" as user \"username\" on socket \"/tmp\" at port \"None\".\nTime: 0.000s\nPour obtenir de l’aide, utiliser la commande \\d? et laissez vous guider.\nNous nous intéresserons en général à un ensemble de tables formant un schéma. Ici, nous choisissons comme schéma par défaut world et nous affichons les tables du schéma.\nusername@/tmp:bd_2023-24&gt; set search_path to world ;\nSET\nTime: 0.001s\nusername@/tmp:bd_2023-24&gt; \\dt\n+--------+-----------------+-------+-----------+\n| Schema | Name            | Type  | Owner     |\n|--------+-----------------+-------+-----------|\n| world  | city            | table | boucheron |\n| world  | country         | table | boucheron |\n| world  | countrylanguage | table | boucheron |\n+--------+-----------------+-------+-----------+\nSELECT 3\nTime: 0.011s\nusername@/tmp:bd_2023-24&gt; ...\n\n\nConnexions ssh avec tunnel\nVous avez pu constater que les connexions ssh sous MacOS, Linux et Windows sont presque identiques.\nMais utiliser une connexion ssh et un client base de données qui s’exécute sur etu-pgsql.math.univ-paris-diderot.fr n’est pas la manière la plus confortable de travailler.\nIl est plus agréable d’utiliser un client base de données qui s’exécute sur sa propre machine (en local) et qui interagit avec le serveur PostGres au travers d’un tunnel ssh.\nLa commande suivante établit un tunnel en tâche de fond (background job) grâce à l’option -f\n$ ssh -f username@etu-pgsql.math.univ-paris-diderot.fr -L 5436:localhost:5432 -N\n(username@etu-pgsql.math.univ-paris-diderot.fr) Password for username@etu-pgsql.math.univ-paris-diderot.fr:\n$ \nUne fois le tunnel établi, on peut continuer d’utiliser la fenêtre terminal, par exemple pour lancer pgcli ou psql.\nLa commande suivante établit aussi un tunnel mais en tâche de premier plan.\n$ ssh username@etu-pgsql.math.univ-paris-diderot.fr -L 5436:localhost:5432 -N\n(username@etu-pgsql.math.univ-paris-diderot.fr) Password for username@etu-pgsql.math.univ-paris-diderot.fr:\n$ \nUne fois le tunnel établi, la fenêtre terminal est bloquée. Si on veut lancer pgcli ou psql, il faut disposer d’une autre fenêtre.\n\n\n\n\n\n\nTunnel en tâche de fond ou pas ?\n\n\n\nLe lancement du tunnel en tâche de premier plan peut paraître moins pratique que le lancement du tunnel en tâche de fond.\nIl présente un avantage : lorsque le tunnel cesse de fonctionner (en général parce qu’on ne s’en est pas servi depuis quelques minutes), il faut termniner (tuer) le processus qui contrôle le tunnel, pour pouvoir récupérer l’usage du port local ; si le tunnel est contrôlé par une tache de premier plan, c’est trivial (^C sous Unix), si le tunnel est contrôlé par une tâche de fond, il faut déterminer le processus contrôleur, puis le terminer explicitement ($ kill -9 pid).\n\n\n\n\n\n\n\n\nRenvoi de port -L 5436:localhost:5432\n\n\n\nUn serveur PostGres écoute (attend) d’éventuels clients sur le port officiel 5432. Le serveur que nous utiliserons attend effectivement ses clients sur le port 5432 de la machine qui l’héberge. Notre client local ne va pas s’adresser directement au port 5432 de etu-pgsql.math.univ-paris-diderot.fr (c’est interdit). Notre client local s’adressera au port 5436 de la machine qui héberge le client et qui est lui-même renvoyé via le tunnel ssh vers le port 5432 de la machine qui héberge le serveur.\n\n\nOn peut maintenant lancer un client sur sa propre machine (localhost) en précisant qu’on s’adresse au port local 5436 (ou le port que vous choisissez), la requête de conexion au serveur PostGres distant sera transmise par le tunnel : elle sera envoyée sur le port officiel 5432 de la machine distante. Une fois la session établie, tout se passsera comme précédemment (ou presque).\n$ pgcli -d bd_2023-24 -h localhost -p 5436 -u username -W\nServer: PostgreSQL 13.8\nVersion: 3.5.0\nHome: http://pgcli.com\nbd_2023-24&gt; \\dn\n+----------------+--------------+\n| Name           | Owner        |\n|----------------+--------------|\n...\n...\n\n\nClient dbeaver\nLe mécanisme du tunnel ssh peut être utilisé pour connecter un client plus ambitieux au serveur. Le client dbeaver est particulièrement facile à utiliser.\n\n\nClient VS Code + extensions SQLTools\nSi vous êtes déjà habitué à l’éditeur Visual Studio Code (VS Code), vous pouvez utiliser l’extension SQLToos et son pilote ‘PostgreSQL/Cockroach’.\nVotre configuration de connexion devrait ressembler à :\n{\n  \"label\": \"etu-pgsql\",\n  \"host\": \"localhost\",\n  \"user\": \"&lt;identifiant ENT&gt;\",\n  \"port\": 5436,\n  \"ssl\": false,\n  \"database\": \"bd_2023-24\",\n  \"schema\": \"world\",\n  \"password\": \"Ask on connect\"\n}\nIl faut par ailleurs ouvrir un tunnel SSH dans un terminal\n$ ssh  username@etu-pgsql.math.univ-paris-diderot.fr -L 5436:localhost:5432 -N\n(username@etu-pgsql.math.univ-paris-diderot.fr) Password for username@etu-pgsql.math.univ-paris-diderot.fr:\n$ \nen remplaçant username par votre identifiant ENT.",
    "crumbs": [
      "Support",
      "Accès Informatique"
    ]
  },
  {
    "objectID": "computing-cloudbeaver.html",
    "href": "computing-cloudbeaver.html",
    "title": "Client CloudBeaver",
    "section": "",
    "text": "Démonstration\nDémo\n\n\nInstaller\n\n\nDocker\n\n\nConfigurer une connexion\n\nOnglet Main\n\nConnect by Host,\n\nHost: localhost,\nPort: 5434 (ou un autre nombre exotique)\nDatabase: bd_2023-24\nDécocher `Show all databases\n\nAuthentification: Database Native\n\nUsername: username (ENT)\nPassword: xxxxxxx (ENT)\nCocher Save password\n\n\n\nOnglet PostgreSQL\nOnglet SSH\n\nCocher Use SSH Tunnel\nSettings\n\nHost/IP: localhost\nPort 22\nUsername: username (ENT)\nPassword: xxxxxxx (ENT)\nCocher Save credentials\n\nJump servers\n\nJump #1 etu-pgsql.math.univ-paris-diderot.fr username Password\nTarget localhost:22 username Password\n\n\n\n\n\nUtiliser une connexion\n\n\nDéfinir et utiliser un projet\n\nConnections\nBookmarks\nDashboards\nDiagrams\nScripts\n\n\n\nÉditeur SQL\n\n\n\n\n\nConnexions ssh (Linux/MacOS)\nPour accéder au serveur Postgres (SGBD), il faut d’abord se connecter à la machine qui héberge ce serveur etu-pgsql.math.univ-paris-diderot.fr.\nPour se connecter à etu-pgsql.math.univ-paris-diderot.fr, on utilise le protocole ssh, avec son identifiant et son mot de passe ENT.\n$ ssh username@etu-pgsql.math.univ-paris-diderot.fr\n(username@etu-pgsql.math.univ-paris-diderot.fr) Password for username@etu-pgsql.math.univ-paris-diderot.fr:\nLast login: ..................\n....\n....\nThis fortune brought to you by:\n$FreeBSD$\n[username@etu-pgsql ~]$ ...\nAttention : pas d’écho lorsque vous saisissez votre mot de passe.\nOn peut maintenant se connecter au serveur Postgres, toujours avec son identifiant et son mot de passe ENT\nIci, nous proposons d’utiliser le client pgcli :\n[username@etu-pgsql ~]$ pgcli -d bd_2023-24 \nPassword for username: \nServer: PostgreSQL 13.8\nVersion: 3.5.0\nHome: http://pgcli.com\nuserame@/tmp:bd_2023-24&gt; \n\n\n\n\n\n\nPourquoi préciser -d bd_2023-24 ?\n\n\n\nbd_2023-24 est un des catalogues hébergés par le serveur PostGres. bd_2023-24 contient les schemas sur lesquels nous travaillerons.\n\n\nNous sommes maintenant dans une session du serveur\nusername@/tmp:bd_2023-24&gt; \\conninfo\nYou are connected to database \"bd_2023-24\" as user \"username\" on socket \"/tmp\" at port \"None\".\nTime: 0.000s\nPour obtenir de l’aide, utiliser la commande \\d? et laissez vous guider.\nNous nous intéresserons en général à un ensemble de tables formant un schéma. Ici, nous choisissons comme schéma par défaut world et nous affichons les tables du schéma.\nusername@/tmp:bd_2023-24&gt; set search_path to world ;\nSET\nTime: 0.001s\nusername@/tmp:bd_2023-24&gt; \\dt\n+--------+-----------------+-------+-----------+\n| Schema | Name            | Type  | Owner     |\n|--------+-----------------+-------+-----------|\n| world  | city            | table | boucheron |\n| world  | country         | table | boucheron |\n| world  | countrylanguage | table | boucheron |\n+--------+-----------------+-------+-----------+\nSELECT 3\nTime: 0.011s\nusername@/tmp:bd_2023-24&gt; ...\n\n\nConnexions ssh sous windows\n\n\n\nConnexions ssh avec tunnel\n$ ssh -f username@etu-pgsql.math.univ-paris-diderot.fr -L 5436:localhost:5432 -N\n(username@etu-pgsql.math.univ-paris-diderot.fr) Password for username@etu-pgsql.math.univ-paris-diderot.fr:\n$ \n\n\n\n\n\n\nRenvoi de port -L 5436:localhost:5432\n\n\n\n\n\n\n\n\n\n\n\n\nPourquoi -N ?\n\n\n\n\n\n\nOn peut maintenant lancer un client sur sa propre machine (localhost) en précisant qu’on s’adresse au port local 5436 (ou le port que vous choisissez), la requête de conexion au serveur PostGres distant sera transmise par le tunnel : elle sera envoyée sur le port officiel 5432 de la machine distante. Une fois la session établie, tout se passsera comme précédemment (ou presque).\n$ pgcli -d bd_2023-24 -h localhost -p 5436 -u username\nServer: PostgreSQL 13.8\nVersion: 3.5.0\nHome: http://pgcli.com\nbd_2023-24&gt; \\dn\n+----------------+--------------+\n| Name           | Owner        |\n|----------------+--------------|\n...\n...\n\n\nClient dbeaver\nLe mécanisme du tunnel ssh peut être utilisé pour connecter un client plus ambitieux au serveur. Le client dbeaver est particulièrement facile à utiliser."
  },
  {
    "objectID": "computing-pipelines.html",
    "href": "computing-pipelines.html",
    "title": "Pipelines",
    "section": "",
    "text": "Interroger une base de données avec R (via ODBC)\n\n\nInterroger une base de données avec Python (via ODBC)"
  },
  {
    "objectID": "corriges-tds.html",
    "href": "corriges-tds.html",
    "title": "Corrigés",
    "section": "",
    "text": "Note\n\n\n\n Ne vous précipitez pas sur les propositions de corrections avant d’avoir tenté par vous-même de réaliser les exercices.\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Titre\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Description\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nDate\n\n\nTitre\n\n\nDescription\n\n\n\n\n\n\nSep 20, 2024\n\n\nTD 1 2024-25\n\n\nRequêtes, SQL\n\n\n\n\nSep 27, 2024\n\n\nTD 2 2024-25\n\n\nRequêtes, SQL\n\n\n\n\nOct 4, 2024\n\n\nTD 3 2024-25\n\n\nRequêtes, SQL\n\n\n\n\nOct 11, 2024\n\n\nTD 4 2024-25\n\n\nRequêtes, Aggrégation, Fenêtres\n\n\n\n\nOct 18, 2024\n\n\nTD 5 2024-25\n\n\nRequêtes Aggrégation, Fenêtres\n\n\n\n\nOct 25, 2024\n\n\nTD 6 2024-25\n\n\nContraintes\n\n\n\n\nNov 8, 2024\n\n\nTD 7 2024-25\n\n\nContraintes\n\n\n\n\nNov 15, 2024\n\n\nTD 8 2024-25\n\n\nModélisation\n\n\n\n\nNov 22, 2024\n\n\nTD 9 2024-25\n\n\nModélisation\n\n\n\n\nNov 29, 2024\n\n\nTD 10 2024-25\n\n\nNormalisation\n\n\n\n\nDec 6, 2024\n\n\nTD 11 2024-25\n\n\nNormalisation\n\n\n\n\n\nNo matching items\n\n\n\n\n\n\n\n\nNote\n\n\n\n Les corrigés ne sont que des propositions. Il est très possible que vous ayez en tête des solutions différentes des propositions et que vos propositions soient correctes.\n Pour lever les doutes, comparer les résultats de vos requêtes et de celles proposées dans les solutions. Avec ... EXCEPT ... vous devriez y voir clair.",
    "crumbs": [
      "Corrections"
    ]
  },
  {
    "objectID": "exams-listings.html",
    "href": "exams-listings.html",
    "title": "Annales",
    "section": "",
    "text": "Note\n\n\n\nLes annales recueillent les sujets de contrôle continu (CC) et de contrôle terminal (CT) des années universitaires 2022-23 et 2023-24.\nLes sujets sont partiellement corrigés.\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Titre\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Description\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nDate\n\n\nTitre\n\n\nDescription\n\n\n\n\n\n\nNov 15, 2024\n\n\nCC 2 2024-25\n\n\nRequêtes, Aggrégation, Fenêtres, pagila, world\n\n\n\n\nOct 25, 2024\n\n\nCC 1 2024-25\n\n\nRequêtes simples, Aggrégation, pagila\n\n\n\n\nJun 19, 2024\n\n\nCT 2 2023-24\n\n\nRequêtes Aggrégation, Fenêtres, nycflights\n\n\n\n\nJan 8, 2024\n\n\nCT 1 2023-24\n\n\nModélisation, Normalisation, Requêtes Aggrégation, Fenêtres, nycflights\n\n\n\n\nDec 8, 2023\n\n\nCC 3 2023-24\n\n\nModélisation, Aggrégation, Fenêtres, French-Towns\n\n\n\n\nNov 24, 2023\n\n\nCC 2 2023-24\n\n\nAggrégation, Fenêtres, world\n\n\n\n\nOct 27, 2023\n\n\nCC 1 2023-24\n\n\nRequêtes, world\n\n\n\n\nNov 25, 2022\n\n\nCC 2 2022-23\n\n\nAggrégation, Fenêtres, nycflights, babynames\n\n\n\n\nNov 13, 2022\n\n\nCC 3-4 2022-23\n\n\nAggrégation, Fenêtres, nycflights\n\n\n\n\nNov 3, 2022\n\n\nCC 3-3 2022-23\n\n\nAggrégation, Fenêtres, nycflights\n\n\n\n\nOct 21, 2022\n\n\nCC 3-2 2022-23\n\n\nAggrégation, Fenêtres, babynames\n\n\n\n\nOct 14, 2022\n\n\nCC 3-1 2022-23\n\n\nAggrégation, Fenêtres, world\n\n\n\n\n\nNo matching items\n\n\n\n\n\n\n\n\nCaution\n\n\n\nLe contrôle continu 3 (CC3) de l’année 2022-23 est formé d’une suite de devoirs à réaliser à la maison entre deux séances de TD.\nLes contrôles continus 1 et 2 (CC1 et CC2) de l’année 2022-23 se déroulaient en salle de TP sur machines.\nTous les autres contrôles consistaient en épreuves sur table de 1 heure, 1 heure 30 ou 2 heures.",
    "crumbs": [
      "Annales"
    ]
  },
  {
    "objectID": "project-description.html",
    "href": "project-description.html",
    "title": "Project description",
    "section": "",
    "text": "Topic ideas due Fri, Feb 18\nProposal due Fri, Mar 18\nDraft report due Fri, Apr 8\nPeer review due Fri, Apr 15\nFinal report due Mon, Apr 25\nVideo presentation + slides and final GitHub repo due Thu, Apr 28\nPresentation comments due Sat, Apr 30"
  },
  {
    "objectID": "project-description.html#timeline",
    "href": "project-description.html#timeline",
    "title": "Project description",
    "section": "",
    "text": "Topic ideas due Fri, Feb 18\nProposal due Fri, Mar 18\nDraft report due Fri, Apr 8\nPeer review due Fri, Apr 15\nFinal report due Mon, Apr 25\nVideo presentation + slides and final GitHub repo due Thu, Apr 28\nPresentation comments due Sat, Apr 30"
  },
  {
    "objectID": "project-description.html#introduction",
    "href": "project-description.html#introduction",
    "title": "Project description",
    "section": "Introduction",
    "text": "Introduction\nTL;DR: Pick a data set and do a regression analysis. That is your final project.\nThe goal of the final project is for you to use regression analysis to analyze a data set of your own choosing. The data set may already exist or you may collect your own data by scraping the web.\nChoose the data based on your group’s interests or work you all have done in other courses or research projects. The goal of this project is for you to demonstrate proficiency in the techniques we have covered in this class (and beyond, if you like!) and apply them to a data set to analyze it in a meaningful way.\nAll analyses must be done in RStudio, and all components of the project must be reproducible (with the exception of the presentation).\n\nLogistics\nYou will work on the project with your lab groups.\nThe four primary deliverables for the final project are\n\nA written, reproducible report detailing your analysis\nA GitHub repository corresponding to your report\nSlides + a video presentation\nFormal peer review on another team’s project"
  },
  {
    "objectID": "project-description.html#topic-ideas",
    "href": "project-description.html#topic-ideas",
    "title": "Project description",
    "section": "Topic ideas",
    "text": "Topic ideas\nIdentify 2-3 data sets you’re interested in potentially using for the final project. If you’re unsure where to find data, you can use the list of potential data sources in the Tips + Resources section as a starting point. It may also help to think of topics you’re interested in investigating and find data sets on those topics.\nThe purpose of submitting project ideas is to give you time to find data for the project and to make sure you have a data set that can help you be successful in the project. Therefore, you must use one of the data sets submitted as a topic idea, unless otherwise notified by the teaching team.\nThe data sets should meet the following criteria:\n\nAt least 500 observations\nAt least 10 columns\nAt least 6 of the columns must be useful and unique predictor variables.\n\nIdentifier variables such as “name”, “social security number”, etc. are not useful predictor variables.\nIf you have multiple columns with the same information (e.g. “state abbreviation” and “state name”), then they are not unique predictors.\n\nAt least one variable that can be identified as a reasonable response variable.\n\nThe response variable can be quantitative or categorical.\n\nA mix of quantitative and categorical variables that can be used as predictors.\nObservations should reasonably meet the independence condition. Therefore, avoid data with repeated measures, data collected over time, etc.\nYou may not use data that has previously been used in any course materials, or any derivation of data that has been used in course materials.\n\nPlease ask a member of the teaching team if you’re unsure whether your data set meets the criteria.\nFor each data set, include the following:\n\nIntroduction and data\n\nState the source of the data set.\nDescribe when and how it was originally collected (by the original data curator, not necessarily how you found the data)\nDescribe the observations and the general characteristics being measured in the data\n\n\n\nResearch question\n\nDescribe a research question you’re interested in answering using this data.\n\n\n\nGlimpse of data\n\nUse the glimpse function to provide an overview of each data set\n\nSubmit the PDF of the topic ideas to Gradescope. Mark all pages associated with each data set."
  },
  {
    "objectID": "project-description.html#project-proposal",
    "href": "project-description.html#project-proposal",
    "title": "Project description",
    "section": "Project proposal",
    "text": "Project proposal\nThe purpose of the project proposal is to help you think about your analysis strategy early.\nInclude the following in the proposal:\n\nSection 1 - Introduction\nThe introduction section includes\n\nan introduction to the subject matter you’re investigating\nthe motivation for your research question (citing any relevant literature)\nthe general research question you wish to explore\nyour hypotheses regarding the research question of interest.\n\n\n\nSection 2 - Data description\nIn this section, you will describe the data set you wish to explore. This includes\n\ndescription of the observations in the data set,\ndescription of how the data was originally collected (not how you found the data but how the original curator of the data collected it).\n\n\n\nSection 3 - Analysis approach\nIn this section, you will provide a brief overview of your analysis approach. This includes:\n\nDescription of the response variable.\nVisualization and summary statistics for the response variable.\nList of variables that will be considered as predictors\nRegression model technique (multiple linear regression and logistic regression)\n\n\n\nData dictionary (aka code book)\nSubmit a data dictionary for all the variables in your data set in the README of your project repo, in the data folder. Link to this file from your proposal writeup.\n\n\nSubmission\nPush all of your final changes to the GitHub repo, and submit the PDF of your proposal to Gradescope.\n\n\nProposal grading\n\n\n\nTotal\n10 pts\n\n\n\n\nIntroduction\n3 pts\n\n\nData description\n2 pts\n\n\nAnalysis plan\n4 pts\n\n\nData dictionary\n1 pts\n\n\n\nEach component will be graded as follows:\n\nMeets expectations (full credit): All required elements are completed and are accurate. The narrative is written clearly, all tables and visualizations are nicely formatted, and the work would be presentable in a professional setting.\nClose to expectations (half credit): There are some elements missing and/or inaccurate. There are some issues with formatting.\nDoes not meet expectations (no credit): Major elements missing. Work is not neatly formatted and would not be presentable in a professional setting."
  },
  {
    "objectID": "project-description.html#draft-report",
    "href": "project-description.html#draft-report",
    "title": "Project description",
    "section": "Draft report",
    "text": "Draft report\nThe purpose of the draft and peer review is to give you an opportunity to get early feedback on your analysis. Therefore, the draft and peer review will focus primarily on the exploratory data analysis, modeling, and initial interpretations.\nWrite the draft in the written-report.qmd file in your project repo. You do not need to submit the draft on Gradescope.\nBelow is a brief description of the sections to focus on in the draft:\n\nIntroduction and data\nThis section includes an introduction to the project motivation, data, and research question. Describe the data and definitions of key variables. It should also include some exploratory data analysis. All of the EDA won’t fit in the paper, so focus on the EDA for the response variable and a few other interesting variables and relationships.\n\n\nMethodology\nThis section includes a brief description of your modeling process. Explain the reasoning for the type of model you’re fitting, predictor variables considered for the model including any interactions. Additionally, show how you arrived at the final model by describing the model selection process, any variable transformations (if needed), and any other relevant considerations that were part of the model fitting process.\n\n\nResults\nIn this section, you will output the final model and include a brief discussion of the model assumptions, diagnostics, and any relevant model fit statistics.\nThis section also includes initial interpretations and conclusions drawn from the model."
  },
  {
    "objectID": "project-description.html#peer-review",
    "href": "project-description.html#peer-review",
    "title": "Project description",
    "section": "Peer review",
    "text": "Peer review\nCritically reviewing others’ work is a crucial part of the scientific process, and STA 210 is no exception. Each lab team will be assigned two other teams’s projects to review. Each team should push their draft to their GitHub repo by the due date. One lab in the following week will be dedicated to the peer review, and all reviews will be due by the end of that lab session.\nDuring the peer review process, you will be provided read-only access to your partner teams’ GitHub repos. Provide your review in the form of GitHub issues to your partner team’s GitHub repo using the issue template provided. The peer review will be graded on the extent to which it comprehensively and constructively addresses the components of the partner team’s report: the research context and motivation, exploratory data analysis, modeling, interpretations, and conclusions.\n\nPairings\n\nSection 1 - M 1:45PM - 3:00PM\n\n\n\nTeam being reviewed\nReviewer 1\nReviewer 2\n\n\n\n\nchaa_chaa_chaa\nyay_stats\nstat_over_flow\n\n\ndekk\nchaa_chaa_chaa\nyay_stats\n\n\neight\ndekk\nchaa_chaa_chaa\n\n\nhousecats\neight\ndekk\n\n\nkrafthouse\nhousecats\neight\n\n\nrrawr\nkrafthouse\nhousecats\n\n\nstat_over_flow\nrrawr\nkrafthouse\n\n\nyay_stats\nstat_over_flow\nrrawr\n\n\n\n\n\nSection 2 - M 3:30PM - 4:45PM\n\n\n\nTeam being reviewed\nReviewer 1\nReviewer 2\n\n\n\n\na_plus_plus_plus\nwe_r\ntina\n\n\npredictors\na_plus_plus_plus\nwe_r\n\n\nsixers\npredictors\na_plus_plus_plus\n\n\nsoy_nuggets\nsixers\npredictors\n\n\ntina\nsoy_nuggets\nsixers\n\n\nwe_r\ntina\nsoy_nuggets\n\n\n\n\n\nSection 3 - M 5:15PM - 6:30PM\n\n\n\n\n\n\n\n\nTeam being reviewed\nReviewer 1\nReviewer 2\n\n\n\n\ndown_to_earth_goats\nthe_three_musketeers\nteam_five\n\n\nginger_and_stats\ndown_to_earth_goats\nthe_three_musketeers\n\n\npineapple_wedge_and_diced_papaya\nginger_and_stats\ndown_to_earth_goats\n\n\nstatchelorettes\npineapple_wedge_and_diced_papaya\nginger_and_stats\n\n\nstatisix\nstatchelorettes\npineapple_wedge_and_diced_papaya\n\n\nstats_squad\nstatisix\nstatchelorettes\n\n\nteam_five\nstats_squad\nstatisix\n\n\nthe_three_musketeers\nteam_five\nstats_squad\n\n\n\n\n\n\nProcess and questions\nSpend ~30 mins to review each team’s project.\n\nFind your team name on the Reviewer 1 and Reviewer 2 columns.\nFor each of the columns, find the name of the team to review in the Team being reviewed column. You should already have access to this team’s repo.\nOpen the repo of the team you’re reviewing, read their project draft, and browser around the rest of their repo.\nThen, go to the Issues tab in that repo, click on New issue, and click on Get started for the Peer review issue. Fill out this issue, answering the following questions:\n\nPeer review by: [NAME OF TEAM DOING THE REVIEW]\nNames of team members that participated in this review: [FULL NAMES OF TEAM MEMBERS DOING THE REVIEW]\nDescribe the goal of the project.\nDescribe the data used or collected, if any. If the proposal does not include the use of a specific dataset, comment on whether the project would be strengthened by the inclusion of a dataset.\nDescribe the approaches, tools, and methods that will be used.\nIs there anything that is unclear from the proposal?\nProvide constructive feedback on how the team might be able to improve their project. Make sure your feedback includes at least one comment on the statistical modeling aspect of the project, but do feel free to comment on aspects beyond the modeling.\nWhat aspect of this project are you most interested in and would like to see highlighted in the presentation.\nProvide constructive feedback on any issues with file and/or code organization.\n(Optional) Any further comments or feedback?"
  },
  {
    "objectID": "project-description.html#written-report",
    "href": "project-description.html#written-report",
    "title": "Project description",
    "section": "Written report",
    "text": "Written report\nYour written report must be completed in the written-report.qmd file and must be reproducible. All team members should contribute to the GitHub repository, with regular meaningful commits.\nBefore you finalize your write up, make sure the printing of code chunks is off with the option echo = FALSE.\nYou will submit the PDF of your final report on Gradescope.\nThe PDF you submit must match the files in your GitHub repository exactly. The mandatory components of the report are below. You are free to add additional sections as necessary. The report, including visualizations, should be no more than 10 pages long. is no minimum page requirement; however, you should comprehensively address all of the analysis and report.\nBe selective in what you include in your final write-up. The goal is to write a cohesive narrative that demonstrates a thorough and comprehensive analysis rather than explain every step of the analysis.\nYou are welcome to include an appendix with additional work at the end of the written report document; however, grading will largely be based on the content in the main body of the report. You should assume the reader will not see the material in the appendix unless prompted to view it in the main body of the report. The appendix should be neatly formatted and easy for the reader to navigate. It is not included in the 10-page limit.\nThe written report is worth 40 points, broken down as follows\n\n\n\nTotal\n40 pts\n\n\n\n\nIntroduction/data\n6 pts\n\n\nMethodology\n10 pts\n\n\nResults\n14 pts\n\n\nDiscussion + conclusion\n6 pts\n\n\nOrganization + formatting\n4 pts\n\n\n\nClick here for a PDF of the written report rubric.\n\nIntroduction and data\nThis section includes an introduction to the project motivation, data, and research question. Describe the data and definitions of key variables. It should also include some exploratory data analysis. All of the EDA won’t fit in the paper, so focus on the EDA for the response variable and a few other interesting variables and relationships.\n\nGrading criteria\nThe research question and motivation are clearly stated in the introduction, including citations for the data source and any external research. The data are clearly described, including a description about how the data were originally collected and a concise definition of the variables relevant to understanding the report. The data cleaning process is clearly described, including any decisions made in the process (e.g., creating new variables, removing observations, etc.) The explanatory data analysis helps the reader better understand the observations in the data along with interesting and relevant relationships between the variables. It incorporates appropriate visualizations and summary statistics.\n\n\n\nMethodology\nThis section includes a brief description of your modeling process. Explain the reasoning for the type of model you’re fitting, predictor variables considered for the model including any interactions. Additionally, show how you arrived at the final model by describing the model selection process, interactions considered, variable transformations (if needed), assessment of conditions and diagnostics, and any other relevant considerations that were part of the model fitting process.\n\nGrading criteria\nThe analysis steps are appropriate for the data and research question. The group used a thorough and careful approach to select the final model; the approach is clearly described in the report. The model selection process took into account potential interaction effects and addressed any violations in model conditions. The model conditions and diagnostics are thoroughly and accurately assessed for their model. If violations of model conditions are still present, there was a reasonable attempt to address the violations based on the course content.\n\n\n\nResults\nThis is where you will output the final model with any relevant model fit statistics.\nDescribe the key results from the model. The goal is not to interpret every single variable in the model but rather to show that you are proficient in using the model output to address the research questions, using the interpretations to support your conclusions. Focus on the variables that help you answer the research question and that provide relevant context for the reader.\n\nGrading criteria\nThe model fit is clearly assessed, and interesting findings from the model are clearly described. Interpretations of model coefficients are used to support the key findings and conclusions, rather than merely listing the interpretation of every model coefficient. If the primary modeling objective is prediction, the model’s predictive power is thoroughly assessed.\n\n\n\nDiscussion + Conclusion\nIn this section you’ll include a summary of what you have learned about your research question along with statistical arguments supporting your conclusions. In addition, discuss the limitations of your analysis and provide suggestions on ways the analysis could be improved. Any potential issues pertaining to the reliability and validity of your data and appropriateness of the statistical analysis should also be discussed here. Lastly, this section will include ideas for future work.\n\nGrading criteria\nOverall conclusions from analysis are clearly described, and the model results are put into the larger context of the subject matter and original research question. There is thoughtful consideration of potential limitations of the data and/or analysis, and ideas for future work are clearly described.\n\n\n\nOrganization + formatting\nThis is an assessment of the overall presentation and formatting of the written report.\n\nGrading criteria\nThe report neatly written and organized with clear section headers and appropriately sized figures with informative labels. Numerical results are displayed with a reasonable number of digits, and all visualizations are neatly formatted. All citations and links are properly formatted. If there is an appendix, it is reasonably organized and easy for the reader to find relevant information. All code, warnings, and messages are suppressed. The main body of the written report (not including the appendix) is no longer than 10 pages."
  },
  {
    "objectID": "project-description.html#video-presentation-slides",
    "href": "project-description.html#video-presentation-slides",
    "title": "Project description",
    "section": "Video presentation + slides",
    "text": "Video presentation + slides\n\nSlides\nIn addition to the written report, your team will also create presentation slides and record a video presentation that summarize and showcase your project. Introduce your research question and data set, showcase visualizations, and discuss the primary conclusions. These slides should serve as a brief visual addition to your written report and will be graded for content and quality.\nFor submission, convert these slides to a .pdf document, and submit the PDF of the slides on Gradescope.\nThe slide deck should have no more than 6 content slides + 1 title slide. Here is a suggested outline as you think through the slides; you do not have to use this exact format for the 6 slides.\n\nTitle Slide\nSlide 1: Introduce the topic and motivation\nSlide 2: Introduce the data\nSlide 3: Highlights from EDA\nSlide 4: Final model\nSlide 5: Interesting findings from the model\nSlide 6: Conclusions + future work\n\n\n\nVideo presentation\nFor the video presentation, you can speak over your slide deck, similar to the lecture content videos. The video presentation must be no longer than 8 minutes. It is fine if the video is shorter than 8 minutes, but it cannot exceed 8 minutes. You may use can use any platform that works best for your group to record your presentation. Below are a few resources on recording videos:\n\nRecording presentations in Zoom\nApple Quicktime for screen recording\nWindows 10 built-in screen recording functionality\nKap for screen recording\n\nOnce your video is ready, upload the video to Warpwire, then embed the video in an new discussion post on Conversations.\n\nTo upload your video to Warpwire:\n\nClick the Warpwire tab in the course Sakai site.\nClick the “+” and select “Upload files”.\nLocate the video on your computer and click to upload.\nOnce you’ve uploaded the video to Warpwire, click to share the video and copy the video’s URL. You will need this when you post the video in the discussion forum.\n\n\n\nTo post the video to the discussion forum\n\nClick the Presentations tab in the course Sakai site.\nClick the Presentations topic.\nClick “Start a new conversation”.\nMake the title “Your Team Name: Project Title”. For example, “Teaching Team: Our Awesome Presentation”.\nClick the Warpwire icon (between the table and shopping cart icons).\nSelect your video, then click “Insert 1 item.” This will embed your video in the conversation.\nUnder the video, paste the URL to your video.\nYou’re done!"
  },
  {
    "objectID": "project-description.html#presentation-comments",
    "href": "project-description.html#presentation-comments",
    "title": "Project description",
    "section": "Presentation comments",
    "text": "Presentation comments\nEach student will be assigned 2 presentations to watch. Your viewing assignments will be posted later in the semester.\nWatch the group’s video, then click “Reply” to post a question for the group. You may not post a question that’s already been asked on the discussion thread. Additionally, the question should be (i) substantive (i.e. it shouldn’t be “Why did you use a bar plot instead of a pie chart”?), (ii) demonstrate your understanding of the content from the course, and (iii) relevant to that group’s specific presentation, i.e demonstrating that you’ve watched the presentation.\nThis portion of the project will be assessed individually.\n\nPairings\nFind your team name in the first column, watch videos from teams in the second column and leave comments.\n\n\n\n\n\n\n\n\nReviewer\nFirst video to review\nSecond video to review\n\n\n\n\nGinger and Stats\nEight\nWe R\n\n\nKrafthouse\nGinger and Stats\nEight\n\n\nSoy Nuggets\nKrafthouse\nGinger and Stats\n\n\nDown To Earth Goats\nSoy Nuggets\nKrafthouse\n\n\nA+++\nDown To Earth Goats\nSoy Nuggets\n\n\nTeam Five\nA+++\nDown To Earth Goats\n\n\nRrawr\nTeam Five\nA+++\n\n\nHousecats\nRrawr\nTeam Five\n\n\nDekk\nHousecats\nRrawr\n\n\nStat OverFlow\nDekk\nHousecats\n\n\nThe Three Musketeers\nStat OverFlow\nDekk\n\n\nPredictors\nThe Three Musketeers\nStat OverFlow\n\n\nStats Squad\nPredictors\nThe Three Musketeers\n\n\nStatisix\nStats Squad\nPredictors\n\n\nSixers\nStatisix\nStats Squad\n\n\nYay Stats\nSixers\nStatisix\n\n\nTINA\nYay Stats\nSixers\n\n\nStatchelorettes\nTINA\nYay Stats\n\n\nPineapple Wedge and Diced Papaya\nStatchelorettes\nTINA\n\n\nChaa Chaa Chaa\nPineapple Wedge and Diced Papaya\nStatchelorettes\n\n\nWe R\nChaa Chaa Chaa\nPineapple Wedge and Diced Papaya\n\n\nEight\nWe R\nChaa Chaa Chaa"
  },
  {
    "objectID": "project-description.html#reproducibility-organization",
    "href": "project-description.html#reproducibility-organization",
    "title": "Project description",
    "section": "Reproducibility + organization",
    "text": "Reproducibility + organization\nAll written work (with exception of presentation slides) should be reproducible, and the GitHub repo should be neatly organized.\nThe GitHub repo should have the following structure:\n\nREADME: Short project description and data dictionary\nwritten-report.qmd & written-report.pdf: Final written report\n/data: Folder that contains the data set for the final project.\n/previous-work: Folder that contains the topic-ideas and project-proposal files.\n/presentation: Folder with the presentation slides.\n\nIf your presentation slides are online, you can put a link to the slides in a README.md file in the presentation folder.\n\n\nPoints for reproducibility + organization will be based on the reproducibility of the written report and the organization of the project GitHub repo. The repo should be neatly organized as described above, there should be no extraneous files, all text in the README should be easily readable."
  },
  {
    "objectID": "project-description.html#peer-teamwork-evaluation",
    "href": "project-description.html#peer-teamwork-evaluation",
    "title": "Project description",
    "section": "Peer teamwork evaluation",
    "text": "Peer teamwork evaluation\nYou will be asked to fill out a survey where you rate the contribution and teamwork of each team member by assigning a contribution percentage for each team member. Filling out the survey is a prerequisite for getting credit on the team member evaluation. If you are suggesting that an individual did less than half the expected contribution given your team size (e.g., for a team of four students, if a student contributed less than 12.5% of the total effort), please provide some explanation. If any individual gets an average peer score indicating that this was the case, their grade will be assessed accordingly.\nIf you have concerns with the teamwork and/or contribution from any team members, please email me by the project video deadline. You only need to email me if you have concerns. Otherwise, I will assume everyone on the team equally contributed and will receive full credit for the teamwork portion of the grade."
  },
  {
    "objectID": "project-description.html#overall-grading",
    "href": "project-description.html#overall-grading",
    "title": "Project description",
    "section": "Overall grading",
    "text": "Overall grading\nThe grade breakdown is as follows:\n\n\n\nTotal\n100 pts\n\n\n\n\nTopic ideas\n5 pts\n\n\nProject proposal\n10 pts\n\n\nPeer review\n10 pts\n\n\nWritten report\n40 pts\n\n\nSlides + video presentation\n20 pts\n\n\nReproducibility + organization\n5 pts\n\n\nVideo comments\n5 pts\n\n\nPeer teamwork evaluation\n5 pts\n\n\n\nNote: No late project reports or videos are accepted.\n\nGrading summary\nGrading of the project will take into account the following:\n\nContent - What is the quality of research and/or policy question and relevancy of data to those questions?\nCorrectness - Are statistical procedures carried out and explained correctly?\nWriting and Presentation - What is the quality of the statistical presentation, writing, and explanations?\nCreativity and Critical Thought - Is the project carefully thought out? Are the limitations carefully considered? Does it appear that time and effort went into the planning and implementation of the project?\n\nA general breakdown of scoring is as follows:\n\n90%-100%: Outstanding effort. Student understands how to apply all statistical concepts, can put the results into a cogent argument, can identify weaknesses in the argument, and can clearly communicate the results to others.\n80%-89%: Good effort. Student understands most of the concepts, puts together an adequate argument, identifies some weaknesses of their argument, and communicates most results clearly to others.\n70%-79%: Passing effort. Student has misunderstanding of concepts in several areas, has some trouble putting results together in a cogent argument, and communication of results is sometimes unclear.\n60%-69%: Struggling effort. Student is making some effort, but has misunderstanding of many concepts and is unable to put together a cogent argument. Communication of results is unclear.\nBelow 60%: Student is not making a sufficient effort.\n\n\n\nLate work policy\nThere is no late work accepted on this project. Be sure to turn in your work early to avoid any technological mishaps."
  },
  {
    "objectID": "schemas-listings.html",
    "href": "schemas-listings.html",
    "title": "Schemas",
    "section": "",
    "text": "Avertissement\n\n\n\nPour écrire des requêtes correctes, il est néecessaire de maîtriser le schéma sur lequel on travaille.\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Schéma\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Tags\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nDate\n\n\nSchéma\n\n\nTags\n\n\n\n\n\n\nSep 18, 2025\n\n\nWorld\n\n\nworld, crowfoot\n\n\n\n\nSep 18, 2025\n\n\nBabynames\n\n\nbabynames, INSEE, counts, crowfoot\n\n\n\n\nSep 18, 2025\n\n\nNYCflights\n\n\nnycflights13, messy data, roles, datetime, star, crowfoot\n\n\n\n\nSep 18, 2025\n\n\nPagila\n\n\npagila, vues, fonctions\n\n\n\n\nSep 22, 2025\n\n\nDell DVD Store\n\n\ndellstore, Dell DVD store, crowfoot\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Schemas"
    ]
  },
  {
    "objectID": "schemas/schema-pagila-address.html",
    "href": "schemas/schema-pagila-address.html",
    "title": "Schéma : pagila (films)",
    "section": "",
    "text": "Présentation de la partie address du schéma pagila, pour l’entrainement à PostGres."
  },
  {
    "objectID": "schemas/schema-pagila-address.html#contexte",
    "href": "schemas/schema-pagila-address.html#contexte",
    "title": "Schéma : pagila (films)",
    "section": "Contexte",
    "text": "Contexte"
  },
  {
    "objectID": "schemas/schema-pagila-address.html#table-pagila.address",
    "href": "schemas/schema-pagila-address.html#table-pagila.address",
    "title": "Schéma : pagila (films)",
    "section": "Table pagila.address",
    "text": "Table pagila.address\n\n\n\n\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\naddress_id\ninteger DEFAULT nextval(‘pagila.address_address_id_seq’::regclass)\n\n\n*\naddress\nvarchar(50)\n\n\n\naddress2\nvarchar(50)\n\n\n*\ndistrict\nvarchar(20)\n\n\n* 🔎 ⬈\ncity_id\nsmallint\n\n\n\npostal_code\nvarchar(10)\n\n\n*\nphone\nvarchar(20)\n\n\n*\nlast_update\ntimestamp DEFAULT now()\n\n\n\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\n\naddress_city_id_fkey\n( city_id ) ref pagila.city (city_id)"
  },
  {
    "objectID": "schemas/schema-pagila-address.html#table-pagila.city",
    "href": "schemas/schema-pagila-address.html#table-pagila.city",
    "title": "Schéma : pagila (films)",
    "section": "Table pagila.city",
    "text": "Table pagila.city\n\n\n\n\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\ncity_id\ninteger DEFAULT nextval(‘pagila.city_city_id_seq’::regclass)\n\n\n*\ncity\nvarchar(50)\n\n\n* 🔎 ⬈\ncountry_id\nsmallint\n\n\n*\nlast_update\ntimestamp DEFAULT now()\n\n\n\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\n\ncity_country_id_fkey\n( country_id ) ref pagila.country (country_id)"
  },
  {
    "objectID": "schemas/schema-pagila-address.html#table-pagila.country",
    "href": "schemas/schema-pagila-address.html#table-pagila.country",
    "title": "Schéma : pagila (films)",
    "section": "Table pagila.country",
    "text": "Table pagila.country\n\n\n\n\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\ncountry_id\ninteger DEFAULT nextval(‘pagila.country_country_id_seq’::regclass)\n\n\n*\ncountry\nvarchar(50)\n\n\n*\nlast_update\ntimestamp DEFAULT now()"
  },
  {
    "objectID": "schemas/schema-pagila-address.html#table-pagila.customer",
    "href": "schemas/schema-pagila-address.html#table-pagila.customer",
    "title": "Schéma : pagila (films)",
    "section": "Table pagila.customer",
    "text": "Table pagila.customer\n\n\n\n\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\ncustomer_id\ninteger DEFAULT nextval(‘pagila.customer_customer_id_seq’::regclass)\n\n\n* 🔎 ⬈\nstore_id\nsmallint\n\n\n*\nfirst_name\nvarchar(45)\n\n\n* 🔎\nlast_name\nvarchar(45)\n\n\n\nemail\nvarchar(50)\n\n\n* 🔎 ⬈\naddress_id\nsmallint\n\n\n*\nactivebool\nboolean DEFAULT true\n\n\n*\ncreate_date\ndate DEFAULT (‘now’::text)::date\n\n\n\nlast_update\ntimestamp DEFAULT now()\n\n\n\nactive\ninteger\n\n\n\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\n\ncustomer_store_id_fkey\n( store_id ) ref pagila.store (store_id)\n\n\n\ncustomer_address_id_fkey\n( address_id ) ref pagila.address (address_id)"
  },
  {
    "objectID": "schemas/schema-pagila-address.html#table-pagila.staff",
    "href": "schemas/schema-pagila-address.html#table-pagila.staff",
    "title": "Schéma : pagila (films)",
    "section": "Table pagila.staff",
    "text": "Table pagila.staff\n\n\n\n\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\nstaff_id\ninteger DEFAULT nextval(‘pagila.staff_staff_id_seq’::regclass)\n\n\n*\nfirst_name\nvarchar(45)\n\n\n*\nlast_name\nvarchar(45)\n\n\n* ⬈\naddress_id\nsmallint\n\n\n\nemail\nvarchar(50)\n\n\n* ⬈\nstore_id\nsmallint\n\n\n*\nactive\nboolean DEFAULT true\n\n\n*\nusername\nvarchar(16)\n\n\n\npassword\nvarchar(40)\n\n\n*\nlast_update\ntimestamp DEFAULT now()\n\n\n\npicture\nbytea\n\n\n\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\n\nstaff_store_id_fkey\n( store_id ) ref pagila.store (store_id)\n\n\n\nstaff_address_id_fkey\n( address_id ) ref pagila.address (address_id)"
  },
  {
    "objectID": "schemas/schema-pagila-address.html#table-pagila.store",
    "href": "schemas/schema-pagila-address.html#table-pagila.store",
    "title": "Schéma : pagila (films)",
    "section": "Table pagila.store",
    "text": "Table pagila.store\n\n\n\n\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\nstore_id\ninteger DEFAULT nextval(‘pagila.store_store_id_seq’::regclass)\n\n\n* 🔍 ⬈\nmanager_staff_id\nsmallint\n\n\n* ⬈\naddress_id\nsmallint\n\n\n*\nlast_update\ntimestamp DEFAULT now()\n\n\n\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\n\nstore_manager_staff_id_fkey\n( manager_staff_id ) ref pagila.staff (staff_id)\n\n\n\nstore_address_id_fkey\n( address_id ) ref pagila.address (address_id)"
  },
  {
    "objectID": "schemas/schema-pagila.html",
    "href": "schemas/schema-pagila.html",
    "title": "Schéma : pagila",
    "section": "",
    "text": "Présentation de la partie film du schéma pagila, pour l’entrainement à PostGres."
  },
  {
    "objectID": "schemas/schema-pagila.html#contexte",
    "href": "schemas/schema-pagila.html#contexte",
    "title": "Schéma : pagila",
    "section": "Contexte",
    "text": "Contexte\nDescription de presque toutes les tables de la base pagila ,\n\nPagemaison de la base de données pagila.\nPagemaison de la base de données sakila\nDétails sur les films\nDétails sur les adresses, clients, magasins, paiements\n\npagila est une base d’entrainement pour PostgreSQL. Cette base est une adaptation de la base sakila utilisée pour l’entrainement à MySQL.\nLa base pagila est censée permettre de gérer les prêts et la facturation d’une chaine fictive de magasins de location de DVD (une activité commerciale florissante durant les années 1990 et au début des années 2000).\nLe schéma pagila est formé de 15 tables. Un groupe de tables concerne les films diponibles au catalogue de la chaîne de magasins: film, actor, language, category, film_actor, film_category.\nLes lignes de la table film sont les entrées du catalogue de la chaîne. Une ligne est identifiée par l’attribut film_id (noter l’attribution automatique des identifiants grâce au mécanisme des séquences).\nUn film possède une distribution constituée d’actrices et d’acteurs. Comme une actrice peut jouer dans plusieurs films, l’association plusieurs-à-plusieurs entre films et acteurs/actrices est rerésentée par une table intémédiaire film_actor.\nUn film relève d’une ou plusieurs catégories. Là encore, l’association plusieurs-à-plusieurs entre films et catégories est rerésentée par une table intémédiaire film_category.\nUne entrée au catalogue correspond à un titre de film tourné dans une certaine langue (la langue originale) et à une bande son dans une langue qui peut être différente de la langue originale.\n\n\n\n\n\n\nNotons ici qu’une entrée de la table film ne correspond pas tout à fait à l’idée que nous nous faisons d’un film (entrée dans la base IMDB), mais plutôt à une édition (simplifiée) de film en DVD.\n\n\n\nUne film disponible au catalogue correspond à un ou plusieurs DVD (objets physiques) qui sont représentés par des lignes de la table inventory. Les conditions de location d’un même titre (ligne de film) sont identiques pour les DVDs physiques correspondant au même titre.\nUn ligne de la table inventory peut faire l’objet d’une location qui correspond à une ligne de rental. La table rental est encore un cas de table intermédiaire entre les tables inventory, customer (client) et staff (employé). Le fait qu’il s’agisse d’une table intermédiaire destinée à représenter une association ternaire plusieurs-à-plusieurs entre élément d’inventaire, client et employé est en partie caché par le fait que rental possède un identifiant propre rental_id. Un élément de rental devrait pouvoir être identifié grâce aux identifiants des lignes participantes de inventory, customer et staff et à un identifiant relatif comme rental_date.\nUn client est rattaché à un magasin (store). Les employés sont eux aussi attachés à un magasin.\nLes clients, employés et magasins sont liés à une adresse (address) qui relève d’une ville (city) qui elle même relève d’un pays (country).\nUn paiement relie un employé à un client à propos d’une location."
  },
  {
    "objectID": "schemas/schema-pagila.html#table-pagila.address",
    "href": "schemas/schema-pagila.html#table-pagila.address",
    "title": "Schéma : pagila",
    "section": "Table pagila.address",
    "text": "Table pagila.address\n\n\n\n\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\naddress_id\ninteger DEFAULT nextval(‘pagila.address_address_id_seq’::regclass)\n\n\n*\naddress\nvarchar(50)\n\n\n\naddress2\nvarchar(50)\n\n\n*\ndistrict\nvarchar(20)\n\n\n* 🔎 ⬈\ncity_id\nsmallint\n\n\n\npostal_code\nvarchar(10)\n\n\n*\nphone\nvarchar(20)\n\n\n*\nlast_update\ntimestamp DEFAULT now()\n\n\n\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\n\naddress_city_id_fkey\n( city_id ) ref pagila.city (city_id)\n\n\n\n Dans les tables address, city, country, store, inventory, rental, actor, film, category, language, payment, on trouve une colonne nommée nom de la table_id qui est la clé primaire de la table. Cette colonne est (en général) renseignée automatiquement : la valeur par défaut est calculée en invoquant la fonction nextval() sur la séquence associée à la table. La clé primaire ne comporte d’information intéressante pour l’usager final, elle correspond à un rang d’insertion dans la table.\n Les tables de pagila comportent une colonne last_update (dernière mise-à-jour) de type timestamp (instant, nombre de secondes écoulées depuis le premier janvier 1970, origine des temps selon Unix). Cette colonne est remplie (renseignée) automatiquement lors des insertions et mises à jour grâce à la valeur par défaut calculée par la fonction now().\n\n\n\n\n\n\nLes colonnes last_update des différentes tables de pagila n’ont rien à voir les unes avec les autres (vérifier l’absence de contrainte référentielle au sujet de ces colonnes). Il n’est donc pas question (en général) d’utiliser ces colonnes last_update pour effectuer des jointures entre les tables de pagila.\nLa présence des colonnes last_update nous empêche de faire des jointures naturelles (NATURAL JOIN) entre film, film_actor, actor, etc.\nSELECT count(*) \nFROM \n  film\nJOIN\n  film_actor \nUSING(film_id) ;\n\n count \n-------\n  5462\nalors que\nSELECT count(*) \nFROM \n  film\nNATURAL JOIN\n  film_actor ;\n\n count \n-------\n     0"
  },
  {
    "objectID": "schemas/schema-pagila.html#table-pagila.city",
    "href": "schemas/schema-pagila.html#table-pagila.city",
    "title": "Schéma : pagila",
    "section": "Table pagila.city",
    "text": "Table pagila.city\n\n\n\n\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\ncity_id\ninteger DEFAULT nextval(‘pagila.city_city_id_seq’::regclass)\n\n\n*\ncity\nvarchar(50)\n\n\n* 🔎 ⬈\ncountry_id\nsmallint\n\n\n*\nlast_update\ntimestamp DEFAULT now()\n\n\n\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\n\ncity_country_id_fkey\n( country_id ) ref pagila.country (country_id)\n\n\n\n On dit que la contrainte référentielle city_country_id_fkey est émise par l’attribut country_id de la table city vers l’attribut country_id de la table country. Une ville n’appartient qu’à un seul pays, mais un pays peut comporter plusieurs villes."
  },
  {
    "objectID": "schemas/schema-pagila.html#table-pagila.country",
    "href": "schemas/schema-pagila.html#table-pagila.country",
    "title": "Schéma : pagila",
    "section": "Table pagila.country",
    "text": "Table pagila.country\n\n\n\n\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\ncountry_id\ninteger DEFAULT nextval(‘pagila.country_country_id_seq’::regclass)\n\n\n*\ncountry\nvarchar(50)\n\n\n*\nlast_update\ntimestamp DEFAULT now()"
  },
  {
    "objectID": "schemas/schema-pagila.html#table-pagila.customer",
    "href": "schemas/schema-pagila.html#table-pagila.customer",
    "title": "Schéma : pagila",
    "section": "Table pagila.customer",
    "text": "Table pagila.customer\n\n\n\n\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\ncustomer_id\ninteger DEFAULT nextval(‘pagila.customer_customer_id_seq’::regclass)\n\n\n* 🔎 ⬈\nstore_id\nsmallint\n\n\n*\nfirst_name\nvarchar(45)\n\n\n* 🔎\nlast_name\nvarchar(45)\n\n\n\nemail\nvarchar(50)\n\n\n* 🔎 ⬈\naddress_id\nsmallint\n\n\n*\nactivebool\nboolean DEFAULT true\n\n\n*\ncreate_date\ndate DEFAULT (‘now’::text)::date\n\n\n\nlast_update\ntimestamp DEFAULT now()\n\n\n\nactive\ninteger\n\n\n\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\n\ncustomer_store_id_fkey\n( store_id ) ref pagila.store (store_id)\n\n\n\ncustomer_address_id_fkey\n( address_id ) ref pagila.address (address_id)"
  },
  {
    "objectID": "schemas/schema-pagila.html#table-pagila.film",
    "href": "schemas/schema-pagila.html#table-pagila.film",
    "title": "Schéma : pagila",
    "section": "Table pagila.film",
    "text": "Table pagila.film\n\n\n\n\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\nfilm_id\ninteger DEFAULT nextval(‘pagila.film_film_id_seq’::regclass)\n\n\n* 🔎\ntitle\nvarchar(255)\n\n\n\ndescription\ntext\n\n\n\nrelease_year\nyear\n\n\n* 🔎 ⬈\nlanguage_id\nsmallint\n\n\n🔎 ⬈\noriginal_language_id\nsmallint\n\n\n*\nrental_duration\nsmallint DEFAULT 3\n\n\n*\nrental_rate\nnumeric(4,2) DEFAULT 4.99\n\n\n\nlength\nsmallint\n\n\n*\nreplacement_cost\nnumeric(5,2) DEFAULT 19.99\n\n\n\nrating\nmpaa_rating DEFAULT ‘G’::pagila.mpaa_rating\n\n\n*\nlast_update\ntimestamp DEFAULT now()\n\n\n\nspecial_features\ntext[]\n\n\n\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\n\nfilm_original_language_id_fkey\n( original_language_id ) ref pagila.language (language_id)\n\n\n\nfilm_language_id_fkey\n( language_id ) ref pagila.language (language_id)"
  },
  {
    "objectID": "schemas/schema-pagila.html#table-pagila.inventory",
    "href": "schemas/schema-pagila.html#table-pagila.inventory",
    "title": "Schéma : pagila",
    "section": "Table pagila.inventory",
    "text": "Table pagila.inventory\n\n\n\n\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\ninventory_id\ninteger DEFAULT nextval(‘pagila.inventory_inventory_id_seq’::regclass)\n\n\n* 🔎 ⬈\nfilm_id\nsmallint\n\n\n* 🔎 ⬈\nstore_id\nsmallint\n\n\n*\nlast_update\ntimestamp DEFAULT now()\n\n\n\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\n\ninventory_store_id_fkey\n( store_id ) ref pagila.store (store_id)\n\n\n\ninventory_film_id_fkey\n( film_id ) ref pagila.film (film_id)\n\n\n\nUne instance d’inventory correspond à un support physique, quelque chose qui peut-être loué. Elle permet au client de voir une instance de film, soit un film dans une certaine langue."
  },
  {
    "objectID": "schemas/schema-pagila.html#table-pagila.payment",
    "href": "schemas/schema-pagila.html#table-pagila.payment",
    "title": "Schéma : pagila",
    "section": "Table pagila.payment",
    "text": "Table pagila.payment\n\n\n\n\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑\npayment_id\ninteger DEFAULT nextval(‘pagila.payment_payment_id_seq’::regclass)\n\n\n* 🔎 ⬈\ncustomer_id\nsmallint\n\n\n* 🔎 ⬈\nstaff_id\nsmallint\n\n\n* ⬈\nrental_id\ninteger\n\n\n*\namount\nnumeric(5,2)\n\n\n*\npayment_date\ntimestamp\n\n\n\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\n\npayment_staff_id_fkey\n( staff_id ) ref pagila.staff (staff_id)\n\n\n\npayment_rental_id_fkey\n( rental_id ) ref pagila.rental (rental_id)\n\n\n\npayment_customer_id_fkey\n( customer_id ) ref pagila.customer (customer_id)\n\n\n\nUn paiement (une ligne de payment) concerne une location (un tuple de rental), d’où la contrainte référentielle payment_rental_id_fkey. un paiement concerne ausi un client (tuple de customer) et un employé (tuple de staff)."
  },
  {
    "objectID": "schemas/schema-pagila.html#table-pagila.rental",
    "href": "schemas/schema-pagila.html#table-pagila.rental",
    "title": "Schéma : pagila",
    "section": "Table pagila.rental",
    "text": "Table pagila.rental\n\n\n\n\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\nrental_id\ninteger DEFAULT nextval(‘pagila.rental_rental_id_seq’::regclass)\n\n\n* 🔍\nrental_date\ntimestamp\n\n\n* 🔍 ⬈\ninventory_id\ninteger\n\n\n* 🔍 ⬈\ncustomer_id\nsmallint\n\n\n\nreturn_date\ntimestamp\n\n\n* ⬈\nstaff_id\nsmallint\n\n\n*\nlast_update\ntimestamp DEFAULT now()\n\n\n\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\n\nrental_staff_id_fkey\n( staff_id ) ref pagila.staff (staff_id)\n\n\n\nrental_inventory_id_fkey\n( inventory_id ) ref pagila.inventory (inventory_id)\n\n\n\nrental_customer_id_fkey\n( customer_id ) ref pagila.customer (customer_id)"
  },
  {
    "objectID": "schemas/schema-pagila.html#table-pagila.staff",
    "href": "schemas/schema-pagila.html#table-pagila.staff",
    "title": "Schéma : pagila",
    "section": "Table pagila.staff",
    "text": "Table pagila.staff\n\n\n\n\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\nstaff_id\ninteger DEFAULT nextval(‘pagila.staff_staff_id_seq’::regclass)\n\n\n*\nfirst_name\nvarchar(45)\n\n\n*\nlast_name\nvarchar(45)\n\n\n* ⬈\naddress_id\nsmallint\n\n\n\nemail\nvarchar(50)\n\n\n* ⬈\nstore_id\nsmallint\n\n\n*\nactive\nboolean DEFAULT true\n\n\n*\nusername\nvarchar(16)\n\n\n\npassword\nvarchar(40)\n\n\n*\nlast_update\ntimestamp DEFAULT now()\n\n\n\npicture\nbytea\n\n\n\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\n\nstaff_store_id_fkey\n( store_id ) ref pagila.store (store_id)\n\n\n\nstaff_address_id_fkey\n( address_id ) ref pagila.address (address_id)"
  },
  {
    "objectID": "schemas/schema-pagila.html#table-pagila.store",
    "href": "schemas/schema-pagila.html#table-pagila.store",
    "title": "Schéma : pagila",
    "section": "Table pagila.store",
    "text": "Table pagila.store\n\n\n\n\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\nstore_id\ninteger DEFAULT nextval(‘pagila.store_store_id_seq’::regclass)\n\n\n* 🔍 ⬈\nmanager_staff_id\nsmallint\n\n\n* ⬈\naddress_id\nsmallint\n\n\n*\nlast_update\ntimestamp DEFAULT now()\n\n\n\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\n\nstore_manager_staff_id_fkey\n( manager_staff_id ) ref pagila.staff (staff_id)\n\n\n\nstore_address_id_fkey\n( address_id ) ref pagila.address (address_id)"
  },
  {
    "objectID": "td-listings.html",
    "href": "td-listings.html",
    "title": "Feuilles d’exercices",
    "section": "",
    "text": "Note\n\n\n\nLes feuilles d’exercice forment le matériau de base des TDS et TPS. Vous êtes invités à les lire avant la séance et à réfléchir par vous-même. Ne vous précipitez pas sur les propositions de corrections qui sont disponibles sur ce site\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Titre\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nDate\n\n\nTitre\n\n\nDescription\n\n\n\n\n\n\nSep 20, 2024\n\n\nTD 1: Algèbre relationnelle\n\n\nLogistique et Algèbre relationnelle\n\n\n\n\nSep 27, 2024\n\n\nTD 2: SQL\n\n\nSQL Interrogation de données\n\n\n\n\nOct 4, 2024\n\n\nTD 3: SQL\n\n\nSQL Interrogation de données, requêtes complexes\n\n\n\n\nOct 11, 2024\n\n\nTD 4: SQL\n\n\nAggrégations, Partitions, Fenêtres\n\n\n\n\nOct 18, 2024\n\n\nTD 5: SQL\n\n\nFenêtres et fonctions SQL\n\n\n\n\nOct 25, 2024\n\n\nTD 6 : Contraintes\n\n\nDéfinition de données Contraintes\n\n\n\n\nNov 8, 2024\n\n\nTD 7 : Contraintes (suite)\n\n\nDéfinition de données et Contraintes\n\n\n\n\nNov 15, 2024\n\n\nTD 8 : Modélisation\n\n\nModélisation\n\n\n\n\nNov 22, 2024\n\n\nTD 9: Normalisation et dépendances\n\n\nDépendances fonctionnelles\n\n\n\n\n\nNov 29, 2024\n\n\n\nTD 10: Normalisation\n\n\n\nNormalisation, Perte de DF, Perte d'Information, FNBC, FN3\n\n\n\n\n\n\nDec 6, 2024\n\n\n\nTD 11: Normalisation et dépendances\n\n\n\nNormalisation et dépendances\n\n\n\n\n\nDec 13, 2024\n\n\nTD Récapitulatif SQL\n\n\nTD révision générale\n\n\n\n\n\nNo matching items\n\n\n\n\n\n\n\n\nConseil\n\n\n\nAvant de travailler sur un exercice, assurez vous que vous maîtrisez/comprenez le schéma relationnel concerné.",
    "crumbs": [
      "Exercices"
    ]
  },
  {
    "objectID": "weeks/week-10.html",
    "href": "weeks/week-10.html",
    "title": "Semaine 10",
    "section": "",
    "text": "Important\n\n\n\n\nCours magistral en Amphi 2 Olympe de Gouges 14h-15h30\nTD/TP Ingémaths/METIS salle 2006 Etage 2 Sophie Germain Jeudi 13h30-16h00\nTD/TP MIASHS salles 2004-2005-2006 Étage 2 Sophie Germain Vendredi 15h45-18h15\n Emploi du temps MIASHS\n Emploi du temps Ingémaths/METIS",
    "crumbs": [
      "Journal",
      "Semaine 10"
    ]
  },
  {
    "objectID": "weeks/week-10.html#préparer",
    "href": "weeks/week-10.html#préparer",
    "title": "Semaine 10",
    "section": "Préparer",
    "text": "Préparer\nFinir TD 8 TD 8",
    "crumbs": [
      "Journal",
      "Semaine 10"
    ]
  },
  {
    "objectID": "weeks/week-10.html#cours-magistral-diapositives",
    "href": "weeks/week-10.html#cours-magistral-diapositives",
    "title": "Semaine 10",
    "section": "Cours magistral : diapositives",
    "text": "Cours magistral : diapositives\nNormalisation I",
    "crumbs": [
      "Journal",
      "Semaine 10"
    ]
  },
  {
    "objectID": "weeks/week-10.html#exercices-td-9",
    "href": "weeks/week-10.html#exercices-td-9",
    "title": "Semaine 10",
    "section": "Exercices : TD 9",
    "text": "Exercices : TD 9\nhtml pdf",
    "crumbs": [
      "Journal",
      "Semaine 10"
    ]
  },
  {
    "objectID": "weeks/week-10.html#solutions-du-td-8-semaine-9",
    "href": "weeks/week-10.html#solutions-du-td-8-semaine-9",
    "title": "Semaine 10",
    "section": "Solutions du TD 8 (Semaine 9)",
    "text": "Solutions du TD 8 (Semaine 9)\nhtml pdf",
    "crumbs": [
      "Journal",
      "Semaine 10"
    ]
  },
  {
    "objectID": "weeks/week-10.html#travail-personnel",
    "href": "weeks/week-10.html#travail-personnel",
    "title": "Semaine 10",
    "section": "Travail personnel",
    "text": "Travail personnel\nCC 1 2023-24\n\n\nretour à Agenda ⏎",
    "crumbs": [
      "Journal",
      "Semaine 10"
    ]
  },
  {
    "objectID": "weeks/week-12.html",
    "href": "weeks/week-12.html",
    "title": "Semaine 12",
    "section": "",
    "text": "Important\n\n\n\n\nCours magistral en Amphi 2 Olympe de Gouges 14h-15h30\nTD/TP Ingémaths/METIS salle 2006 Etage 2 Sophie Germain Jeudi 13h30-16h00\nTD/TP MIASHS salles 2004-2005-2006 Étage 2 Sophie Germain Vendredi 15h45-18h15\n Emploi du temps MIASHS\n Emploi du temps Ingémaths/METIS",
    "crumbs": [
      "Journal",
      "Semaine 12"
    ]
  },
  {
    "objectID": "weeks/week-12.html#préparer",
    "href": "weeks/week-12.html#préparer",
    "title": "Semaine 12",
    "section": "Préparer",
    "text": "Préparer\nFinir TD 10 TD 10",
    "crumbs": [
      "Journal",
      "Semaine 12"
    ]
  },
  {
    "objectID": "weeks/week-12.html#cours-magistral-diapositives",
    "href": "weeks/week-12.html#cours-magistral-diapositives",
    "title": "Semaine 12",
    "section": "Cours magistral : diapositives",
    "text": "Cours magistral : diapositives\nNormalisation III",
    "crumbs": [
      "Journal",
      "Semaine 12"
    ]
  },
  {
    "objectID": "weeks/week-12.html#exercices-td-11",
    "href": "weeks/week-12.html#exercices-td-11",
    "title": "Semaine 12",
    "section": "Exercices : TD 11",
    "text": "Exercices : TD 11\nhtml pdf",
    "crumbs": [
      "Journal",
      "Semaine 12"
    ]
  },
  {
    "objectID": "weeks/week-12.html#solutions-du-td-9-semaine-10",
    "href": "weeks/week-12.html#solutions-du-td-9-semaine-10",
    "title": "Semaine 12",
    "section": "Solutions du TD 9 (Semaine 10)",
    "text": "Solutions du TD 9 (Semaine 10)\nhtml pdf",
    "crumbs": [
      "Journal",
      "Semaine 12"
    ]
  },
  {
    "objectID": "weeks/week-12.html#travail-personnel",
    "href": "weeks/week-12.html#travail-personnel",
    "title": "Semaine 12",
    "section": "Travail personnel",
    "text": "Travail personnel\nCC 1 2023-24\n\n\nretour à Agenda ⏎",
    "crumbs": [
      "Journal",
      "Semaine 12"
    ]
  },
  {
    "objectID": "weeks/week-2.html",
    "href": "weeks/week-2.html",
    "title": "Semaine 2",
    "section": "",
    "text": "Important\n\n\n\n\nCours magistral en Amphi 2 Olympe de Gouges 14h-15h30\nTD/TP 2004-2005-2006 Étage 2 Sophie Germain 15h45-18h15\n Emploi du temps",
    "crumbs": [
      "Journal",
      "Semaine 2"
    ]
  },
  {
    "objectID": "weeks/week-2.html#préparer",
    "href": "weeks/week-2.html#préparer",
    "title": "Semaine 2",
    "section": "Préparer",
    "text": "Préparer\nRequêtes du TD 1 TD 1",
    "crumbs": [
      "Journal",
      "Semaine 2"
    ]
  },
  {
    "objectID": "weeks/week-2.html#cours-magistral-diapositives",
    "href": "weeks/week-2.html#cours-magistral-diapositives",
    "title": "Semaine 2",
    "section": "Cours magistral : diapositives",
    "text": "Cours magistral : diapositives\nReprise de Introduction à l’algèbre relationnelle au  renommage jusqu’à Exemples de requêtes (sans aborder les jointures externes)\nPuis nous aborderons le langage de requêtes SQL dans SQL requêtes élémentaires jusqu’à Syntaxe de la clause WHERE",
    "crumbs": [
      "Journal",
      "Semaine 2"
    ]
  },
  {
    "objectID": "weeks/week-2.html#exercices-tdtp-1",
    "href": "weeks/week-2.html#exercices-tdtp-1",
    "title": "Semaine 2",
    "section": "Exercices : TD/TP 1",
    "text": "Exercices : TD/TP 1\nNous abordons avec les outils de l’algèbre relationnelle et de SQL les questions posées dans le td1 :\nhtml pdf",
    "crumbs": [
      "Journal",
      "Semaine 2"
    ]
  },
  {
    "objectID": "weeks/week-2.html#travail-personnel-optionnel",
    "href": "weeks/week-2.html#travail-personnel-optionnel",
    "title": "Semaine 2",
    "section": "Travail personnel (optionnel)",
    "text": "Travail personnel (optionnel)\n\nEssayer d’installer un client sur votre ordinateur personnel\nEssayez d’établir une connexion ssh entre votre ordinateur personnel et etu-pgsql.math.univ-paris-diderot.fr et depuis cette machine de vous connecter au serveur PostGres (par exemple via psql -d bd_2023-24)\nEssayez d’établir un tunnel ssh entre votre ordinateur personnel et etu-pgsql.math.univ-paris-diderot.fr, puis de vous connecter au serveur PostGres depuis le client installé sur votre machine\n\nEssayer de finir le TD 1\nVous pouvez aussi vous entrainer sur annales :\nCC 1 2023-24\n\n\nretour à Agenda ⏎",
    "crumbs": [
      "Journal",
      "Semaine 2"
    ]
  },
  {
    "objectID": "weeks/week-4.html",
    "href": "weeks/week-4.html",
    "title": "Semaine 4",
    "section": "",
    "text": "Important\n\n\n\n\nCours magistral en Amphi 2 Olympe de Gouges 14h-15h30\nTD/TP Ingémaths/METIS salle 2006 Etage 2 Sophie Germain Jeudi 13h30-16h00\nTD/TP MIASHS salles 2004-2005-2006 Étage 2 Sophie Germain Vendredi 15h45-18h15\n Emploi du temps MIASHS\n Emploi du temps Ingémaths/METIS",
    "crumbs": [
      "Journal",
      "Semaine 4"
    ]
  },
  {
    "objectID": "weeks/week-4.html#préparer",
    "href": "weeks/week-4.html#préparer",
    "title": "Semaine 4",
    "section": "Préparer",
    "text": "Préparer\nFinir requêtes du TD 2 TD 2",
    "crumbs": [
      "Journal",
      "Semaine 4"
    ]
  },
  {
    "objectID": "weeks/week-4.html#cours-magistral-diapositives",
    "href": "weeks/week-4.html#cours-magistral-diapositives",
    "title": "Semaine 4",
    "section": "Cours magistral : diapositives",
    "text": "Cours magistral : diapositives\nSQL Aggrégations/Fenêtres et Partitions",
    "crumbs": [
      "Journal",
      "Semaine 4"
    ]
  },
  {
    "objectID": "weeks/week-4.html#exercices-td-3",
    "href": "weeks/week-4.html#exercices-td-3",
    "title": "Semaine 4",
    "section": "Exercices : TD 3",
    "text": "Exercices : TD 3\nCommencer\n\nEnoncés html pdf\nSolutions html pdf",
    "crumbs": [
      "Journal",
      "Semaine 4"
    ]
  },
  {
    "objectID": "weeks/week-4.html#solutions-du-td-2-semaine-3",
    "href": "weeks/week-4.html#solutions-du-td-2-semaine-3",
    "title": "Semaine 4",
    "section": "Solutions du TD 2 (Semaine 3)",
    "text": "Solutions du TD 2 (Semaine 3)\nhtml pdf\n Construisez des vues à partir de vos requêtes",
    "crumbs": [
      "Journal",
      "Semaine 4"
    ]
  },
  {
    "objectID": "weeks/week-4.html#travail-personnel",
    "href": "weeks/week-4.html#travail-personnel",
    "title": "Semaine 4",
    "section": "Travail personnel ",
    "text": "Travail personnel \nCC 1 2023-24\n\n\nretour à Agenda ⏎",
    "crumbs": [
      "Journal",
      "Semaine 4"
    ]
  },
  {
    "objectID": "weeks/week-6.html",
    "href": "weeks/week-6.html",
    "title": "Semaine 5",
    "section": "",
    "text": "Important\n\n\n\n\nCours magistral en Amphi 2 Olympe de Gouges 14h-15h30\nTD/TP Ingémaths/METIS salle 2006 Etage 2 Sophie Germain Jeudi 13h30-16h00\nTD/TP MIASHS salles 2004-2005-2006 Étage 2 Sophie Germain Vendredi 15h45-18h15\n Emploi du temps MIASHS\n Emploi du temps Ingémaths/METIS",
    "crumbs": [
      "Journal",
      "Semaine 6"
    ]
  },
  {
    "objectID": "weeks/week-6.html#préparer",
    "href": "weeks/week-6.html#préparer",
    "title": "Semaine 5",
    "section": "Préparer",
    "text": "Préparer\nFinir requêtes du TD 3 TD 4 en particulier les questions portant sur la partie verte du schéma pagila",
    "crumbs": [
      "Journal",
      "Semaine 6"
    ]
  },
  {
    "objectID": "weeks/week-6.html#cours-magistral-diapositives",
    "href": "weeks/week-6.html#cours-magistral-diapositives",
    "title": "Semaine 5",
    "section": "Cours magistral : diapositives",
    "text": "Cours magistral : diapositives\nFonctions SQL, Vues et requêtes préparées",
    "crumbs": [
      "Journal",
      "Semaine 6"
    ]
  },
  {
    "objectID": "weeks/week-6.html#exercices-td-4",
    "href": "weeks/week-6.html#exercices-td-4",
    "title": "Semaine 5",
    "section": "Exercices : TD 4",
    "text": "Exercices : TD 4\nhtml pdf\n Construisez des vues à partir de vos requêtes",
    "crumbs": [
      "Journal",
      "Semaine 6"
    ]
  },
  {
    "objectID": "weeks/week-6.html#solutions-du-td-3-semaine-5",
    "href": "weeks/week-6.html#solutions-du-td-3-semaine-5",
    "title": "Semaine 5",
    "section": "Solutions du TD 3 (Semaine 5)",
    "text": "Solutions du TD 3 (Semaine 5)\nhtml pdf",
    "crumbs": [
      "Journal",
      "Semaine 6"
    ]
  },
  {
    "objectID": "weeks/week-6.html#travail-personnel",
    "href": "weeks/week-6.html#travail-personnel",
    "title": "Semaine 5",
    "section": "Travail personnel",
    "text": "Travail personnel\nCC 1 2023-24\n\n\nretour à Agenda ⏎",
    "crumbs": [
      "Journal",
      "Semaine 6"
    ]
  },
  {
    "objectID": "weeks/week-8.html",
    "href": "weeks/week-8.html",
    "title": "Semaine 8",
    "section": "",
    "text": "Important\n\n\n\n\nCours magistral en Amphi 2 Olympe de Gouges 14h-15h30\nTD/TP Ingémaths/METIS salle 2006 Etage 2 Sophie Germain Jeudi 13h30-16h00\nTD/TP MIASHS salles 2004-2005-2006 Étage 2 Sophie Germain Vendredi 15h45-18h15\n Emploi du temps MIASHS\n Emploi du temps Ingémaths/METIS",
    "crumbs": [
      "Journal",
      "Semaine 8"
    ]
  },
  {
    "objectID": "weeks/week-8.html#cours-magistral-diapositives",
    "href": "weeks/week-8.html#cours-magistral-diapositives",
    "title": "Semaine 8",
    "section": "Cours magistral : diapositives",
    "text": "Cours magistral : diapositives\nModélisation I\nModèle Entité-Association (sauf les spécialisations)",
    "crumbs": [
      "Journal",
      "Semaine 8"
    ]
  },
  {
    "objectID": "weeks/week-8.html#exercices-td-5",
    "href": "weeks/week-8.html#exercices-td-5",
    "title": "Semaine 8",
    "section": "Exercices : TD 5",
    "text": "Exercices : TD 5\n\nhtml pdf \n\nContraintes",
    "crumbs": [
      "Journal",
      "Semaine 8"
    ]
  },
  {
    "objectID": "weeks/week-8.html#solutions-complétées-des-td-4-et-5-semaine-7",
    "href": "weeks/week-8.html#solutions-complétées-des-td-4-et-5-semaine-7",
    "title": "Semaine 8",
    "section": "Solutions complétées des TD 4 et 5 (Semaine 7)",
    "text": "Solutions complétées des TD 4 et 5 (Semaine 7)\n\nhtml pdf\nhtml pdf\n\n\n\nretour à Agenda ⏎",
    "crumbs": [
      "Journal",
      "Semaine 8"
    ]
  },
  {
    "objectID": "workshops/td1.html#schémas",
    "href": "workshops/td1.html#schémas",
    "title": "TD 1: Algèbre relationnelle",
    "section": "Schémas",
    "text": "Schémas\nLes schémas sont une abstraction spécifique à PostgreSQL. Les schémas permettent de faire cohabiter sur une même base de données (ou catalogue dans le jargon PostgreSQL) plusieurs ensembles d’informations de nature différentes. On peut indiquer à pgcli, psql ou un autre client (dbeaver ou autre) quels schémas on veut utiliser par défaut.\nDans ce TP, nous allons nous concentrer sur le schéma world qui contient des informations concernant des villes et des pays/territoires du monde entier. Au cours de ce semestre, nous serons amenés à utiliser d’autres schémas : pagila qui contient des informations concernant des films, …\nPour lister et modifier les schémas de votre environnement de travail:\nbd_2023-24&gt; SHOW search_path ;                  -- lister\nbd_2023-24&gt; SET search_path TO world, public ;  -- modifier\nbd_2023-24&gt; SHOW search_path ;       -- visualiser \nLister les schémas du catalogue bd_2023-24.\n\\dn\nPour lister les tables des schemas inscrits sur votre search_path.\nbd_2023-24&gt; \\d\n+----------+---------------------+--------+----------+\n| Schema   | Name                | Type   | Owner    |\n|----------+---------------------+--------+----------|\n| world    | city                | table  | postgres |\n| world    | country             | table  | postgres |\n| world    | countrylanguage     | table  | postgres |\n+----------+---------------------+--------+----------+\nVue d’ensemble du schéma world"
  },
  {
    "objectID": "workshops/td1.html#suggestion",
    "href": "workshops/td1.html#suggestion",
    "title": "TD 1: Algèbre relationnelle",
    "section": "Suggestion",
    "text": "Suggestion\nSi vous travaillez avec pgcli/psql, utilisez en local votre éditeur préféré (emacs, vi, sublime text, visual studio code, …), transférez votre script sql grâce à scp, et chargez le script dans votre session psql/pgcli à l’aide de \\\\i."
  },
  {
    "objectID": "workshops/td1.html#tables",
    "href": "workshops/td1.html#tables",
    "title": "TD 1: Algèbre relationnelle",
    "section": "Tables",
    "text": "Tables\nPour voir la définition (c’est-à-dire les différentes colonnes) d’une table:\nbd_2023-24&gt; \\d world.country\n\n+--------------------+---------------+-------------+\n| Column             | Type          | Modifiers   |\n|--------------------+---------------+-------------|\n| countrycode        | character(3)  |  not null   |\n| name_country       | text          |  not null   |\n| continent          | text          |  not null   |\n| region             | text          |  not null   |\n| surfacearea        | real          |  not null   |\n| indepyear          | smallint      |             |\n| population_country | integer       |  not null   |\n| lifeexpectancy     | real          |             |\n| gnp                | numeric(10,2) |             |\n| gnpold             | numeric(10,2) |             |\n| localname          | text          |  not null   |\n| governmentform     | text          |  not null   |\n| headofstate        | text          |             |\n| capital            | integer       |             |\n| code2              | character(2)  |  not null   |\n+--------------------+---------------+-------------+"
  },
  {
    "objectID": "workshops/td1.html#explorer-les-possibilités-de-psql-ou-de-pgcli",
    "href": "workshops/td1.html#explorer-les-possibilités-de-psql-ou-de-pgcli",
    "title": "TD 1: Algèbre relationnelle",
    "section": "Explorer les possibilités de psql ou de pgcli",
    "text": "Explorer les possibilités de psql ou de pgcli\nbd_2023-24&gt; \\?\nDans la deuxième partie du TP, on s’intéresse aux requêtes, c’est-à-dire, les moyens d’extraire une information pertinente d’une base de données."
  },
  {
    "objectID": "workshops/td7.html#schéma-pagila",
    "href": "workshops/td7.html#schéma-pagila",
    "title": "TD 7 : Contraintes (suite)",
    "section": "Schéma pagila",
    "text": "Schéma pagila\n\n\n\n\n\n\nQuestion\n\n\n\nImposer la contrainte suivante : un client ne peut emprunter plusieurs DVD simultanément.\n\n\n\n\n\n\n\n\nÉcrire d’abord une requête correspondant à la contrainte.\nLa requête est facile à écrire si on est prêt à utiliser le type tsrange, l’opérateur de recouvrement && (overlap).\nPostgresql documentation on range types\nDans l’instance du schéma pagila disponible sur le serveur etu-pgsql, la contrainte est-elle vérifiée ?\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nImposer la contrainte : un film est identifié par son titre, son année de sortie et sa langue originale.\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nImposer la contrainte : le prix de location doit être croissant en fonction de la durée du film\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nImposer la contrainte : un même DVD ne peut pas être loué simultanément à deux clients différents."
  },
  {
    "objectID": "workshops/td7.html#schéma-nycflights",
    "href": "workshops/td7.html#schéma-nycflights",
    "title": "TD 7 : Contraintes (suite)",
    "section": "Schéma nycflights",
    "text": "Schéma nycflights\n\n\n\n\n\n\nQuestion\n\n\n\nDans flights et weather imposer les contraintes\nyear, month, day, hour ⟶ time_hour\ntime_hour  ⟶  year, month, day, hour\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nDans flights imposer la contrainte : un aéronef ne peut pas effectuer deux missions simultanément.\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nDans flights imposer la contrainte : un aéronef ne peut pas être exploité par deux compagnies différentes à la même date.\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nDans planes, imposer les contraintes model ⟶ manufacturer et model ⟶ type"
  },
  {
    "objectID": "computing-dbeaver.html",
    "href": "computing-dbeaver.html",
    "title": "Client dbeaver",
    "section": "",
    "text": "À partir de Dbeaver community edition",
    "crumbs": [
      "Support",
      "Client dbeaver"
    ]
  },
  {
    "objectID": "computing-dbeaver.html#connections",
    "href": "computing-dbeaver.html#connections",
    "title": "Client dbeaver",
    "section": "Connections",
    "text": "Connections\nVous devrez créer une connection avec le serveur au sein de votre projet. Vous pouvez en créer d’autres avec d’autres serveurs, possiblement un serveur PostGres hébergé sur votre propre machine.",
    "crumbs": [
      "Support",
      "Client dbeaver"
    ]
  },
  {
    "objectID": "computing-dbeaver.html#bookmarkssignets",
    "href": "computing-dbeaver.html#bookmarkssignets",
    "title": "Client dbeaver",
    "section": "Bookmarks/Signets",
    "text": "Bookmarks/Signets\nDocumentation sur les signets\n\n\n\n\n\n\nTip\n\n\n\nVous pouvez créer des signets pour retrouver facilement les schémas sur lesquels vous travaillez, ou avez travaillé.",
    "crumbs": [
      "Support",
      "Client dbeaver"
    ]
  },
  {
    "objectID": "computing-dbeaver.html#diagrammes-er",
    "href": "computing-dbeaver.html#diagrammes-er",
    "title": "Client dbeaver",
    "section": "Diagrammes ER",
    "text": "Diagrammes ER\ndbeaver permet de faire un peu de rétro-ingénieurie et de visualiser (partiellement) un schéma. Outil utile quand on veut retoucher un schéma ou simplement le comprendre.",
    "crumbs": [
      "Support",
      "Client dbeaver"
    ]
  },
  {
    "objectID": "computing-dbeaver.html#scripts",
    "href": "computing-dbeaver.html#scripts",
    "title": "Client dbeaver",
    "section": "Scripts",
    "text": "Scripts\n\nUn script pour chaque séance de TD/TP\nNommer le script de façon utile (avec rename)\nCommenter le script\nSéparer les requêtes par des lignes blanches et une ligne de commentaire blanche --\nUtiliser le reformattage pour rendre votre code plus lisible",
    "crumbs": [
      "Support",
      "Client dbeaver"
    ]
  },
  {
    "objectID": "schemas/schema-dellstore.html",
    "href": "schemas/schema-dellstore.html",
    "title": "Schéma : dellstore",
    "section": "",
    "text": "Présentation du schéma dellstore, pour l’entrainement à PostGres."
  },
  {
    "objectID": "schemas/schema-dellstore.html#contexte",
    "href": "schemas/schema-dellstore.html#contexte",
    "title": "Schéma : dellstore",
    "section": "Contexte",
    "text": "Contexte\nLa base de données du magasin de DVD est gérée par six procédures stockées. Les deux premières sont utilisées pendant la phase de connexion.\nSi le client revient, la procédure Login est utilisée pour récupérer les informations du client, en particulier l’identifiant du client (CUSTOMERID). Si le client est un nouveau client, New_customer est utilisée pour créer une nouvelle ligne dans la table Customers avec les données de l’utilisateur. Après la phase de connexion, le client peut rechercher un DVD par catégorie, acteur ou titre, acteur ou titre. Ces critères sont mis en œuvre par Browse_by_category, Browse_by_actor et Browse_by_title, respectivement. Enfin, une fois que l’utilisateur a fait ses choix, la procédure stockée Purchase est appelée pour terminer la transaction.\nLes procédures stockées de l’application DS2 présentent des caractéristiques qui permettent de mieux modéliser les magasins en ligne d’aujourd’hui.\nLors de la connexion, par exemple, la commande précédente de l’utilisateur (jusqu’à dix titres) est signalée, ainsi que les titres recommandés par d’autres clients qui aiment ces titres.\nLa fonction Parcourir_par_catégorie renvoie les titres de la catégorie spécifiée qui sont actuellement en vente.\nEnfin, la procédure stockée Achat vérifie désormais le champ QUAN_IN_STOCK de la table Inventaire pour voir si un titre est disponible. Cette opération est réalisée à l’aide d’une transaction de base de données,\nde sorte que si la quantité est insuffisante pour honorer la commande, les données QUAN_IN_STOCK ne sont pas mises à jour et un nouvel enregistrement n’est pas écrit dans la base de données. ni un nouvel enregistrement dans la table ORDERS.\nLe schéma de la base de données « dellstore » dans PostgreSQL, utilisée à des fins de formation.\n\nTables :\n\ndellstore.categories : Contient les détails des catégories avec des colonnes comme category (clé primaire) et categoryname. (Action, Animation, Children, …, en tout 16 catégories)\ndellstore.cust_hist : Trace l’historique des clients avec des références aux clients , aux commandes (orders)et aux produits (products), en utilisant des clés étrangères (customerid, (*customers*)orderid, et prod_id).\ndellstore.customers : Stocke les informations sur les clients (customers) avec des champs tels que customerid, firstname, lastname, address, city, et creditcard details.\ndellstore.inventory : Gère l’inventaire des produits en suivant prod_id (clé primaire).\n\nClés étrangères :\n\ndellstore.cust_hist a des références de clés étrangères à d’autres tables comme customers, orders, et products.\n\n\nCe schéma décrit les tables clés utilisées pour une application de type commerce électronique, gérant les catégories, les informations sur les clients et les transactions. Vous souhaitez obtenir une description plus détaillée de certaines tables ou de leurs relations ?\nLes sources du schéma sont décrites sur le site de Dell"
  },
  {
    "objectID": "schemas/schema-dellstore.html#table-dellstore.categories",
    "href": "schemas/schema-dellstore.html#table-dellstore.categories",
    "title": "Schéma : dellstore",
    "section": "Table dellstore.categories",
    "text": "Table dellstore.categories\n\n\n\n\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\ncategory\ninteger DEFAULT nextval(‘dellstore.categories_category_seq’::regclass)\n\n\n*\ncategoryname\nvarchar(50)"
  },
  {
    "objectID": "schemas/schema-dellstore.html#table-dellstore.cust_hist",
    "href": "schemas/schema-dellstore.html#table-dellstore.cust_hist",
    "title": "Schéma : dellstore",
    "section": "Table dellstore.cust_hist",
    "text": "Table dellstore.cust_hist\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔎 ⬈\ncustomerid\ninteger\n\n\n* ⬈\norderid\ninteger\n\n\n* ⬈\nprod_id\ninteger\n\n\n\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\n\nfk_cust_hist_customerid\n( customerid ) ref dellstore.customers (customerid)\n\n\n\nfk_cust_hist_orders\n( orderid ) ref dellstore.orders (orderid)\n\n\n\nfk_cust_hist_products\n( prod_id ) ref dellstore.products (prod_id)\n\n\n\n C’est une table raccourci (redondante) dont le contenu peut être reconstruit à l’aide de customers, orders et orderlines?"
  },
  {
    "objectID": "schemas/schema-dellstore.html#table-dellstore.customers",
    "href": "schemas/schema-dellstore.html#table-dellstore.customers",
    "title": "Schéma : dellstore",
    "section": "Table dellstore.customers",
    "text": "Table dellstore.customers\n\n\n\n\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\ncustomerid\ninteger DEFAULT nextval(‘dellstore.customers_customerid_seq’::regclass)\n\n\n*\nfirstname\nvarchar(50)\n\n\n*\nlastname\nvarchar(50)\n\n\n*\naddress1\nvarchar(50)\n\n\n\naddress2\nvarchar(50)\n\n\n*\ncity\nvarchar(50)\n\n\n\nstate\nvarchar(50)\n\n\n\nzip\ninteger\n\n\n*\ncountry\nvarchar(50)\n\n\n*\nregion\nsmallint\n\n\n\nemail\nvarchar(50)\n\n\n\nphone\nvarchar(50)\n\n\n*\ncreditcardtype\ninteger\n\n\n*\ncreditcard\nvarchar(50)\n\n\n*\ncreditcardexpiration\nvarchar(50)\n\n\n* 🔍\nusername\nvarchar(50)\n\n\n*\npassword\nvarchar(50)\n\n\n\nage\nsmallint\n\n\n\nincome\ninteger\n\n\n\ngender\nvarchar(1)"
  },
  {
    "objectID": "schemas/schema-dellstore.html#table-dellstore.inventory",
    "href": "schemas/schema-dellstore.html#table-dellstore.inventory",
    "title": "Schéma : dellstore",
    "section": "Table dellstore.inventory",
    "text": "Table dellstore.inventory\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬈\nprod_id\ninteger\n\n\n*\nquan_in_stock\ninteger\n\n\n*\nsales\ninteger\n\n\n\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\n\nfk_inventory_products\n( prod_id ) ref dellstore.products (prod_id)\n\n\n\nCette table nous indique l’état du stock pour chaque produit au catalogue, et combien d’exemplaires du produit ont étés vendus."
  },
  {
    "objectID": "schemas/schema-dellstore.html#table-dellstore.orderlines",
    "href": "schemas/schema-dellstore.html#table-dellstore.orderlines",
    "title": "Schéma : dellstore",
    "section": "Table dellstore.orderlines",
    "text": "Table dellstore.orderlines\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔍\norderlineid\ninteger\n\n\n* 🔍 ⬈\norderid\ninteger\n\n\n* ⬈\nprod_id\ninteger\n\n\n*\nquantity\nsmallint\n\n\n*\norderdate\ndate\n\n\n\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\n\nfk_orderid\n( orderid ) ref dellstore.orders (orderid)\n\n\n\nfk_orderlines_products\n( prod_id ) ref dellstore.products (prod_id)\n\n\n\nChaque ligne de orderlines nous renseigne sur l’achat d’un produit désigné par prod_id en une certaine quantité , à une certaine date."
  },
  {
    "objectID": "schemas/schema-dellstore.html#table-dellstore.orders",
    "href": "schemas/schema-dellstore.html#table-dellstore.orders",
    "title": "Schéma : dellstore",
    "section": "Table dellstore.orders",
    "text": "Table dellstore.orders\n\n\n\n\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\norderid\ninteger DEFAULT nextval(‘dellstore.orders_orderid_seq’::regclass)\n\n\n*\norderdate\ndate\n\n\n🔎 ⬈\ncustomerid\ninteger\n\n\n*\nnetamount\nnumeric(12,2)\n\n\n*\ntax\nnumeric(12,2)\n\n\n*\ntotalamount\nnumeric(12,2)\n\n\n\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\n\nfk_customerid\n( customerid ) ref dellstore.customers (customerid)"
  },
  {
    "objectID": "schemas/schema-dellstore.html#table-dellstore.products",
    "href": "schemas/schema-dellstore.html#table-dellstore.products",
    "title": "Schéma : dellstore",
    "section": "Table dellstore.products",
    "text": "Table dellstore.products\n\n\n\n\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\nprod_id\ninteger DEFAULT nextval(‘dellstore.products_prod_id_seq’::regclass)\n\n\n* 🔎 ⬈\ncategory\ninteger\n\n\n*\ntitle\nvarchar(50)\n\n\n*\nactor\nvarchar(50)\n\n\n*\nprice\nnumeric(12,2)\n\n\n🔎\nspecial\nsmallint\n\n\n*\ncommon_prod_id\ninteger\n\n\n\nUn petit apperçu de la table aide à comprendre :\n+---------+----------+--------------------+------------------+-------+---------+----------------+\n| prod_id | category | title              | actor            | price | special | common_prod_id |\n|---------+----------+--------------------+------------------+-------+---------+----------------|\n| 1       | 14       | ACADEMY ACADEMY    | PENELOPE GUINESS | 25.99 | 0       | 1976           |\n| 2       | 6        | ACADEMY ACE        | EWAN RICKMAN     | 20.99 | 0       | 6289           |\n| 3       | 6        | ACADEMY ADAPTATION | VIVIEN KAHN      | 28.99 | 0       | 7173           |\n| 4       | 3        | ACADEMY AFFAIR     | ALAN MARX        | 14.99 | 0       | 8042           |\n| 5       | 3        | ACADEMY AFRICAN    | CARRIE HANNAH    | 11.99 | 1       | 2183           |\n| 6       | 9        | ACADEMY AGENT      | LISA SPACEK      | 15.99 | 0       | 5243           |\n| 7       | 8        | ACADEMY AIRPLANE   | FRANCES WINFREY  | 25.99 | 0       | 7700           |\n| 8       | 7        | ACADEMY AIRPORT    | FARRAH TOMEI     | 16.99 | 0       | 9191           |\n| 9       | 2        | ACADEMY ALABAMA    | JULIETTE WEAVER  | 10.99 | 0       | 6633           |\n| 10      | 15       | ACADEMY ALADDIN    | ANNETTE FREEMAN  | 9.99  | 0       | 631            |\n+---------+----------+--------------------+------------------+-------+---------+----------------+\nUne ligne représente un DVD fictif. Un DVD contient un film désigné par un titre. Dans ce film apparaît une actrice ou un acteur. Le DVD est vendu au prix price (USD?). Un film/produi relève d’une seule catégorie. - special vaut 1 pour 104 lignes, 0 pour les autes. - common_prod_id ?\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\nVir\nfk_products_category\n( category ) ref dellstore.categories (category)"
  },
  {
    "objectID": "schemas/schema-dellstore.html#table-dellstore.reorder",
    "href": "schemas/schema-dellstore.html#table-dellstore.reorder",
    "title": "Schéma : dellstore",
    "section": "Table dellstore.reorder",
    "text": "Table dellstore.reorder\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* ⬈\nprod_id\ninteger\n\n\n*\ndate_low\ndate\n\n\n*\nquan_low\ninteger\n\n\n\ndate_reordered\ndate\n\n\n\nquan_reordered\ninteger\n\n\n\ndate_expected\ndate\n\n\n\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\n\nfk_reorder_products\n( prod_id ) ref dellstore.products (prod_id)\n\n\n\n\n\n\n\n\n\nOn peut se demander quel est l’usage de la table reorder.\n\n\n\nLa table reorder gère (peut-être) les réapprovisionements de produits (lorsque l’inventaire inventory signale la quantité en stock d’un produit est dangereusement basse, on effectue une nouvelle commande).\n\nColonnes :\n\nprod_id : un nombre entier identifiant le produit (clé étrangère liée à la table products).\ndate_low : la date à laquelle le niveau de stock a été détecté comme bas.\nquan_low : La quantité qui a déclenché le processus de réapprovisionnement.\ndate_reordered : La date à laquelle le produit a été commandé à nouveau.\nquan_reordered : La quantité du produit commandé à nouveau.\ndate_expected : la date à laquelle les produits commandés à nouveau sont censés arriver.\n\n** Foreign Key ** :\n\nfk_reorder_products : lie prod_id à la table products.\n\n\n Dans l’instance courante du schéma, cette table est vide."
  },
  {
    "objectID": "workshops/td-recap-sql.html#schéma-world",
    "href": "workshops/td-recap-sql.html#schéma-world",
    "title": "TD Récapitulatif SQL",
    "section": "Schéma world",
    "text": "Schéma world\n\n\n\n\n\n\nQuestion\n\n\n\nQuel est le pays qui a le plus de villes recensées dans la table world.city? Combien de villes ? (363 villes)\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuels sont les pays qui ont \\(3\\) ou plus langues officielles ? (8 lignes)\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuels sont les pays dont plus de \\(1.000.000\\) d’habitants parlent une langue non officielle ? (72 lignes)\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuelles sont les langues qui sont officielles dans tous les continents où au moins une langue est parlée ? (1 ligne)\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuels sont les pays pour lesquels une langue non officielle est parlée par strictement plus de monde (dans le pays) qu’il n’y a d’habitants dans la capitale ? (118 lignes)\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuels est le nombre de villes par region ?"
  },
  {
    "objectID": "workshops/td-recap-sql.html#schéma-pagila",
    "href": "workshops/td-recap-sql.html#schéma-pagila",
    "title": "TD Récapitulatif SQL",
    "section": "Schéma pagila",
    "text": "Schéma pagila\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuel est l’acteur (actor_id) présent sur le plus de DVD (inventory_id) ?\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuel est le prix moyen d’une location de DVD ?\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuel est le DVD qui a rapporté le plus d’argent ? Le film (film_id)?\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuels sont les employés (staff_id) qui travaillent dans une autre ville que celle dans laquelle ils vivent ? (4 lignes)"
  },
  {
    "objectID": "workshops/td11.html",
    "href": "workshops/td11.html",
    "title": "TD 11: Normalisation et dépendances",
    "section": "",
    "text": "L3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2024-2025\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\n\nExercice\nSoit le schéma \\[\\mathcal{A}=\\left\\{\\texttt{A,B,C,D,E,F,G,H}\\right\\}\\] et l’ensemble de DF\nBE → AC  \nB → H  \nF → CD  \nD → G\n\nAppliquer l’algorithme de décomposition vu en cours pour obtenir une décomposition de \\(\\mathcal{A}\\) qui respecte la FNBC et est sans perte d’information. Déterminer quelles DF sont préservées.\nPeut-on, en ajoutant un sous-schéma à la décomposition, obtenir une décomposition FNBC sans perte d’information et sans perte de DF ?\n\n\n\nExercice\nReprendre les questions de l’exercice précédent pour le schéma \\[\\mathcal{A}=\\left\\{\\texttt{A,B,C,D,E,F,G,H}\\right\\}\\] et l’ensemble de DF\nBE → AC  \nB → H\nF → CD\nD → G\nA→ E"
  },
  {
    "objectID": "workshops/td4.html",
    "href": "workshops/td4.html",
    "title": "TD 4: SQL",
    "section": "",
    "text": "Documentation Postgres\nDocumentation Postgres en Français"
  },
  {
    "objectID": "workshops/td4.html#count",
    "href": "workshops/td4.html#count",
    "title": "TD 4: SQL",
    "section": "Count",
    "text": "Count\nPour compter les pays en Europe, on écrira :\nSELECT COUNT(countrycode)\nFROM world.country\nWHERE continent='Europe';\nCette requête renvoie une table ayant une ligne et une colonne contenant le nombre de lignes dans le résultat de la requête."
  },
  {
    "objectID": "workshops/td4.html#sum-max-min-avg",
    "href": "workshops/td4.html#sum-max-min-avg",
    "title": "TD 4: SQL",
    "section": "Sum, Max, Min, Avg",
    "text": "Sum, Max, Min, Avg\nUne autre fonction importante est la fonction SUM(col) qui effectue la somme des valeurs (numériques) d’une colonne :\nSELECT SUM(population_country)\nFROM world.country;\nrenvoie la population mondiale.\nOn peut de même utiliser GROUP BY pour faire des paquets :\nSELECT \n  continent, SUM(population_country)\nFROM \n  world.country\nGROUP BY continent;\nrenvoie la population de chaque continent.\nOn peut même faire des opérations sur la colonne à l’intérieur de SUM. Par exemple: SUM(percentage/100).\n\n\n\n\n\n\nQuestion\n\n\n\nÉcrire une requête qui renvoie le nombre de langues officielles par pays"
  },
  {
    "objectID": "workshops/td6.html#contraintes-check.",
    "href": "workshops/td6.html#contraintes-check.",
    "title": "TD 6 : Contraintes",
    "section": "Contraintes CHECK.",
    "text": "Contraintes CHECK.\nCette contrainte permet de vérifier que les colonnes d’une ligne donnée vérifient une certaine condition. Par exemple, on pourrait vouloir vérifier que la valeur de la colonne percentage de la table countrylanguage est inférieure à 100 ou que la valeur de la colonne return_date de la table rental est soit NULL ou supérieure à rental_date. Ces contraintes se définissent lors de la création de la table. Par exemple :\nCREATE TABLE solde(\n    produit TEXT,\n    reduc_pourcentage INT,\n    CHECK (reduc_pourcentage&lt;=100 AND reduc_pourcentage%10=0)\n);\nOn peut ajouter une contrainte CHECK à une table qui existe déjà. Par exemple :\nALTER TABLE solde ADD \n    CHECK (reduc_pourcentage &gt;=0);\nou bien en nommant la contrainte :\nALTER TABLE solde \n    ADD CONSTRAINT reduc_positive \n    CHECK (reduc_pourcentage &gt;=0);"
  },
  {
    "objectID": "workshops/td6.html#contraintes-default-not-null-unique",
    "href": "workshops/td6.html#contraintes-default-not-null-unique",
    "title": "TD 6 : Contraintes",
    "section": "Contraintes DEFAULT / NOT NULL / UNIQUE",
    "text": "Contraintes DEFAULT / NOT NULL / UNIQUE\nCes contraintes s’appliquent à une colonne en particulier. La contrainte DEFAULT spécifie une valeur par défaut pour remplir une colonne lorsque sa valeur n’est pas spécifiée, NOT NULL que la valeur de la colonne ne peut pas être NULL et UNIQUE que deux lignes différentes de la table ne peuvent pas avoir la même valeur sur les colonnes indiquées. Par exemple:\nCREATE TABLE membre(\n    nom VARCHAR(50) NOT NULL,\n    prenom VARCHAR(50) NOT NULL,\n    date_inscription DATE DEFAULT NOW(),\n    UNIQUE(nom, prenom)  \n);"
  },
  {
    "objectID": "workshops/td6.html#contraintes-primaryforeign-key.",
    "href": "workshops/td6.html#contraintes-primaryforeign-key.",
    "title": "TD 6 : Contraintes",
    "section": "Contraintes PRIMARY/FOREIGN KEY.",
    "text": "Contraintes PRIMARY/FOREIGN KEY.\nFormellement, la contrainte PRIMARY KEY est équivalente à UNIQUE et NOT NULL. C’est un moyen d’identifier de façon unique chaque ligne. Chaque table est censée avoir une clé primaire. La contrainte FOREIGN KEY spécifie que la valeur d’une (ou de plusieurs) colonne contient des valeurs présentes dans une autre table. Par exemple, la colonne capital de country contient une valeur qui doit apparaître dans la colonne id de city. Par exemple:\nCREATE TABLE membre(\n    nom VARCHAR(50) NOT NULL, \n    prenom VARCHAR(50) NOT NULL, \n    id INT, \nPRIMARY KEY (id)\n);\n\nCREATE TABLE amis(\n    id1 INT, \n    id2 INT,\n  FOREIGN KEY (id1) REFERENCES membre (id)\n);\nOn peut aussi ajouter une seconde clef étrangère comme ceci :\nALTER TABLE amis ADD \n    FOREIGN KEY (id2) REFERENCES membre;"
  },
  {
    "objectID": "workshops/td6.html#contraintes-exclude.",
    "href": "workshops/td6.html#contraintes-exclude.",
    "title": "TD 6 : Contraintes",
    "section": "Contraintes EXCLUDE.",
    "text": "Contraintes EXCLUDE.\nLes contraintes NOT NULL, DEFAULT, KEY, CHECK portent uniquement sur une ligne tandis que la contrainte UNIQUE permet uniquement de tester des égalités entre lignes. On veut parfois vérifier une condition plus riche sur deux lignes. Par exemple, si notre table contient des réservations d’une salle entre start_date et end_date, on ne veut pas que deux réservations se chevauchent. On écrira:\nCREATE TABLE reservation(\n    start_date DATE, \n    end_date DATE,\n\n    EXCLUDE USING gist (\n        daterange(start_date, end_date) WITH &&)\n);"
  },
  {
    "objectID": "schemas/schema-world.html",
    "href": "schemas/schema-world.html",
    "title": "Schéma : world",
    "section": "",
    "text": "Présentation du schéma world, pour l’entrainement à PostGres.\nCréé avec DbSchema"
  },
  {
    "objectID": "schemas/schema-world.html#contexte",
    "href": "schemas/schema-world.html#contexte",
    "title": "Schéma : world",
    "section": "Contexte",
    "text": "Contexte\nworld est un schéma formé par trois tables country, city et countrylanguage. Les instances de ce schéma sont censées fournir des données de géographie politique : un état du monde à une date donnée.\nLa table country nous renseigne sur les états reconnus (à l’ONU) et sur des territoires jugés plus ou moins autonomes Dépendances, Territoires non autonomes\nLa table city nous renseigne sur les villes les plus importantes de chaque territoire.\nLatable countrylanguage nous indique quelles langues sont parlées dans quels pas.\nL’instance du schéma utilisée donne une idée du monde au début des années 2000."
  },
  {
    "objectID": "schemas/schema-world.html#diagrammme-en-pattes-de-corbeau-crowfoot",
    "href": "schemas/schema-world.html#diagrammme-en-pattes-de-corbeau-crowfoot",
    "title": "Schéma : world",
    "section": "Diagrammme en pattes de corbeau (crowfoot)",
    "text": "Diagrammme en pattes de corbeau (crowfoot)\nUn diagramme en pattes de corbeau est formé par les tables (pour chaque colonne/attribut, nom et domaine) et des arcs qui décrivent des contraintes référentielles.\n\n\n\nSchéma world en pattes de corbeau"
  },
  {
    "objectID": "schemas/schema-world.html#table-world.country",
    "href": "schemas/schema-world.html#table-world.country",
    "title": "Schéma : world",
    "section": "Table world.country",
    "text": "Table world.country\n\n\n\n\n\n\n\n\n\n\nIdx\nName\nData Type\nDescription\n\n\n\n\n* 🔑 ⬋\ncountrycode\nchar(3)\nCode ISO à 3 symboles\n\n\n*\nname_country\ntext\nNom du territoire en Anglais\n\n\n*\ncontinent\ntext\n\n\n\n*\nregion\ntext\n\n\n\n*\nsurfacearea\nreal\nSurface en Km2\n\n\n\nindepyear\nsmallint\nAnnée de fondation/indépendance\n\n\n*\npopulation_country\ninteger\nNombre d’habitants\n\n\n\nlifeexpectancy\nreal\nEspérance de vie à naissance\n\n\n\ngnp\nnumeric(10,2)\nPIB (en Millions de USD?)\n\n\n\ngnpold\nnumeric(10,2)\n\n\n\n*\nlocalname\ntext\nNom du territoire dans les langues officielles\n\n\n*\ngovernmentform\ntext\nType de régime\n\n\n\nheadofstate\ntext\nChef de l’état\n\n\n⬈\ncapital\ninteger\nIdentifiant (id) de la capitale dans city\n\n\n*\ncode2\nchar(2)\nCode ISO à 2 symboles\n\n\n\ngnp est formé par les initiales de Gross National Product (Produit National Brut), un indicateur de revenu défini par les économistes.\nlifeexpectancy (espérance de vie à la naissance) est un indicateur de santé publique construit par les démographes. Ce n’est pas l’âge moyen au décès.\n\nChaque ligne de country est identifiée par la valeur de countrycode. Cet attribut ne peut pas être NULL. Deux lignes distinctes de country ne peuvent coïncider sur l’attribut countrycode.\nL’attribut countrycode peut être utilisé pour désigner une ligne de la table country. Cette possibilité est utilisée dans les tables city et countrylanguage\nEn jargon, l’attribut countrycode sert de clé primaire à la table country\nUn extrait de la table concernant les pays de région Western Europe permet de comprendre au moins une partie de la signification et des usages des colonnes\n\n\n\n\n\n\n\n\n\n\n\n\n\ncountrycode\ncode2\nname_country\nlocalname\ngovernmentform\nheadofstate\ncapital\n\n\n\n\nNLD\nNL\nNetherlands\nNederland\nConstitutional Monarchy\nBeatrix\n5\n\n\nBEL\nBE\nBelgium\nBelgië/Belgique\nConstitutional Monarchy, Federation\nAlbert II\n179\n\n\nAUT\nAT\nAustria\nÖsterreich\nFederal Republic\nThomas Klestil\n1523\n\n\nLIE\nLI\nLiechtenstein\nLiechtenstein\nConstitutional Monarchy\nHans-Adam II\n2446\n\n\nLUX\nLU\nLuxembourg\nLuxembourg/Lëtzebuerg\nConstitutional Monarchy\nHenri\n2452\n\n\nMCO\nMC\nMonaco\nMonaco\nConstitutional Monarchy\nRainier III\n2695\n\n\nFRA\nFR\nFrance\nFrance\nRepublic\nJacques Chirac\n2974\n\n\nDEU\nDE\nGermany\nDeutschland\nFederal Republic\nJohannes Rau\n3068\n\n\nCHE\nCH\nSwitzerland\nSchweiz/Suisse/Svizzera/Svizra\nFederation\nAdolf Ogi\n3248\n\n\n\n\n\nForeign Keys (clée étrangères)\nLa colonne capital ne contient pas les noms de capitale (il existe des territoires sans capitale), elle contient des entiers (ou NULL) qui renvoient à des lignes dans la table city.\n\n\n\n\nType\nName\nOn\n\n\n\n\n\ncountry_capital_fkey\n( capital ) ref world.city (id)\n\n\n\n\n\n\nConstraints\nLe domaine de la colonne (de l’atttribut) continent est un type énuméré (défini en extension).\n\n\n\n\n\n\n\nName\nDefinition\n\n\n\n\ncountry_continent_check\n((continent = ‘Asia’::text) OR (continent = ‘Europe’::text) OR (continent = ‘North America’::text) OR (continent = ‘Africa’::text) OR (continent = ‘Oceania’::text) OR (continent = ‘Antarctica’::text) OR (continent = ‘South America’::text))"
  },
  {
    "objectID": "schemas/schema-world.html#table-world.city",
    "href": "schemas/schema-world.html#table-world.city",
    "title": "Schéma : world",
    "section": "Table world.city",
    "text": "Table world.city\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬋\nid\ninteger\n\n\n*\nname\ntext\n\n\n* ⬈\ncountrycode\nchar(3)\n\n\n*\ndistrict\ntext\n\n\n*\npopulation\ninteger\n\n\n\n\nChaque ligne de city est identifiée par la valeur de is. Cet attribut ne peut pas être NULL. Deux lignes distinctes de city ne peuvent coïncider sur l’attribut id.\n\nForeign Keys\nLa colonne countrycode ne contient pas les noms des pays, mais le code à 3 symboles du territoire où se situe la ville\n\n\n\n\nType\nName\nOn\n\n\n\n\n\ncity_country_fk\n( countrycode ) ref world.country (countrycode)\n\n\n\n\nL’extrait suivant correspond au villes du pays nommé France.\n\n\n\nid\nname\ndistrict\npopulation\n\n\n\n\n2974\nParis\nÎle-de-France\n2125246\n\n\n2975\nMarseille\nProvence-Alpes-Côte\n798430\n\n\n2976\nLyon\nRhône-Alpes\n445452\n\n\n2977\nToulouse\nMidi-Pyrénées\n390350\n\n\n2978\nNice\nProvence-Alpes-Côte\n342738\n\n\n2979\nNantes\nPays de la Loire\n270251\n\n\n2980\nStrasbourg\nAlsace\n264115\n\n\n2981\nMontpellier\nLanguedoc-Roussillon\n225392\n\n\n2982\nBordeaux\nAquitaine\n215363\n\n\n2983\nRennes\nHaute-Normandie\n206229\n\n\n2984\nLe Havre\nChampagne-Ardenne\n190905\n\n\n2985\nReims\nNord-Pas-de-Calais\n187206\n\n\n2986\nLille\nRhône-Alpes\n184657\n\n\n2987\nSt-Étienne\nBretagne\n180210\n\n\n2988\nToulon\nProvence-Alpes-Côte\n160639\n\n\n2989\nGrenoble\nRhône-Alpes\n153317\n\n\n2990\nAngers\nPays de la Loire\n151279\n\n\n2991\nDijon\nBourgogne\n149867\n\n\n2992\nBrest\nBretagne\n149634\n\n\n2993\nLe Mans\nPays de la Loire\n146105\n\n\n2994\nClermont-Ferrand\nAuvergne\n137140\n\n\n2995\nAmiens\nPicardie\n135501\n\n\n2996\nAix-en-Provence\nProvence-Alpes-Côte\n134222\n\n\n2997\nLimoges\nLimousin\n133968\n\n\n2998\nNîmes\nLanguedoc-Roussillon\n133424\n\n\n2999\nTours\nCentre\n132820\n\n\n3000\nVilleurbanne\nRhône-Alpes\n124215\n\n\n3001\nMetz\nLorraine\n123776\n\n\n3002\nBesançon\nFranche-Comté\n117733\n\n\n3003\nCaen\nBasse-Normandie\n113987\n\n\n3004\nOrléans\nCentre\n113126\n\n\n3005\nMulhouse\nAlsace\n110359\n\n\n3006\nRouen\nHaute-Normandie\n106592\n\n\n3007\nBoulogne-Billancourt\nÎle-de-France\n106367\n\n\n3008\nPerpignan\nLanguedoc-Roussillon\n105115\n\n\n3009\nNancy\nLorraine\n103605\n\n\n3010\nRoubaix\nNord-Pas-de-Calais\n96984\n\n\n3011\nArgenteuil\nÎle-de-France\n93961\n\n\n3012\nTourcoing\nNord-Pas-de-Calais\n93540\n\n\n3013\nMontreuil\nÎle-de-France\n90674\n\n\n\n\n\n\n\n\n\n La description des tables country et city n’impose pas que la capitale d’un pays soit une ville située dans ce pays.\nEst-ce que cette contrainte devrait être mise en place ?"
  },
  {
    "objectID": "schemas/schema-world.html#table-world.countrylanguage",
    "href": "schemas/schema-world.html#table-world.countrylanguage",
    "title": "Schéma : world",
    "section": "Table world.countrylanguage",
    "text": "Table world.countrylanguage\nLa table countrylanguage nous renseigne sur les langues parlées dans les différents pays.\n\n\n\n\nIdx\nName\nData Type\n\n\n\n\n* 🔑 ⬈\ncountrycode\nchar(3)\n\n\n* 🔑\nlanguage\ntext\n\n\n*\nisofficial\nboolean\n\n\n*\npercentage\nreal\n\n\n\n\nUn extrait correspondant au pays FRA (France) aide à comprendre\n\n\n\n\ncountrycode\nlanguage\nisofficial\npercentage\n\n\n\n\nFRA\nFrench\nt\n93.6\n\n\nFRA\nArabic\nf\n2.5\n\n\nFRA\nPortuguese\nf\n1.2\n\n\nFRA\nItalian\nf\n0.4\n\n\nFRA\nSpanish\nf\n0.4\n\n\nFRA\nTurkish\nf\n0.4\n\n\n\n\nLes lignes nous renseignent sur 6 langues. Une documentation complète serait nécessaire pour vérifier si le percentage correspond à la proportion d’individus qui déclarent telle ou telle langue comme langue maternelle. On ne sait pas si un individu peut déclarer posséder plusieurs langues.\n\n\n\n\n\n\n La documentation d’une base de données ne se réduit pas toujours à un diagramme.\n\n\n\nD’après l’instance du schéma world, la seule langue réputée officielle en France est le français.\n\n\n\n\n\n\n Qu’est ce qu’une langue officielle ?\n\n\n\nDans la table countrylanguage, l’attribut countrycode renvoie à une ligne de country grâce à l’attribut de même nom dans la table country.\n\nForeign Keys\n\n\n\nType\nName\nOn\n\n\n\n\n\ncountrylanguage_countrycode_fkey\n( countrycode ) ref world.country (countrycode)\n\n\n\n\n\n\n\n\n\nDans le schéma world, chaque ligne de countrylanguage est identifiée par les valeurs des colonnes countrycode et language. On parle de clé primaire composée."
  },
  {
    "objectID": "slides/DF_norm_1.html#conception-du-modèle-relationnel",
    "href": "slides/DF_norm_1.html#conception-du-modèle-relationnel",
    "title": "Normalisation I",
    "section": "Conception du modèle relationnel",
    "text": "Conception du modèle relationnel\nUne première approche pour concevoir un modèle relationnel (l’ensemble des schémas de tables d’une bd) consiste à :\n\nIdentifier les attributs d’intérêt\nRépartir les attributs dans plusieurs relations\n\n\n\nComment savoir si le modèle relationnel est bon ?\n\n\n\n\nSi ce n’est pas le cas : y a-t-il des techniques pour le transformer en un bon modèle?"
  },
  {
    "objectID": "slides/DF_norm_1.html#qualité-dun-schéma",
    "href": "slides/DF_norm_1.html#qualité-dun-schéma",
    "title": "Normalisation I",
    "section": "Qualité d’un schéma",
    "text": "Qualité d’un schéma\nQuelles sont de bonnes propriétés d’un schéma ?\nExemple\nAttributs relatifs à des vendeurs, produits et livraisons\n\n\n\nAttribut\nUsage\n\n\n\n\nV#\nnuméro du vendeur\n\n\nVnom\nnom du vendeur\n\n\nVville\nville du vendeur\n\n\nP#\nnuméro du produit\n\n\nPnom\nnom du produit\n\n\nPville\nville où le produit est stocké\n\n\nQte\nquantité de produit livrée au vendeur"
  },
  {
    "objectID": "slides/DF_norm_1.html#qualité-dun-schéma-1",
    "href": "slides/DF_norm_1.html#qualité-dun-schéma-1",
    "title": "Normalisation I",
    "section": "Qualité d’un schéma",
    "text": "Qualité d’un schéma\nUn schéma relationnel possible : une seule relation R avec tous les attributs\nR(V#, Vnom, Vville, P#, Pnom, Pville, Qte)\n\n\n C’est une mauvaise modélisation.\n Pourquoi ?"
  },
  {
    "objectID": "slides/DF_norm_1.html#qualité-dun-schéma-relationnel",
    "href": "slides/DF_norm_1.html#qualité-dun-schéma-relationnel",
    "title": "Normalisation I",
    "section": "Qualité d’un schéma relationnel",
    "text": "Qualité d’un schéma relationnel\n\n\n\n\n\n\nRedondance\n\n\n\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\n\n3\nMagicV\nParis\n…\n…\n…\n…\n\n\n3\nMagicV\nParis\n…\n…\n…\n…\n\n\n2\nIdealB\nLyon\n…\n…\n…\n…\n\n\n2\nIdealB\nLyon\n…\n…\n…\n…\n\n\n\nVnom et Vville sont déterminés parV# :\nsi deux livraisons ont le même V#, elles ont aussi le même Vville et le même Vnom"
  },
  {
    "objectID": "slides/DF_norm_1.html#section",
    "href": "slides/DF_norm_1.html#section",
    "title": "Normalisation I",
    "section": "",
    "text": "Anomalies de mise à jour\n\nVnom ou Vville pourrait être mis à jour dans une livraison et pas dans une autre, ce qui donnerait une incohérence. Les mesures pour éviter cela rendent la mise à jour est coûteuse\n\n\nAnomalies d’insertion\n\nOn ne peut pas enregistrer un vendeur s’il ne reçoit pas de livraison\n\n\n\nAnomalies de suppression\n\nSi on supprime toutes les livraisons à un vendeur, on perd toute l’information sur ce vendeur"
  },
  {
    "objectID": "slides/DF_norm_1.html#qualité-dun-schéma-relationnel-1",
    "href": "slides/DF_norm_1.html#qualité-dun-schéma-relationnel-1",
    "title": "Normalisation I",
    "section": "Qualité d’un schéma relationnel",
    "text": "Qualité d’un schéma relationnel\n\nUn bon schéma\n\nVendeur(V#, Vnom, Vville)    Clef : V#\nProduit(P#, Pnom, Pville)    Clef : P#\nLivraison(V#, P#, Qte)       Clef : (V#,P#)\n\nPlus d’anomalie ! Comment y arriver?\n\n\nLa théorie de la normalisation des BD relationnelles fournit\n\nla notion de forme normale : propriétés d’un schéma qui garantissent l’absence de redondance et des anomalies qui en dérivent. Ces propriétés sont définies par rapport à un ensemble de contraintes\ndes techniques de normalisation : passage d’un schéma arbitraire (mauvais) à un schéma en forme normale (obtenu typiquement par décomposition)"
  },
  {
    "objectID": "slides/DF_norm_1.html#df-exemple-suite",
    "href": "slides/DF_norm_1.html#df-exemple-suite",
    "title": "Normalisation I",
    "section": "DF exemple (suite)",
    "text": "DF exemple (suite)\n\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\n\n3\nMagicV\nParis\n322\nmanteau\nLille\n2\n\n\n1\nStarV\nRome\n546\nveste\nRome\n1\n\n\n3\nMagicV\nParis\n322\nmanteau\nLille\n5\n\n\n2\nIdealB\nLyon\n145\njupe\nParis\n7\n\n\n2\nIdealB\nLyon\n234\njupe\nLille\n1\n\n\n\n\n\nR satisfait V# ⟶ Vnom Vville et P# ⟶ Pnom Pville\nR viole V# P# ⟶ Qte"
  },
  {
    "objectID": "slides/DF_norm_1.html#autre-exemple",
    "href": "slides/DF_norm_1.html#autre-exemple",
    "title": "Normalisation I",
    "section": "Autre Exemple",
    "text": "Autre Exemple\nSchéma Films(titre, année, durée, genre, producteur, acteur)\n\n\n\n\n\n\n\n\n\n\n\ntitre\nannée\ndurée\ngenre\nproducteur\nacteur\n\n\n\n\nStar Wars\n1977\n124\nSciFi\nFox\nCarrie Fisher\n\n\nStar Wars\n1977\n124\nSciFi\nFox\nMark Hamill\n\n\nStar Wars\n1977\n124\nSciFi\nFox\nHarrison Ford\n\n\nGone With The Wind\n1939\n231\ndrame\nMGM\nVivien Leigh\n\n\nWayne’s World\n1992\n95\ncomédie\nParamount\nDana Carvey\n\n\nWayne’s World\n1992\n95\ncomédie\nParamount\nMike Meyers\n\n\n…"
  },
  {
    "objectID": "slides/DF_norm_1.html#définition-dune-dépendance-fonctionnelle",
    "href": "slides/DF_norm_1.html#définition-dune-dépendance-fonctionnelle",
    "title": "Normalisation I",
    "section": "Définition d’une dépendance fonctionnelle",
    "text": "Définition d’une dépendance fonctionnelle\n\n\n\n\n\n\nDéfinition : Dépendance fonctionnelle\n\n\nSoit \\(\\mathcal{A}\\) un schéma de relation (\\(\\mathcal{A}\\) est un ensemble d’attributs)\nUne dépendance fonctionnelle sur \\(\\mathcal{A}\\) est une expression de la forme\n\\[X → Y\\]\noù \\(X ⊆ \\mathcal{A}\\) et \\(Y ⊆ \\mathcal{A}\\)\nUne relation \\(R\\) de schéma \\(\\mathcal{A}\\) satisfait \\(X → Y\\) si pour tous tuples \\(s,t ∈ R\\) on a\n\\[\\bigl(∀ A∈ X\\ s.A=t.A\\bigr) ⟹ \\bigl(\\forall A∈ Y\\ s.A=t.A\\bigr)\\]\n(si \\(s\\) et \\(t\\) coïncident sur \\(X\\) alors \\(s\\) et \\(t\\) coïncident sur \\(Y\\))\nUne relation \\(R\\), de schéma \\(\\mathcal{A}\\), satisfait un ensemble \\(\\Sigma\\) de DF si \\(R\\) satisfait chaque DF de \\(\\Sigma\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#exemples",
    "href": "slides/DF_norm_1.html#exemples",
    "title": "Normalisation I",
    "section": "Exemples",
    "text": "Exemples\nDans la base Pagila, relation Actor :\n\nActor_id ⟶ last_name, first_name\ncar Actor_id est une clé…"
  },
  {
    "objectID": "slides/DF_norm_1.html#dépendance-fonctionnelle-triviale",
    "href": "slides/DF_norm_1.html#dépendance-fonctionnelle-triviale",
    "title": "Normalisation I",
    "section": "Dépendance fonctionnelle triviale",
    "text": "Dépendance fonctionnelle triviale\nUne DF triviale est une DF satisfaite par toute relation\n\n\n\n\n\n\nDéfinition (dépendance triviale)\n\n\nSoient \\(X,Y⊂ \\mathcal{A}\\)\n\\(X\\rightarrow Y\\) est une dépendance triviale si \\(Y ⊂ X\\)\n\n\n\n\n\n\n\n\n\n\nExemple\n\n\nNo_insee ⟶ No_insee est triviale"
  },
  {
    "objectID": "slides/DF_norm_1.html#implication-pour-les-df",
    "href": "slides/DF_norm_1.html#implication-pour-les-df",
    "title": "Normalisation I",
    "section": "Implication pour les DF",
    "text": "Implication pour les DF\n\nSoit \\(\\mathcal{A}\\) un schéma de relation ( \\(\\mathcal{A}\\) est un ensemble d’attributs) et \\(\\Sigma\\) un ensemble de DF sur \\(\\mathcal{A}\\)\nExemple : \\(\\mathcal{A}=\\{A,B,C\\}\\) et \\(\\Sigma=\\{A\\rightarrow B, B\\rightarrow C\\}\\)\nLes DF données impliquent d’autres DF additionnelles\n\n\n\n\n\n\n\n\nExemple I\n\n\n\\(A\\rightarrow B\\) et \\(B\\rightarrow C\\) impliquent \\(A\\rightarrow C\\)\nc’est-à-dire : toute relation de schéma \\(\\mathcal{A}\\) qui satisfait \\(A\\rightarrow B\\) et \\(B\\rightarrow C\\) satisfait également \\(A\\rightarrow C\\)\n\n\n\n\n\n\n\n\n\n\n\nExemple II\n\n\n\\(A\\rightarrow C\\), \\(BC\\rightarrow D\\), \\(AD\\rightarrow E\\) impliquent \\(AB\\rightarrow E\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#implication-entre-df",
    "href": "slides/DF_norm_1.html#implication-entre-df",
    "title": "Normalisation I",
    "section": "Implication entre DF",
    "text": "Implication entre DF\n\n\n\n\n\n\nDéfinition\n\n\nUn ensemble \\(\\Sigma\\) de DF implique une autre DF \\(X\\rightarrow Y\\) si toute relation (instance) qui satisfait \\(\\Sigma\\) satisfait également \\(X\\rightarrow Y\\).\nNotation pour \\(\\Sigma\\) implique \\(X\\rightarrow Y\\) :\n\\[\\Sigma \\models X \\rightarrow Y\\]\n\n\n\n\n\n\n\n\n\n\nExemple\n\n\n\\(\\Sigma=\\{A\\rightarrow B, B\\rightarrow C\\}\\) implique\n\\(A\\rightarrow B\\), \\(B\\rightarrow C\\), \\(A\\rightarrow C\\), \\(A,B\\rightarrow C\\), …\nmais aussi les DF triviales \\(A\\rightarrow A\\), \\(AB\\rightarrow A\\), …"
  },
  {
    "objectID": "slides/DF_norm_1.html#preuve",
    "href": "slides/DF_norm_1.html#preuve",
    "title": "Normalisation I",
    "section": "Preuve",
    "text": "Preuve"
  },
  {
    "objectID": "slides/DF_norm_1.html#exemples-1",
    "href": "slides/DF_norm_1.html#exemples-1",
    "title": "Normalisation I",
    "section": "Exemples",
    "text": "Exemples\n\\(\\mathcal{A}=\\{A,B,C,D\\}\\),\n\\(\\Sigma= \\{AB\\rightarrow C, C\\rightarrow A, BC\\rightarrow D\\}\\)|\n\\(\\Sigma'=\\{AB\\rightarrow D\\}\\)\n\\(\\Sigma\\models\\Sigma'\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#question-principale",
    "href": "slides/DF_norm_1.html#question-principale",
    "title": "Normalisation I",
    "section": "Question principale",
    "text": "Question principale\n\nComment vérifier si un ensemble \\(\\Sigma\\) de DF implique une DF \\(X\\rightarrow Y\\)~?\n\n\n\nPar les équivalences présentées précédemment, la question se ramène à :\n\nComment vérifier si un ensemble \\(\\Sigma\\) de DF implique une DF \\(X\\rightarrow A\\) où \\(A\\) est un attribut~?"
  },
  {
    "objectID": "slides/DF_norm_1.html#fermeture-dun-ensemble-dattributs-1",
    "href": "slides/DF_norm_1.html#fermeture-dun-ensemble-dattributs-1",
    "title": "Normalisation I",
    "section": "Fermeture d’un ensemble d’attributs",
    "text": "Fermeture d’un ensemble d’attributs\nSoit \\(X \\subset\\mathcal{A}\\) un sous-ensemble d’attributs et \\(\\Sigma\\) un ensemble de DF sur \\(\\mathcal{A}\\)\n\n\n\n\n\n\nDéfinition\n\n\nLa fermeture de \\(X\\) par rapport à \\(\\Sigma\\) est\n\\[X^+=\\{ A\\in\\mathcal{A} \\mid \\Sigma\\models X\\rightarrow A \\}\\]\n\n\n\n\n\nAutrement dit \\(X^+\\) est l’ensemble des attributs déterminés par \\(X\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#exemple-de-fermeture",
    "href": "slides/DF_norm_1.html#exemple-de-fermeture",
    "title": "Normalisation I",
    "section": "Exemple de fermeture",
    "text": "Exemple de fermeture\n\n\\(R(ABCDE)\\)\n\\(\\Sigma=\\{AB\\rightarrow C, C\\rightarrow D, E\\rightarrow D\\}\\)\n\\(\\{A,B\\}^+=\\{A,B,C,D\\}\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#section-2",
    "href": "slides/DF_norm_1.html#section-2",
    "title": "Normalisation I",
    "section": "",
    "text": "\\begin{algorithm} \\caption{Fermeture} \\begin{algorithmic} \\Procedure{Fermeture}{$X, Σ$} \\State $X^c ← X$ \\Repeat \\State stop ← \\True \\For{$(Y → Z) ∈ Σ$} \\If{$Y ⊆ X^c ∧ Z ⊄ X^c$} \\State $X^c ← X^c ∪ Z$ \\State stop ← \\False \\EndIf \\EndFor \\Until{stop} \\Return $X^c$ \\EndProcedure \\end{algorithmic} \\end{algorithm}\n\n\n\nXc &lt;-  X\n\nwhile (exists Y -&gt; Z in Σ with Y ⊂ Xc and not Z ⊄ Xc) {\n  Xc &lt;- Xc ∪ Z\n}\n\nreturn Xc"
  },
  {
    "objectID": "slides/DF_norm_1.html#section-3",
    "href": "slides/DF_norm_1.html#section-3",
    "title": "Normalisation I",
    "section": "",
    "text": "Xc &lt;-  X\n\nwhile (exists Y -&gt; Z in Σ with Y ⊂ Xc and not Z ⊄ Xc) {\n  Xc &lt;- Xc ∪ Z\n}\n\nreturn Xc\n\n\nXc grandit à chaque itération\n\nComme \\(\\mathcal{A}\\) est fini, l’algorithme se termine en au plus \\(|\\mathcal{A}|\\) itérations"
  },
  {
    "objectID": "slides/DF_norm_1.html#preuve-de-la-correction-de-lalgorithme-de-fermeture",
    "href": "slides/DF_norm_1.html#preuve-de-la-correction-de-lalgorithme-de-fermeture",
    "title": "Normalisation I",
    "section": "Preuve de la correction de l’algorithme de fermeture",
    "text": "Preuve de la correction de l’algorithme de fermeture"
  },
  {
    "objectID": "slides/DF_norm_1.html#exemple-de-calcul-de-fermeture",
    "href": "slides/DF_norm_1.html#exemple-de-calcul-de-fermeture",
    "title": "Normalisation I",
    "section": "Exemple de calcul de fermeture",
    "text": "Exemple de calcul de fermeture\n\\(\\mathcal{A}=\\{ABCDEF\\}\\) \\(\\Sigma=\\{A\\rightarrow C, BC\\rightarrow D, AD\\rightarrow E\\}\\) \\(X=\\{A,B\\}\\)\n\n\\(X_c=\\{A,B\\}\\)\n\\(A\\rightarrow C\\) donc on obtient \\(X_c=\\{A,B,C\\}\\)\n\\(BC\\rightarrow D\\) donc on obtient \\(X_c=\\{A,B,C,D\\}\\)\n\\(AD\\rightarrow E\\) donc on obtient \\(X_c=\\{A,B,C,D, E\\}\\)\nOn obtient \\(X^+=\\{A,B,C,D, E\\}\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#correction-de-lalgorithme-de-fermeture",
    "href": "slides/DF_norm_1.html#correction-de-lalgorithme-de-fermeture",
    "title": "Normalisation I",
    "section": "Correction de l’algorithme de fermeture",
    "text": "Correction de l’algorithme de fermeture\n\nL’algorithme calcule uniquement des attributs dans la fermeture car on a toujours \\(X_c\\subset X^+\\)\nL’algorithme calcule tous les attributs dans la fermeture: \\(X_c=X^+\\) quand l’algorithme se termine"
  },
  {
    "objectID": "slides/DF_norm_1.html#calcul-de-la-fermeture-transitive-exemple",
    "href": "slides/DF_norm_1.html#calcul-de-la-fermeture-transitive-exemple",
    "title": "Normalisation I",
    "section": "Calcul de la fermeture transitive : exemple",
    "text": "Calcul de la fermeture transitive : exemple\n\n\nSoit \\(R\\) d’ensemble d’attributs\n\\[\\mathcal{A} =\\{A,B,C,D,E,F,G\\}\\]\nSoit \\(X=\\{B,D\\} \\subset \\mathcal{A}\\)\nEt \\(Σ\\) l’ensemble de dépendances fonctionnelles ci-contre\n\n\n\n\n\\(\\Sigma\\)\n\n\n\n\n\\(A,B \\rightarrow C\\)\n\n\n\\(C \\rightarrow A\\)\n\n\n\\(B,C \\rightarrow D\\)\n\n\n\\(A,C,D \\rightarrow B\\)\n\n\n\\(F\\rightarrow A,C\\)\n\n\n\\(D \\rightarrow E,G\\)\n\n\n\\(B,E \\rightarrow C\\)\n\n\n\\(C,G \\rightarrow B,D\\)\n\n\n\\(C,E \\rightarrow A,G\\)\n\n\n\n\nMontrer que \\(X^+=\\{A,B,C,D,E,G\\}\\)\nDonner une clef de \\(R\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#forme-normale-de-boyce-codd-fnbc",
    "href": "slides/DF_norm_1.html#forme-normale-de-boyce-codd-fnbc",
    "title": "Normalisation I",
    "section": "Forme normale de Boyce-Codd (FNBC)",
    "text": "Forme normale de Boyce-Codd (FNBC)\n\n\n\n\n\n\nDéfinition\n\n\nUn schéma \\(\\mathcal{A}\\) est en FNBC par rapport à un ensemble de dépendances fonctionnelles \\(\\Sigma\\) sur \\(\\mathcal{A}\\)\nsi\npour toute DF \\(X\\rightarrow Y\\) impliquée par \\(\\Sigma\\) avec \\(Y\\not\\subset X\\), \\(X\\) est une super-clef\n\n\n\n\n\n \\((\\mathcal{A},\\Sigma)\\) est en FNBC si pour toute DF non triviale impliquée par \\(\\Sigma\\), le membre de gauche est une super-clef"
  },
  {
    "objectID": "slides/DF_norm_1.html#fnbc-exemple-1",
    "href": "slides/DF_norm_1.html#fnbc-exemple-1",
    "title": "Normalisation I",
    "section": "FNBC : exemple 1",
    "text": "FNBC : exemple 1\n\nSchéma \\(\\mathcal{A}=\\{\\texttt{V\\#, Vnom, Vville, P\\#, Pnom, Pville, Qte}\\}\\)\n\nEnsemble de dépendances fonctionnelles \\(\\Sigma\\) :\nV# ⟶ Vnom Vville\nP# ⟶ Pnom Pville\nV# P# ⟶ Qte\n\n\\(\\mathcal{A}\\) n’est pas en FNBC par rapport \\(\\Sigma\\).\nEn effet ni V# ni P# ne sont des super-clefs"
  },
  {
    "objectID": "slides/DF_norm_1.html#fnbc-exemple-2",
    "href": "slides/DF_norm_1.html#fnbc-exemple-2",
    "title": "Normalisation I",
    "section": "FNBC : exemple 2",
    "text": "FNBC : exemple 2\nSchéma Films(titre, année, durée, genre, producteur, acteur)\n\nOn a la dépendance suivante titre, année ⟶ durée, genre, producteur\ntitre, année, acteur est la seule clef\nLa DF titre, année ⟶ durée, genre, producteur} viole la condition de FNBC"
  },
  {
    "objectID": "slides/DF_norm_1.html#fnbc-exemple-3",
    "href": "slides/DF_norm_1.html#fnbc-exemple-3",
    "title": "Normalisation I",
    "section": "FNBC : exemple 3",
    "text": "FNBC : exemple 3\nTrois schémas en FNBC :\n\n\n\nRelation\nClef\n\n\n\n\nVendeur(V#, Vnom, Vville)\nV#\n\n\nProduit(P#, Pnom, Pville)\nP#\n\n\nLivraison(V#, P#, Qte)\n(V#,P#)"
  },
  {
    "objectID": "slides/DF_norm_1.html#schéma-avec-deux-attributs",
    "href": "slides/DF_norm_1.html#schéma-avec-deux-attributs",
    "title": "Normalisation I",
    "section": "Schéma avec deux attributs",
    "text": "Schéma avec deux attributs\n\n\n\n\n\n\nProposition\n\n\nSoit \\(\\mathcal{A}=\\{A,B\\}\\) un schéma avec deux attributs et \\(\\Sigma\\) un ensemble de DF non triviales.\n\\(\\mathcal{A}\\) est toujours en FNBC par rapport à \\(\\Sigma\\)\n\n\n\n\n\nPreuve. On distingue 4 cas\n\n\\(\\Sigma=\\emptyset\\)\n\\(\\Sigma=\\{A\\rightarrow B\\}\\)\n\\(\\Sigma=\\{B\\rightarrow A\\}\\)\n\\(\\Sigma=\\{A\\rightarrow B, B\\rightarrow A\\}\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#décomposition-dun-schéma-de-relation",
    "href": "slides/DF_norm_1.html#décomposition-dun-schéma-de-relation",
    "title": "Normalisation I",
    "section": "Décomposition d’un schéma de relation",
    "text": "Décomposition d’un schéma de relation\n\n\n\n\n\n\nDéfinition\n\n\nSoit \\(\\mathcal{A}\\) un schéma de relation\nUn décomposition de \\(\\mathcal{A}\\) est un ensemble \\(\\{\\mathcal{A}_1,..., \\mathcal{A}_k\\}\\) de sous-ensembles de \\(\\mathcal{A}\\) tel que\n\\[\\mathcal{A}_i\\not=\\emptyset, 1\\le i\\le k, \\quad \\text{ et } \\quad \\mathcal{A} = \\bigcup_{i=1}^k \\mathcal{A}_i\\]"
  },
  {
    "objectID": "slides/DF_norm_1.html#exemple-de-décomposition-i",
    "href": "slides/DF_norm_1.html#exemple-de-décomposition-i",
    "title": "Normalisation I",
    "section": "Exemple de décomposition I",
    "text": "Exemple de décomposition I\nVendeur(V#, Vnom, Vville)\nProduit(P#, Pnom, Pville)\nLivraison(V#, P#, Qte)\nest une décomposition du schéma\nR(V#, Vnom, Vville, P#, Pnom, Pville, Qte)"
  },
  {
    "objectID": "slides/DF_norm_1.html#exemple-de-décomposition-ii",
    "href": "slides/DF_norm_1.html#exemple-de-décomposition-ii",
    "title": "Normalisation I",
    "section": "Exemple de décomposition II",
    "text": "Exemple de décomposition II\nSchéma :\nFilms(titre, année, durée, genre, producteur, acteur)\n\nUne décomposition :\nFilms1(titre, année, durée, genre, producteur)\nFilms2(titre, année, acteur)\n\nFilms1 est FNBC par rapport à \\(\\Sigma_1=\\{\\texttt{titre, année ⟶ durée, genre, producteur}\\}\\)\nFilms2 est en FNBC par rapport à \\(\\Sigma_2=\\emptyset\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#propriétés-dune-décomposition",
    "href": "slides/DF_norm_1.html#propriétés-dune-décomposition",
    "title": "Normalisation I",
    "section": "Propriétés d’une décomposition",
    "text": "Propriétés d’une décomposition\nOn ne peut pas décomposer arbitrairement\nToutes les décompositions ne sont pas intéressantes\n\nConditions pour une décomposition raisonnable :\n\nDécomposition sans perte d’information\nDécomposition sans perte de dépendance fonctionnelle"
  },
  {
    "objectID": "slides/DF_norm_1.html#décomposition-sans-perte-dinformation-1",
    "href": "slides/DF_norm_1.html#décomposition-sans-perte-dinformation-1",
    "title": "Normalisation I",
    "section": "Décomposition sans perte d’information",
    "text": "Décomposition sans perte d’information\nIdée : Si on remplace le schéma\n(V#, Vnom, Vville, P#, Pnom, Pville, Qte)\npar les trois schémas\nVendeur(V#, Vnom, Vville)\nProduit(P#, Pnom, Pville)\nLivraison(V#, P#, Qte)\nalors au lieu de stocker une relation R(V#, Vnom, Vville, P#, Pnom, Pville, Qte), on stockera ses projections:\n\\[\\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R}) \\qquad \\pi_{\\texttt{P\\#,Pnom,Pville}}(\\texttt{R}) \\qquad \\pi_{\\texttt{V\\#,P\\#,Qte}}(\\texttt{R})\\]\n Peut-on retrouver R à partir de ces trois projections ?"
  },
  {
    "objectID": "slides/DF_norm_1.html#décomposition-sans-perte-dinformation-2",
    "href": "slides/DF_norm_1.html#décomposition-sans-perte-dinformation-2",
    "title": "Normalisation I",
    "section": "Décomposition sans perte d’information",
    "text": "Décomposition sans perte d’information\n\nLa décomposition doit garantir que pour toute relation R, ses projections contiennent la même information que R au sens que l’on doit pouvoir reconstruire R à partir de ses projections\nComment tenter de reconstruire R à partir de ses projections ?\n\nOn considère la jointure naturelle\n\\[\\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{P\\#,Pnom,Pville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{V\\#,P\\#,Qte}}(\\texttt{R})\\]"
  },
  {
    "objectID": "slides/DF_norm_1.html#décomposition-sans-perte-dinformation-3",
    "href": "slides/DF_norm_1.html#décomposition-sans-perte-dinformation-3",
    "title": "Normalisation I",
    "section": "Décomposition sans perte d’information",
    "text": "Décomposition sans perte d’information\nLa propriété souhaitée s’écrit donc\n\\[R = \\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{P\\#,Pnom,Pville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{V\\#,P\\#,Qte}}(\\texttt{R})\\]\npour toute relation R(V#, Vnom, Vville, P#, Pnom, Pville, Qte) satisfaisant les DF\n\n\nEst ce vrai?\nIntuitivement, oui : à partir d’un tuple de Livraison(V#,P#,Qte)\nV# permet de récupérer toutes les informations sur le vendeur (V# ⟶ Vnom Vville)\nP# permet de récupérer toutes les informations sur le produit (P# ⟶ Pnom Pville)\n La propriété d’être sans perte d’information est liée à l’ensemble de DF considéré"
  },
  {
    "objectID": "slides/DF_norm_1.html#décomposition-sans-perte-dinformation-lossless-join",
    "href": "slides/DF_norm_1.html#décomposition-sans-perte-dinformation-lossless-join",
    "title": "Normalisation I",
    "section": "Décomposition sans perte d’information (lossless join)",
    "text": "Décomposition sans perte d’information (lossless join)\n\n\n\n\n\n\nDéfinition\n\n\nSoit \\(\\mathcal{A}\\) un schéma de relation et \\(\\Sigma\\) un ensemble de DF sur \\(\\mathcal{A}\\).\nUne décomposition \\(\\{\\mathcal{A}_1,..., \\mathcal{A}_k\\}\\) est sans perte d’information par rapport à \\(\\Sigma\\) si pour toute relation \\(R\\) de schéma \\(\\mathcal{A}\\) satisfaisant \\(\\Sigma\\) on a\n\\[R= \\pi_{\\mathcal{A}_1}(R) \\bowtie \\pi_{\\mathcal{A}_2}(R) \\bowtie...\\bowtie\\pi_{\\mathcal{A}_k}(R)\\]"
  },
  {
    "objectID": "slides/DF_norm_1.html#exemple-de-décomposition-avec-perte-dinformation",
    "href": "slides/DF_norm_1.html#exemple-de-décomposition-avec-perte-dinformation",
    "title": "Normalisation I",
    "section": "Exemple de décomposition avec perte d’information",
    "text": "Exemple de décomposition avec perte d’information\n\\(\\mathcal{A}=\\{A,B,C\\} \\quad  \\Sigma=\\{AB\\rightarrow C\\}\\)\nDécomposition \\(\\mathcal{A}_1=\\{A,B\\}  \\quad  \\mathcal{A}_2=\\{B,C\\}\\)\n\n\nSoit \\(R\\) la relation\n\n\n\nA\nB\nC\n\n\n\n\n1\n2\n3\n\n\n4\n2\n5\n\n\n\n\n\\(\\pi_{AB}(R)=\\)\n\n\n\nA\nB\n\n\n\n\n1\n2\n\n\n4\n2\n\n\n\n\n\\(\\pi_{BC}(R)=\\)\n\n\n\nB\nC\n\n\n\n\n2\n3\n\n\n2\n5\n\n\n\n\n\\(\\pi_{AB}(R) \\bowtie \\pi_{BC}(R)=\\)\n\n\n\nA\nB\nC\n\n\n\n\n1\n2\n3\n\n\n4\n2\n5\n\n\n1\n2\n5\n\n\n4\n2\n3"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite-1",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite-1",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite",
    "text": "Algorithme de poursuite\n\nComment déterminer si une décomposition est sans perte d’information?\nSi \\(R\\) est une relation de schéma \\(\\mathcal{A}\\) on a toujours que\n\n\\[R\\subset \\pi_{\\mathcal{A}_1}(R) \\bowtie \\pi_{\\mathcal{A}_2}(R) \\bowtie...\\bowtie\\pi_{\\mathcal{A}_k}(R)\\]\npar définition de la jointure naturelle et de la projection\n\nLe seul problème est que les jointures peuvent générer des tuples supplémentaires\nMais comme \\(R\\) est supposée vérifier les DF de \\(\\Sigma\\), l’inclusion inverse est garantie dans certains cas\nPour le savoir, un algorithme simple existe appelé algorithme de poursuite"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite : exemple",
    "text": "Algorithme de poursuite : exemple\nSi on remplace le schéma (V#, Vnom, Vville, P#, Pnom, Pville, Qte) par\nVendeur(V#, Vnom, Vville)}\nProduit(P#, Pnom, Pville)}\nLivraison(V#, P#, Qte)\nA-t-on\n\\[\\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{P\\#,Pnom,Pville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{V\\#,P\\#,Qte}}(R) \\subset \\texttt{R} \\quad ?\\]"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-1",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-1",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite : exemple",
    "text": "Algorithme de poursuite : exemple\nSoit \\(t\\) un tuple dans la jointure\n\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\n\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d\\)\n\\(e\\)\n\\(f\\)\n\\(g\\)\n\n\n\n\n\\((a, b, c)\\in \\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R})\\) donc il existe \\(e_1, f_1, g_1\\) tels que \\((a, b, c, d_1, e_1, f_1, g_1) \\in \\texttt{R}\\)\n\\((d,e,f) \\in \\pi_{\\texttt{P\\#,Pnom,Pville}}(\\texttt{R})\\) donc il existe \\(a_2, b_2, c_2, g_2\\) tels que \\((a_2, b_2, c_2, d, e, f, g_2)\\in \\texttt{R}\\)\n\\((a,d,g)\\in \\pi_{\\texttt{V\\#,P\\#,Qte}}(R)\\) donc il existe \\(b_3,c_3,e_3,f_3\\) tels que \\((a,b_3,c_3,d,e_3,f_3,g)\\in \\texttt{R}\\)\nOn peut le représenter comme ceci :\n\n\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\n\nVendeur\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d_1\\)\n\\(e_1\\)\n\\(f_1\\)\n\n\nProduit\n\\(a_2\\)\n\\(b_2\\)\n\\(c_2\\)\n\\(d\\)\n\\(e\\)\n\\(f\\)\n\n\nLivraison\n\\(a\\)\n\\(b_3\\)\n\\(c_3\\)\n\\(d\\)\n\\(e_3\\)\n\\(f_3\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-2",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-2",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite : exemple",
    "text": "Algorithme de poursuite : exemple\n\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\n\nVendeur\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d_1\\)\n\\(e_1\\)\n\\(f_1\\)\n\n\nProduit\n\\(a_2\\)\n\\(b_2\\)\n\\(c_2\\)\n\\(d\\)\n\\(e\\)\n\\(f\\)\n\n\nLivraison\n\\(a\\)\n\\(b_3\\)\n\\(c_3\\)\n\\(d\\)\n\\(e_3\\)\n\\(f_3\\)\n\n\n\n\nV# ⟶ Vnom, Vville donc \\(b_3=b\\) et \\(c_3=c\\)\n\n\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\n\nVendeur\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d_1\\)\n\\(e_1\\)\n\\(f_1\\)\n\n\nProduit\n\\(a_2\\)\n\\(b_2\\)\n\\(c_2\\)\n\\(d\\)\n\\(e\\)\n\\(f\\)\n\n\nLivraison\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d\\)\n\\(e_3\\)\n\\(f_3\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-suite",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-suite",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite : exemple (suite)",
    "text": "Algorithme de poursuite : exemple (suite)\n\nP#⟶ Pnom, Pville donc \\(e_3=e\\) et \\(f_3=f\\)\n\n\n\n\nV#\nVnom\nVville\nP#\nPnom\nPville\nQte\n\n\n\n\nVendeur\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d_1\\)\n\\(e_1\\)\n\\(f_1\\)\n\n\nProduit\n\\(a_2\\)\n\\(b_2\\)\n\\(c_2\\)\n\\(d\\)\n\\(e\\)\n\\(f\\)\n\n\nLivraison\n\\(a\\)\n\\(b\\)\n\\(c\\)\n\\(d\\)\n\\(e\\)\n\\(f\\)\n\n\n\n\nOn a obtenu une ligne égale au tuple \\(t=(a,b,c,d,e,f,g)\\) donc \\(t\\in \\texttt{R}\\).\n\nOn en déduit que la décomposition est Sans Perte d’Information (SPI)"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite-cas-général",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite-cas-général",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite : cas général",
    "text": "Algorithme de poursuite : cas général\n\nEntrée : un schéma \\(\\mathcal{A}\\), une décomposition \\(\\{\\mathcal{A}_1,...,\\mathcal{A}_k\\}\\) et un ensemble \\(\\Sigma\\) de DF\nPour chaque attribut de \\(\\mathcal{A}\\), choisir un symbole (par exemple \\(a\\), \\(b\\), \\(c\\),…). La correspondance doit être injective.\nConstruire un tableau dont les colonnes sont les attributs de \\(\\mathcal{A}\\)\n\nLe tableau a une ligne pour chaque \\(\\mathcal{A}_i\\)\nSur la ligne associée à \\(\\mathcal{A}_i\\), les positions correspondant à \\(\\mathcal{A}_i\\) sont remplies avec les symboles choisis.\nLes autres positions sont remplies avec les symboles indicés par \\(i\\)\n\nRépéter tant que possible : s’il existe une DF \\(X\\rightarrow Y\\) dans \\(\\Sigma\\) et deux lignes du tableau en accord sur \\(X\\), égaliser ces deux lignes sur \\(Y\\)\nSortie : Si on obtient une ligne sans valeur indicée, la décomposition est sans perte d’information, sinon il y a perte d’information"
  },
  {
    "objectID": "slides/DF_norm_1.html#section-5",
    "href": "slides/DF_norm_1.html#section-5",
    "title": "Normalisation I",
    "section": "",
    "text": "Preuve ()."
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-2-1",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-2-1",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite : exemple 2",
    "text": "Algorithme de poursuite : exemple 2\nConsidérons l’exemple : \\(\\mathcal{A}=\\{A,B,C,D\\}\\) avec \\(\\mathcal{A}_1=\\{A,B\\}\\), \\(\\mathcal{A}_2=\\{B,C\\}\\) et \\(\\mathcal{A}_3=\\{C,D\\}\\)\nSoit \\(\\Sigma=\\{{C}\\rightarrow{D}; {B}\\rightarrow{A}\\}\\).\nSoit \\(t=(a,b,c,d)\\). Soit \\(t_1,t_2,t_3\\) les tuples de \\(R\\) suivants:\n\n\n\n\nA\nB\nC\nD\n\n\n\n\n\\(t_2\\)\n\\(a_2\\)\nb\nc\n\\(d_2\\)\n\n\n\\(t_3\\)\n\\(a_3\\)\n\\(b_3\\)\nc\nd\n\n\n\nOn a pris \\(c_1,d_1, a_2,d_2, a_3,b_3\\) comme valeurs variables et a,b,c,d comme constantes"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite---exemple-2",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite---exemple-2",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite - exemple 2",
    "text": "Algorithme de poursuite - exemple 2\n\n\n\n\nA\nB\nC\nD\n\n\n\n\n\\(t_1\\)\na\nb\n\\(c_1\\)\n\\(d_1\\)\n\n\n\\(t_2\\)\n\\(a_2\\)\nb\nc\n\\(d_2\\)\n\n\n\\(t_3\\)\n\\(a_3\\)\n\\(b_3\\)\nc\nd\n\n\n\nPar la dépendance \\({B}\\rightarrow{A}\\), il vient :\n\n\n\n\nA\nB\nC\nD\n\n\n\n\n\\(t_1\\)\na\nb\n\\(c_1\\)\n\\(d_1\\)\n\n\n\\(t_2\\)\na\nb\nc\n\\(d_2\\)\n\n\n\\(t_3\\)\n\\(a_3\\)\n\\(b_3\\)\nc\nd"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-2-2",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite-exemple-2-2",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite : exemple 2",
    "text": "Algorithme de poursuite : exemple 2\nPar la dépendance \\({C}\\rightarrow{D}\\), il vient :\n\n\n\n\nA\nB\nC\nD\n\n\n\n\n\\(t_1\\)\na\nb\n\\(c_1\\)\n\\(d_1\\)\n\n\n\\(t_2\\)\na\nb\nc\nd\n\n\n\\(t_3\\)\n\\(a_3\\)\n\\(b_3\\)\nc\nd\n\n\n\nOn a bien fait apparaître \\(t\\) qui appartient donc à \\(R\\)."
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-de-poursuite---exemple-3",
    "href": "slides/DF_norm_1.html#algorithme-de-poursuite---exemple-3",
    "title": "Normalisation I",
    "section": "Algorithme de poursuite - exemple 3",
    "text": "Algorithme de poursuite - exemple 3\nConsidérons toujours l’exemple : \\(\\mathcal{A}=\\{A,B,C,D\\}\\) avec\n\\(\\mathcal{A}_1=\\{A,B\\}\\), \\(\\mathcal{A}_2=\\{B,C\\}\\) et \\(\\mathcal{A}_3=\\{C,D\\}\\)\nMais avec \\(\\Sigma=\\{{B}\\rightarrow{AD}\\}\\).\n\n\n\nA\nB\nC\nD\n\n\n\n\na\nb\n\\(c_1\\)\n\\(d_1\\)\n\n\n\\(a_2\\)\nb\nc\n\\(d_2\\)\n\n\n\\(a_3\\)\n\\(b_3\\)\nc\nd\n\n\n\nDans ce cas, en utilisant la seule DF \\({B}\\rightarrow{AD}\\), on obtient \\(a_2=a\\) et \\(d_1=d_2\\) :\n\n\n\nA\nB\nC\nD\n\n\n\n\na\nb\n\\(c_1\\)\n\\(d_1\\)\n\n\na\nb\nc\n\\(d_1\\)\n\n\n\\(a_3\\)\n\\(b_3\\)\nc\nd\n\n\n\n\n\n\n\n\n\nNote\n\n\nMais on ne peut aller plus loin : la jointure des projections contient des tuples qui ne sont pas dans la relation originelle"
  },
  {
    "objectID": "slides/Modelisation_1.html#pourquoi",
    "href": "slides/Modelisation_1.html#pourquoi",
    "title": "Modélisation I : Entité/Association",
    "section": "Pourquoi ?",
    "text": "Pourquoi ?\nPour construire/concevoir des bases de données utiles, il n’est pas facile d’utiliser immédiatement le Langage de Définition de Données (partie de SQL)\n\nIl est plus raisonnable de s’appuyer sur\n\n\n\nUn formalisme pour décrire les informations à intégrer dqns une base\nUn formalisme pour décrire les liens entre ses informations\nUn formalisme lisible par les humains\nUn formalisme traduisible dans un Langage de Définition de Données, c’est-à-dire dans un langage où tout doit se décrire à l’aide de tables et de contraintes"
  },
  {
    "objectID": "slides/Modelisation_1.html#comment",
    "href": "slides/Modelisation_1.html#comment",
    "title": "Modélisation I : Entité/Association",
    "section": "Comment ?",
    "text": "Comment ?\nDepuis les temps originels des Bases de Données, on a multiplié les formalismes, les méthodes de conception\nLes différents formalismes sont presque toujours des variations autour du modèle dit Entité-Association proposé par Chen en 1976"
  },
  {
    "objectID": "slides/Modelisation_1.html#modèle-entité-association-eaer",
    "href": "slides/Modelisation_1.html#modèle-entité-association-eaer",
    "title": "Modélisation I : Entité/Association",
    "section": "Modèle Entité-Association (EA/ER)",
    "text": "Modèle Entité-Association (EA/ER)\nPeter Chen, the father of ER modeling écrivait dans le texte fondateur:\n\nThe entity-relationship model adopts the more natural view that the real world consists of entities and relationships. It incorporates some of the important semantic information about the real world.\n\nDans l’article de 1976, Chen distingue explicitement les diagrammes entité–associations des techniques de modélisation par record:\n\nThe data structure diagram is a representation of the organization of records and is not an exact representation of entities and relationships.\n\n\n\nVoir La Sémantique selon wikipedia"
  },
  {
    "objectID": "slides/Modelisation_1.html#exemple-dentités-world",
    "href": "slides/Modelisation_1.html#exemple-dentités-world",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemple d’entités : world",
    "text": "Exemple d’entités : world\nPour la constitution de la base de données de géographie politique world, la modélisation choisirait les entités :\n\ncountry: les pays/territoires\ncity: les villes de population urbaine supérieure à un seuil donné lors de la constitution de la base\nlanguage: les langues parlées lors de la constitution de la base"
  },
  {
    "objectID": "slides/Modelisation_1.html#exemple-dentités-nycflights",
    "href": "slides/Modelisation_1.html#exemple-dentités-nycflights",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemple d’entités (nycflights)",
    "text": "Exemple d’entités (nycflights)\nPour la modélisation du traffic aérien civil aux États-Unis, on peut considérer les entités suivantes\n\nairports: les aéroports (civils, sur le sol des États-Unis)\nairlines: les compagnies aériennes\nplanes : les avions (aéronefs)"
  },
  {
    "objectID": "slides/Modelisation_1.html#les-noms-et-les-notations-graphiques",
    "href": "slides/Modelisation_1.html#les-noms-et-les-notations-graphiques",
    "title": "Modélisation I : Entité/Association",
    "section": "Les noms et les notations graphiques",
    "text": "Les noms et les notations graphiques\nLes entités sont généralement associées à des noms (substantifs). Une entité est en effet une collection d’objets apparentés (avec des caractériques communes)\n\nDans les diagrammes EA, les entités sont représentées par des rectangles. Le nom de l’entité est inscrit au centre du rectangle."
  },
  {
    "objectID": "slides/Modelisation_1.html#instances-et-entités",
    "href": "slides/Modelisation_1.html#instances-et-entités",
    "title": "Modélisation I : Entité/Association",
    "section": "Instances et Entités",
    "text": "Instances et Entités\n\n\n\n\n\n\nDéfinition\n\n\nUne instance est un élément d’une entité.\n\n\n\n\nDans word, le pays Luxemburg est une instance de country.\nLes instances d’une entité sont discernables (pas d’éléments dupliqués)\n\n\n\nLe jargon de la modélisation EA nomme des notions qui sont déjà présentes dans la théorie naïve des ensembles (le langage des mathématiciens)"
  },
  {
    "objectID": "slides/Modelisation_1.html#attributs",
    "href": "slides/Modelisation_1.html#attributs",
    "title": "Modélisation I : Entité/Association",
    "section": "Attributs",
    "text": "Attributs\n\n\n\n\n\n\nDéfinition\n\n\nUn attribut est une fonction qui envoie une entité dans un domaine (ensemble de valeurs, type)\n\n\n\n\nDans world, l’attribut name envoie country vers l’ensemble des chaînes de caractères. Dans l’égalité name(Luxemburg) = \"Luxemburg\", à gauche Luxemburg désigne le pays, à droite, \"Luxemburg\" est une chaîne de caractères\nL’attribut population envoie country vers les entiers (positifs)\n\n\nDans les diagrammes EA, les attributs sont représentés par des ellipses. Le nom de l’attribut est placé au centre de l’ellipse\nUn arête relie l’ellipse attribut au rectangle entité."
  },
  {
    "objectID": "slides/Modelisation_1.html#attributs-notation-graphique",
    "href": "slides/Modelisation_1.html#attributs-notation-graphique",
    "title": "Modélisation I : Entité/Association",
    "section": "Attributs (notation graphique)",
    "text": "Attributs (notation graphique)\n\n\n\n\n\n\nER\n\n\n\ncountry\n\ncountry\n\n\n\ncity\n\ncity\n\n\n\nname1\n\nname\n\n\n\ncity--name1\n\n\n\n\nlanguage\n\nlanguage\n\n\n\nname2\n\nname\n\n\n\nlanguage--name2\n\n\n\n\nname0\n\nname\n\n\n\nname0--country\n\n\n\n\npopulation\n\npopulation\n\n\n\npopulation--country\n\n\n\n\ngovernmentForm\n\ngovernmentForm\n\n\n\ngovernmentForm--country\n\n\n\n\nheadOfState\n\nheadOfState\n\n\n\nheadOfState--country"
  },
  {
    "objectID": "slides/Modelisation_1.html#identifiant",
    "href": "slides/Modelisation_1.html#identifiant",
    "title": "Modélisation I : Entité/Association",
    "section": "Identifiant",
    "text": "Identifiant\n\n\n\n\n\n\nDéfinition\n\n\nPour une entité, un identifiant est un attribut qui envoie deux instances distinctes vers deux valeurs distinctes du domaine.\n\n\n\n\n\n\n\n\n\nAstuce\n\n\nUn identifiant est un attribut (une fonction) injectif(ve)\nDans un schéma EA, on choisit un attribut injectif et on le désigne comme identifiant en soulignant le nom de l’attribut.\n L’identifiant d’une entité n’est pas le nom de l’entité"
  },
  {
    "objectID": "slides/Modelisation_1.html#identifiant-exemple",
    "href": "slides/Modelisation_1.html#identifiant-exemple",
    "title": "Modélisation I : Entité/Association",
    "section": "Identifiant (exemple)",
    "text": "Identifiant (exemple)\nLa norme ISO-3166 associe à chaque pays un code en deux lettres (alpha-2). Pour le Luxemburg, il s’agit de LU\nLa norme ISO-3166 associe à chaque pays un code en trois lettres (alpha-3). Pour le Luxemburg, il s’agit de LUX\n\n\nNorme ISO 3166 selon Wikipedia"
  },
  {
    "objectID": "slides/Modelisation_1.html#identifiant-représentation",
    "href": "slides/Modelisation_1.html#identifiant-représentation",
    "title": "Modélisation I : Entité/Association",
    "section": "Identifiant (représentation)",
    "text": "Identifiant (représentation)\n\n\n\n\n\n\nER\n\n\n\ncountry\n\ncountry\n\n\n\niso\n\niso3\n\n\n\ncountry--iso\n\n\n\n\ncity\n\ncity\n\n\n\nname1\n\nname\n\n\n\ncity--name1\n\n\n\n\nlanguage\n\nlanguage\n\n\n\nname2\n\nname\n\n\n\nlanguage--name2\n\n\n\n\nname0\n\nname\n\n\n\nname0--country\n\n\n\n\npopulation\n\npopulation\n\n\n\npopulation--country\n\n\n\n\ngovernmentForm\n\ngovernmentForm\n\n\n\ngovernmentForm--country\n\n\n\n\nheadOfState\n\nheadOfState\n\n\n\nheadOfState--country\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nOn singularise les identifiants en les soulignant."
  },
  {
    "objectID": "slides/Modelisation_1.html#association-exemple",
    "href": "slides/Modelisation_1.html#association-exemple",
    "title": "Modélisation I : Entité/Association",
    "section": "Association (exemple)",
    "text": "Association (exemple)\nDans world, on peut définir une association is-in entre les entités city et country."
  },
  {
    "objectID": "slides/Modelisation_1.html#graphique",
    "href": "slides/Modelisation_1.html#graphique",
    "title": "Modélisation I : Entité/Association",
    "section": "Graphique",
    "text": "Graphique\n\n\n\n\n\n\nER\n\n\n\ncountry\n\ncountry\n\n\n\niso\n\niso3\n\n\n\ncountry--iso\n\n\n\n\ncity\n\ncity\n\n\n\nname1\n\nname\n\n\n\ncity--name1\n\n\n\n\nid\n\nid\n\n\n\ncity--id\n\n\n\n\nis-in\n\nis-in\n\n\n\ncity--is-in\n\n\n\n\nis-capital\n\nis-capital\n\n\n\ncity--is-capital\n\n\n\n\nlanguage\n\nlanguage\n\n\n\nname2\n\nname\n\n\n\nlanguage--name2\n\n\n\n\nisol\n\niso\n\n\n\nlanguage--isol\n\n\n\n\nis-spoken-in\n\nis-spoken-in\n\n\n\nlanguage--is-spoken-in\n\n\n\n\nname0\n\nname\n\n\n\nname0--country\n\n\n\n\npopulation\n\npopulation\n\n\n\npopulation--country\n\n\n\n\ngovernmentForm\n\ngovernmentForm\n\n\n\ngovernmentForm--country\n\n\n\n\nheadOfState\n\nheadOfState\n\n\n\nheadOfState--country\n\n\n\n\nis-in--country\n\n\n\n\nis-spoken-in--country\n\n\n\n\nis-capital--country"
  },
  {
    "objectID": "slides/Modelisation_1.html#remarques-suite",
    "href": "slides/Modelisation_1.html#remarques-suite",
    "title": "Modélisation I : Entité/Association",
    "section": "Remarques (suite)",
    "text": "Remarques (suite)\n\n\n\n\n\n\nNote\n\n\nUne association est représentée par un losange, elle est nommée.\nLe losange est relié aux dfférentes entités participantes par une arête\nLe nom d’une association reflète (en principe) la signification de cette association.\nLe nom d’une association renvoie souvent à un verbe, pas forcémment d’action\n\n\n\n\n\n\n\n\n\nAvertissement\n\n\nIl n’est pas toujours évident de lire sur le graphique le rôle joué par les différentes entités participantes dans une association. Bien nommer aide."
  },
  {
    "objectID": "slides/Modelisation_1.html#attributs-dassociation",
    "href": "slides/Modelisation_1.html#attributs-dassociation",
    "title": "Modélisation I : Entité/Association",
    "section": "Attributs d’association",
    "text": "Attributs d’association\nUne association peut posséder des attributs.\nGraphiquement, les attributs d’association sont représentés comme les attributs d’entité, par des ellipses. Les ellipses sont reliées au losange de l’association par une arête\n\nDans world, l’association is-spoken-in peut être munie d’un attribut official qui précise si une langue donnée est officielle dans un territoire donné."
  },
  {
    "objectID": "slides/Modelisation_1.html#partipations-multiples-à-une-association",
    "href": "slides/Modelisation_1.html#partipations-multiples-à-une-association",
    "title": "Modélisation I : Entité/Association",
    "section": "Partipations multiples à une association",
    "text": "Partipations multiples à une association\n Une même entité peut participer plusieurs fois à une même association\nOn distingue ces participations grâce à des rôles qui étiquettent les arêtes qui relient le rectangle entité au losange association."
  },
  {
    "objectID": "slides/Modelisation_1.html#exemples-de-rôle-dans-une-association-réflexive",
    "href": "slides/Modelisation_1.html#exemples-de-rôle-dans-une-association-réflexive",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemples de rôle dans une association réflexive",
    "text": "Exemples de rôle dans une association réflexive\nDans une base de donnée généalogique, on part d’une entité individu. On définit une auto-association mère qui relie l’entité individu avec elle-même.\n\nCette auto-association n’est pas symétrique: quand on écrit qu’Elizabeth est mère de Charles, Elisabeth et Charles ne jouent pas le même rôle.\n\n\nDans une instance \\((x,y)\\) de l’association mère \\(x\\) joue le rôle de la génitrice, \\(y\\) de l’enfant.\n\n\nOn peut rendre compte de ces rôles en marquant les arêtes qui lient l’entité individu à l’association mère (pour est-maman-de)"
  },
  {
    "objectID": "slides/Modelisation_1.html#une-association-darité-supérireure-à-2",
    "href": "slides/Modelisation_1.html#une-association-darité-supérireure-à-2",
    "title": "Modélisation I : Entité/Association",
    "section": "Une association d’arité supérireure à 2",
    "text": "Une association d’arité supérireure à 2\nPour construire un modèle des vols aériens (comme dans nycflights13), on définit des entités airline plane, airport et une association quaternaire flight\n\nL’association flight est quaternaire: une instance de flight associe un aéroport d’origine à un aéroport de destination (2 arêtes entre airport et flight), elle associe aussi une instance de plane et une instance de airline\n\n\nOn distingue les deux participations de airport à flight par des rôles"
  },
  {
    "objectID": "slides/Modelisation_1.html#principe-et-objet",
    "href": "slides/Modelisation_1.html#principe-et-objet",
    "title": "Modélisation I : Entité/Association",
    "section": "Principe et objet",
    "text": "Principe et objet\nDans une association entre plusieurs entités, les instances d’une entité peuvent participer a priori 0, 1, ou un nombre illimité de fois aux instances de l’association\nPour traduire les associations dans le langage des tables et des contraintes (LDD), il est très utile d’encadrer le plus précisément possible le nombre de participations d’une instance d’une entité aux instances d’une associations\nLes cardinalités sont des décorations sur les arêtes qui relient entités et associations"
  },
  {
    "objectID": "slides/Modelisation_1.html#cas-des-relations-binaires-2-entités",
    "href": "slides/Modelisation_1.html#cas-des-relations-binaires-2-entités",
    "title": "Modélisation I : Entité/Association",
    "section": "Cas des relations binaires (2 entités)",
    "text": "Cas des relations binaires (2 entités)"
  },
  {
    "objectID": "slides/Modelisation_1.html#exemples-11",
    "href": "slides/Modelisation_1.html#exemples-11",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemples 1:1",
    "text": "Exemples 1:1\nDans le modèle world,\n\nune instance de city apparaît 1 et 1 seule fois dans l’association is-in. On dira que is-in est de cardinalité 1:1 du côté de city. Une ville se situe sur le territoire d’un pays (et d’un seul)"
  },
  {
    "objectID": "slides/Modelisation_1.html#exemples-1n",
    "href": "slides/Modelisation_1.html#exemples-1n",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemples 1:n",
    "text": "Exemples 1:n\nDans le modèle world,\n\nune instance de country peut apparaître une nombre arbitraire de fois dans l’association ‘is-in’. On dira que is-in est de cardinalité 0:n du côté de city. Un territoire peut ne comporter aucune ville de population supérieure à un seuil. Il n’y a pas de borne a priori sur le nombre de grandes villes situées sur un territoire"
  },
  {
    "objectID": "slides/Modelisation_1.html#exemples-0n",
    "href": "slides/Modelisation_1.html#exemples-0n",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemples 0:n",
    "text": "Exemples 0:n\nDans le modèle world,\n\nune instance de language peut apparaître une nombre arbitraire de fois dans l’association is-spoken-in. On dira que is-spoken-in est de cardinalité 0:n du côté de language.\nune instance de country peut apparaître une nombre arbitraire de fois dans l’association ‘is-spoken-in’. On dira que is-spoken-in est de cardinalité 0:n du côté de country."
  },
  {
    "objectID": "slides/Modelisation_1.html#diagrammes",
    "href": "slides/Modelisation_1.html#diagrammes",
    "title": "Modélisation I : Entité/Association",
    "section": "Diagrammes",
    "text": "Diagrammes\nUne indication de cardinalité comporte une borne inférieure (0 ou 1) et une borne supérieure (1 ou \\(n\\))\nOn décore le lien entité-association avec l’indication de cardinalité"
  },
  {
    "objectID": "slides/Modelisation_1.html#représentation-graphique-des-cardinalités",
    "href": "slides/Modelisation_1.html#représentation-graphique-des-cardinalités",
    "title": "Modélisation I : Entité/Association",
    "section": "Représentation graphique des cardinalités",
    "text": "Représentation graphique des cardinalités\n\n\n\n\n\n\nER\n\n\n\ncountry\n\ncountry\n\n\n\niso\n\niso3\n\n\n\ncountry--iso\n\n\n\n\ncity\n\ncity\n\n\n\nname1\n\nname\n\n\n\ncity--name1\n\n\n\n\nid\n\nid\n\n\n\ncity--id\n\n\n\n\nis-in\n\nis-in\n\n\n\ncity--is-in\n\n1:1\n\n\n\nis-capital\n\nis-capital\n\n\n\ncity--is-capital\n\n0:1\n\n\n\nlanguage\n\nlanguage\n\n\n\nname2\n\nname\n\n\n\nlanguage--name2\n\n\n\n\nisol\n\niso\n\n\n\nlanguage--isol\n\n\n\n\nis-spoken-in\n\nis-spoken-in\n\n\n\nlanguage--is-spoken-in\n\n0:n\n\n\n\nname0\n\nname\n\n\n\nname0--country\n\n\n\n\npopulation\n\npopulation\n\n\n\npopulation--country\n\n\n\n\ngovernmentForm\n\ngovernmentForm\n\n\n\ngovernmentForm--country\n\n\n\n\nheadOfState\n\nheadOfState\n\n\n\nheadOfState--country\n\n\n\n\nis-in--country\n\n0:n\n\n\n\nis-spoken-in--country\n\n0:n\n\n\n\nis-capital--country\n\n0:1"
  },
  {
    "objectID": "slides/Modelisation_1.html#représentation-graphique-des-cardinalités-suite",
    "href": "slides/Modelisation_1.html#représentation-graphique-des-cardinalités-suite",
    "title": "Modélisation I : Entité/Association",
    "section": "Représentation graphique des cardinalités (suite)",
    "text": "Représentation graphique des cardinalités (suite)\nOn peut utilement préciser les cardinalités dans notre schéma des vols.\n\n\n\n\n\n\nER\n\n\n\nairport\n\nairport\n\n\n\nflight\n\nflight\n\n\n\nairport--flight\n\norig\n0:n\n\n\n\nplane\n\nplane\n\n\n\nairline\n\nairline\n\n\n\nflight--airport\n\ndest\n0:n\n\n\n\nflight--plane\n\n0:n\n\n\n\nflight--airline\n\n0:n"
  },
  {
    "objectID": "slides/Modelisation_1.html#définition-6",
    "href": "slides/Modelisation_1.html#définition-6",
    "title": "Modélisation I : Entité/Association",
    "section": "Définition",
    "text": "Définition\n\n\n\n\n\n\nNote\n\n\nUne entité faible \\(E\\) est définie relativement à une entité \\(A\\). C’est une collection d’objets apparentés (comme une entité), mais chaque instance de \\(E\\) est liée (est partie de) à une et une seule instance de \\(A\\)."
  },
  {
    "objectID": "slides/Modelisation_1.html#exemple",
    "href": "slides/Modelisation_1.html#exemple",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemple",
    "text": "Exemple\nDans world, on peut considérer que les instances de country sont des unités territoriales de niveau 0. Ces unités territoriales de niveau 1 sont parfois découpées en unités territoriales de niveau 1 : les régions en France, en Italie, les Länder en Allemagne, …\nChaque unité territoriale de niveau 1 est située dans une et une seule unité territoriale de niveau 0, elle fait partie de l’unité territoriale de niveau 0.\nUnités territoriales\n\nNous allons ajouter à notre modèle EA Géographie une entité faible appelée nut1 (pour Nouvelle Unité Territoriale de niveau 1)\nL’entité faible nut1 est liée à l’entité forte country par une association faible is-in."
  },
  {
    "objectID": "slides/Modelisation_1.html#diagrammes-pour-les-entités-faibles",
    "href": "slides/Modelisation_1.html#diagrammes-pour-les-entités-faibles",
    "title": "Modélisation I : Entité/Association",
    "section": "Diagrammes pour les entités faibles",
    "text": "Diagrammes pour les entités faibles\n\n\n\n\n\n\nER\n\n\n\ncountry\n\ncountry\n\n\n\niso\n\niso3\n\n\n\ncountry--iso\n\n\n\n\ncity\n\ncity\n\n\n\nname1\n\nname\n\n\n\ncity--name1\n\n\n\n\nid\n\nid\n\n\n\ncity--id\n\n\n\n\nis-in\n\nis-in\n\n\n\ncity--is-in\n\n1:1\n\n\n\nis-capital\n\nis-capital\n\n\n\ncity--is-capital\n\n0:1\n\n\n\nlanguage\n\nlanguage\n\n\n\nname2\n\nname\n\n\n\nlanguage--name2\n\n\n\n\nisol\n\niso\n\n\n\nlanguage--isol\n\n\n\n\nis-spoken-in\n\nis-spoken-in\n\n\n\nlanguage--is-spoken-in\n\n0:n\n\n\n\nname0\n\nname\n\n\n\nname0--country\n\n\n\n\npopulation\n\npopulation\n\n\n\npopulation--country\n\n\n\n\ngovernmentForm\n\ngovernmentForm\n\n\n\ngovernmentForm--country\n\n\n\n\nheadOfState\n\nheadOfState\n\n\n\nheadOfState--country\n\n\n\n\nis-in--country\n\n0:n\n\n\n\nis-spoken-in--country\n\n0:n\n\n\n\nis-capital--country\n\n0:1\n\n\n\nnut1\n\n\nnut1\n\n\n\nis-in2\n\n\nis-in\n\n\n\nnut1--is-in2\n\n1:1\n\n\n\nis-in2--country\n\n0:n"
  },
  {
    "objectID": "slides/Modelisation_1.html#identifiant-pour-les-entités-faibles",
    "href": "slides/Modelisation_1.html#identifiant-pour-les-entités-faibles",
    "title": "Modélisation I : Entité/Association",
    "section": "Identifiant pour les entités faibles",
    "text": "Identifiant pour les entités faibles\nPour identifier une instance d’une entité faible, on utilise l’identifiant de l’instance associée de l’entité faible et on le complète à l’aide d’un identifiant relatif.\n Deux instances distinctes d’une identité faible peuvent porter le même identifiant relatif (si elles sont parties de deux instances différentes de l’entité forte).\n\nNous ajoutons à notre modèle EA un identifiant relatif/faible id pour l’entité faible nut1\nPour identifier une instance de nut1, il faut disposer de son identifiant relatif id et de l’identifiant iso3 de l’instance associée dans l’entité forte.\nOn dit que l’association faible is-in est identifiante"
  },
  {
    "objectID": "slides/Modelisation_1.html#définition-7",
    "href": "slides/Modelisation_1.html#définition-7",
    "title": "Modélisation I : Entité/Association",
    "section": "Définition",
    "text": "Définition\n\n\n\n\n\n\nNote\n\n\nUne association qui relie une entité faible à une entité forte qui participe à l’identification des instances de l’entité faible est dite faible.\nLes instances de l’entité faible participentt à cette association faible avec une cardinalité 1:1\nLes instances de l’entité forte participent à l’association faible avec une cardinalitę 0:n"
  },
  {
    "objectID": "slides/Modelisation_1.html#exemple-1",
    "href": "slides/Modelisation_1.html#exemple-1",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemple",
    "text": "Exemple\nDans nycflights, si on représente les vols (flight) comme des entités faibles, les associations entre vols et aéroports (décolle de, atterrit à) sont des associations faibles, chaque instance de flight participe une fois exactement à chaque association faible."
  },
  {
    "objectID": "slides/Modelisation_1.html#association-darité-quelconque-en-associations-binaires",
    "href": "slides/Modelisation_1.html#association-darité-quelconque-en-associations-binaires",
    "title": "Modélisation I : Entité/Association",
    "section": "Association d’arité quelconque en associations binaires",
    "text": "Association d’arité quelconque en associations binaires\nOn définit une entité faible de même nom que l’association.\nPour chaque entité participant à l’association, on définit une association faible entre l’entité participante et la nouvelle entité faible.\nSi une entité participe plusieurs fois à l’association, on définit autant d’associations faibles qu’on nomme à l’aide des rôles\nL’entité faible participe aux associations faibles avec une cardinalité 1:1\nLes entités participantes sont reliées aux associations faibles avec les cardinalités de leur participation à l’associatoin \\(n\\)-aire."
  },
  {
    "objectID": "slides/Modelisation_1.html#transformation-du-diagramme-des-vols",
    "href": "slides/Modelisation_1.html#transformation-du-diagramme-des-vols",
    "title": "Modélisation I : Entité/Association",
    "section": "Transformation du diagramme des vols",
    "text": "Transformation du diagramme des vols\nOn définit donc\n\nune entité faible flight\nquatre associations faibles dest, orig, operates, uses\n\n\nLes quatre associations faibles sont identifiantes\nPour identifier une instance de l’entité faible flight, il faut disposer des identifiants des instances des entités fortes associées (une par entité forte, compte tenu des cardinalités)"
  },
  {
    "objectID": "slides/Modelisation_1.html#définition-8",
    "href": "slides/Modelisation_1.html#définition-8",
    "title": "Modélisation I : Entité/Association",
    "section": "Définition",
    "text": "Définition\n\n\n\n\n\n\nDéfinition\n\n\nUne association est-un entre une entité A et une entité B indique que toute instance (élément) de A est aussi instance (élément) de B (autrement dit en langage ensembliste que A ⊆ B)\nOn note graphiquement les associations est-un avec un symbole spécial : un triangle (A ◃ B)\n\n\n\n\n\n\n\n\n\n\nRemarques\n\n\n\nUne association est-un est binaire\nUne entité peut participer à plusieurs associations est-un\nSi A ◃ B on dit (souvent) que A est une spécialisation de B"
  },
  {
    "objectID": "slides/Modelisation_1.html#propriété",
    "href": "slides/Modelisation_1.html#propriété",
    "title": "Modélisation I : Entité/Association",
    "section": "Propriété",
    "text": "Propriété\nPour les associations est-un, il n’est pas nécessaire de préciser les cardinalités.\n\n\n\n\n\n\nCardinalités des associations est-un\n\n\n\n1:1 du côté de l’entité spécialisée\n0:1 du côté de l’entité générale\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nL’association est identifiante : une instance de l’entité spécialisée hérite de l’identifiant de l’entité générale"
  },
  {
    "objectID": "slides/Modelisation_1.html#exemple-2",
    "href": "slides/Modelisation_1.html#exemple-2",
    "title": "Modélisation I : Entité/Association",
    "section": "Exemple",
    "text": "Exemple\nUn médecin peut exercer en mode libéral, au sein d’un cabinet, ou dans une clinique (ou les deux) ou exercer en milieu hospitalier.\nIl est aussi possible qu’un médecin partage son temps entre une activité hospitalière et une activité libérale.\nOn peut définir une entité générale médecin et deux entités spécialisées hospitalier et libéral. Les entités spécialisées sont reliées à l’entité générale par une association est-un.\n Une association est-un nous indique qu’une entité (un emsemble) est incluse dans une autre entité (un au ensemble)\nTout attribut (fonction) défini sur l’entité générale est défini sur les entités spécialisées\nCertains attributs peuvent être définis sur une entité spécialisée sans être définis sur toute l’entité générale\nPar exemple, on peut définir un attribut hôpital pour l’entité hospitalier, et un attribut cabinet pour l’entité libéral."
  },
  {
    "objectID": "slides/Modelisation_1.html#diagramme",
    "href": "slides/Modelisation_1.html#diagramme",
    "title": "Modélisation I : Entité/Association",
    "section": "Diagramme",
    "text": "Diagramme\n\n\n\n\n\n\nER\n\n\n\nmédecin\n\nmédecin\n\n\n\nmatricule\n\nmatricule\n\n\n\nmédecin--matricule\n\n\n\n\nhospitalier\n\nhospitalier\n\n\n\nis-a-1\n\nest-un\n\n\n\nhospitalier--is-a-1\n\n\n\n\nlibéral\n\nlibéral\n\n\n\nis-a-2\n\nest-un\n\n\n\nlibéral--is-a-2\n\n\n\n\nis-a-1--médecin\n\n\n\n\nis-a-2--médecin\n\n\n\n\nhôpital\n\nhôpital\n\n\n\nhôpital--hospitalier\n\n\n\n\ncabinet\n\ncabinet\n\n\n\ncabinet--libéral"
  },
  {
    "objectID": "slides/Modelisation_1.html#compléter-le-schéma",
    "href": "slides/Modelisation_1.html#compléter-le-schéma",
    "title": "Modélisation I : Entité/Association",
    "section": "Compléter le schéma",
    "text": "Compléter le schéma\nLe schéma/diagramme ne restitue pas toujours intégralement les informations récoltées pendant la phase de définition du système d’information\nLes contraintes de cardinalité ne sont pas les seules possibles\nLes autres contraintes rentrent dans la catégorie des contraintes dites externes (elles sont externes au diagramme)\nLes contraintes externes doivent être consignées et prises en compte ultérieurement lors de la traduction en modèle relationnel"
  },
  {
    "objectID": "slides/Modelisation_1.html#types-de-contraintes",
    "href": "slides/Modelisation_1.html#types-de-contraintes",
    "title": "Modélisation I : Entité/Association",
    "section": "Types de contraintes",
    "text": "Types de contraintes\n\nContraintes d’exclusion\n\nDans nycflights, deux instances de l’association flights portant sur le même aéronef ne devraient pas se chevaucher dans le temps\n\nContraintes de spécialisation\n\nContrainte de spécialisation disjointe : une instance appartient à au plus une spécialisation\nContrainte de spécialisation totale : une instance appartient à au moins une spécialisation\nContrainte de spécialisation disjointe et totale : une instance appartient à exactement une spécialisation"
  },
  {
    "objectID": "slides/Modelisation_1.html#restructuration-des-spécialisations",
    "href": "slides/Modelisation_1.html#restructuration-des-spécialisations",
    "title": "Modélisation I : Entité/Association",
    "section": "Restructuration des spécialisations",
    "text": "Restructuration des spécialisations\nPourquoi ?\n\nPlusieurs manières de procéder:\n\nÉliminer les entités mères (spécialisation totale avec peu d’attributs propres à l’entié mère)\n\nOU\n\nÉliminer les entités filles (entités filles ont peu d’attributs propres, participent à peu d’associations)\n\nOU\n\nSimuler la spécialisation avec une association faible (les entités filles sont vues comme des entités faibles)"
  },
  {
    "objectID": "slides/Modelisation_1.html#sites-et-livres",
    "href": "slides/Modelisation_1.html#sites-et-livres",
    "title": "Modélisation I : Entité/Association",
    "section": "Sites et Livres",
    "text": "Sites et Livres\n\nGarcia-Molina, H., Ullman, J. D., & Widom, J. (2002). Database systems-the complete book (International Ed.). Prenctice Hall, Upper Saddle River.\nChen, P. P. S. (1976). The entity-relationship model—toward a unified view of data. ACM transactions on database systems (TODS), 1(1), 9-36.\nSilberschatz, A., Korth, H. F., & Sudarshan, S. (2011). Database system concepts."
  },
  {
    "objectID": "slides/LDD_1.html#problème",
    "href": "slides/LDD_1.html#problème",
    "title": "BD : Contraintes",
    "section": "Problème",
    "text": "Problème\n\nLa définition d’un schéma de base ne s’arrête pas à la définition des tables, des colonnes et des types des colonnes\n\n\n\nLes contraintes décrivent des propriétés que devront vérifier toutes les mises en oeuvre (instances) du schéma durant toute sa durée de vie\n\n La définition d’un schéma de base ne s’arrête pas à la définition des tables, des colonnes et des types des colonnes\nLes contraintes décrivent des propriétés que devront vérifier toutes les mises en oeuvre (instances) du schémas durant toute leur durée de vie\n Pour spécifier une contrainte, il suffit de préciser que le résultat d’une certaine requête doit toujours être vide"
  },
  {
    "objectID": "slides/LDD_1.html#famille-de-contraintes",
    "href": "slides/LDD_1.html#famille-de-contraintes",
    "title": "BD : Contraintes",
    "section": "Famille de contraintes",
    "text": "Famille de contraintes\n\nContraintes d’attribut\n\nContrainte de type\n\nContrainte de non-nullité\n\n\n\n\nContraintes de tupe\n\nContrainte de vérification\n\n\n\n\n\nContraintes de table\n\nContrainte de clé primaire\n\nContrainte d’unicité\nContrainte d’unicité avancée\nContraintes d’exclusion\n\n\n\n\n\nContraintes multi-tables\n\nContraintes de clé étrangère"
  },
  {
    "objectID": "slides/LDD_1.html#contrainte-de-type",
    "href": "slides/LDD_1.html#contrainte-de-type",
    "title": "BD : Contraintes",
    "section": "Contrainte de type",
    "text": "Contrainte de type\nUne contrainte de type spécifie le type/domaine d’une colonne\nLes contrainte de type sont les plus simples à mettre en oeuvre.\n\nAu delà des types de base varchar, integer, ... PostgreSQL propose des types sophistiqués pour :\n\ndates,\nles estampilles avec ou sans fuseau horaire,\ndes types intervalles (rangetype),\ndes types énumérés,\ndes types tableaux,\netc"
  },
  {
    "objectID": "slides/LDD_1.html#consulter-la-liste-des-types",
    "href": "slides/LDD_1.html#consulter-la-liste-des-types",
    "title": "BD : Contraintes",
    "section": "Consulter la liste des types",
    "text": "Consulter la liste des types\nhttps://docs.postgresql.fr/docs/current/datatype.html\nIl faut essayer d’utiliser ces types pour préciser les contenus des colonnes\n\n\n\n\n\n\nConseil\n\n\nIl faut essayer d’utiliser autant que possible ces types pour préciser les contenus des colonnes\nCela permet de contraindre les contenus\nCela permet d’utiliser une foule de fonctions de manipulation très pratiques, notamment pour l’arithmétique du temps\n\n\n\n\n\n\n\n\n\n\nMise en garde\n\n\nLes types disponibles diffèrent d’un SGBD à l’autre (Mysql, Postgres, Oracle, SQL Server, …)"
  },
  {
    "objectID": "slides/LDD_1.html#contraintes-de-tuple",
    "href": "slides/LDD_1.html#contraintes-de-tuple",
    "title": "BD : Contraintes",
    "section": "Contraintes de tuple",
    "text": "Contraintes de tuple\nUne contrainte de tuple peut être vérifiée tuple par tuple (ligne par ligne)\n\nLors d’une insertion ou d’une modification de tuple, il suffit de vérifier que la contrainte est respectée par le nouveau tuple"
  },
  {
    "objectID": "slides/LDD_1.html#exemple",
    "href": "slides/LDD_1.html#exemple",
    "title": "BD : Contraintes",
    "section": "Exemple",
    "text": "Exemple\nDans un tuple de Piece, on devrait toujours avoir une valeur du prix positive.\nOn peut imposer cela en ajoutant au schéma de la table Piece une contrainte de type CHECK"
  },
  {
    "objectID": "slides/LDD_1.html#exemple-suite",
    "href": "slides/LDD_1.html#exemple-suite",
    "title": "BD : Contraintes",
    "section": "Exemple (suite)",
    "text": "Exemple (suite)\nCREATE TABLE piece(\n    nomp VARCHAR(20),\n    prix MONEY CHECK (prix&gt;= 0::money), \n    couleur VARCHAR(15)\n);\n\n\n\n\n\n\n\nNote\n\n\nHave a look at PostGres Monetary type"
  },
  {
    "objectID": "slides/LDD_1.html#exemple-world.country",
    "href": "slides/LDD_1.html#exemple-world.country",
    "title": "BD : Contraintes",
    "section": "Exemple world.country",
    "text": "Exemple world.country\nDans un tuple de country, les colonnes numériques ne devraient pas prendre de valeur négative\n\n\nCREATE TABLE world.country (\n    countrycode BPCHAR(3) NOT NULL,\n    name_country TEXT NOT NULL,\n    continent TEXT NOT NULL,\n    region TEXT NOT NULL,\n    surfacearea FLOAT4 CHECK (surfacearea&gt;= 0) NOT NULL, \n    indepyear INT2 NULL,\n    population_country INT4 NOT NULL,\n    lifeexpectancy FLOAT4 CHECK (lifeexpectancy&gt;= 0) NULL, \n    gnp NUMERIC(10, 2) NULL,    \n    gnpold NUMERIC(10, 2) NULL,  \n    localname TEXT NOT NULL,\n    governmentform TEXT NOT NULL,\n    headofstate TEXT NULL,\n    capital INT4 NULL,\n    code2 BPCHAR(2) NOT NULL,\n    CONSTRAINT country_continent_check CHECK (\n        ((continent = 'Asia'::text) OR (continent = 'Europe'::text) OR \n         (continent = 'North America'::text) OR (continent = 'Africa'::text) OR \n         (continent = 'Oceania'::text) OR (continent = 'Antarctica'::text) OR \n         (continent = 'South America'::text))),\n    CONSTRAINT country_pkey PRIMARY KEY (countrycode)\n);"
  },
  {
    "objectID": "slides/LDD_1.html#contrainte-de-vérification---exemple-suite",
    "href": "slides/LDD_1.html#contrainte-de-vérification---exemple-suite",
    "title": "BD : Contraintes",
    "section": "Contrainte de vérification - Exemple (suite)",
    "text": "Contrainte de vérification - Exemple (suite)\n\nCREATE TABLE piece(\n    nomp VARCHAR(20),\n    prix moNey CHECK (prix&gt;= 0::money),  \n    prix_promo MONEY CHECK (prix_promo &gt;= 0::MONEY), \n    couleur VARCHAR(15),\n    CHECK(prix &gt; prix_promo) \n); \n\n\nINSERT INTO piece \n  VALUES\n  ('x21', 1.51, 1.61,'rouge');\nERROR:  new row for relation \"piece\" violates check constraint piece_check \n\n\nINSERT INTO piece VALUES('x21', 1.51, null,'rouge');\nest accepté"
  },
  {
    "objectID": "slides/LDD_1.html#valeurs-nulles-et-contraintes-de-tuple",
    "href": "slides/LDD_1.html#valeurs-nulles-et-contraintes-de-tuple",
    "title": "BD : Contraintes",
    "section": " Valeurs nulles et contraintes de tuple",
    "text": "Valeurs nulles et contraintes de tuple\nLes contraintes CHECK sont satisfaites si l’expression associée vaut TRUE ou NULL\n\nComme une expression composée vaut parfois NULL si l’un des opérandes vaut lui-même NULL, les contraintes CHECK ne suffisent pas à prévenir l’insertion de valeurs nulles\n\n\n\n\n\n\n\n\nAstuce\n\n\nIl faut compléter les contraintes de tuple avec des contraintes de non-nullité"
  },
  {
    "objectID": "slides/LDD_1.html#pourquoi-imposer-quune-colonne-soit-toujours-renseignée",
    "href": "slides/LDD_1.html#pourquoi-imposer-quune-colonne-soit-toujours-renseignée",
    "title": "BD : Contraintes",
    "section": "Pourquoi imposer qu’une colonne soit toujours renseignée ?",
    "text": "Pourquoi imposer qu’une colonne soit toujours renseignée ?\n\n\n\n\n\n\nImportant\n\n\nLa présence possible des valeurs nulles rend beaucoup d’opérations complexes\nIl faut avoir en tête que en SQL,\n\nles booléens peuvent avoir trois valeurs : TRUE, FALSE et NULL et que\nle fait qu’une expression ne vaille pas FALSE ne veut pas dire qu’elle vaut TRUE …\n\n\n\n\n\nPour imposer qu’une colonne soit renseignée :\n\npréciser après le type : NOT NULL"
  },
  {
    "objectID": "slides/LDD_1.html#contrainte-de-non-nullité-exemple",
    "href": "slides/LDD_1.html#contrainte-de-non-nullité-exemple",
    "title": "BD : Contraintes",
    "section": "Contrainte de non-nullité (Exemple)",
    "text": "Contrainte de non-nullité (Exemple)\n\nCREATE TABLE piece(\n    nomp VARCHAR(20) NOT NULL,\n    prix MONEY CHECK (prix&gt;= 0::MONEY),  \n    prix_promo MONEY CHECK (prix_promo &gt;= 0::MONEY),  \n    couleur VARCHAR(15),\n    CHECK (prix &gt; prix_promo)   \n);"
  },
  {
    "objectID": "slides/LDD_1.html#contrainte-dunicité-1",
    "href": "slides/LDD_1.html#contrainte-dunicité-1",
    "title": "BD : Contraintes",
    "section": "Contrainte d’unicité",
    "text": "Contrainte d’unicité\n\nLes contraintes d’unicité garantissent l’unicité des données contenues dans une colonne ou un groupe de colonnes par rapport à toutes les lignes de la table\nC’est une contrainte de table puisqu’elle fait intervenir tous les tuples de la table"
  },
  {
    "objectID": "slides/LDD_1.html#contrainte-dunicité-2",
    "href": "slides/LDD_1.html#contrainte-dunicité-2",
    "title": "BD : Contraintes",
    "section": "Contrainte d’unicité",
    "text": "Contrainte d’unicité\n\n\n\n\n\n\nNote\n\n\nLa contrainte d’unicité peut porter sur un groupe de colonnes\n\n\n\n\nCREATE TABLE fournisseur(\n    nomf VARCHAR(20) NOT NULL,\n    villef VARCHAR(20) NOT NULL,\n    UNIQUE(nomf, villef)  \n);\n\n\n\n Il ne peut pas y avoir deux lignes identiques dans la table fournisseur"
  },
  {
    "objectID": "slides/LDD_1.html#clef-primaire-primary-key",
    "href": "slides/LDD_1.html#clef-primaire-primary-key",
    "title": "BD : Contraintes",
    "section": "Clef primaire : PRIMARY KEY",
    "text": "Clef primaire : PRIMARY KEY\n\n\n\n\n\n\nDéfinition\n\n\nUne contrainte de type clef primaire indique qu’une colonne, ou un groupe de colonnes, peuvent être utilisée comme un identifiant unique de ligne pour cette table.\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nCeci nécessite que les valeurs soient à la fois uniques et NON NULL.\n\n\n\n\n\nLes définitions de table suivantes acceptent de ce fait les mêmes données\n\n\nCREATE TABLE fournisseur(\n    nomf VARCHAR(20) NOT NULL,\n    villef VARCHAR(20) NOT NULL,\n    UNIQUE(nomf, villef)  \n);\n\nCREATE TABLE fournisseur(\n    nomf VARCHAR(20),\n    villef VARCHAR(20),\n    PRIMARY KEY (nomf, villef)  \n);\n\n\n\n\n Une table a au plus une clef primaire"
  },
  {
    "objectID": "slides/LDD_1.html#clef-étrangère-1",
    "href": "slides/LDD_1.html#clef-étrangère-1",
    "title": "BD : Contraintes",
    "section": "Clef étrangère",
    "text": "Clef étrangère\n\nUne contrainte de clef étrangère stipule que les valeurs d’une colonne (ou d’un groupe de colonnes) doivent correspondre aux valeurs qui apparaissent dans les lignes d’une autre table.\nOn dit que cela maintient l’intégrité référentielle entre les deux tables\nSoit les deux tables suivantes\n\n\n\nCREATE TABLE fournisseur(\n    idf INT PRIMARY KEY,\n    nomf VARCHAR(20),\n    villef VARCHAR(20)\n);\n\nCREATE TABLE piece(\n    nomp VARCHAR(20) PRIMARY KEY,\n    prix MONEY CHECK \n        (prix&gt;= 0::MONEY),\n    prix_promo MONEY CHECK \n        (prix_promo &gt;= 0::MONEY),\n    couleur VARCHAR(15),\n    CHECK (prix &gt; prix_promo)\n);"
  },
  {
    "objectID": "slides/LDD_1.html#clef-étrangère-references",
    "href": "slides/LDD_1.html#clef-étrangère-references",
    "title": "BD : Contraintes",
    "section": "Clef étrangère : REFERENCES",
    "text": "Clef étrangère : REFERENCES\n\nSoit également une table livraison qui stocke les livraisons de ces pièces\nIl est intéressant de s’assurer que la table livraison ne contient que des références de pièces et de fournisseurs qui existent dans la base\n\nPour cela, deux contraintes de clef étrangère sont émises par la table des livraisons\n\nUne contrainte référence piece\nUne contrainte référence fournisseur\n\n\nCREATE TABLE livraison(\n    numliv INT PRIMARY KEY,\n    idf INT REFERENCES fournisseur,   \n    nomp VARCHAR(20) REFERENCES piece,  \n    dateLiv DATE DEFAULT NOW(),\n    quantite INT DEFAULT 1 CHECK (quantite&gt;=0)\n);\n \n\n\n\n\n\n\nIl est désormais impossible de créer des livraisons pour lesquelles les valeurs non NULL de nomp n’apparaissent pas dans la table piece et les valeurs non NULL de idf n’apparaissent pas dans la table fournisseur\nOn dit que la table des livraisons est la table qui référence et la table des pièces est la table référencée"
  },
  {
    "objectID": "slides/LDD_1.html#définition-de-world.countrylanguage",
    "href": "slides/LDD_1.html#définition-de-world.countrylanguage",
    "title": "BD : Contraintes",
    "section": "Définition de world.countrylanguage",
    "text": "Définition de world.countrylanguage\n+-------------+--------------+-------------+\n| Column      | Type         | Modifiers   |\n|-------------+--------------+-------------|\n| countrycode | character(3) |  not null   |\n| language    | text         |  not null   |\n| isofficial  | boolean      |  not null   |\n| percentage  | real         |  not null   |\n+-------------+--------------+-------------+\nIndexes:\n    \"countrylanguage_pkey\" PRIMARY KEY, btree (countrycode, language)"
  },
  {
    "objectID": "slides/LDD_1.html#définition-de-world.country",
    "href": "slides/LDD_1.html#définition-de-world.country",
    "title": "BD : Contraintes",
    "section": "Définition de world.country",
    "text": "Définition de world.country\n\n\n+--------------------+---------------+-------------+\n| Column             | Type          | Modifiers   |\n|--------------------+---------------+-------------|\n| countrycode        | character(3)  |  not null   |\n| name_country       | text          |  not null   |\n| continent          | text          |  not null   |\n| region             | text          |  not null   |\n| surfacearea        | real          |  not null   |\n| indepyear          | smallint      |             |\n| population_country | integer       |  not null   |\n| lifeexpectancy     | real          |             |\n| gnp                | numeric(10,2) |             |\n| gnpold             | numeric(10,2) |             |\n| localname          | text          |  not null   |\n| governmentform     | text          |  not null   |\n| headofstate        | text          |             |\n| capital            | integer       |             |\n| code2              | character(2)  |  not null   |\n+--------------------+---------------+-------------+\n\nIndexes:\n    \"country_pkey\" PRIMARY KEY, btree (countrycode)\nCheck constraints:\n    \"country_continent_check\" CHECK\n    (continent = 'Asia'::text OR \n      continent = 'Europe'::text OR \n      continent = 'North America'::text OR \n      continent = 'Africa'::text OR \n      continent = 'Oceania'::text OR \n      continent = 'Antarctica'::text OR \n      continent = 'South America'::text)\nForeign-key constraints:\n    \"country_capital_fkey\" \n        FOREIGN KEY (capital) \n        REFERENCES world.city(id)  \nReferenced by:\n    TABLE \"world.countrylanguage\"\n    CONSTRAINT \"countrylanguage_countrycode_fkey\" \n        FOREIGN KEY (countrycode)\n        REFERENCES country(countrycode)"
  },
  {
    "objectID": "slides/LDD_1.html#foreign-keys-emitted-by-world.country",
    "href": "slides/LDD_1.html#foreign-keys-emitted-by-world.country",
    "title": "BD : Contraintes",
    "section": "Foreign keys emitted by world.country",
    "text": "Foreign keys emitted by world.country\nALTER TABLE world.country ADD \n    CONSTRAINT country_capital_fkey \n        FOREIGN KEY (capital)   \n        REFERENCES world.city(id);  \n\nALTER TABLE world.country \n    ADD CONSTRAINT country_fk \n        FOREIGN KEY (continent)   \n        REFERENCES world.code_continent(continent);"
  },
  {
    "objectID": "slides/SQL_4.html#pourquoi",
    "href": "slides/SQL_4.html#pourquoi",
    "title": "Fonctions SQL et Vues",
    "section": "Pourquoi ?",
    "text": "Pourquoi ?\nLorsqu’une collection de requêtes de même forme est utilisée sur une base de données, il est pertinent de préparer ces requêtes\nLes objectifs de cette préparation sont divers:\n\néviter de coder de façon répétitive\npermettre une planification en amont des requêtes\néviter de recalculer des jointures coûteuses\n…\n\n\n\nOn cherche à suivre le principe DRY (Don’t Repeat Yourself) plutôt que la routine WET (Write Everything Twice ou We Enjoy Typing)"
  },
  {
    "objectID": "slides/SQL_4.html#comment",
    "href": "slides/SQL_4.html#comment",
    "title": "Fonctions SQL et Vues",
    "section": "Comment ?",
    "text": "Comment ?\nLes SGBD relationnels offrent une gamme d’outils pour combler ces besoins\n\nLes PREPARED STATEMENT\nLes fonctions\nLes vues"
  },
  {
    "objectID": "slides/SQL_4.html#syntaxe-générale-des-fonctions",
    "href": "slides/SQL_4.html#syntaxe-générale-des-fonctions",
    "title": "Fonctions SQL et Vues",
    "section": "Syntaxe générale des fonctions",
    "text": "Syntaxe générale des fonctions\nCREATE OR REPLACE FUNCTION \n  func_name(arg1 arg1_datatype DEFAULT arg1_default)\n\nRETURNS some type | set of some type | TABLE (..) AS\n$$\n\nBODY of function\n\n$$\nLANGUAGE language_of_function\n\n\nlangage_of_function peut prendre différentes valeurs :\n\nSQL (Trusted)\nPL/pgSQL (Trusted)\nC\nPL/Python (Untrusted)\n…\n\n\nSELECT lanname \nFROM pg_language;\nlanname |\n--------+\ninternal|\nc       |\nsql     |\nplpgsql |"
  },
  {
    "objectID": "slides/SQL_4.html#signature-de-la-fonction",
    "href": "slides/SQL_4.html#signature-de-la-fonction",
    "title": "Fonctions SQL et Vues",
    "section": "Signature de la fonction",
    "text": "Signature de la fonction\nCREATE OR REPLACE FUNCTION \n  &lt;func_name&gt;(&lt;arg1&gt; &lt;arg1_datatype&gt; [DEFAULT &lt;arg1_default&gt;])\n\nRETURNS &lt;some type&gt; | SETOF &lt;some type&gt; | TABLE (..)\nLa signature d’une fonction est formée par:\n\nle nom de la fonction &lt;func_name&gt;\nla liste des arguments (nom &lt;arg1&gt; et type attendu )\nle type du résultat retourné par la fonction"
  },
  {
    "objectID": "slides/SQL_4.html#signature-de-la-fonction-suite",
    "href": "slides/SQL_4.html#signature-de-la-fonction-suite",
    "title": "Fonctions SQL et Vues",
    "section": "Signature de la fonction (suite)",
    "text": "Signature de la fonction (suite)\n\n&lt;arg1_datatype&gt;:\n\ntype prédéfini ou non, voir CREATE TYPE ...\ntype de colonne d’une table : country.countrycode%TYPE\ntype des tuples d’une table : country%ROWTYPE…\n\n&lt;arg1_default&gt;: litéral ou expression\nType du résultat:\n\ntype prédéfini ou non\nSETOF ... (table)\nTABLE (...)\n\n\n\n\nChaque schéma de table définit (implicitement) un type"
  },
  {
    "objectID": "slides/SQL_4.html#types-définis-par-lusager",
    "href": "slides/SQL_4.html#types-définis-par-lusager",
    "title": "Fonctions SQL et Vues",
    "section": "Types définis par l’usager",
    "text": "Types définis par l’usager\nCREATE TYPE  type_utilisateur AS (\n  &lt;identifiant&gt; &lt;type défini&gt;\n  [, &lt;identifiant&gt; &lt;type défini&gt;]*\n);\nUsage pour une création de table\nCREATE TABLE &lt;nom de table&gt; OF \n  type_utilisateur\n  (CONSTRAINT &lt;nom de contrainte&gt; PRIMARY KEY  (&lt;nom de colonne&gt;));\nPratique pour créer des tables de même schéma\n\n\n\n\n\n\nNote\n\n\nquand on crée une table, PostgreSQL crée automatiquement un type associé (bis)"
  },
  {
    "objectID": "slides/SQL_4.html#exemple",
    "href": "slides/SQL_4.html#exemple",
    "title": "Fonctions SQL et Vues",
    "section": "Exemple",
    "text": "Exemple\n\nDéfinition d’un type\n\nCREATE TYPE basic_user AS (\n  user_name varchar(50), \n  pwd varchar(10)\n);\n\nUsage du type défini par usager\n\nCREATE TABLE super_users OF basic_user \n  (CONSTRAINT pk_su PRIMARY KEY  (user_name));"
  },
  {
    "objectID": "slides/SQL_4.html#annotations",
    "href": "slides/SQL_4.html#annotations",
    "title": "Fonctions SQL et Vues",
    "section": "Annotations",
    "text": "Annotations\nLes définitions de fonctions comportent parfois des qualifications supplémentaires\n\nVOLATILITY: IMMUTABLE, STABLE, VOLATILE (default)\nSECURITY : SECURITY DEFINER, SECURITY INVOKER"
  },
  {
    "objectID": "slides/SQL_4.html#les-fonctions-écrites-en-langage-sql",
    "href": "slides/SQL_4.html#les-fonctions-écrites-en-langage-sql",
    "title": "Fonctions SQL et Vues",
    "section": "Les fonctions écrites en langage SQL",
    "text": "Les fonctions écrites en langage SQL\nSQL est d’abord un langage permettant d’émettre des requêtes, il peut aussi être utilisé pour écrire des fonctions\nDans PostgreSQL, l’utilisation d’un morceau de SQL existant est facile :\n\nprenez vos instructions SQL existantes (éventuellement plusieurs)\najoutez un en-tête et une conclusion fonctionnels\n\net … vous avez terminé"
  },
  {
    "objectID": "slides/SQL_4.html#les-fonctions-écrites-en-langage-sql-suite",
    "href": "slides/SQL_4.html#les-fonctions-écrites-en-langage-sql-suite",
    "title": "Fonctions SQL et Vues",
    "section": "Les fonctions écrites en langage SQL (suite)",
    "text": "Les fonctions écrites en langage SQL (suite)\nMais cette facilité a un prix \nVous ne pouvez pas :\n\nutiliser des structures de contrôle (boucles, alternatives) ou des définitions de variables locales\nexécuter des instructions SQL dynamiques que vous assemblez à la volée en utilisant les arguments passés dans la fonction\n\n\nMais, tout de même\n\nle planificateur de requêtes peut examiner une fonction SQL et en optimiser l’exécution"
  },
  {
    "objectID": "slides/SQL_4.html#corps-de-la-fonction",
    "href": "slides/SQL_4.html#corps-de-la-fonction",
    "title": "Fonctions SQL et Vues",
    "section": "Corps de la fonction",
    "text": "Corps de la fonction\n La syntaxe du corps de la fonction dépend du language_of_function\nDans le cas où language_of_function est SQL\n$$\n\nBODY of function\n\n$$"
  },
  {
    "objectID": "slides/SQL_4.html#références-aux-argument",
    "href": "slides/SQL_4.html#références-aux-argument",
    "title": "Fonctions SQL et Vues",
    "section": "Références aux argument",
    "text": "Références aux argument\nOn peut faire références aux arguments en les nommant dans le corps de la fonction\nSi les arguments ne sont pas nommés, vous faites référence aux arguments par leur position dans la signature : $1, $2, $3, etc\n Si vous nommez les arguments, vous pouvez utiliser la notation\nbig_elephant(name =&gt; 'Wooly', ear_size =&gt; 1.2)\nlors des appels à la fonction"
  },
  {
    "objectID": "slides/SQL_4.html#exemple-1",
    "href": "slides/SQL_4.html#exemple-1",
    "title": "Fonctions SQL et Vues",
    "section": "Exemple",
    "text": "Exemple\nCREATE OR REPLACE FUNCTION \n  write_to_log(param_user_name varchar,\n               param_description text)\nRETURNS integer AS\n$$\nINSERT INTO logs\n   (user_name, description) \n   VALUES($1, $2)\nRETURNING log_id;\n$$\nLANGUAGE 'sql' VOLATILE;\n\nInvocation\nSELECT write_to_log('alex', \n    'Logged in at 11:59 AM.') AS new_id;"
  },
  {
    "objectID": "slides/SQL_4.html#exemple-de-fonction-retournant-un-type-simple",
    "href": "slides/SQL_4.html#exemple-de-fonction-retournant-un-type-simple",
    "title": "Fonctions SQL et Vues",
    "section": "Exemple de fonction retournant un type simple",
    "text": "Exemple de fonction retournant un type simple\nDans le schéma world, on veut écrire une fonction qui prend en argument une région et renvoie la population maximale parmi les capitales de la région\nCREATE OR REPLACE \n  FUNCTION username.taille_max_capitale_region(p_region text)\n  RETURNS INTEGER \n  LANGUAGE SQL AS\n$$\nSELECT MAX(population_city) AS max_pop\nFROM world.country c \n  JOIN world.city cc ON (c.capital=cc.id)\nWHERE c.region=p_region AND\n cc.population_city IS NOT NULL;\n$$ ;"
  },
  {
    "objectID": "slides/SQL_4.html#fonctions-qui-retournent-un-type-composé-défini-par-les-lignes-dune-table",
    "href": "slides/SQL_4.html#fonctions-qui-retournent-un-type-composé-défini-par-les-lignes-dune-table",
    "title": "Fonctions SQL et Vues",
    "section": "Fonctions qui retournent un type composé défini par les lignes d’une table",
    "text": "Fonctions qui retournent un type composé défini par les lignes d’une table\nDans le schéma world, on veut écrire une fonction qui prend en argument une région et renvoie la description de la capitale la plus peuplée de cette région\nOn se contente de nommer la table pour indiquer que le résultat doit avoir même structure qu’une ligne de la table\n  CREATE OR REPLACE FUNCTION username.capitale(p_region text)\n  RETURNS world.city  \n  LANGUAGE SQL AS\n  $$\n  WITH r AS(\n    SELECT cc.*, RANK() OVER (PARTITION BY c.region ORDER BY cc.population_city DESC) AS rnk\n    FROM world.country c JOIN world.city cc ON (c.capital=cc.id)\n    WHERE c.region=p_region)\n  SELECT r.id, r.name_city, r.countrycode, r.district, r.population_city\n  FROM r \n  WHERE r.rnk = 1 ;\n  $$ ;"
  },
  {
    "objectID": "slides/SQL_4.html#fonctions-qui-retournent-une-table",
    "href": "slides/SQL_4.html#fonctions-qui-retournent-une-table",
    "title": "Fonctions SQL et Vues",
    "section": "Fonctions qui retournent une table",
    "text": "Fonctions qui retournent une table\nDans le schéma world, on veut écrire une fonction qui prend en argument une région et renvoie la table des capitales de la région"
  },
  {
    "objectID": "slides/SQL_4.html#table-de-schéma-explicite",
    "href": "slides/SQL_4.html#table-de-schéma-explicite",
    "title": "Fonctions SQL et Vues",
    "section": "Table de schéma explicite",
    "text": "Table de schéma explicite\nOn se contente d’abord de renvoyer le nom de la capitale.\nOn explicite le schéma de la table résultat\nCREATE OR REPLACE FUNCTION username.capitales_region(p_region text)\nRETURNS TABLE (name_capital text) \nLANGUAGE SQL AS\n$$\nSELECT cc.name_city \nFROM world.country c JOIN world.city cc ON (c.capital=cc.id)\nWHERE c.region=p_region ;\n$$ ;"
  },
  {
    "objectID": "slides/SQL_4.html#table-de-même-schéma-quune-autre-table",
    "href": "slides/SQL_4.html#table-de-même-schéma-quune-autre-table",
    "title": "Fonctions SQL et Vues",
    "section": "Table de même schéma qu’une autre table",
    "text": "Table de même schéma qu’une autre table\nhttps://www.postgresql.org/docs/15/xfunc-sql.html\nOn veut maintenant récupérer une table de même schéma que city.\nLa solution est très simple.\nOn profite de ce qu’à chaque table correspond un type de même nom et on utilise le mot-clé SETOF.\nCREATE OR REPLACE FUNCTION username.capitales_region_large(p_region text)\nRETURNS SETOF world.city  \nLANGUAGE SQL AS\n$$\nSELECT cc.* \nFROM world.country c JOIN world.city cc ON (c.capital=cc.id)\nWHERE c.region=p_region ;\n$$ ;"
  },
  {
    "objectID": "slides/SQL_4.html#autres-langages",
    "href": "slides/SQL_4.html#autres-langages",
    "title": "Fonctions SQL et Vues",
    "section": "Autres langages",
    "text": "Autres langages\n\nPL/pgSQL\nC\nPL/Python\nPL/R\n…"
  },
  {
    "objectID": "slides/SQL_4.html#fonction-reprise-depuis-pagila",
    "href": "slides/SQL_4.html#fonction-reprise-depuis-pagila",
    "title": "Fonctions SQL et Vues",
    "section": "Fonction reprise depuis pagila",
    "text": "Fonction reprise depuis pagila\nCREATE OR REPLACE FUNCTION user.inventory_held_by_customer(\n    p_inventory_id integer,\n    OUT customer_id int2) AS \n$$\n  SELECT customer_id \n  FROM pagila.rental\n  WHERE return_date IS NULL AND inventory_id = p_inventory_id ;\n$$ LANGUAGE 'sql' ;"
  },
  {
    "objectID": "slides/SQL_4.html#fonctions-de-pagila",
    "href": "slides/SQL_4.html#fonctions-de-pagila",
    "title": "Fonctions SQL et Vues",
    "section": "Fonctions de pagila",
    "text": "Fonctions de pagila\nCREATE OR REPLACE FUNCTION uname.film_in_stock(\n  p_film_id integer, \n  p_store_id integer, \n  OUT p_film_count integer)\n RETURNS SETOF integer\nAS $$\n     SELECT inventory_id\n     FROM pagila.inventory\n     WHERE film_id = $1\n     AND store_id = $2\n     AND pagila.inventory_in_stock(inventory_id);\n$$ LANGUAGE sql ;"
  },
  {
    "objectID": "slides/SQL_4.html#invocation",
    "href": "slides/SQL_4.html#invocation",
    "title": "Fonctions SQL et Vues",
    "section": "Invocation",
    "text": "Invocation\nSELECT * \nFROM pagila.film_in_stock(12, 1) ;\n\n\n\np_film_count\n\n\n\n\n60\n\n\n61\n\n\n62"
  },
  {
    "objectID": "slides/SQL_4.html#section-1",
    "href": "slides/SQL_4.html#section-1",
    "title": "Fonctions SQL et Vues",
    "section": "",
    "text": "Presque tous les SGBD relationnels proposent des vues comme niveau d’abstraction des tables. Dans une vue, vous pouvez interroger plusieurs tables et présenter des colonnes dérivées supplémentaires basées sur des calculs complexes.\n\n\nLes vues sont généralement en lecture seule, mais PostgreSQL vous permet de mettre à jour les données sous-jacentes en mettant à jour la vue, à condition que la vue provienne d’une seule table.\n\n\nPour mettre à jour des données à partir de vues qui joignent plusieurs tables, vous devez créer une gachette contre la vue.\n\n\nLes vues matérialisées mettent en cache les données afin d’accélérer les requêtes les plus courantes, au détriment des données les plus récentes."
  },
  {
    "objectID": "slides/SQL_4.html#motivation",
    "href": "slides/SQL_4.html#motivation",
    "title": "Fonctions SQL et Vues",
    "section": "Motivation",
    "text": "Motivation\n\n\n\n\n\n\nAstuce\n\n\nSi vous vous retrouvez à écrire tous les jours la même requête, créer une vue !\n\n\n\nUne vue n’est rien d’autre qu’une requête stockée de façon persistante"
  },
  {
    "objectID": "slides/SQL_4.html#vues-sur-une-seule-table",
    "href": "slides/SQL_4.html#vues-sur-une-seule-table",
    "title": "Fonctions SQL et Vues",
    "section": "Vues sur une seule table",
    "text": "Vues sur une seule table\nCREATE OR REPLACE VIEW co_asia AS\nSELECT * \nFROM world.country \nWHERE continent = 'Asia' ;"
  },
  {
    "objectID": "slides/SQL_4.html#interroger-une-vue",
    "href": "slides/SQL_4.html#interroger-une-vue",
    "title": "Fonctions SQL et Vues",
    "section": "Interroger une vue",
    "text": "Interroger une vue\nUne vue s’interroge comme une table :\nSELECT region, sum(population_country) AS pop \nFROM co_asia \nGROUP BY region \nORDER BY pop DESC ;\nregion                   |pop       |\n-------------------------+----------+\nEastern Asia             |1507328000|\nSouthern and Central Asia|1490776000|\nSoutheast Asia           | 518541000|\nMiddle East              | 188380700|"
  },
  {
    "objectID": "slides/SQL_4.html#vues-et-manipulation-de-données",
    "href": "slides/SQL_4.html#vues-et-manipulation-de-données",
    "title": "Fonctions SQL et Vues",
    "section": "Vues et manipulation de données",
    "text": "Vues et manipulation de données\nSi\n\nla vue (VIEW) provient d’une table unique\nla vue contient la clé primaire de la table d’origine\n\nAlors\non peut modifier la table au travers de la vue. On peut\n\ninsérer\nsupprimer\nmettre à jour\n\n\n\n\n\n\n\nExemple\n\n\n\nLa vue co_asia provient d’une unique table : world.country\nLa vue co_asia contient la clé primaire countrycode de la table world.country"
  },
  {
    "objectID": "slides/SQL_4.html#section-2",
    "href": "slides/SQL_4.html#section-2",
    "title": "Fonctions SQL et Vues",
    "section": "",
    "text": "Cette instruction :\nUPDATE co_asia\n  SET continent='Antarctica';\n… est légale !\n–\nMais, après exécution :\n\nla vue co_asia est vide \nles pays d’Asie de country sont délocalisés en Antarctique"
  },
  {
    "objectID": "slides/SQL_4.html#pour-éviter-ca-with-check-option",
    "href": "slides/SQL_4.html#pour-éviter-ca-with-check-option",
    "title": "Fonctions SQL et Vues",
    "section": "Pour éviter ca : WITH CHECK OPTION",
    "text": "Pour éviter ca : WITH CHECK OPTION\n\nCREATE OR REPLACE VIEW boucheron.co_asia AS\n  SELECT * \n  FROM world.country \n  WHERE continent = 'Asia' \n\nWITH CHECK OPTION ;\n\nAjouter cette modification lors de la création de la vue et PostgreSQL s’opposera à une tentative d’insertion hors de la vue ou à une tentative de mise à jour qui placerait des tuples hors de la vue"
  },
  {
    "objectID": "slides/SQL_4.html#section-3",
    "href": "slides/SQL_4.html#section-3",
    "title": "Fonctions SQL et Vues",
    "section": "",
    "text": "CREATE OR REPLACE VIEW pagila.actor_info\nAS SELECT a.actor_id,\n    a.first_name,\n    a.last_name,\n    pagila.group_concat(DISTINCT (c.name::text || ': '::text) || \n        (( SELECT pagila.group_concat(f.title::text) AS group_concat\n           FROM pagila.film f\n             JOIN pagila.film_category fc_1 ON f.film_id = fc_1.film_id\n             JOIN pagila.film_actor fa_1 ON f.film_id = fa_1.film_id\n          WHERE fc_1.category_id = c.category_id AND fa_1.actor_id = a.actor_id\n          GROUP BY fa_1.actor_id))\n        ) AS film_info\n   FROM pagila.actor a\n     LEFT JOIN pagila.film_actor fa ON a.actor_id = fa.actor_id\n     LEFT JOIN pagila.film_category fc ON fa.film_id = fc.film_id\n     LEFT JOIN pagila.category c ON fc.category_id = c.category_id\n  GROUP BY a.actor_id, a.first_name, a.last_name;"
  },
  {
    "objectID": "slides/SQL_4.html#vues-multi-tables-exemple-de-vue-sur-world",
    "href": "slides/SQL_4.html#vues-multi-tables-exemple-de-vue-sur-world",
    "title": "Fonctions SQL et Vues",
    "section": "Vues multi-tables : exemple de vue sur world",
    "text": "Vues multi-tables : exemple de vue sur world\nCREATE OR REPLACE VIEW country_info AS\n\n  SELECT\n    cn.countrycode, \n    cn.name_country, \n    cn.region,\n    string_agg(DISTINCT ci.name_city::text , ', '::text) AS cities\n\n  FROM world.country cn LEFT JOIN \n       world.city ci \n       ON (cn.countrycode = ci.countrycode)\n\n  GROUP BY cn.countrycode, cn.name_country, cn.region;\nStackoverflow"
  },
  {
    "objectID": "slides/SQL_4.html#insertionmise-à-joursuppression-sur-les-vues-multi-tables",
    "href": "slides/SQL_4.html#insertionmise-à-joursuppression-sur-les-vues-multi-tables",
    "title": "Fonctions SQL et Vues",
    "section": "Insertion/Mise à jour/Suppression sur les vues multi-tables",
    "text": "Insertion/Mise à jour/Suppression sur les vues multi-tables\nProblème : quelles tables doivent être modifiées ?\nDELETE \nFROM boucheron.country_info\nWHERE countrycode = 'FRA' ;\n\nsupprimer les lignes de country ?\nsupprimer les lignes de city ?\n\nDatabase abstraction"
  },
  {
    "objectID": "slides/SQL_4.html#vues-matérialisées",
    "href": "slides/SQL_4.html#vues-matérialisées",
    "title": "Fonctions SQL et Vues",
    "section": "Vues matérialisées",
    "text": "Vues matérialisées\nLes vue matérialisées cachent les données récupérées\nCela se produit\n\nlors de la création de la vue et\nlorsque on exécute REFRESH MATERIALIZED VIEW ..."
  },
  {
    "objectID": "slides/SQL_3.html#limite-de-lalgèbre-relationnelle-pure",
    "href": "slides/SQL_3.html#limite-de-lalgèbre-relationnelle-pure",
    "title": "BD IV: SQL III",
    "section": "Limite de l’algèbre relationnelle pure",
    "text": "Limite de l’algèbre relationnelle pure\nL’algèbre relationnelle pure (σ, π, ⋈)ne sait pas tout calculer\nCertains problèmes aisément solubles par un langage de programmation complet (Python, C, R, …) ne sont pas solubles dans l’algèbre relationnelle pure ( \\(\\sigma(), \\pi(), \\bowtie(), ...\\) ) :\n\naccessibilité dans un graphe non-orienté (qui puis-je contacter dans un réseau social?)\ncompter : quel est le nombre de lignes d’une table ?"
  },
  {
    "objectID": "slides/SQL_3.html#extension-de-lalgèbre-relationnelle",
    "href": "slides/SQL_3.html#extension-de-lalgèbre-relationnelle",
    "title": "BD IV: SQL III",
    "section": "Extension de l’algèbre relationnelle",
    "text": "Extension de l’algèbre relationnelle\n\n\n\n\n\n\nIdée générale\n\n\nUn opérateur Résume() qui admet une opérande T de type table et comme autres arguments une suite d’expressions susceptibles de calculer des agrégats\nRésume(T, expr1, ..., exprk) retourne une table S à une ligne et k colonnes\nLa colonne i de S contient l’évaluation de expri sur la table T\n\n\n\n\n\n\n\n\n\nMise en garde\n\n\nIl n’est pas évident de définir ce que peut être une fonction d’agrégation et un agrégat\nNous travaillerons à partir d’exemples concrets"
  },
  {
    "objectID": "slides/SQL_3.html#fonctions-dagrégation-en-sql-1",
    "href": "slides/SQL_3.html#fonctions-dagrégation-en-sql-1",
    "title": "BD IV: SQL III",
    "section": " Fonctions d’agrégation en SQL",
    "text": "Fonctions d’agrégation en SQL\n\nPossibilité de compter, de faire des moyennes, de trouver un maximum, … en SQL (contrairement à l’algèbre relationnelle “classique”)\n\n\nTutorial Aggregation functions PostgreSQL"
  },
  {
    "objectID": "slides/SQL_3.html#usages",
    "href": "slides/SQL_3.html#usages",
    "title": "BD IV: SQL III",
    "section": "Usages",
    "text": "Usages\n\nAnalyse commerciale ou Buisiness Analytics,\nOLAP\nStatistique et Data Science"
  },
  {
    "objectID": "slides/SQL_3.html#dans-la-partie-select",
    "href": "slides/SQL_3.html#dans-la-partie-select",
    "title": "BD IV: SQL III",
    "section": "Dans la partie SELECT",
    "text": "Dans la partie SELECT\n\nSomme des valeurs prises par nomattribut\n\nRésume(T, SOMME(nomattribut))\nse traduit en\nSELECT \n  SUM (DISTINCT|ALL &lt;nomattribut&gt;)  \nFROM T\n\n\nMoyenne des valeurs prises par nomattribut\n\nRésume(T, MOYENNE(nomattribut))\nse traduit en\nSELECT \n  AVG (DISTINCT|ALL &lt;nom_attribut&gt;) \nFROM T\n\n\n Le type des attributs doit être un nombre ou un entier (sinon, impossible de faire des sommes, des moyennes…)."
  },
  {
    "objectID": "slides/SQL_3.html#fonctions-dagrégation-sum-et-avg",
    "href": "slides/SQL_3.html#fonctions-dagrégation-sum-et-avg",
    "title": "BD IV: SQL III",
    "section": "Fonctions d’agrégation : SUM et AVG",
    "text": "Fonctions d’agrégation : SUM et AVG\n\nSomme des populations des villes du pays de code FRA (dans le schéma world).\n\nSELECT SUM (population)  \nFROM city \nWHERE countrycode = 'FRA';\nTraduction de\n\nσ(city, countrycode = 'FRA') |&gt;\n  Résume(SOMME(population))\n\n\nGNP moyen par habitant (pas pondéré!) sur le continent South America\n\nSELECT \n  AVG(1e6*gnp/population_country)::decimal(8,0) \nFROM \n  country \nWHERE \n  continent = 'South America'\nTraduction de\nσ(country, continent = 'South America') |&gt;\n  Résume(MOYENNE(1e6*gnp/population_country))"
  },
  {
    "objectID": "slides/SQL_3.html#fonctions-de-calcul-max-min",
    "href": "slides/SQL_3.html#fonctions-de-calcul-max-min",
    "title": "BD IV: SQL III",
    "section": "Fonctions de calcul : MAX, MIN",
    "text": "Fonctions de calcul : MAX, MIN\nSELECT \n  MAX (&lt;nomattribut&gt;)  \nFROM T ;\nmaximum des valeurs prises par &lt;nomattribut&gt;\n\nSELECT \n  MIN (&lt;nomattribut&gt;)  \nFROM T \nminimum des valeurs prises par &lt;nomattribut&gt; dans T\n\n\n\n\n\n\nMise en garde\n\n\nAttention aux valeurs nulles !\nNULL = MIN(NULL, 3, 100) ou 3 = MIN(NULL, 3, 100) ?\n Essayez SELECT MIN(gnpold) FROM country; !\n\n\n\n\n\nSELECT MAX (gnpold), max(gnp)   \nFROM country \nWHERE region = 'Caribbean';\n   max    |   max    \n----------+----------\n 32100.00 | 34100.00"
  },
  {
    "objectID": "slides/SQL_3.html#fonctions-de-calcul-count",
    "href": "slides/SQL_3.html#fonctions-de-calcul-count",
    "title": "BD IV: SQL III",
    "section": "Fonctions de calcul : COUNT",
    "text": "Fonctions de calcul : COUNT\nOn peut aussi compter le nombre de tuples dans le résultat d’une requête\nSELECT \n  COUNT(* |[ ALL | DISTINCT &lt;nomattribut&gt;])  \nFROM T\nNombre de valeurs prises par le résultat\n\n\nDISTINCT : sans les doublons\nALL: avec les doublons\n* : y compris les valeurs nullles/manquantes\n\nNombre de territoires dans la région Carribean\nSELECT COUNT(*)  \nFROM country\nWHERE region = 'Caribbean'; \n\n\n\nDans COUNT(* |[ ALL | DISTINCT &lt;nomattribut&gt;]), il faut comprendre qu’on peut écrire COUNT(*) ou COUNT (ALL country) ou COUNT (DISTINCT country). Le symbole | est utilisé pour décrire une alternative"
  },
  {
    "objectID": "slides/SQL_3.html#fonction-de-calcul-sum",
    "href": "slides/SQL_3.html#fonction-de-calcul-sum",
    "title": "BD IV: SQL III",
    "section": "Fonction de calcul SUM()",
    "text": "Fonction de calcul SUM()\nOn peut sommer les valeurs contenues dans une colonne numérique\n\nSELECT \n  SUM(population) AS urban_pop\nFROM city  ci\nWHERE ci.countrycode = 'GBR' ;\n\n+-----------+\n| urban_pop |\n|-----------|\n| 22436673  |\n+-----------+"
  },
  {
    "objectID": "slides/SQL_3.html#sommation-sur-tableau-vide",
    "href": "slides/SQL_3.html#sommation-sur-tableau-vide",
    "title": "BD IV: SQL III",
    "section": "Sommation sur tableau vide",
    "text": "Sommation sur tableau vide\n\nSELECT \n  SUM(population) AS urban_pop\nFROM city  ci\nWHERE ci.countrycode = 'zzz' ;\n+-----------+\n| urban_pop |\n|-----------|\n| &lt;null&gt;    |\n+-----------+\n\nEst-ce cohérent?"
  },
  {
    "objectID": "slides/SQL_3.html#autre-approche-avec-case-when-...then-...-else-...",
    "href": "slides/SQL_3.html#autre-approche-avec-case-when-...then-...-else-...",
    "title": "BD IV: SQL III",
    "section": "Autre approche avec CASE WHEN ...THEN ... ELSE ...",
    "text": "Autre approche avec CASE WHEN ...THEN ... ELSE ...\nSELECT \n  SUM(\n    CASE \n      WHEN countrycode='GBR' THEN population \n      ELSE 0 \n    END) AS urban_pop \n FROM city  ci ;\n\n+-----------+\n| urban_pop |\n|-----------|\n| 22436673  |\n+-----------+"
  },
  {
    "objectID": "slides/SQL_3.html#calculer-les-populations-vivant-sous-diﬀérents-régimes",
    "href": "slides/SQL_3.html#calculer-les-populations-vivant-sous-diﬀérents-régimes",
    "title": "BD IV: SQL III",
    "section": "Calculer les populations vivant sous diﬀérents régimes",
    "text": "Calculer les populations vivant sous diﬀérents régimes\nSELECT \n  SUM(CASE \n    WHEN governmentform LIKE '%Monarchy%' THEN population_COUNTRY \n    ELSE 0 \n  END) AS pop_monarch,  \n  SUM(CASE \n    WHEN governmentform LIKE '%Republic%' THEN population_COUNTRY \n    ELSE 0 \n  END) AS pop_repu \nFROM country ;\n+-------------+------------+\n| pop_monarch | pop_repu   |\n|-------------+------------|\n| 519485000   | 5502453700 |\n+-------------+------------+"
  },
  {
    "objectID": "slides/SQL_3.html#agrégats-sur-données-filtrées-filter-where-condition",
    "href": "slides/SQL_3.html#agrégats-sur-données-filtrées-filter-where-condition",
    "title": "BD IV: SQL III",
    "section": "Agrégats sur données filtrées FILTER (WHERE condition)",
    "text": "Agrégats sur données filtrées FILTER (WHERE condition)\nSELECT \n  SUM(population_country) FILTER  \n    (WHERE governmentform LIKE '%Monarchy%') AS pop_monarch,  \n  SUM(population_country) FILTER \n    (WHERE governmentform LIKE '%Republic%') AS pop_repu \nFROM country ;\n+-------------+------------+\n| pop_monarch | pop_repu   |\n|-------------+------------|\n| 519485000   | 5502453700 |\n+-------------+------------+"
  },
  {
    "objectID": "slides/SQL_3.html#pour-en-savoir-plus",
    "href": "slides/SQL_3.html#pour-en-savoir-plus",
    "title": "BD IV: SQL III",
    "section": "Pour en savoir plus ?",
    "text": "Pour en savoir plus ?\nDocumentation PostgreSQL"
  },
  {
    "objectID": "slides/SQL_3.html#combinaison-de-quelques-opérations-et-fonctions",
    "href": "slides/SQL_3.html#combinaison-de-quelques-opérations-et-fonctions",
    "title": "BD IV: SQL III",
    "section": "Combinaison de quelques opérations et fonctions",
    "text": "Combinaison de quelques opérations et fonctions\nNom des régions comportant plus de \\(10\\) territoires.\n\n--| eval: false\n--| echo: false\n--| code-line-numbers: \"1-2|4-6|\"\nSELECT DISTINCT c.region \nFROM country c \nWHERE (\n  SELECT COUNT (*)     \n  FROM country co     \n  WHERE co.region = c.region\n) &gt;= 15;"
  },
  {
    "objectID": "slides/SQL_3.html#musée-des-horreurs",
    "href": "slides/SQL_3.html#musée-des-horreurs",
    "title": "BD IV: SQL III",
    "section": "Musée des horreurs",
    "text": "Musée des horreurs\nTrouver les régions où au moins un pays possède une espérance de vie inférieure à 50\nSELECT DISTINCT continent, region\nFROM country c \nWHERE (\n  SELECT MIN(d.lifeexpectancy)     \n  FROM country d    \n  WHERE c.region=d.region\n  ) &lt; 50    \nORDER BY continent, region;\n\n\n\nContinent\nRegion\n\n\n\n\nAfrica\nCentral Africa\n\n\nAfrica\nEastern Africa\n\n\nAfrica\nNorthern Africa\n\n\nAfrica\nSouthern Africa\n\n\nAfrica\nWestern Africa\n\n\nAsia\nSoutheast Asia\n\n\nAsia\nSouthern and Central Asia\n\n\nNorth America\nCaribbean\n\n\n\n\n\nPourquoi cette requête est-elle horrible ?"
  },
  {
    "objectID": "slides/SQL_3.html#section-1",
    "href": "slides/SQL_3.html#section-1",
    "title": "BD IV: SQL III",
    "section": "",
    "text": "On peut faire plus simple (et plus efficace) dans le case présent\nSELECT \n  DISTINCT continent, region\nFROM country c \nWHERE c.lifeexpectancy &lt;50 \nORDER BY continent, region;\n\n\n\nContinent\nRegion\n\n\n\n\nAfrica\nCentral Africa\n\n\nAfrica\nEastern Africa\n\n\nAfrica\nNorthern Africa\n\n\nAfrica\nSouthern Africa\n\n\nAfrica\nWestern Africa\n\n\nAsia\nSoutheast Asia\n\n\nAsia\nSouthern and Central Asia\n\n\nNorth America\nCaribbean"
  },
  {
    "objectID": "slides/SQL_3.html#fonctions-de-calcul-exemples-suite",
    "href": "slides/SQL_3.html#fonctions-de-calcul-exemples-suite",
    "title": "BD IV: SQL III",
    "section": "Fonctions de calcul : exemples (suite)",
    "text": "Fonctions de calcul : exemples (suite)\nUtilisation d’opérateurs arithmétique entre les différents attributs d’un même tuple…\n\nSELECT \n  AVG(1e6*gnp/population_country)::decimal(8,0) \nFROM country \nWHERE \n  continent LIKE 'South Am%' AND\n  population_country &gt; 0 ;"
  },
  {
    "objectID": "slides/SQL_3.html#partition-de-résultats-de-requêtes",
    "href": "slides/SQL_3.html#partition-de-résultats-de-requêtes",
    "title": "BD IV: SQL III",
    "section": "Partition de résultats de requêtes",
    "text": "Partition de résultats de requêtes\nGROUP BY &lt;nomattribut1&gt;, ..., &lt;nomattributn&gt;\n\nGROUP BY permet de regrouper selon la valeur de certains attributs l’ensemble des résults d’une requête\nForme des sous-relations auxquelles on peut appliquer des opérateurs (SUM, MAX, …) renvoyant un résultat par sous-relation\n\nExemple d’utilisation : regrouper les livraisons par numéro de fournisseur et prendre la quantité maximum livrée par fournisseur."
  },
  {
    "objectID": "slides/SQL_3.html#partition-de-résultats-de-requêtes-1",
    "href": "slides/SQL_3.html#partition-de-résultats-de-requêtes-1",
    "title": "BD IV: SQL III",
    "section": "Partition de résultats de requêtes",
    "text": "Partition de résultats de requêtes\nSchéma général\nSELECT ... \nFROM country \nGROUP BY continent"
  },
  {
    "objectID": "slides/SQL_3.html#section-2",
    "href": "slides/SQL_3.html#section-2",
    "title": "BD IV: SQL III",
    "section": "",
    "text": "+-------------+---------------------+---------------+\n| countrycode | name_country        | continent     |\n|-------------+---------------------+---------------|\n| DZA         | Algeria             | Africa        |\n| AGO         | Angola              | Africa        |\n| ...         |                     |               |\n| ATA         | Antarctica          | Antarctica    |\n| BVT         | Bouvet Island       | Antarctica    |\n| ...         |                     |               |\n| AFG         | Afghanistan         | Asia          |\n| ARM         | Armenia             | Asia          |\n| ...         |                     |               |\n| ALB         | Albania             | Europe        |\n| AND         | Andorra             | Europe        |\n| ...         |                     |               |\n| AIA         | Anguilla            | North America |\n| ATG         | Antigua and Barbuda | North America |\n| ...         |                     |               |\n| ASM         | American Samoa      | Oceania       |\n| AUS         | Australia           | Oceania       |\n| ...         |                     |               |\n| ARG         | Argentina           | South America |\n| BOL         | Bolivia             | South America |\n+-------------+---------------------+---------------+"
  },
  {
    "objectID": "slides/SQL_3.html#partition-de-résultats-de-requêtes-2",
    "href": "slides/SQL_3.html#partition-de-résultats-de-requêtes-2",
    "title": "BD IV: SQL III",
    "section": "Partition de résultats de requêtes",
    "text": "Partition de résultats de requêtes\nPopulation maximale par continent\nSELECT continent, max(population_country) \nFROM country \nGROUP BY continent ; \n+---------------+------------+\n| continent     | max        |\n|---------------+------------|\n| Asia          | 1277558000 |\n| South America | 170115000  |\n| North America | 278357000  |\n| Oceania       | 18886000   |\n| Antarctica    | 0          |\n| Africa        | 111506000  |\n| Europe        | 146934000  |\n+---------------+------------+\nLes opérateurs (MAX, SUM, etc) s’appliquent à chaque groupe de relations."
  },
  {
    "objectID": "slides/SQL_3.html#exemple",
    "href": "slides/SQL_3.html#exemple",
    "title": "BD IV: SQL III",
    "section": "Exemple",
    "text": "Exemple\nDans le schéma world, quel est le gnp moyen par region sur le continent Europe ?\nSELECT region, \n       ROUND(1000 * SUM(gnp)/SUM(population_country),2) AS avg_gnp,  \n       ROUND(MAX(1000* gnp/population_country),2) AS max_gnp, \n       ROUND(MIN(1000* gnp/population_country),2) AS min_gnp,\n       MIN(lifeexpectancy) AS min_life_exp\nFROM country \nWHERE continent = 'Europe' \nGROUP BY region \nORDER BY avg_gnp DESC;\n\n\n\nregion\navg_gnp\nmax_gnp\nmin_gnp\nmin_life_exp\n\n\n\n\nNordic Countries\n28.00\n32.66\n0.00\n76.5\n\n\nWestern Europe\n25.50\n37.46\n22.82\n77.1\n\n\nBritish Islands\n22.94\n23.12\n20.11\n76.8\n\n\nSouthern Europe\n13.91\n20.90\n0.72\n71.5\n\n\nBaltic Countries\n2.96\n3.70\n2.64\n68.4\n\n\nEastern Europe\n2.15\n5.35\n0.36\n64.5"
  },
  {
    "objectID": "slides/SQL_3.html#partition-de-résultats-de-requêtes-3",
    "href": "slides/SQL_3.html#partition-de-résultats-de-requêtes-3",
    "title": "BD IV: SQL III",
    "section": "Partition de résultats de requêtes",
    "text": "Partition de résultats de requêtes\nQuel est le sens de cette requête ?\nSELECT \n  continent, \n  COUNT(*) as nombre_pays, \n  SUM(population_country) as population_totale\nFROM country \nGROUP BY continent;"
  },
  {
    "objectID": "slides/SQL_3.html#partition-de-résultats-de-requêtes-4",
    "href": "slides/SQL_3.html#partition-de-résultats-de-requêtes-4",
    "title": "BD IV: SQL III",
    "section": "Partition de résultats de requêtes",
    "text": "Partition de résultats de requêtes\n\nLa clause HAVING permet de poser une condition portant sur chacune des sous-relations générées par le GROUP BY\nLes sous-relations ne vérifiant pas la condition sont écartées du résultat.\n\nListe des continents comportent au moins cinq régions.\nSELECT continent \nFROM country \nGROUP BY continent    \nHAVING COUNT(DISTINCT region) &gt;= 5;"
  },
  {
    "objectID": "slides/SQL_3.html#operation-group-by-et-calcul-sur-les-tables",
    "href": "slides/SQL_3.html#operation-group-by-et-calcul-sur-les-tables",
    "title": "BD IV: SQL III",
    "section": "Operation GROUP BY et calcul sur les tables",
    "text": "Operation GROUP BY et calcul sur les tables\n\n\n\n\n\n\nNote\n\n\nL’opération GROUP BY ne renvoie pas une table mais (implicitement) une collection de sous-tables indicées/étiquetées par les valeurs des attributs de groupement\nL’opération GROUP BY ne peut pas s’intégrer dans une algèbre relationnelle, même étendue.\n\n\n\n\n\n\n\n\n\nMise en garde\n\n\nSQL n’offre pas de moyen de mémoriser le résultat d’un GROUP BY avant d’effectuer des agrégations ou une projection sur les attributs de groupement.\n\n\n\n\n\nSELECT *  \nFROM country \nGROUP BY continent  ;\ncolumn \"country.countrycode\" must appear in the GROUP BY clause or be used in an aggregate function\nLINE 1: SELECT * FROM country GROUP BY continent"
  },
  {
    "objectID": "slides/SQL_3.html#présentationtri-de-résultats",
    "href": "slides/SQL_3.html#présentationtri-de-résultats",
    "title": "BD IV: SQL III",
    "section": "Présentation/tri de résultats",
    "text": "Présentation/tri de résultats\n\nLa clause ORDER BY permet de trier le résultat de la requête, en fournissant la liste des attributs sur lesquels effectuer le tri et en spécifiant le sens du tri (ascendan ou descendant)\n\nListe des pays triée par ordre décroissant de population\nSELECT * \nFROM country \nORDER BY population_country DESC;"
  },
  {
    "objectID": "slides/SQL_3.html#regroupement-tri-etc-exemple",
    "href": "slides/SQL_3.html#regroupement-tri-etc-exemple",
    "title": "BD IV: SQL III",
    "section": "Regroupement, tri, etc : exemple",
    "text": "Regroupement, tri, etc : exemple\nQue fait cette requête ?\nSELECT continent, COUNT(*) \nFROM country \nWHERE countrycode IN (\n  SELECT countrycode \n  FROM countrylanguage \n  WHERE language='English' AND percentage &gt; 10 \n) \nGROUP BY continent \nHAVING AVG(1e6*gnpold/population_country) &gt;= 1000 \nORDER BY continent;"
  },
  {
    "objectID": "slides/SQL_3.html#retour-au-musée-des-horreurs",
    "href": "slides/SQL_3.html#retour-au-musée-des-horreurs",
    "title": "BD IV: SQL III",
    "section": "Retour au musée des horreurs",
    "text": "Retour au musée des horreurs\nSELECT continent, region, MIN(c.lifeexpectancy)\nFROM country c \nGROUP BY continent, region\nHAVING MIN(c.lifeexpectancy) &lt; 50  \nORDER BY continent, region ;   \n\n\n\nContinent\nRegion\nmax\nmin\n\n\n\n\nAfrica\nCentral Africa\n65.3\n38.3\n\n\nAfrica\nEastern Africa\n72.7\n37.2\n\n\nAfrica\nNorthern Africa\n75.5\n49.8\n\n\nAfrica\nSouthern Africa\n51.1\n39.3\n\n\nAfrica\nWestern Africa\n76.8\n41.3\n\n\nAsia\nSoutheast Asia\n80.1\n46.0\n\n\nAsia\nSouthern and Central Asia\n71.8\n45.9\n\n\nNorth America\nCaribbean\n78.9\n49.2"
  },
  {
    "objectID": "slides/SQL_3.html#exemple-1",
    "href": "slides/SQL_3.html#exemple-1",
    "title": "BD IV: SQL III",
    "section": "Exemple",
    "text": "Exemple\nDans le schéma world, présenter pour chaque pays dont la région comprend le motif Countries, l’espérance de vie, l’espérance de vie maximale et minimale dans la région.\n\nSELECT region, name_country, lifeexpectancy, \n       min(lifeexpectancy) OVER (PARTITION BY region),  \n       max(lifeexpectancy) OVER (PARTITION BY region)   \nFROM country \nWHERE region LIKE '%Countries'\nORDER BY region, lifeexpectancy  \nLIMIT 6 ;\n\n\n\n\nRegion\nName of country\nLife expectancy\nmin\nmax\n\n\n\n\nBaltic Countries\nLatvia\n68.4\n68.4\n69.5\n\n\nBaltic Countries\nLithuania\n69.1\n68.4\n69.5\n\n\nBaltic Countries\nEstonia\n69.5\n68.4\n69.5\n\n\nNordic Countries\nDenmark\n76.5\n76.5\n79.6\n\n\nNordic Countries\nFinland\n77.4\n76.5\n79.6\n\n\nNordic Countries\nFaroe Islands\n78.4\n76.5\n79.6"
  },
  {
    "objectID": "slides/SQL_3.html#calculer-une-fonction-fenêtre-sans-invoquer-over-...",
    "href": "slides/SQL_3.html#calculer-une-fonction-fenêtre-sans-invoquer-over-...",
    "title": "BD IV: SQL III",
    "section": "Calculer une fonction fenêtre sans invoquer OVER (...)",
    "text": "Calculer une fonction fenêtre sans invoquer OVER (...)\nPour calculer ce résultat sans fonctions fenêtres,\n\non effectue une partition selon la region, une aggrégation par groupe pour calculer min(lifeexpectancy) et max(lifeexpectancy). On obtient une table à trois colonnes.\non calcule une (équi)-jointure avec la table country originelle sur la colonne commune region\non projette le résultat sur les cinq colonnes pertinentes.\n\n\n\nWITH R AS (\n  SELECT region, min(lifeexpectancy) AS minlex, max(lifeexpectancy) AS maxlex\n  FROM country\n  WHERE region LIKE '%Countries' AND lifeexpectancy IS NOT NULL \n  GROUP BY region\n)\n\nSELECT region, name_country, lifeexpectancy, minlex, maxlex\nFROM country co NATURAL JOIN R"
  },
  {
    "objectID": "slides/SQL_3.html#variations",
    "href": "slides/SQL_3.html#variations",
    "title": "BD IV: SQL III",
    "section": "Variations",
    "text": "Variations\nSELECT region, name_country, lifeexpectancy, \n    rank() OVER (\n    PARTITION BY region   \n      ORDER BY lifeexpectancy DESC\n  )  \nFROM country \nWHERE region LIKE '%Countries'\nORDER BY region, lifeexpectancy DESC \nLIMIT 6 ;\n\n\n\nRegion\nName of country\nlife expectancy\nrank\n\n\n\n\nBaltic Countries\nEstonia\n69.5\n1\n\n\nBaltic Countries\nLithuania\n69.1\n2\n\n\nBaltic Countries\nLatvia\n68.4\n3\n\n\nNordic Countries\nSvalbard and Jan Mayen\n\n1\n\n\nNordic Countries\nSweden\n79.6\n2\n\n\nNordic Countries\nIceland\n79.4\n3\n\n\n\n\n\nQue se passe-t-il avec les valeurs nulles ?"
  },
  {
    "objectID": "slides/SQL_3.html#sommes-cumulées-par-groupes-selon-un-ordre",
    "href": "slides/SQL_3.html#sommes-cumulées-par-groupes-selon-un-ordre",
    "title": "BD IV: SQL III",
    "section": "Sommes cumulées par groupes selon un ordre",
    "text": "Sommes cumulées par groupes selon un ordre\nSELECT \n    region, name_country, \n    sum(gnp) OVER (\n    PARTITION BY region  \n        ORDER BY gnp\n)     \nFROM country c \nWHERE region LIKE '%Europe' \nLIMIT 6;\n\n\n\nRegion\nName Country\nSum\n\n\n\n\nEastern Europe\nMoldova\n1579.00\n\n\nEastern Europe\nBulgaria\n13757.00\n\n\nEastern Europe\nBelarus\n27471.00\n\n\nEastern Europe\nSlovakia\n48065.00\n\n\nEastern Europe\nRomania\n86223.00\n\n\nEastern Europe\nUkraine\n128391.00"
  },
  {
    "objectID": "slides/SQL_3.html#exemple-2",
    "href": "slides/SQL_3.html#exemple-2",
    "title": "BD IV: SQL III",
    "section": "Exemple",
    "text": "Exemple\nPour chaque continent, afficher les trois pays ayant l’espérance de vie à la naissance la plus élevée\n\nSELECT continent, \n  name_country, \n  lifeexpectancy, \n  pos\nFROM\n  (SELECT continent, \n    name_country, \n    lifeexpectancy,\n    rank() OVER (\n      PARTITION BY continent \n      ORDER BY lifeexpectancy DESC) AS pos\n  FROM country\n  WHERE lifeexpectancy IS NOT NULL\n  ) AS ws\nWHERE pos &lt;= 3;"
  },
  {
    "objectID": "slides/SQL_3.html#avec-with-...-et-les-ctes",
    "href": "slides/SQL_3.html#avec-with-...-et-les-ctes",
    "title": "BD IV: SQL III",
    "section": "Avec WITH ... et les CTEs",
    "text": "Avec WITH ... et les CTEs\nWITH ws AS (\n  SELECT continent, \n    name_country, \n    lifeexpectancy,\n    rank() OVER (\n      PARTITION BY continent \n      ORDER BY lifeexpectancy DESC) AS pos\n  FROM country\n  WHERE lifeexpectancy IS NOT NULL\n) \nSELECT continent, \n  name_country, \n  lifeexpectancy, \n  pos\nFROM ws   \nWHERE pos &lt;= 3;"
  },
  {
    "objectID": "slides/SQL_3.html#exemple-3",
    "href": "slides/SQL_3.html#exemple-3",
    "title": "BD IV: SQL III",
    "section": "Exemple",
    "text": "Exemple\nAfficher le pays le plus peuplé\n\n\n\nSELECT S.name_country, \n  S.continent, \n  S.population_country\nFROM (\n  SELECT max(population_country) AS mpc \n  FROM country c\n  ) AS R \n  JOIN LATERAL (    \n      SELECT * \n      FROM country c2 \n      WHERE c2.population_country &gt;= R.mpc\n    ) AS S \n  ON (TRUE)\n) ;\n\nSELECT c.name_country, \n       c.continent, \n       c.population_country\nFROM (\n    SELECT max(population_country) AS mpc \n    FROM country c2\n  ) AS S\n  JOIN country c \n  ON (c.population_country &gt;= S.mpc)    \n;\n\nname_country|continent|population_country|\n------------+---------+------------------+\nChina       |Asia     |        1277558000|"
  },
  {
    "objectID": "slides/SQL_3.html#exemple-suite",
    "href": "slides/SQL_3.html#exemple-suite",
    "title": "BD IV: SQL III",
    "section": "Exemple (suite)",
    "text": "Exemple (suite)\nAfficher le pays le plus peuplé\n\n\nSELECT * \nFROM world.country c  \nWHERE population_country &gt;= ALL(\n  SELECT cc.population_country  \n  FROM world.country  cc\n) ;     \n\nWITH S AS (        \n    SELECT c.*, max(population_country) \n         OVER () AS mpc  \n    FROM world.country c\n)\nSELECT * \nFROM S   \nWHERE population_country &gt;= mpc ;\n\nname_country|continent|population_country|\n------------+---------+------------------+\nChina       |Asia     |        1277558000|"
  },
  {
    "objectID": "slides/SQL_3.html#exemple-4",
    "href": "slides/SQL_3.html#exemple-4",
    "title": "BD IV: SQL III",
    "section": "Exemple",
    "text": "Exemple\nAfficher les 10 pays les plus peuplés\n\nWITH S AS (        \n    SELECT c.*, rank() \n    OVER (ORDER BY population_country DESC) AS rpc  \n    FROM world.country c\n)\n\nSELECT name_country, continent, population_country\nFROM S   \nWHERE rpc &lt;= 10 \nORDER BY rpc DESC;\n\n\nname_country      |continent    |population_country|\n------------------+-------------+------------------+\nChina             |Asia         |        1277558000|\nIndia             |Asia         |        1013662000|\nUnited States     |North America|         278357000|\nIndonesia         |Asia         |         212107000|\nBrazil            |South America|         170115000|\nPakistan          |Asia         |         156483000|\nRussian Federation|Europe       |         146934000|\nBangladesh        |Asia         |         129155000|\nJapan             |Asia         |         126714000|\nNigeria           |Africa       |         111506000|"
  },
  {
    "objectID": "slides/SQL_3.html#rollup",
    "href": "slides/SQL_3.html#rollup",
    "title": "BD IV: SQL III",
    "section": "ROLLUP",
    "text": "ROLLUP\n\nSELECT continent, region, max(lifeexpectancy)\nFROM country c \nWHERE continent LIKE '%America'\nGROUP BY ROLLUP  (continent, region)  \nORDER BY continent, region ;\n\n|Continent    |Region         |max |\n|:------------|:--------------|---:|\n|North America|Caribbean      |78.9|\n|North America|Central America|75.8|\n|North America|North America  |79.4|\n|North America|               |79.4|\n|South America|South America  |76.1|\n|South America|               |76.1|\n|             |               |79.4|"
  },
  {
    "objectID": "slides/SQL_3.html#grouping-sets",
    "href": "slides/SQL_3.html#grouping-sets",
    "title": "BD IV: SQL III",
    "section": "GROUPING SETS",
    "text": "GROUPING SETS\n\nSELECT c1, c2, aggregate_function(c3)\nFROM table_name\nGROUP BY GROUPING SETS ((c1, c2), (c1), (c2), ());   \n\n ROLLUP and CUBE are special cases of GROUPING SETS"
  },
  {
    "objectID": "slides/SQL_3.html#grouping-sets-suite",
    "href": "slides/SQL_3.html#grouping-sets-suite",
    "title": "BD IV: SQL III",
    "section": "GROUPING SETS (suite)",
    "text": "GROUPING SETS (suite)\nSELECT continent, region, max(lifeexpectancy)\nFROM country c \nWHERE continent LIKE '%America'\nGROUP BY GROUPING SETS  ((continent, region), (continent), ())  \nORDER BY continent, region ;\n|Continent    |Region         |max |\n|:------------|:--------------|---:|\n|North America|Caribbean      |78.9|\n|North America|Central America|75.8|\n|North America|North America  |79.4|\n|North America|               |79.4|\n|South America|South America  |76.1|\n|South America|               |76.1|\n|             |               |79.4|"
  },
  {
    "objectID": "slides/SQL_3.html#cube",
    "href": "slides/SQL_3.html#cube",
    "title": "BD IV: SQL III",
    "section": "CUBE",
    "text": "CUBE\n\nSELECT c1, c2, c3,\n  aggregate (c4) \nFROM table_name\nGROUP BY CUBE (c1, c2, c3);"
  },
  {
    "objectID": "slides/SQL_3.html#section-4",
    "href": "slides/SQL_3.html#section-4",
    "title": "BD IV: SQL III",
    "section": "",
    "text": "|Continent    |Region       |Governmentf   |cnt|max |\n|:------------|:------------|:-------------|:--|:---|\n|             |               |                             | 51|79.4|\n|South America|South America  |Republic                     |  9|75.7|\n|North America|Central America|Republic                     |  6|75.8|\n|North America|Caribbean      |Constitutional Monarchy      |  8|75.2|\n|North America|Caribbean      |                             | 24|78.9|\n|South America|South America  |                             | 14|76.1|\n|North America|Central America|                             |  8|75.8|\n|South America|               |                             | 14|76.1|\n|North America|               |                             | 37|79.4|\n|             |Caribbean      |Constitutional Monarchy      |  8|75.2|\n|             |South America  |Republic                     |  9|75.7|\n|             |Central America|Republic                     |  6|75.8|\n|             |South America  |                             | 14|76.1|\n|             |Central America|                             |  8|75.8|\n|             |Caribbean      |                             | 24|78.9|\n|North America|               |Constitutional Monarchy      |  9|75.2|\n|North America|               |Republic                     | 10|75.8|\n|South America|               |Republic                     |  9|75.7|\n|North America|               |Dependent Territory of the UK|  6|78.9|\n|             |               |Republic                     | 19|75.8|\n|             |               |Constitutional Monarchy      |  9|75.2|\n|             |               |Dependent Territory of the UK|  7|78.9|"
  },
  {
    "objectID": "slides/SQL_3.html#compter-les-formes-de-gouvernement-et-les-région-dans-les-amériques",
    "href": "slides/SQL_3.html#compter-les-formes-de-gouvernement-et-les-région-dans-les-amériques",
    "title": "BD IV: SQL III",
    "section": "Compter les formes de gouvernement et les région dans les Amériques",
    "text": "Compter les formes de gouvernement et les région dans les Amériques\n\nSELECT  \n       region, \n       governmentform, \n       count(*) AS cnt, \n       max(lifeexpectancy)\nFROM country c \nWHERE continent LIKE '%America'\nGROUP BY CUBE   (region, governmentform)   \nHAVING COUNT(*) &gt; 0\nORDER BY region, cnt DESC;"
  },
  {
    "objectID": "slides/SQL_3.html#compter-les-formes-de-gouvernement-et-les-région-dans-les-amériques-1",
    "href": "slides/SQL_3.html#compter-les-formes-de-gouvernement-et-les-région-dans-les-amériques-1",
    "title": "BD IV: SQL III",
    "section": "Compter les formes de gouvernement et les région dans les Amériques",
    "text": "Compter les formes de gouvernement et les région dans les Amériques\nregion         |governmentform                              |cnt|max |\n---------------+--------------------------------------------+---+----+\nCaribbean      |                                            | 24|78.9|\nCaribbean      |Constitutional Monarchy                     |  8|75.2|\nCaribbean      |Dependent Territory of the UK               |  5|78.9|\nCaribbean      |Republic                                    |  4|73.4|\n...            |                                            |   |    |\n               |Republic                                    | 19|75.8|\n               |Constitutional Monarchy                     |  9|75.2|\n               |Dependent Territory of the UK               |  7|78.9|\n               |Federal Republic                            |  5|77.1|\n               |Overseas Department of France               |  3|78.3|\n..."
  },
  {
    "objectID": "slides/SQL_3.html#portrait-robot-dune-requête",
    "href": "slides/SQL_3.html#portrait-robot-dune-requête",
    "title": "BD IV: SQL III",
    "section": "Portrait robot d’une requête",
    "text": "Portrait robot d’une requête\nSELECT &lt;attributs&gt;           -- les colonnes de la table résultat\n\nFROM &lt;relations&gt;             -- la/les table/s qui émettent les données\n\n[WHERE &lt;condition&gt; ]         -- filtre\n\n[GROUP BY &lt;attributs de partitionnement&gt;   -- découpage en groupes\n\n[HAVING &lt;condition&gt;]]      -- filtrage des groupes\n\n[ORDER BY &lt;critere&gt;]       -- trier \n\nSELECT : attributs du résultat (avec agrégats éventuels)\nWHERE : condition de sélection indépendante du GROUP BY\nHAVING : condition de sélection portant sur les groupes"
  },
  {
    "objectID": "slides/SQL_3.html#ordre-dexécution-des-éléments-dune-requête",
    "href": "slides/SQL_3.html#ordre-dexécution-des-éléments-dune-requête",
    "title": "BD IV: SQL III",
    "section": "Ordre d’exécution des éléments d’une requête",
    "text": "Ordre d’exécution des éléments d’une requête\n\nRassembler les données mentionnées dans la clause FROM\nFilter les lignes selon la clause WHERE\nRegrouper les lignes selon la clause GROUP BY\nFiltrer les groupes selon la clause HAVING\nSpecifier les colonnes du résultat selon la clause SELECT\nTrier le résultat final selon la clause ORDER BY"
  },
  {
    "objectID": "slides/BD_intro.html#situation-du-cours-bases-de-données-ma15y030-dans-la-licence-miashs",
    "href": "slides/BD_intro.html#situation-du-cours-bases-de-données-ma15y030-dans-la-licence-miashs",
    "title": "BD I: Introduction aux SGBD",
    "section": "Situation du cours Bases de Données (MA15Y030) dans la Licence MIASHS",
    "text": "Situation du cours Bases de Données (MA15Y030) dans la Licence MIASHS\n\nTroisième cours tourné vers l’informatique\n\nInitiation (L1, S1)\nAlgorithmes et Programmation (L2, S3)\n\nUn cours tourné vers les données avant Science des Données (L3, S6)"
  },
  {
    "objectID": "slides/BD_intro.html#le-déluge-des-données-une-mode",
    "href": "slides/BD_intro.html#le-déluge-des-données-une-mode",
    "title": "BD I: Introduction aux SGBD",
    "section": "Le déluge des données : une mode ?",
    "text": "Le déluge des données : une mode ?"
  },
  {
    "objectID": "slides/BD_intro.html#rien-de-neuf-sous-le-soleil",
    "href": "slides/BD_intro.html#rien-de-neuf-sous-le-soleil",
    "title": "BD I: Introduction aux SGBD",
    "section": "Rien de neuf sous le soleil …",
    "text": "Rien de neuf sous le soleil …\n\n De qui sont ces lignes ? Quand furent-elles écrites ?\n\n\nJe croyais que le goût de la statistique était particulier aux administrateurs de nos jours ; mais je me trompais. Vers la fin de l’ancien régime, on envoie souvent à l’intendant de petits tableaux tout imprimés qu’il n’a plus qu’à faire remplir par ses subdélégués et par les syndics des paroisses. Le contrôleur-général se fait faire des rapports sur la nature des terres, sur leur culture, l’espèce et la quantité des produits, le nombre des bestiaux, l’industrie et les mœurs des habitants. Les renseignements ainsi obtenus ne sont guère moins circonstanciés ni plus certains que ceux que fournissent en pareils cas de nos jours les sous-préfets et les maires. Le jugement que les subdélégués portent, à cette occasion, sur le caractère de leurs administrés, est en général peu favorable. Ils reviennent souvent sur cette opinion que « le paysan est naturellement paresseux, et ne travaillerait pas s’il n’y était obligé pour vivre. »\n\n\nC’est là une doctrine économique qui paraît fort répandue chez ces administrateurs."
  },
  {
    "objectID": "slides/BD_intro.html#les-données-intéressent",
    "href": "slides/BD_intro.html#les-données-intéressent",
    "title": "BD I: Introduction aux SGBD",
    "section": "Les données intéressent",
    "text": "Les données intéressent\n\nles sciences\nles administrations\nles entreprises\nles citoyennes (et les citoyens)\n…"
  },
  {
    "objectID": "slides/BD_intro.html#les-données-en-sciences-sociales",
    "href": "slides/BD_intro.html#les-données-en-sciences-sociales",
    "title": "BD I: Introduction aux SGBD",
    "section": "Les données en Sciences Sociales",
    "text": "Les données en Sciences Sociales\n\n\n\nPourquoi ?\nDe quoi sont faites les données ?\nComment les accumuler ?\nComment les interroger ?\nComment les conserver ? les éditer ?\n\n\n\n\n\nBN Salle ovale"
  },
  {
    "objectID": "slides/BD_intro.html#sources-et-usages-des-données",
    "href": "slides/BD_intro.html#sources-et-usages-des-données",
    "title": "BD I: Introduction aux SGBD",
    "section": "Sources et usages des données",
    "text": "Sources et usages des données\n\n\nQuelques références\n\n\n\nData humanities with R. Arnold and Tilton\n\n\nQuantitative tour at social sciences edited by Gelman and Cortina, 2009\n Relational databses on slideshare\n\nQuelques problèmes\n\nConstitution (archivage, etc)\nAcquisition/organisation\nUsage(s)\nMaintenance"
  },
  {
    "objectID": "slides/BD_intro.html#les-données-de-lentreprisedes-administrations",
    "href": "slides/BD_intro.html#les-données-de-lentreprisedes-administrations",
    "title": "BD I: Introduction aux SGBD",
    "section": "Les données de l’entreprise/des administrations",
    "text": "Les données de l’entreprise/des administrations\n\n\n\nLa comptabilité\nLes stocks (ERP)\nLa clientèle (CRM)\n…"
  },
  {
    "objectID": "slides/BD_intro.html#la-vie-des-données-en-résumé",
    "href": "slides/BD_intro.html#la-vie-des-données-en-résumé",
    "title": "BD I: Introduction aux SGBD",
    "section": "La vie des données (en résumé)",
    "text": "La vie des données (en résumé)\n\n\n\n Saisie/Alimentation\n Traitement(s)\n Usage(s)\n Archivage\n Maintenance\n\n\n\n\n\npipelines"
  },
  {
    "objectID": "slides/BD_intro.html#avant-hier",
    "href": "slides/BD_intro.html#avant-hier",
    "title": "BD I: Introduction aux SGBD",
    "section": "Avant-hier",
    "text": "Avant-hier\n\n\nLes entreprises et les administrations ont toujours cultivé une mémoire sous forme de fichiers plus ou moins mécanisés et formattés.\nCes collections de fichiers mécanisées répondaient à des exigences de fiabilité, de convenance (facilité de la recherche, de la maintenance)\n\n\n\n\nFrom https://www.ibm.com/history/punched-card"
  },
  {
    "objectID": "slides/BD_intro.html#aujourdhui",
    "href": "slides/BD_intro.html#aujourdhui",
    "title": "BD I: Introduction aux SGBD",
    "section": "Aujourd’hui",
    "text": "Aujourd’hui\n\n\n\nExplosion des volumes\nExplosion des débits\nUsages (très) divers"
  },
  {
    "objectID": "slides/BD_intro.html#systèmes-dinformation-1",
    "href": "slides/BD_intro.html#systèmes-dinformation-1",
    "title": "BD I: Introduction aux SGBD",
    "section": "Systèmes d’information",
    "text": "Systèmes d’information\n\nUn système d’information (SI) est un ensemble de composants qui fonctionnent ensemble pour collecter, traiter, stocker et diffuser des informations.\n\n\n\nLes systèmes d’information ont des objectifs (très) divers.\n\n\nPar exemple : les systèmes de traitement des transactions (TPS), les systèmes d’information de gestion (MIS), les systèmes d’aide à la décision (DSS) et les systèmes de planification des ressources de l’entreprise (ERP)."
  },
  {
    "objectID": "slides/BD_intro.html#décomposition-des-si",
    "href": "slides/BD_intro.html#décomposition-des-si",
    "title": "BD I: Introduction aux SGBD",
    "section": "Décomposition des SI",
    "text": "Décomposition des SI\nUn système d’information comprend en général les éléments suivants:\n\n\nMatériel informatique (ou pas) : dispositifs physiques utilisés pour collecter, stocker et traiter l’information (ordinateurs, serveurs, stockage, réseau, …).\nLogiciels : Les programmes exécutés sur le matériel pour gérer les données et effectuer des tâches spécifiques (OS, SGBD, Logiciels applicatifs).\nDonnées\nPersonnes : Les usagers du système d’information\nProcessus : Les flux de travail et les règles régissant la manière dont les données sont collectées, traitées et distribuées, conformément aux objectifs."
  },
  {
    "objectID": "slides/BD_intro.html#systèmes-dinformation-si-et-bases-de-données-bd-sgbd-sgbdr",
    "href": "slides/BD_intro.html#systèmes-dinformation-si-et-bases-de-données-bd-sgbd-sgbdr",
    "title": "BD I: Introduction aux SGBD",
    "section": "Systèmes d’information (SI) et Bases de Données (BD, SGBD, SGBDR)",
    "text": "Systèmes d’information (SI) et Bases de Données (BD, SGBD, SGBDR)\nAu coeur des systèmes d’information (modernes) on trouve (presque toujours) les bases de données\n\n\n\n\n\n\nMise en garde\n\n\nToutes les bases de données ne sont pas relationnelles"
  },
  {
    "objectID": "slides/BD_intro.html#des-propriétés-désirables-acid",
    "href": "slides/BD_intro.html#des-propriétés-désirables-acid",
    "title": "BD I: Introduction aux SGBD",
    "section": "Des propriétés désirables (ACID)",
    "text": "Des propriétés désirables (ACID)\n\n\n\n\n\n\nAtomicité\n\n\nChaque ajout/modification d’information doit former un tout cohérent\nSi tout se passe correctement, les actions de la transaction sont toutes validées, sinon on retourne à l’état initial\n\n\n\n\n\n\n\n\n\n\nCohérence\n\n\nLe contenu de la base de données doit rester conforme à des contraintes définies lors de la conception\n\n\n\n\n\n\n\n\n\n\n\nIsolation\n\n\nLa bases de données doit pouvoir être utilisée concurremment par plusieurs usagers\n\n\n\n\n\n\n\n\n\n\n\nDurabilité\n\n\nLa vie d’une base de données s’étale sur plusieurs dizaines d’années"
  },
  {
    "objectID": "slides/BD_intro.html#bases-de-données",
    "href": "slides/BD_intro.html#bases-de-données",
    "title": "BD I: Introduction aux SGBD",
    "section": " Bases de données",
    "text": "Bases de données\n\nQu’est-ce que c’est (plus précisément) ?\n\n\nCe sont des logiciels intermédiaires (middleware) entre :\n\nSystèmes de gestion de fichiers/Systèmes d’exploitation   …\nApplications (CRM, ERP, CMS, …)    …\n\n\n\nLes bases de données ne sont pas (simplement) un langage (comme JAVA, , )"
  },
  {
    "objectID": "slides/BD_intro.html#collection-de-tablesdata-frames",
    "href": "slides/BD_intro.html#collection-de-tablesdata-frames",
    "title": "BD I: Introduction aux SGBD",
    "section": " Collection de tables/data frames",
    "text": "Collection de tables/data frames\nCaricaturalement :\n\nUne base de données relationnelle est une collection de tables\n\n\nLes tables s’incarnent de plusieurs façons en informatique\nR, Pandas, les tableurs (Excel …), offrent un environnement interactif de manipulation de données et un environnement de définition de données"
  },
  {
    "objectID": "slides/BD_intro.html#data-frame",
    "href": "slides/BD_intro.html#data-frame",
    "title": "BD I: Introduction aux SGBD",
    "section": " Data frame",
    "text": "Data frame\n\n\n\nUn dataframe est une liste de vecteurs (colonnes)\nLes vecteurs (colonnes) d’un dataframe sont tous de même longueur\nLes éléments d’un vecteur sont d’un même type de base\nChaque vecteur a un nom et son propre type"
  },
  {
    "objectID": "slides/BD_intro.html#autres-environments-excel-java-python",
    "href": "slides/BD_intro.html#autres-environments-excel-java-python",
    "title": "BD I: Introduction aux SGBD",
    "section": "Autres environments (Excel, JAVA, Python)",
    "text": "Autres environments (Excel, JAVA, Python)\n\n\nLes spreadsheet des tableurs \nLes Dataframes de Pandas  \nLes tableaux d’objets en JAVA\n\npermettent de représenter ce que les dataframes représentent en R"
  },
  {
    "objectID": "slides/BD_intro.html#les-sgbd-vont-au-delà",
    "href": "slides/BD_intro.html#les-sgbd-vont-au-delà",
    "title": "BD I: Introduction aux SGBD",
    "section": "Les SGBD vont au delà :",
    "text": "Les SGBD vont au delà :\nIls offrent:\n\n\n\n\n\n\nPersistance\n\n\nEntre deux sessions, les données sont confiées au système de fichiers de l’ordinateur\n\n\n\n\n\n\n\n\n\n\nIntégrité\n\n\nLes données confiées au système de fichiers ne peuvent pas être altérées par d’autres logiciels\n\n\n\n\n\n\n\n\n\n\n\nConcurrence\n\n\nLes données peuvent être manipulées/consultées/mises à jour de manière concurrente par plusieurs voire par une grande quantité d’ utilisateurs."
  },
  {
    "objectID": "slides/BD_intro.html#usages",
    "href": "slides/BD_intro.html#usages",
    "title": "BD I: Introduction aux SGBD",
    "section": "Usages",
    "text": "Usages\n\nSites web dynamiques  \nLogiciels personnels\n\nDerrière certaines applications (gestion de photos, de carnet d’adresses, …), on trouve des bases de données légères (SQLITE)\n\nPartout\n\nsmartphones, tablettes, …\nweb, réseaux sociaux\nadministrations (APOGEE, …)\nentreprises (Stocks Supply Chain, Customer Relationship Management, …)\nNSA"
  },
  {
    "objectID": "slides/BD_intro.html#lidée-clé-codd-1970",
    "href": "slides/BD_intro.html#lidée-clé-codd-1970",
    "title": "BD I: Introduction aux SGBD",
    "section": "L’idée clé (Codd, 1970)",
    "text": "L’idée clé (Codd, 1970)\nOrganiser les informations en tables ou relations\nDévelopper et formaliser un langage de manipulation de tables : l’algèbre relationnelle (langage SQL, Structured Query Language)\n\nL’usager peut définir l’organisation des données\nIl peut interroger celles-ci (par des requêtes)\nLe langage est déclaratif :\n\nOn décrit ce que l’on veut obtenir (quoi mais pas comment)\nLe système fait le reste…\n\nL’évaluation de toutes les requêtes s’arrête (au moins en théorie : si on y met les moyens…)\nL’algèbre relationnelle/SQL n’est pas un langage complet (différence avec JAVA, C, Python, etc)"
  },
  {
    "objectID": "slides/BD_intro.html#quelques-acteurs",
    "href": "slides/BD_intro.html#quelques-acteurs",
    "title": "BD I: Introduction aux SGBD",
    "section": "Quelques acteurs",
    "text": "Quelques acteurs\n\n\nServeurs\n\nORACLE (commercial)\nDB2 (IBM commercial)\nSQLSERVER (Microsoft commercial)\nMySQL (open source)\nPostGres (open source)\nHana (commercial)\n\n\nClients\n\npsql\npgcli\ndbeaver\nPgAdmin\n…"
  },
  {
    "objectID": "slides/BD_intro.html#postgres-postgresql",
    "href": "slides/BD_intro.html#postgres-postgresql",
    "title": "BD I: Introduction aux SGBD",
    "section": "PostGres (PostgreSQL)",
    "text": "PostGres (PostgreSQL)\n\nUn serveur : etu-pgsql\nUn catalogue : bd_2023-24\nDes schémas: world, pagila, nycflights13, ..."
  },
  {
    "objectID": "slides/BD_intro.html#un-exemple-de-schéma-world",
    "href": "slides/BD_intro.html#un-exemple-de-schéma-world",
    "title": "BD I: Introduction aux SGBD",
    "section": "Un exemple de schéma world",
    "text": "Un exemple de schéma world\nUn schema\nDes schémas de table\n\ncontinent : association nom de continent (texte)-code de continent (entier)\ncountry : chaque tuple porte sur un état/territoire\ncity : chaque tuple porte sur une ville (déisgnée par id) qui appartient à un état/territoire désigné par countrycode\ncountrylanguage : chaque tuple indique la part de la population d’un état/territoire (désigné par countrycode) qui parle/connaît une langue (désignée par language) et précise si la langue est officielle dans cet état/territoire."
  },
  {
    "objectID": "slides/BD_intro.html#détails-du-schema-world",
    "href": "slides/BD_intro.html#détails-du-schema-world",
    "title": "BD I: Introduction aux SGBD",
    "section": "Détails du schema world",
    "text": "Détails du schema world\n\n\n\nImage World\n\n\n\n\nUn schéma de table : la donnée des noms des colonnes et des types des colonnes"
  },
  {
    "objectID": "slides/BD_intro.html#quelques-questions-et-propriétés-typiques",
    "href": "slides/BD_intro.html#quelques-questions-et-propriétés-typiques",
    "title": "BD I: Introduction aux SGBD",
    "section": "Quelques questions et propriétés typiques",
    "text": "Quelques questions et propriétés typiques\n\nExtraire de l’information\nAssurer de la cohérence après modification\n\nFaire en sorte que chaque état/territoire soit identifié par un numéro unique\nFaire en sorte que chaque ville soit identifiée par un numéro unique\nNe pas proposer de données sur des villes/territoires/états qui n’existent pas\n\n\n\n\nPropager l’information\n\nHistoriciser le schéma"
  },
  {
    "objectID": "slides/BD_intro.html#objectifs-du-cours",
    "href": "slides/BD_intro.html#objectifs-du-cours",
    "title": "BD I: Introduction aux SGBD",
    "section": "Objectifs du cours",
    "text": "Objectifs du cours\n\nCompétences d’un usager de BD relationnelles\nExprimer des requêtes en algèbre relationnelle et en SQL\nSQL Définition, manipulation et contrôle des données\nConcevoir un Modèle Conceptuel de Données (Entités/Associations)\nDéterminer les dépendances fonctionnelles et normaliser une relation"
  },
  {
    "objectID": "slides/BD_intro.html#plan-du-cours",
    "href": "slides/BD_intro.html#plan-du-cours",
    "title": "BD I: Introduction aux SGBD",
    "section": "Plan du cours",
    "text": "Plan du cours\n\nAlgèbre et calcul relationnels\nSQL (algèbre relationnelle stricte)\nSQL sous-requêtes\nSQL agrégation\nSQL requêtes paramétrées\nDéfinition de données/Conception\nNormalisation"
  },
  {
    "objectID": "slides/BD_intro.html#entrepôts-de-données-fin-des-années-1980",
    "href": "slides/BD_intro.html#entrepôts-de-données-fin-des-années-1980",
    "title": "BD I: Introduction aux SGBD",
    "section": "Entrepôts de données (Fin des années 1980)",
    "text": "Entrepôts de données (Fin des années 1980)\n\n\n\n\n\n\nDatawarehouse\n\n\n\nUn Data Warehouse est une technologie qui regroupe des données structurées provenant d’une ou de plusieurs sources afin qu’elles puissent être comparées et analysées.\n\n\n\n\n\nEntrepôt_de_données sur Wikipedia"
  },
  {
    "objectID": "slides/BD_intro.html#lacs-de-données-2010",
    "href": "slides/BD_intro.html#lacs-de-données-2010",
    "title": "BD I: Introduction aux SGBD",
    "section": "Lacs de données (2010)",
    "text": "Lacs de données (2010)\n\n\n\n\n\n\nDatalake\n\n\nLe concept de Data Lake a été évoqué pour la première fois, en 2010, par James Dixon, comme une solution pour le stockage de données sans pré-traitement et sans connaître précisément l’usage futur qui en sera fait. L’image du lac, permettant d’expliquer, que différentes sources peuvent l’alimenter de manière naturelle et brute, et que les utilisateurs peuvent y plonger pour l’explorer et en rapporter des échantillons à examiner"
  },
  {
    "objectID": "slides/BD_intro.html#au-delà-du-relationnel-no-sql",
    "href": "slides/BD_intro.html#au-delà-du-relationnel-no-sql",
    "title": "BD I: Introduction aux SGBD",
    "section": "Au delà du relationnel: No SQL",
    "text": "Au delà du relationnel: No SQL\n\nCe sont les grandes entreprises du web qui ont été les premières confrontées aux limitations intrinsèques des SGBD relationnels traditionnels. Ces systèmes fondés sur une application stricte des propriétés ACID et généralement conçus pour fonctionner sur des ordinateurs uniques ont rapidement posé des problèmes d’extensibilité.\n\n\n\nAfin de répondre à ces limites, ces entreprises ont commencé à développer leurs propres systèmes de gestion de bases de données pouvant fonctionner sur des architectures matérielles distribuées et permettant de traiter des volumes de données importants.\n\n\n\n\nLes systèmes propriétaires qui en ont résulté, Google (BigTable), Amazon (Dynamo (en)), LinkedIn (Voldemort), Facebook (Cassandra puis HBase), SourceForge.net (MongoDB), Ubuntu One (CouchDB), Baidu (Hypertable) ont été les précurseurs du modèle NoSQL."
  },
  {
    "objectID": "slides/BD_intro.html#lire-plus",
    "href": "slides/BD_intro.html#lire-plus",
    "title": "BD I: Introduction aux SGBD",
    "section": "Lire plus",
    "text": "Lire plus\nGuy Harrison. Next Generation Databases. NoSQL, NewSQL, Big Data"
  },
  {
    "objectID": "slides/BD_admin_2.html#les-lois-des-tables",
    "href": "slides/BD_admin_2.html#les-lois-des-tables",
    "title": "BD VII: Administration et Droits",
    "section": "Les lois des tables",
    "text": "Les lois des tables\n\n\n\n\n\n\nNote\n\n\n\n\n\n\n\n\nCodd’s Twelve Principles\n\n\n\nInformation is represented logically in tables\nData must be logically accessible by table, primary key, and column.\nNull values must be uniformly treated as “missing information,” not as empty strings, blanks, or zeros.\nMetadata (data about the database) must be stored in the database just as regular data is\nA single language must be able to define data, views, integrity constraints, authorization, transactions, and data manipulation\nViews must show the updates of their base tables and vice versa\nA single operation must be available to do each of the following operations: retrieve data, insert data, update data, or delete data\nBatch and end-user operations are logically separate from physical storage and access methods\nBatch and end-user operations can change the database schema without having to recreate it or the applications built upon it\nIntegrity constraints must be available and stored in the metadata, not in an application program\nThe data manipulation language of the relational system should not care where or how the physical data is distributed and should not require alteration if the physical data is centralized or distributed\nAny row processing done in the system must obey the same integrity rules and constraints that set-processing operations do"
  },
  {
    "objectID": "slides/BD_admin_2.html#problème",
    "href": "slides/BD_admin_2.html#problème",
    "title": "BD VII: Administration et Droits",
    "section": "Problème",
    "text": "Problème\nUn serveur de BD met à la disposition d’une collectivité d’usagers un multitude de bases formées d’une collection de tables, de vues, de routines…\n\nLes usagers ne sont pas tous égaux…\n\n–\nCertains utilisateurs doivent pouvoir créer des bases, d’autres les mettre à jour, d’autres les consulter\n–\n\n Le contrôle de l’accès…\n\nPeut être motivé par un désir de maintenir l’intégrité ou la confidentialité des données.\nLe niveau de contrôle (granularité) désirable peut varier : base, schema, table, colonne, ligne…."
  },
  {
    "objectID": "slides/BD_admin_2.html#confidentialité-et-sécurité",
    "href": "slides/BD_admin_2.html#confidentialité-et-sécurité",
    "title": "BD VII: Administration et Droits",
    "section": "Confidentialité et sécurité",
    "text": "Confidentialité et sécurité\nObjectif :\nProtéger les données gérées contre tout accès (malveillant ou accidentel) non autorisé\n\n\nQuels outils ?\n\nUn système de privilèges implémenté dans SQL pour définir l’accès des usagers et plus généralement des rôles aux différents objets"
  },
  {
    "objectID": "slides/BD_admin_2.html#commandes",
    "href": "slides/BD_admin_2.html#commandes",
    "title": "BD VII: Administration et Droits",
    "section": "Commandes",
    "text": "Commandes\nPour octroyer ou retirer des droits d’accès (par exemple sur une relation ou une vue) :\nGRANT et REVOKE\nLes droits d’accès donnent la possibilité d’exécuter des requêtes SQL\n Le propriétaire (créateur) d’une relation à tous les droits sur cette relation et on ne peut lui les retirer"
  },
  {
    "objectID": "slides/BD_admin_2.html#les-commandes",
    "href": "slides/BD_admin_2.html#les-commandes",
    "title": "BD VII: Administration et Droits",
    "section": "Les commandes",
    "text": "Les commandes\nDépendent du type d’objet auquel on s’intéresse.\nPour une table ou une vue :\n\n\nSyntaxe :\nGRANT {ALL PRIVILEGES |\n   privilege {,privilege*}\nON {[TABLE] table_name [, ...]\n    | ALL TABLES IN SCHEMA schema_name}\nTO role-specification [, ...]\n[WITH GRANT OPTION]\n\nrole-specification :\nrole_name, PUBLIC, ...\n\nprivilege :\nSELECT, DELETE, INSERT,\nUPDATE [(nom-attribut\n    {, nom-attribut})],\nREFERENCES [(nom-attribut\n     {, nom-attribut})]\n\n *WITH GRANT OPTION:] si spécifié, donne le droit de transmettre les droits obtenus\n voir : https://www.postgresql.org/docs/current/sql-grant.html"
  },
  {
    "objectID": "slides/BD_admin_2.html#les-commandes-suite-granularité",
    "href": "slides/BD_admin_2.html#les-commandes-suite-granularité",
    "title": "BD VII: Administration et Droits",
    "section": "Les commandes (suite) : granularité",
    "text": "Les commandes (suite) : granularité\nOn peut aller plus loin et spécifier le droit d’accès à seulement une ou plusieurs colonnes d’une table\nPour d’autres objets, comme les domaines, fonction, bases de données, schémas ou rôles d’autres types de droits sont pertinents:\n\nle droit de créer une BD ou un schéma dans une BD existante\nle droit de se connecter à une BD existante\nle droit d’exécuter une fonction\nle droit d’usage d’un schéma (i.e. d’en voir les objets existants)\nle droit d’attribuer des rôles à des utilisateurs"
  },
  {
    "objectID": "slides/BD_admin_2.html#révoquer-des-droits",
    "href": "slides/BD_admin_2.html#révoquer-des-droits",
    "title": "BD VII: Administration et Droits",
    "section": "Révoquer des droits",
    "text": "Révoquer des droits\nvia le mot clé REVOKE\nSyntaxe (simplifiée) :\nREVOKE [ GRANT OPTION FOR ]\n{ { SELECT | INSERT | UPDATE | DELETE }\n| ALL [ PRIVILEGES ] }\n\nON { [ TABLE ] table_name [, ...]\n      | ALL TABLES IN SCHEMA schema_name }\n\nFROM role_spec [, ...]\n[ GRANTED BY role_spec ]\n[ CASCADE | RESTRICT ]\n *syntaxe complète:] voir https://www.postgresql.org/docs/current/sql-revoke.html\nCommentaire\n\nGRANT OPTION FOR\nCASCADE\nRESTRICT"
  },
  {
    "objectID": "slides/BD_admin_2.html#exemples",
    "href": "slides/BD_admin_2.html#exemples",
    "title": "BD VII: Administration et Droits",
    "section": "Exemples",
    "text": "Exemples\nGRANT USAGE\nON SCHEMA durand\nTO thomas007\n\nGRANT SELECT\nON ALL TABLES IN SCHEMA durand\nTO thomas007\n\n\nOn peut se mettre “à la place” de l’utilisateur thomas007 par la commande :\nset role thomas007\n\n\nREVOKE SELECT\nON ALL TABLES IN SCHEMA durand\nFROM thomas007\nREVOKE USAGE\nON SCHEMA durand\nFROM thomas007\nOn pouvait donner directement les mêmes droits à tous les utilisateurs d’un même rôle etudiant par exemple plutôt qu’un seul utilisateur\n\nUSAGE\nSELECT\nEXECUTE"
  },
  {
    "objectID": "slides/BD_admin_2.html#exemples-suite",
    "href": "slides/BD_admin_2.html#exemples-suite",
    "title": "BD VII: Administration et Droits",
    "section": "Exemples (suite)",
    "text": "Exemples (suite)\nSupposons que le schema durand contiennent une table resultat dont une des colonnes se nomme identifiant.\nQue peut faire (et ne pas faire) l’utilisateur thomas007 après ces trois commandes ?\n\nGRANT INSERT (identifiant) ON TABLE durand.resultat TO thomas007;\nGRANT USAGE ON SCHEMA durand  TO thomas007\nGRANT SELECT ON TABLE durand.resultat TO thomas007;\n\n\nIl peut selectionner les infos de la table resultat, inserer un tuple avec une valeur pour l’attribut identifiant et null pour les autres attributs\nIl ne peut pas effacer son insertion…"
  },
  {
    "objectID": "slides/BD_admin_2.html#politique-de-droits",
    "href": "slides/BD_admin_2.html#politique-de-droits",
    "title": "BD VII: Administration et Droits",
    "section": "Politique de droits",
    "text": "Politique de droits\n\nLors de la conception d’une base de données, on anticipe le fait que tous les utilisateurs ne vont pas avoir les mêmes droits\nIl peut y avoir plusieurs niveaux d’administrateurs aussi\nL’architecture des droits doit être pensée le plus finement possible pour éviter les problèmes de sécurité\nSQL permet d’implémenter directement cela (et ne pas le laisser à la couche applicative au dessus)\n\nRenvoyer aux principes de Codd"
  },
  {
    "objectID": "slides/BD_admin_2.html#administrer-utilisation-dune-métabase",
    "href": "slides/BD_admin_2.html#administrer-utilisation-dune-métabase",
    "title": "BD VII: Administration et Droits",
    "section": "Administrer : utilisation d’une “métabase”",
    "text": "Administrer : utilisation d’une “métabase”\n\nLes SGBD relationnels contiennent des schémas particuliers qui décrivent totalement l’état des bases :\n\nschéma existants,\ntables,\ncolonnes,\nutilisateurs,\nfonction stockées,\ncontraintes,\netc\n\nCes schémas constituent une métabase\nOn peut utiliser SQL pour interroger ces tables et donc (presque) tout savoir de l’état du SGBD sans faire appel à un langage extérieur\nOn peut aussi apporter des modifications en utilisant les instructions SQL classiques INSERT, UPDATE, DELETE, etc"
  },
  {
    "objectID": "slides/BD_admin_2.html#administrer-utilisation-dune-méta-base",
    "href": "slides/BD_admin_2.html#administrer-utilisation-dune-méta-base",
    "title": "BD VII: Administration et Droits",
    "section": "Administrer : utilisation d’une “méta-base”",
    "text": "Administrer : utilisation d’une “méta-base”\nDeux schémas jouent un rôle essentiel dans l’administration de Postgres (situation similaire dans tous les SGBD)\ninformation_schema\n\nles définitions de tables, de vues, de colonnes, les contraintes, …\nil est formé de tables et surtout de (très nombreuses) vues\ncomme pour les autres tables, les instructions, CREATE, ALTER, DROP modifient le contenu de ce schéma (une seule instruction ALTER TABLE peut engendrer en cascade plusieurs mises à jours dans les tables de information_schema)\ncontient, en théorie, des informations compatibles avec le standard SQL (identique sur tout SGBD respectant la norme)\n\npg_catalog\n\nContient des informations de nature similaire à information_schema mais spécifiques à l’organisation de Postgres"
  },
  {
    "objectID": "slides/BD_admin_2.html#quelques-tables-et-vues-de-information_schema",
    "href": "slides/BD_admin_2.html#quelques-tables-et-vues-de-information_schema",
    "title": "BD VII: Administration et Droits",
    "section": "Quelques tables et vues de information_schema",
    "text": "Quelques tables et vues de information_schema\n Une liste complète des tables et vues de information_schema se trouve ici :\nhttps://www.postgresql.org/docs/current/information-schema.html\nQuelques exemples:\n\nschemata contient la liste des schémas, leurs propriétaires, leurs catalogue d’appartenance, etc\ntables contient la liste des noms de toutes les tables et vues et, entre autres, leurs BD et schémas d’appartenance\ncolumns contient les noms de colonnes, les tables (et donc schémas et BD) auxquels elles appartiennent.\nrole_table_grants contient la liste de tous les droits alloués, à qui, par qui etc"
  },
  {
    "objectID": "slides/BD_admin_2.html#quelques-tables-et-vues-de-pg_catalog",
    "href": "slides/BD_admin_2.html#quelques-tables-et-vues-de-pg_catalog",
    "title": "BD VII: Administration et Droits",
    "section": "Quelques tables et vues de pg_catalog",
    "text": "Quelques tables et vues de pg_catalog\nUne liste complète des tables et vues de pg_catalog se trouve ici :\n https://www.postgresql.org/docs/current/catalogs.html\nQuelques exemples:\n\npg_user contient la liste des utilisateurs, leur id système\npg_tables contient des informations similaires à information_schema.tables\npg_views contient la liste des vues\npg_roles contient la liste des roles\npg_auth_members met en relation les rôles entre eux (quel rôle est contenu dans tel autre)"
  },
  {
    "objectID": "slides/BD_admin_2.html#exemples-1",
    "href": "slides/BD_admin_2.html#exemples-1",
    "title": "BD VII: Administration et Droits",
    "section": "Exemples",
    "text": "Exemples\nSELECT *\nFROM information_schema.tables;\nSELECT table_name\nFROM information_schema.tables\nWHERE table_type='VIEW' AND table_schema='durand';\n    +------------------+\n    | table_name       |\n    |------------------|\n    | listevuecc1      |\n    | notescc1         |\n    | listevuecc1_isif |\n    | q4               |\n    | q5               |\n    | q6               |\n    | defi1            |\n    | q1               |\n    | q2               |\n    | q3               |\n    +------------------+"
  },
  {
    "objectID": "slides/BD_admin_2.html#exemple-représentation-des-droits-dans-la-metabase",
    "href": "slides/BD_admin_2.html#exemple-représentation-des-droits-dans-la-metabase",
    "title": "BD VII: Administration et Droits",
    "section": "Exemple : Représentation des droits dans la metabase",
    "text": "Exemple : Représentation des droits dans la metabase\nSELECT table_schema, table_name, privilege_type\nFROM information_schema.role_table_grants\nWHERE grantee='durand'\n +----------------+--------------------+------------------+\n | table_schema   | table_name         | privilege_type   |\n |----------------+--------------------+------------------|\n | gestion_2022   | etudiantsmiashs    | INSERT           |\n | gestion_2022   | etudiantsmiashs    | SELECT           |\n | gestion_2022   | etudiantsmiashs    | UPDATE           |\n | gestion_2022   | etudiantsmiashs    | DELETE           |\n | gestion_2022   | etudiantsmiashs    | TRUNCATE         |\n | gestion_2022   | etudiantsmiashs    | REFERENCES       |\n | gestion_2022   | etudiantsmiashs    | TRIGGER          |"
  },
  {
    "objectID": "slides/BD_admin_2.html#information_schema.table_privileges",
    "href": "slides/BD_admin_2.html#information_schema.table_privileges",
    "title": "BD VII: Administration et Droits",
    "section": "information_schema.table_privileges",
    "text": "information_schema.table_privileges\nThe view table_privileges identifies all privileges granted on tables or views to a currently enabled role or by a currently enabled role.\nThere is one row for each combination of table, grantor, and grantee.\n\nLe role PUBLIC dispose du privilège de SELECT sur les tables de pg_catalog et de information_schema"
  },
  {
    "objectID": "slides/SQL_2.html#opérateurs-ensemblistes-capcupsetminus",
    "href": "slides/SQL_2.html#opérateurs-ensemblistes-capcupsetminus",
    "title": "BD II: SQL II",
    "section": "Opérateurs ensemblistes: \\(\\cap,\\cup,\\setminus\\)",
    "text": "Opérateurs ensemblistes: \\(\\cap,\\cup,\\setminus\\)\n Les deux tables doivent avoir des schémas identiques\n\nIntersection ( \\(\\cap\\) ) : les tuples qui sont à la fois dans la requête 1 et dans la requête 2\n\n&lt;requete1&gt; INTERSECT &lt;requete2&gt;\n\n\nUnion ( \\(\\cup\\) ) : les tuples de la requête 1 et ceux de la requête 2\n\n&lt;requete1&gt; UNION &lt;requete2&gt;\n\n\n\nDifférence ( \\(\\backslash\\) ) : les tuples de la requête 1 qui ne sont pas des tuples de la requête 2\n\n&lt;requete1&gt; EXCEPT &lt;requete2&gt;"
  },
  {
    "objectID": "slides/SQL_2.html#exemple-pour-except",
    "href": "slides/SQL_2.html#exemple-pour-except",
    "title": "BD II: SQL II",
    "section": "Exemple pour EXCEPT",
    "text": "Exemple pour EXCEPT\n`Fournisseur (NomF, VilleF, AdresseF)` \n\n`Piece(NomP, Prix, Couleur)`\n\n`Livraison(NumLiv, NomP, NomF, DateLiv, Quantite)`\nFournisseurs qui ont livré la pièce x22 mais pas la pièce x21\nSELECT NomF \nFROM Livraison \nWHERE NomP='x22'\n\nEXCEPT \n\nSELECT NomF\nFROM Livraison \nWHERE NomP='x21';"
  },
  {
    "objectID": "slides/SQL_2.html#requêtes-imbriquées-in-exists-all-any-lateral",
    "href": "slides/SQL_2.html#requêtes-imbriquées-in-exists-all-any-lateral",
    "title": "BD II: SQL II",
    "section": "Requêtes imbriquées IN, EXISTS, ALL, ANY, LATERAL",
    "text": "Requêtes imbriquées IN, EXISTS, ALL, ANY, LATERAL\n\nLe résultat d’une requête SQL est un ensemble de tuples… donc une relation.\n Dans la clause WHERE d’une requête, on peut utiliser une fonction d’une autre requête, appelée sous-requête\nIN, EXISTS, ALL, ANY sont des fonctions qui prennent une sous-requête (une relation) en argument.\nDans une sous-requête, on peut se référer à des attributs des tables de la clause FROM.\nPour chaque ligne d’un item FROM qui fournit la colonne référencée, l’item LATERAL est évalué en utilisant cette ligne. Les lignes du résultat sont jointes avec la ligne qui a servi à les calculer.\nOn peut utiliser ces résultats comme données d’une autre requête\n Moyens : utiliser des fonctions de table dans la clause WHERE."
  },
  {
    "objectID": "slides/SQL_2.html#utilisation-de-sous-requêtes-in",
    "href": "slides/SQL_2.html#utilisation-de-sous-requêtes-in",
    "title": "BD II: SQL II",
    "section": "Utilisation de sous-requêtes : IN",
    "text": "Utilisation de sous-requêtes : IN\n\nOpérateur IN déjà vu pour exprimer que l’attribut est à valeur dans une certaine liste\nNouvelle utilisation de IN avec des sous-requêtes.\n\n&lt;attribut&gt; [NOT] IN (&lt;sous-requete&gt;)\nEvaluée à vraie si  appartient au résultat de la sous-requête"
  },
  {
    "objectID": "slides/SQL_2.html#utilisation-de-sous-requêtes-in-1",
    "href": "slides/SQL_2.html#utilisation-de-sous-requêtes-in-1",
    "title": "BD II: SQL II",
    "section": "Utilisation de sous-requêtes : IN",
    "text": "Utilisation de sous-requêtes : IN\nLister les villes de fournisseurs qui ont livré la pièce ‘x21’.\n\n\nSELECT DISTINCT VilleF \n\nFROM Fournisseur \n\nWHERE NomF IN ( \n  SELECT NomF  \n  FROM Livraison \n  WHERE NomP = 'x21'\n) ;  \n\nest équivalente à :\nSELECT DISTINCT F.VilleF \n\nFROM Fournisseur F, Livraison L \n\nWHERE (F. NomF = L. NomF) AND \n  (L. NomP = 'x21');"
  },
  {
    "objectID": "slides/SQL_2.html#utilisation-de-sous-requêtes-in-2",
    "href": "slides/SQL_2.html#utilisation-de-sous-requêtes-in-2",
    "title": "BD II: SQL II",
    "section": "Utilisation de sous-requêtes : IN",
    "text": "Utilisation de sous-requêtes : IN\nLister les couleurs de pièces livrées par des fournisseurs de Paris\nSELECT DISTINCT Couleur \nFROM Piece\nWHERE NomP IN (   \n    SELECT NomP  #&lt;&lt; \n  FROM Livraison  #&lt;&lt; \n    WHERE NomF IN (\n    SELECT NomF   #&lt;&lt;\n    FROM Fournisseur   #&lt;&lt;\n    WHERE VilleF='Paris'\n    )  #&lt;&lt;\n  );  \n\nest équivalente à\nSELECT DISTINCT P.Couleur\n\nFROM Piece P, Livraison L, Fournisseur F\n\nWHERE \n  P.NomP = L.NomP AND\n  L.NomF = F.NomF AND   \n  VilleF = 'Paris'  ;"
  },
  {
    "objectID": "slides/SQL_2.html#utilisation-de-sous-requêtes-in-3",
    "href": "slides/SQL_2.html#utilisation-de-sous-requêtes-in-3",
    "title": "BD II: SQL II",
    "section": "Utilisation de sous-requêtes : IN",
    "text": "Utilisation de sous-requêtes : IN\n\nUtilisation ci-dessus pas très utile mais…\nPratique à utiliser sous la forme NOT IN\n\nLister les noms de pièces qui n’ont jamais été livrées.\nSELECT NomP\nFROM Piece P \nWHERE NomP NOT IN  (\n  SELECT NomP   #&lt;&lt;\n  FROM  Livraison  #&lt;&lt;\n);\nEquivalence en algèbre relationnelle :\n\\[\\pi_{\\text{NomP}}(\\text{Piece}) - \\pi_{\\text{NomP}}(\\text{Livraison})\\]\n…. Une des façons de coder la différence en SQL"
  },
  {
    "objectID": "slides/SQL_2.html#utilisation-de-sous-requêtes-in-4",
    "href": "slides/SQL_2.html#utilisation-de-sous-requêtes-in-4",
    "title": "BD II: SQL II",
    "section": "Utilisation de sous-requêtes : IN",
    "text": "Utilisation de sous-requêtes : IN\nLes capitales dont la population est plus grande que la moitié de la population du pays\nSELECT name_city FROM city\nWHERE id IN (\n  SELECT capital \n  FROM country\n  WHERE population_city&gt;=population_country*.5\n);\n\nest équivalente à :\nSELECT name_city \nFROM country JOIN city \n  ON capital=id\nWHERE population_city&gt;=population_country*.5;"
  },
  {
    "objectID": "slides/SQL_2.html#utilisation-de-sous-requêtes-any-all",
    "href": "slides/SQL_2.html#utilisation-de-sous-requêtes-any-all",
    "title": "BD II: SQL II",
    "section": "Utilisation de sous-requêtes : ANY, ALL",
    "text": "Utilisation de sous-requêtes : ANY, ALL\nDeux nouveaux opérateurs manipulant des sous-requêtes : ANY, ALL\n&lt;attributs&gt; =|&lt;&gt;|&lt;=|&lt;|&gt;|=&gt; ANY (&lt;sous-requete&gt;)\névaluée à vraie si au moins un des résultats de la sous requête vérifie la comparaison avec &lt;attributs&gt;\n\n&lt;attributs&gt; =|&lt;&gt;|&lt;=|&lt;|&gt;|=&gt; ALL (&lt;sous-requete&gt;)\névaluée à vraie si tous les résultats de la sous-requête vérifient la comparaison avec &lt;attributs&gt;\n\n\n\n&lt;attributs&gt;: peut être une liste d’attributs"
  },
  {
    "objectID": "slides/SQL_2.html#utilisation-de-sous-requêtes-any-all-1",
    "href": "slides/SQL_2.html#utilisation-de-sous-requêtes-any-all-1",
    "title": "BD II: SQL II",
    "section": "Utilisation de sous-requêtes : ANY, ALL",
    "text": "Utilisation de sous-requêtes : ANY, ALL\nAlternative au IN\nlister les noms de fournisseurs qui ont livré la pièce ‘x21’.\nSELECT NomF\nFROM Fournisseur\nWHERE NomF = ANY (\n    SELECT NomF\n    FROM Livraison\n    WHERE NomP = 'x21' \n);"
  },
  {
    "objectID": "slides/SQL_2.html#utilisation-de-sous-requêtes-any-all-2",
    "href": "slides/SQL_2.html#utilisation-de-sous-requêtes-any-all-2",
    "title": "BD II: SQL II",
    "section": "Utilisation de sous-requêtes : ANY, ALL",
    "text": "Utilisation de sous-requêtes : ANY, ALL\nInformation sur la commande dont la quantité de ièces livrées était la plus importante.\nSELECT *\nFROM Livraison\nWHERE Quantite &gt;= ALL (\n    SELECT Quantite \n  FROM Livraison\n);"
  },
  {
    "objectID": "slides/SQL_2.html#utilisation-de-sous-requêtes-any-all-3",
    "href": "slides/SQL_2.html#utilisation-de-sous-requêtes-any-all-3",
    "title": "BD II: SQL II",
    "section": "Utilisation de sous-requêtes : ANY, ALL",
    "text": "Utilisation de sous-requêtes : ANY, ALL\nNoms et prix des pièces livrées les plus chères\nSELECT P.NomP, P.Prix \nFROM Livraison L, Piece P\nWHERE L.NomP = P.NomP AND \n  P.Prix&gt;=ALL (\n    SELECT Prix \n    FROM Piece\n);"
  },
  {
    "objectID": "slides/SQL_2.html#utilisation-de-sous-requêtes-any-all-4",
    "href": "slides/SQL_2.html#utilisation-de-sous-requêtes-any-all-4",
    "title": "BD II: SQL II",
    "section": "Utilisation de sous-requêtes : ANY, ALL",
    "text": "Utilisation de sous-requêtes : ANY, ALL\nLa ville la plus peuplée de chaque pays\nSELECT c1.name_city \nFROM city as c1\nWHERE population_city &gt;= ALL (\n  SELECT c2.population_city \n  FROM city as c2\n  WHERE c1.countrycode=c2.countrycode\n);"
  },
  {
    "objectID": "slides/SQL_2.html#utilisation-de-sous-requêtes-exists",
    "href": "slides/SQL_2.html#utilisation-de-sous-requêtes-exists",
    "title": "BD II: SQL II",
    "section": "Utilisation de sous-requêtes : EXISTS",
    "text": "Utilisation de sous-requêtes : EXISTS\n[NOT] EXISTS (&lt;sous-requete&gt;)\nest évaluée à vraie si la sous-requête renvoie au moins un résultat.\n\nNom et prix des pièces qui ont été livrées\nSELECT NomP, Prix \nFROM Piece P \nWHERE EXISTS (\n  SELECT * \n  FROM Livraison \n  WHERE Livraison.NomP = P.NomP\n);\n\n\n Différence avec ANY\nL’utilisation de EXISTS s’apparente à une condition booléenne.\nPas de test sur la valeur d’un attribut particulier."
  },
  {
    "objectID": "slides/SQL_2.html#utilisation-de-sous-requêtes-exists-1",
    "href": "slides/SQL_2.html#utilisation-de-sous-requêtes-exists-1",
    "title": "BD II: SQL II",
    "section": "Utilisation de sous-requêtes : EXISTS",
    "text": "Utilisation de sous-requêtes : EXISTS\nNom des Fournisseurs ayant livré la pièce x21 mais qui n’ont jamais livré la pièce a22.\nSELECT DISTINCT NomF \nFROM Livraison L \nWHERE L.NomP='x21' AND \n  NOT EXISTS (\n    SELECT * \n    FROM Livraison L1 \n    WHERE L2.NomP='a22' AND L2.NomF=L.NomF\n  );"
  },
  {
    "objectID": "slides/SQL_2.html#utilisation-de-sous-requêtes-exists-2",
    "href": "slides/SQL_2.html#utilisation-de-sous-requêtes-exists-2",
    "title": "BD II: SQL II",
    "section": "Utilisation de sous-requêtes : EXISTS",
    "text": "Utilisation de sous-requêtes : EXISTS\nLes régions qui ont au moins une langue officielle :\nSELECT DISTINCT region \nFROM world.country AS co\nWHERE EXISTS (\n  SELECT * \n  FROM world.countrylanguage AS cl\n  WHERE co.countrycode = cl.countrycode  AND cl.isofficial\n);"
  },
  {
    "objectID": "slides/SQL_2.html#requêtes-imbriquées-lateral",
    "href": "slides/SQL_2.html#requêtes-imbriquées-lateral",
    "title": "BD II: SQL II",
    "section": "Requêtes imbriquées : LATERAL",
    "text": "Requêtes imbriquées : LATERAL\n\n\n\n\n\n\nImportant\n\n\nLes sous-requêtes d’une clause FROM peuvent être précédées du mot-clé LATERAL\nOn peut alors faire référence à des colonnes des éléments précédents de la clause FROM"
  },
  {
    "objectID": "slides/SQL_2.html#pour-les-fonction-tables",
    "href": "slides/SQL_2.html#pour-les-fonction-tables",
    "title": "BD II: SQL II",
    "section": "Pour les fonction-tables …",
    "text": "Pour les fonction-tables …\nLes arguments de la fonction peuvent contenir des références à des colonnes des items précédents de la clause FROM."
  },
  {
    "objectID": "slides/SQL_2.html#evaluation",
    "href": "slides/SQL_2.html#evaluation",
    "title": "BD II: SQL II",
    "section": "Evaluation",
    "text": "Evaluation\nPour chaque ligne d’un item FROM qui fournit la colonne référencée, l’item LATERAL est évalué en utilisant cette ligne. Les lignes du résultat sont jointes avec la ligne qui a servi à les calculer\nOn peut parler de sous-requête paramétrée"
  },
  {
    "objectID": "slides/SQL_2.html#un-exemple-de-lusage-de-lateral",
    "href": "slides/SQL_2.html#un-exemple-de-lusage-de-lateral",
    "title": "BD II: SQL II",
    "section": "Un exemple de l’usage de LATERAL",
    "text": "Un exemple de l’usage de LATERAL\nSELECT name_country, name_city \nFROM country, LATERAL (  \n  SELECT name_city       \n  FROM city              \n  WHERE city.countrycode=country.countrycode\n) ss   \nORDER BY name_country;\néquivalent à\nSELECT name_country, name_city \nFROM country NATURAL JOIN city\nORDER BY name_country;\n LATERAL est surtout utilisé quand la colonne référencée est nécessaire au calcul des lignes à joindre"
  },
  {
    "objectID": "slides/SQL_2.html#lateral-en-action-sur-world",
    "href": "slides/SQL_2.html#lateral-en-action-sur-world",
    "title": "BD II: SQL II",
    "section": "LATERAL en action sur world",
    "text": "LATERAL en action sur world\n\n\nSELECT name_country, name_city \n\nFROM country, LATERAL ( \n  SELECT name_city  \n  FROM city  \n  WHERE city.countrycode=country.countrycode\n  ) ss  \n\nORDER BY name_city \n\nLIMIT 10 ;\n\n\n\n\nname_country\nname_city\n\n\n\n\nSpain\nA Coruña (La Coruña)\n\n\nGermany\nAachen\n\n\nDenmark\nAalborg\n\n\nNigeria\nAba\n\n\nIran\nAbadan\n\n\nBrazil\nAbaetetuba\n\n\nRussian Federation\nAbakan\n\n\nCanada\nAbbotsford\n\n\nNigeria\nAbeokuta\n\n\n…\n…"
  },
  {
    "objectID": "slides/SQL_2.html#syntaxe-des-clauses-with",
    "href": "slides/SQL_2.html#syntaxe-des-clauses-with",
    "title": "BD II: SQL II",
    "section": "Syntaxe des clauses WITH",
    "text": "Syntaxe des clauses WITH\nWITH r AS (\n  SELECT ...\n  FROM ...\n  WHERE ...\n), s AS (\n  SELECT ...\n  FROM ...\n  WHERE ...     -- possible reference to r \n)\nSELECT ...\nFROM   ... -- possible reference to r, s \nWHERE"
  },
  {
    "objectID": "slides/SQL_2.html#section",
    "href": "slides/SQL_2.html#section",
    "title": "BD II: SQL II",
    "section": "…",
    "text": "…\nWITH better_off AS (\n  SELECT countrycode, name_country, lifeexpectancy, capital\n  FROM country\n  WHERE gnpold &gt;0 AND gnp / gnpold &gt; 1.1\n),\nbig_capital AS (\n  SELECT id, countrycode\n  FROM city \n  WHERE population &gt; 2000000\n)\nSELECT bo.countrycode, name_country, lifeexpectancy\nFROM better_off bo JOIN big_capital bc ON\n  (bo.countrycode=bc.countrycode AND bc.id=bo.capital) ;"
  },
  {
    "objectID": "slides/SQL_0.html#un-peu-de-formalisation",
    "href": "slides/SQL_0.html#un-peu-de-formalisation",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Un peu de formalisation",
    "text": "Un peu de formalisation\nRappel sur la notion de relation (au sens classique)\n\n\n\n\n\n\nDefinition : Domaine\n\n\nUn ensemble d’éléments\n\n\n\n\nExemples : entiers \\(\\mathbb{Z}\\), flottants, chaines de caractères \\(\\mathcal{A}^*\\), date, …\nLes types d’un langage de programmation comme C, Java, …"
  },
  {
    "objectID": "slides/SQL_0.html#remarque",
    "href": "slides/SQL_0.html#remarque",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Remarque",
    "text": "Remarque\n\nUn domaine peut se définir :\n\nen extension (en donnant la liste de toutes les valeurs possibles) ou\nen intention (en donnant une propriété caractéristique)."
  },
  {
    "objectID": "slides/SQL_0.html#produit-cartésien",
    "href": "slides/SQL_0.html#produit-cartésien",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Produit cartésien",
    "text": "Produit cartésien\n\n\n\n\n\n\nDéfinition : Produit cartésien\n\n\nLe Produit cartésien d’une liste de domaines \\(D_1, D_2, \\dots, D_k\\), noté\n\\[D_1 \\times D_2 \\times \\dots \\times D_k\\]\nest l’ensemble\n\\[\\Bigl\\{(t_1,t_2,\\dots,t_k);\\ t_i\\in D_i \\text{ pour } i=1,\\dots,k\\Bigr\\}\\]\nUn élément \\(t=(t_1,t_2,\\dots,t_k)\\in D_1 \\times D_2 \\times \\dots \\times  D_k\\) est appelé \\(k\\) -uplet"
  },
  {
    "objectID": "slides/SQL_0.html#exemple",
    "href": "slides/SQL_0.html#exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Exemple",
    "text": "Exemple\n\n\nDeux domaines\n\\[D_1=\\left\\{1,2,5\\right\\} \\quad\\text{et}\\quad D_2=\\left\\{2,4\\right\\}\\]\nUn produit cartésien\n\\[D_1 \\times D_2 = \\left\\{(1,2),(1,4),(2,2),(2,4),(5,2),(5,4)\\right\\}\\]\nUne relation\n\\[R =\\left\\{(1,2),(1,4),(5,2),(5,4)\\right\\}\\]\nUne relation est un (sous-) ensemble (d’un produit cartésien)\n\nOn peut représenter \\(R\\) par le tableau :\n\n\n\n\n\\(X_1\\)\n\\(X_2\\)\n\n\n\n\n1\n2\n\n\n1\n4\n\n\n5\n2\n\n\n5\n4\n\n\n\n\nChaque ligne de la table correspond à un élément de la relation \\(R\\)"
  },
  {
    "objectID": "slides/SQL_0.html#relations-classiques",
    "href": "slides/SQL_0.html#relations-classiques",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Relations (classiques)",
    "text": "Relations (classiques)\nDans ce cours, toutes les relations ont un nombre fini d’éléments !"
  },
  {
    "objectID": "slides/SQL_0.html#relations-et-schémas",
    "href": "slides/SQL_0.html#relations-et-schémas",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Relations et schémas",
    "text": "Relations et schémas\n\nUne relation (classique) peut se voir comme une table à deux dimensions :\n\nchaque ligne correspond alors à un \\(k\\)-uplet (si la relation est d’arité \\(k\\)),\nchaque élément d’une colonne est à valeur dans un domaine.\nUn domaine peut apparaître plusieurs fois dans la définition d’une relation."
  },
  {
    "objectID": "slides/SQL_0.html#schéma-dune-relation",
    "href": "slides/SQL_0.html#schéma-dune-relation",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Schéma d’une relation",
    "text": "Schéma d’une relation\n\n\n\n\n\n\nDéfinition : schéma\n\n\nLe Schéma d’une relation \\(R\\) est la donnée des attributs et domaines de la relation\n\n\n\nLe schéma peut se noter\n\\[R(A_1\\! :\\! D_1,A_2\\! :\\! D_2,\\dots,A_k\\! :\\! D_k)\\]\noù \\(A_i\\) : attribut et \\(D_i\\) : domaine."
  },
  {
    "objectID": "slides/SQL_0.html#exemple-de-schéma-table-bebes-dans-babynames",
    "href": "slides/SQL_0.html#exemple-de-schéma-table-bebes-dans-babynames",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Exemple de schéma : table bebes dans babynames",
    "text": "Exemple de schéma : table bebes dans babynames\n\n\nbd_2023-24&gt; \\dt\n+-----------+-------+-------+-----------+\n| Schema    | Name  | Type  | Owner     |\n|-----------+-------+-------+-----------|\n| babynames | bebes | table | boucheron |\n+-----------+-------+-------+-----------+\n\nbd_2023-24&gt; \\d bebes\n+--------+------------------------+-----------+\n| Column | Type                   | Modifiers |\n|--------+------------------------+-----------|\n| sexe   | integer                |           |\n| prenom | character varying(500) |           |\n| annee  | integer                |           |\n| nombre | integer                |           |\n+--------+------------------------+-----------+\n\\[\\left((\\textsf{sexe}, \\mathbb{Z}), (\\textsf{prenom}, \\texttt{char}), (\\texttt{annee}, \\mathbb{Z}), (\\texttt{nombre}, \\mathbb{Z})\\right)\\]\n\nDonnées INSEE. Une ligne de la table bébés nous informe qu’en France (héxagone?), pendant une annee, le nombre de naissances de sexe sexe, ayant reçu le prénom prenom est donnée par la colonne nombre.\nbd_2023-24&gt; SELECT * \nFROM bebes \nWHERE sexe=1 AND annee=2000 AND prenom='THÉO' ;\n\n+------+--------+-------+--------+\n| sexe | prenom | annee | nombre |\n|------+--------+-------+--------|\n| 1    | THÉO   | 2000  | 7961   |\n+------+--------+-------+--------+\nL’arité de bebes est \\(4\\), sa cardinalité est \\(648 614\\)."
  },
  {
    "objectID": "slides/SQL_0.html#formalisation-alternative",
    "href": "slides/SQL_0.html#formalisation-alternative",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Formalisation alternative",
    "text": "Formalisation alternative\n\nEn BD, l’ordre des éléments et l’ordre des colonnes n’a pas d’importance (on désigne les membres d’un \\(k\\)-uplet par leur nom plutôt que par leur position/rang)\nLa définition formelle diffère donc de celle d’une relation classique\nSoient \\(\\{A_1,...,A_k\\}\\) un ensemble fini et \\(D_1,...,D_k\\) suite de domaines.\n\n\n\n\n\n\n\nNotation\n\n\nUne relation \\(R\\) de schéma \\(R(A_1\\! :\\! D_1,A_2\\! :\\! D_2,\\dots,A_k\\! :\\! D_k)\\) est la donnée d’un ensemble d’éléments, noté \\(\\mathcal{R}\\) et de \\(k\\) fonctions \\(\\mathcal{A}_1: \\mathcal{R}\\rightarrow D_1\\), …, \\(\\mathcal{A}_k: \\mathcal{R}\\rightarrow D_k\\).\nPour tout \\(t\\in \\mathcal{R}\\) et \\(i\\leq k\\), on note \\(t.A_i=\\mathcal{A}_i(t)\\) l’image par \\(\\mathcal{A}_i\\) de \\(t\\).\nUn élément \\(t\\) de \\(\\mathcal{R}\\) est appelé tuple de la relation \\(R\\)"
  },
  {
    "objectID": "slides/SQL_0.html#relations-et-schémas-formalisation",
    "href": "slides/SQL_0.html#relations-et-schémas-formalisation",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Relations et schémas : formalisation",
    "text": "Relations et schémas : formalisation\n\n\nbd_2023-24&gt; SELECT * \nFROM bebes \nWHERE sexe=1 AND \n  annee&gt; 1960 AND \n  prenom LIKE 'THEODULE' ;\n+------+----------+-------+--------+\n| sexe | prenom   | annee | nombre |\n|------+----------+-------+--------|\n| 1    | THEODULE | 1961  | 4      |\n| 1    | THEODULE | 1962  | 4      |\n| 1    | THEODULE | 1965  | 4      |\n| 1    | THEODULE | 1969  | 4      |\n+------+----------+-------+--------+\n\nQuatre tuples de bebes : \\(t_1, t_2, t_3, t_4\\).\n\\[\\begin{align*}\nt_1.\\text{sexe} & =  1 \\\\\nt_1.\\text{prenom} & = \\texttt{THEODULE} \\\\\nt_1.\\text{annee} & = 1961 \\\\\nt_1.\\text{nombre} & = 4\n\\end{align*}\\]"
  },
  {
    "objectID": "slides/SQL_0.html#résumé-informel",
    "href": "slides/SQL_0.html#résumé-informel",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Résumé informel",
    "text": "Résumé informel\n\nRELATION ↔︎ TABLE À DEUX DIMENSIONS\n(NOM DE) COLONNE ↔︎ ATTRIBUT\nEN-TÊTE DU TABLEAU ↔︎ SCHEMA DE LA RELATION\nLIGNE ↔︎ TUPLE\nENSEMBLE DES LIGNES ↔︎ CONTENU DE LA RELATION"
  },
  {
    "objectID": "slides/SQL_0.html#langage-de-manipulation-de-données",
    "href": "slides/SQL_0.html#langage-de-manipulation-de-données",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Langage de manipulation de données",
    "text": "Langage de manipulation de données\nL’algèbre relationnelle est un système de calcul sur les tables\nElle est formée d’une collection d’opérateurs qui prennent en argument des tables et retournent des tables\n\n\n\n\n\n\nRemarque:\n\n\nLes opérateurs prennent en général des arguments supplémentaires qui ne sont pas des tables. La notion d’algèbre relationnelle est inspirée par les structures algébriques comme les groupes, les anneaux, les corps où des opérations internes opèrent sur une ensemble (par exemple \\((\\mathbb{R}, +, \\times)\\)), mais elle ne rentre pas exactement dans le cadre.\n\n\n\nL’algèbre n’est pas aussi expressive qu’un langage de programmatoin classique (comme Python). C’est cela qui rend ce modèle de calcul intéressant : il permet de faire des choses pas triviales, mais il est plus facile à utiliser qu’un langage de programmation."
  },
  {
    "objectID": "slides/SQL_0.html#opérateurs-de-base",
    "href": "slides/SQL_0.html#opérateurs-de-base",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Opérateurs de base",
    "text": "Opérateurs de base\n\n\n\n\n\n\nListe des opérateurs\n\n\nL’algèbre relationnelle est d’abord un *Langage de Manipulation de Données& (LMD)}.\n\nUnion: \\(\\Large{\\cup}\\)\nIntersection: \\(\\Large{\\cap}\\)\nDifférence: \\(\\Large{\\backslash}\\)\nProjection: \\(\\Large{\\Pi}\\)\nSélection: \\(\\Large{\\sigma}\\)\nProduit cartésien: \\(\\Large{\\times}\\)\nRenommage: \\(\\Large{\\rho}\\)\n\ns’appliquent à des relations pour produire d’autres relations (le résultat)."
  },
  {
    "objectID": "slides/SQL_0.html#union-cup-et-intersection-cap",
    "href": "slides/SQL_0.html#union-cup-et-intersection-cap",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Union \\(\\cup\\) et intersection \\(\\cap\\)",
    "text": "Union \\(\\cup\\) et intersection \\(\\cap\\)\n\n\n\n\n\n\nDéfinition\n\n\n\nL’union et l’intersection sont des opérations portant sur deux relations \\(R_1\\) et \\(R_2\\) de même schéma\n\\(T=R_1\\cup R_2\\) est constituée des tuples appartenant à \\(R_1\\) ou à \\(R_2\\).\n\\(T=R_1\\cap R_2\\) est constituée des tuples appartenant à \\(R_1\\) et à \\(R_2\\).\nLes Schémas de \\(R_1\\cup R_2\\), \\(R_1\\cap R_2\\) sont les mêmes que ceux de \\(R_1\\) et \\(R_2\\)"
  },
  {
    "objectID": "slides/SQL_0.html#union-exemple",
    "href": "slides/SQL_0.html#union-exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Union : exemple",
    "text": "Union : exemple\n\n\n\n-- THEO_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n| 1    | THEOPHANE | 1900  | 3      |\n+------+-----------+-------+--------+\n\n-- THEO_2000\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEO      | 2000  | 6      |\n| 1    | THAO      | 2000  | 4      |\n| 1    | THÉO      | 2000  | 7961   |\n| 1    | THÉO-PAUL | 2000  | 3      |\n| 1    | THEODOR   | 2000  | 3      |\n| 1    | THEOPHANE | 2000  | 47     |\n| 1    | THEODORE  | 2000  | 149    |\n| 1    | THEOPHILE | 2000  | 336    |\n| 1    | THEOPHYLE | 2000  | 4      |\n| 1    | THEOS     | 2000  | 3      |\n| 1    | THEOTIM   | 2000  | 4       |\n| 1    | THEOTIME  | 2000  | 73     |\n+------+-----------+-------+--------+\n\nTHEO_1900 ∪ THEO_2000\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEODOR   | 2000  | 3      |\n| 1    | THAO      | 2000  | 4      |\n| 1    | THÉO      | 2000  | 7961   |\n| 1    | THÉO-PAUL | 2000  | 3      |\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEO      | 2000  | 6      |\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n| 1    | THEODORE  | 2000  | 149    |\n| 1    | THEOPHANE | 1900  | 3      |\n| 1    | THEOPHANE | 2000  | 47     |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEOTIME  | 2000  | 73     |\n| 1    | THEOPHILE | 2000  | 336    |\n| 1    | THEOPHYLE | 2000  | 4      |\n| 1    | THEOS     | 2000  | 3      |\n| 1    | THEOTIM   | 2000  | 4      |\n+------+-----------+-------+--------+"
  },
  {
    "objectID": "slides/SQL_0.html#intersection-exemple",
    "href": "slides/SQL_0.html#intersection-exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Intersection : exemple",
    "text": "Intersection : exemple\n\n\n-- THEO_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n| 1    | THEOPHANE | 1900  | 3      |\n+------+-----------+-------+--------+\n\n-- THEOD_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n+------+-----------+-------+--------+\n\nTHEO_1900 ∩ THEOD_1900\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n+------+-----------+-------+--------+\ncar THEOD_1900 ⊂ THEO_1900"
  },
  {
    "objectID": "slides/SQL_0.html#différence",
    "href": "slides/SQL_0.html#différence",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Différence",
    "text": "Différence\n\n\n\n\n\n\nDéfinition\n\n\n\nLa différence de deux relations \\(R_1\\) et \\(R_2\\) (de même schéma) est une relation \\(T\\)\nde même schéma que \\(R_1\\) et \\(R_2\\)\nconstituée des tuples appartenant à \\(R_1\\) et n’appartenant pas à \\(R_2\\).\nOn note \\(T = R_1 - R_2\\).\n\n\n\n\n\n\n\n\n\n\n\nOpération non commutative !\n\n\n\\(R_1 - R_2\\neq  R_2 - R_1\\) (en général)."
  },
  {
    "objectID": "slides/SQL_0.html#différence-exemple",
    "href": "slides/SQL_0.html#différence-exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Différence : exemple",
    "text": "Différence : exemple\n\n\n-- THEO_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n| 1    | THEOPHANE | 1900  | 3      |\n+------+-----------+-------+--------+\n\n-- THEOD_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n+------+-----------+-------+--------+\n\nTHEO_1900 ∖ THEOD_1900\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEOPHANE | 1900  | 3      |\n+------+-----------+-------+--------+"
  },
  {
    "objectID": "slides/SQL_0.html#produit-cartésien-1",
    "href": "slides/SQL_0.html#produit-cartésien-1",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Produit Cartésien",
    "text": "Produit Cartésien\n\n\n\n\n\n\nDéfinition\n\n\n\nSoient:\n\n\\(R_1\\) de schéma \\(R_1(A_1,A_2,...,A_k)\\)\n\\(R_2\\) de schéma \\(R_2(B_1,B_2,...,B_\\ell)\\)\navec \\(A_i\\neq B_j\\), pour tout \\(i=1,...,k\\), \\(j=1,..,\\ell\\)\n\nDans le contexte “classique” : \\(R_1 \\times R_2= \\{(e_1,e_2): e_1\\in R_1, e_2\\in R_2\\}\\)\n\\(R=R_1 \\times R_2\\) de schéma \\(R(A_1,A_2,...,A_k,B_1,B_2,...,B_\\ell)\\). Le schéma de \\(R\\) est l’union des schémas de \\(R_1\\) et \\(R_2\\)\n\n\n\n\n\n\n\n\n\n\nAttention\n\n\nEn algèbre relationnelle, cette opération est commutative ( \\(R_1\\times R_2 = R_2\\times R_1\\) ) et associative"
  },
  {
    "objectID": "slides/SQL_0.html#produit-cartésien-2",
    "href": "slides/SQL_0.html#produit-cartésien-2",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Produit cartésien :",
    "text": "Produit cartésien :\n\n\n\n\n\n\nDéfinition formelle\n\n\n\\(R=R_1\\times R_2\\) est la relation de schéma \\(R(A_1,A_2,...,A_k,B_1,B_2,...,B_\\ell)\\) vérifiant~:\n\nPour tout \\(t\\in R\\), il existe \\(t_1\\in R_1\\), \\(t_2\\in R_2\\) (\\(\\forall t \\in R, \\exists t_1 \\in R_1, \\exists t_2 \\in R_2, \\ldots\\)) tels que :\n\n\\[t.A_1=t_1.A_1, \\ldots, t.A_k=t_1.A_k,\\quad t.B_1=t_2.B_1, \\ldots, t.B_\\ell=t_2.B_\\ell\\]\n\nRéciproquement, pour tout \\(t_1\\in R_1\\), \\(t_2\\in R_2\\) , il existe \\(t\\in R\\) tels que :\n\n\\[t.A_1=t_1.A_1, \\ldots, t.A_k=t_1.A_k,\\quad \\text{et} \\quad t.B_1=t_2.B_1, \\ldots, t.B_\\ell=t_2.B_\\ell\\]\n\\[\\forall t_1 \\in R_1, \\forall t_2 \\in R_2, \\exists t \\in R, \\qquad  t.A_1=t_1.A_1, \\ldots, t.A_k=t_1.A_k,\\quad \\text{et} \\quad t.B_1=t_2.B_1, \\ldots, t.B_\\ell=t_2.B_\\ell\\]"
  },
  {
    "objectID": "slides/SQL_0.html#produit-cartésien-exemple",
    "href": "slides/SQL_0.html#produit-cartésien-exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Produit cartésien : exemple",
    "text": "Produit cartésien : exemple"
  },
  {
    "objectID": "slides/SQL_0.html#projection-largepi",
    "href": "slides/SQL_0.html#projection-largepi",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Projection ( \\(\\Large{\\pi}\\) )",
    "text": "Projection ( \\(\\Large{\\pi}\\) )\n\n\n\n\n\n\nDéfinition\n\n\n\nLa projection d’une relation \\(R\\) de schéma \\(R(A_1,\\dots, A_k)\\) sur les attributs \\(A_{i_1}, \\dots, A_{i_p}\\), \\(i_1,..., i_p\\in \\{1,...,k\\}\\), est la relation \\(S\\)\n\nde schéma \\(S(A_{i_1}, \\dots,A_{i_p})\\)\ndont les tuples sont obtenus par élimination des attributs non mentionnés dans \\(A_{i_1}, \\dots, A_{i_p}\\) (et par élimination des doublons).\nOn note \\(S = \\pi_{A_{i_1}, \\dots, A_{i_p}} (R)\\).\n\nDéfinition formelle :\n\n\\[s\\in S\\quad  \\iff \\quad \\exists t\\in R, \\forall n\\in\\left\\{1,\\dots,p\\right\\}\\qquad s.A_{i_n}=t.A_{i_n}\\]\n\n\n\n\n\n\n\n\n\nRemarque\n\n\nImplicitement, on a élimination des doublons car une projection peut produire plusieurs fois le même tuple."
  },
  {
    "objectID": "slides/SQL_0.html#projection-exemple",
    "href": "slides/SQL_0.html#projection-exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Projection : Exemple",
    "text": "Projection : Exemple\nΠ(THEOD_1900, prenom, nombre)\n+-----------+---------+\n| prenom    |  nombre |\n|-----------+---------+\n| THEODORE  |  227    |\n| THEODOSE  |  3      |\n| THEODULE  |  39     |\n+-----------+---------+\nIci, aucune éliminitation de doublons n’a été nécessaire"
  },
  {
    "objectID": "slides/SQL_0.html#sélection-largesigma",
    "href": "slides/SQL_0.html#sélection-largesigma",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Sélection ( \\(\\Large{\\sigma}\\) )",
    "text": "Sélection ( \\(\\Large{\\sigma}\\) )\n\n\n\n\n\n\nDéfinition\n\n\n\nLa sélection d’une relation \\(R\\) par une condition \\(C\\) est une relation \\(S\\)\n\nde même schéma que \\(R\\)\ndont les tuples sont ceux de \\(R\\) qui satisfont la condition \\(C\\).\n\nOn note \\(S = \\sigma_C (R)\\).\nLa condition \\(C\\)\n\ns’exprime à l’aide des noms d’attributs de la relation ou de constantes (pour les opérandes)\non peut utiliser des opérateurs arithmétiques de comparaison ( \\(=, \\neq, \\leq, \\geq, &lt;, &gt;\\) ) ainsi que des connecteurs logiques ( \\(\\lnot, \\land, \\lor\\) ).."
  },
  {
    "objectID": "slides/SQL_0.html#sélection-exemple",
    "href": "slides/SQL_0.html#sélection-exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Sélection : Exemple",
    "text": "Sélection : Exemple\nσ(THEO_1900, ¬ prenom LIKE ‘THEOD%’)\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEOPHANE | 1900  | 3      |\n+------+-----------+-------+--------+"
  },
  {
    "objectID": "slides/SQL_0.html#renommage",
    "href": "slides/SQL_0.html#renommage",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Renommage",
    "text": "Renommage\n\n\n\n\n\n\nDéfinition\n\n\n\nSoit \\(R\\) de schéma \\(R(A_1,\\dots, A_k)\\), le renommage d’un attribut \\(A_i\\), \\(i\\leq k\\), en \\(B\\) est une relation \\(S\\) :\n\nde même contenu (mêmes lignes)\nde schéma \\(S(A_1,...,A_{i-1},B,A_{i+1},..., A_k)\\)\nOn le note \\(S=\\rho_{A_i\\mapsto B}(R)\\)"
  },
  {
    "objectID": "slides/SQL_0.html#renommage-exemple",
    "href": "slides/SQL_0.html#renommage-exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Renommage : Exemple",
    "text": "Renommage : Exemple\n-- THEOD_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n+------+-----------+-------+--------+\nρ(THEOD_1900, sexe→sex, prenom→name, annee→year, nombre→count)\n-- THEOD_1900\n\n+------+-----------+-------+--------+\n| sex  | name      | year  | count  |\n|------+-----------+-------+--------|\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n+------+-----------+-------+--------+\nUtilité Va permettre d’étendre certains opérateurs pour des relations de schémas non-disjoints"
  },
  {
    "objectID": "slides/SQL_0.html#algèbre-relationnelle",
    "href": "slides/SQL_0.html#algèbre-relationnelle",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Algèbre relationnelle",
    "text": "Algèbre relationnelle\n\nOpérations ensemblistes classiques.\nProjection : élimine des colonnes\nSélection : élimine des lignes\n\nPour interroger une BD, on compose ces opérateurs :"
  },
  {
    "objectID": "slides/SQL_0.html#exemple-1",
    "href": "slides/SQL_0.html#exemple-1",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Exemple",
    "text": "Exemple\nπ(σ(THEO_1900, prenom LIKE ‘THEOD%’), prenom, nombre)\n\nρ(π(σ(THEO_1900, prenom LIKE ‘THEOD%’), prenom, nombre), prenom→name, nombre→count)"
  },
  {
    "objectID": "slides/SQL_0.html#de-la-composition-aux-tuyaux-pipelines",
    "href": "slides/SQL_0.html#de-la-composition-aux-tuyaux-pipelines",
    "title": "BD I: Algèbre Relationnelle",
    "section": "De la composition aux tuyaux (pipelines)",
    "text": "De la composition aux tuyaux (pipelines)\nOn peut rendre la composition de fonctions plus lisible (pour l’humain) en reprenant un mécanisme d’Unix : le pipe (tuyau) |&gt; (notation de )\nPlutôt qu’écrire \\(g(f(x,y), z, t)\\), on convient d’écrire f(x,y) |&gt; g(z, t) voire x |&gt; f(y) |&gt; g(z,t)\nEt pour rendre l’expression encore plus lisible on peut écrire\nx |&gt; \n  f(y) |&gt; \n  g(z,t)"
  },
  {
    "objectID": "slides/SQL_0.html#de-la-composition-aux-tuyaux-suite",
    "href": "slides/SQL_0.html#de-la-composition-aux-tuyaux-suite",
    "title": "BD I: Algèbre Relationnelle",
    "section": "De la composition aux tuyaux (suite)",
    "text": "De la composition aux tuyaux (suite)\nOn peut ainsi réécrire\nρ(π(σ(THEO_1900, prenom LIKE ‘THEOD%’), prenom, nombre), prenom→name, nombre→count)\nen\nTHEO_1900  |&gt;\n  σ(`prenom` `LIKE` 'THEOD%') |&gt;\n  π(`prenom`, `nombre`) |&gt;\n  ρ(`prenom→name`, `nombre→count`)\n\n\nDans le langage  (&gt; 4.x), le pipe s’écrit |&gt;"
  },
  {
    "objectID": "slides/SQL_0.html#les-jointures",
    "href": "slides/SQL_0.html#les-jointures",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Les jointures",
    "text": "Les jointures\nOn va définir des opérations pratiques pour la manipulation de données : les jointures\n\nJointure\nJointure naturelle\n\\(\\theta\\)-jointure et équi-jointure"
  },
  {
    "objectID": "slides/SQL_0.html#jointure",
    "href": "slides/SQL_0.html#jointure",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Jointure",
    "text": "Jointure\n\n\n\n\n\n\nDéfinition\n\n\nLa jointure \\(T=R_1\\bowtie_C R_2\\) de deux relations \\(R_1\\) et \\(R_2\\) de schémas disjoints sous la condition \\(C\\) est la relation \\(T\\):\n\nde schéma la concaténation des schémas de \\(R_1\\) et \\(R_2\\)\nformée des tuples du produit cartésien \\(R_1  \\times R_2\\) qui satisfont la condition \\(C\\)\n\nRègles de formation de la condition de jointure : comme pour la sélection\n\n\n\n\n\n\n\n\n\nDéfinition formelle\n\n\n\\[R_1 \\bowtie_C R_2 = \\sigma_C(R_1\\times R_2)\\]"
  },
  {
    "objectID": "slides/SQL_0.html#exemple-sur-le-schéma-world",
    "href": "slides/SQL_0.html#exemple-sur-le-schéma-world",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Exemple sur le schéma world",
    "text": "Exemple sur le schéma world\n\nLier les pays (les lignes de country) à leur capitale, c’est à dire les couples de lignes de country et de city qui satisfont capital = id"
  },
  {
    "objectID": "slides/SQL_0.html#exemple-sur-le-schéma-world-suite",
    "href": "slides/SQL_0.html#exemple-sur-le-schéma-world-suite",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Exemple sur le schéma world (suite)",
    "text": "Exemple sur le schéma world (suite)\n`country` |&gt;\n  ⋈(`city`, `capital=id`) |&gt;\n  π(`name_country`, `name`)\n\n+----------------------+------------------+\n| name_country         | name             |\n|----------------------+------------------|\n| Afghanistan          | Kabul            |\n| Netherlands          | Amsterdam        |\n| Netherlands Antilles | Willemstad       |\n| Albania              | Tirana           |\n| Algeria              | Alger            |\n...\n+----------------------+------------------+\n\n\nOn se contente d’afficher les cinq premières lignes du résultat."
  },
  {
    "objectID": "slides/SQL_0.html#différentes-variétés-de-jointures",
    "href": "slides/SQL_0.html#différentes-variétés-de-jointures",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Différentes variétés de jointures",
    "text": "Différentes variétés de jointures\nAutour de la jointure ⋈(R, S, C) on a pris l’habitude de distinguer des types de jointure selon la forme de l’expression de jointure (la condition C)\nOn distingue\n\nles équi-jointures\nles θ-jontures\nles jointures naturelles\n\n\n\nCes distinctions portent sur la condition C. Elles ne sont pas de même nature que les distinctions qui portent sur la manière dont le résultat final est calculé et qui définissent les jointures internes, externes, …"
  },
  {
    "objectID": "slides/SQL_0.html#équi-jointure",
    "href": "slides/SQL_0.html#équi-jointure",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Équi-jointure,",
    "text": "Équi-jointure,\n\n\n\n\n\n\nÉqui-jointure\n\n\nJointure avec égalité entre attributs de types comparables\n\n\n\n\n⋈(`country`, `city`, `capital=id`)"
  },
  {
    "objectID": "slides/SQL_0.html#θ-jointure",
    "href": "slides/SQL_0.html#θ-jointure",
    "title": "BD I: Algèbre Relationnelle",
    "section": "θ-jointure",
    "text": "θ-jointure\n\n\n\n\n\n\n\\(\\theta\\)-jointure\n\n\nCondition de jointure entre attributs de types comparables et avec un opérateur différent de l’égalité, c’est-à-dire dans \\(\\left\\{&lt;,&gt;,\\leq,\\geq, \\neq\\right\\}\\).\n\n\n\n\n⋈(`country`, `city`, `capital=id`  ∧ `population &gt; .5 * population_country`)"
  },
  {
    "objectID": "slides/SQL_0.html#jointure-naturelle",
    "href": "slides/SQL_0.html#jointure-naturelle",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Jointure naturelle",
    "text": "Jointure naturelle\n\n\n\n\n\n\nDéfinition\n\n\nC’est une équi-jointure concernant les attributs communs (même nom et même type) de deux relations\nOn ne garde dans le résultat qu’une copie des attributs communs \n\n\n\nOn considère\n\n\\(R_1\\) d’attributs \\(A_1,..,A_k,B_1,...,B_h\\)\n\\(R_2\\) d’attributs \\(A_1,..,A_k,B_{h+1},...,B_\\ell\\)\n\\(A_1,..., A_k\\) : attributs communs et \\(\\{B_1,...,B_h\\}\\cap \\{ B_{h+1},...,B_\\ell \\}=\\emptyset\\)\nSoit \\(A'_1, ...., A'_k\\) tels que \\(\\{A_1,..., A_k\\}\\cap \\{ A'_1, ...., A'_k \\}=\\emptyset\\)"
  },
  {
    "objectID": "slides/SQL_0.html#jointure-naturelle-formalisation",
    "href": "slides/SQL_0.html#jointure-naturelle-formalisation",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Jointure naturelle (formalisation)",
    "text": "Jointure naturelle (formalisation)\nConsidérons \\(S\\) d’attributs \\(A_1',..,A_k',B_{h+1},...,B_l\\) définie par :\n\\[S=\\rho_{A_1\\mapsto A_1'}(\\rho_{A_2\\mapsto A_2'}(\\cdots (\\rho_{A_k\\mapsto A_k'}(R_2)\\cdots ))\\]\nLa jointure naturelle sur deux relations \\(R_1\\) et \\(R_2\\) est la relation\n\nd’attributs \\(A_1,..,A_k,B_1,...,B_h, B_{h+1},...,B_\\ell\\)\ndéfinie par : \\[\\pi_{A_1,..,A_k,B_1,...,B_h, B_{h+1},...,B_\\ell}(R_1\\bowtie_{C} S)\\] où \\(C\\) est \\((A_1=A_1') \\wedge (A_2=A'_2) \\wedge \\ldots \\wedge (A_k=A_k')\\)\n\n\n\n\n\n on réalise une équi-jointure sur tous les attributs communs et on ne garde qu’un seul “exemplaire” de ces attributs communs par projection. On note cette opération : \\(R_1 \\bowtie R_2\\).\n Pour éviter le renommage, on peut décider de préfixer les noms des attributs par ceux de la relation. La condition \\(C\\) devient :\n\\[(R_1.A_1=R_2.A_1) \\wedge \\ldots \\wedge (R_1.A_k=R_2.A_k)\\]"
  },
  {
    "objectID": "slides/SQL_0.html#exemple-de-jointure-naturelle",
    "href": "slides/SQL_0.html#exemple-de-jointure-naturelle",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Exemple de Jointure naturelle",
    "text": "Exemple de Jointure naturelle\n\n\nbd_2023-24&gt; \\d countrylanguage\n+-------------+--------------+-----------+\n| Column      | Type         | Modifiers |\n|-------------+--------------+-----------|\n| countrycode | character(3) |  not null |\n| language    | text         |  not null |\n| isofficial  | boolean      |  not null |\n| percentage  | real         |  not null |\n+-------------+--------------+-----------+\n\n+--------------------+---------------+-----------+\n| Column             | Type          | Modifiers |\n|--------------------+---------------+-----------|\n| countrycode        | character(3)  |  not null |\n| name_country       | text          |  not null |\n| continent          | text          |  not null |\n| region             | text          |  not null |\n| surfacearea        | real          |  not null |\n| indepyear          | smallint      |           |\n| population_country | integer       |  not null |\n| lifeexpectancy     | real          |           |\n| gnp                | numeric(10,2) |           |\n| gnpold             | numeric(10,2) |           |\n| localname          | text          |  not null |\n| governmentform     | text          |  not null |\n| headofstate        | text          |           |\n| capital            | integer       |           |\n| code2              | character(2)  |  not null |\n+--------------------+---------------+-----------+\n\nJointure naturelle\ncountry |\n  ⋈(countrylanguage) |&gt;\n  σ(country='France') |&gt;\n  π(name_country, language)\n+--------------+------------+\n| name_country | language   |\n|--------------+------------|\n| France       | French     |\n| France       | Arabic     |\n| France       | Portuguese |\n| France       | Italian    |\n| France       | Spanish    |\n| France       | Turkish    |\n+--------------+------------+"
  },
  {
    "objectID": "slides/SQL_0.html#exemples-de-requêtes",
    "href": "slides/SQL_0.html#exemples-de-requêtes",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Exemples de requêtes",
    "text": "Exemples de requêtes\n\ndéterminer les noms des capitales des pays situés en Asie (Asia)\n\ncountry |&gt;\n  σ(continent='Asia') |&gt;\n  ⋈(city, capital=id) |&gt;\n  π(name)\n\n\ndéterminer les langues parlées dans les pays d’Asie\n\ncountry |&gt;\n  σ(continent='Asia') |&gt;\n  ⋈(countrylanguage) |&gt;\n  π(language)"
  },
  {
    "objectID": "slides/SQL_0.html#jointure-externe",
    "href": "slides/SQL_0.html#jointure-externe",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Jointure externe",
    "text": "Jointure externe\n\n\n\n\n\n\nPerte d’information dans jointure naturelle\n\n\nLes tuples ne satisfaisant pas la condition (non appariés) disparaissent\n\n\n\n\n\n\n\n\n\nDéfinition\n\n\n\nOn ajoute symboliquement” une ligne dont les valeurs sont vides (ou avec valeur spéciale NULL) pour garder les tuples initiaux “non satisfaisants” après la jointure\nOn note cette opération entre deux relations \\(R\\) et \\(S\\) :\n\\[R \\bowtie^+ S\\]"
  },
  {
    "objectID": "slides/SQL_0.html#jointure-externe-exemple",
    "href": "slides/SQL_0.html#jointure-externe-exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Jointure externe (exemple)",
    "text": "Jointure externe (exemple)\n\n\nOn veut une table formée par les codes ISO, les noms des pays et (si possible) les noms des capitales. Les territoires sans capitale doivent apparaître en fin de table, avec une colonne nom de capitale nulle.\n\nObtenir la première partie de la réponse avec une jointure est facile. Pour trouver les territoires sans capitale, il suffit de faire une sélection dans country sur le critère capital IS NULL. Ensuite, on peut faire une UNION (∪)\n\n\nAvec une jointure externe on peut obtenir le résultat en une opération\n⋈^+(city, country, id=capital) |&gt;\n  π(countrycode, name_country, name)"
  },
  {
    "objectID": "slides/SQL_0.html#division",
    "href": "slides/SQL_0.html#division",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Division",
    "text": "Division\n\n\n\n\n\n\nDéfinition\n\n\nLa division ou quotient\n\nd’une relation \\(R\\) de schéma \\(R(A_1,A_2,\\dots,A_k)\\)\npar une relation \\(S\\) de schéma \\(S(A_{p+1},\\dots ,A_k)\\)\n\nest la relation \\(T\\) de schéma \\(T(A_1, \\dots, A_p)\\) formée des tuples qui complétés par chaque tuple de \\(S\\) donnent un tuple de \\(R\\).\nAutrement dit\n\\[\\begin{array}{l} t\\in T(A_1,\\dots,A_p)  \\quad \\Longleftrightarrow \\\\\n\\forall s\\in S(A_{p+1},\\dots ,A_k) \\quad \\exists r\\in R \\quad \\begin{cases}\nt.A_1=r.A_1, \\dots, t.A_p=r.A_p\\\\ s.A_{p+1}=r.A_{p+1},\\dots, s.A_{k}=r.A_{k} \\end{cases} \\end{array}\\]\nOn note \\[T = R \\div S\\]"
  },
  {
    "objectID": "slides/SQL_0.html#division-exemple",
    "href": "slides/SQL_0.html#division-exemple",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Division (exemple)",
    "text": "Division (exemple)\n\n\n Lister les langues parlées sur tous les continents\nOn aimerait écrire une expression qui renvoie un résultat correct quelque soit les conventions adoptées sur la définition de continent (les Amériques forment-elles un ou deux continents, etc)\n\nCL ← ⋈(country, countrylanguage) |&gt;\n  π(continent, language)\n\nC ← π(CL, continent)\nL ← π(CL, language)\n\nLPPTC ← (C × L  ∖  CL ) |&gt;\n  π(language)\n\nL  ∖  LPPTC\nOn vient de calculer une division !\nCL ÷ C"
  },
  {
    "objectID": "slides/SQL_0.html#interdéfinissabilité-des-opérateurs",
    "href": "slides/SQL_0.html#interdéfinissabilité-des-opérateurs",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Interdéfinissabilité des opérateurs",
    "text": "Interdéfinissabilité des opérateurs\n\nL’union, la différence, le produit cartésien, la sélection et la projection et le renommage sont suffisants pour définir tous les opérateurs que l’on a vu.\nMais avoir un panier plus large d’opérateurs simplifie l’écriture des requêtes.\n\nQuelques définitions\n\nPour la Jointure : \\(R \\bowtie_C S \\equiv \\sigma_C (R \\times S)\\)\nPour l’intersection : \\(A \\cap B = A \\cup B - ((B - A) \\cup (A - B))\\)"
  },
  {
    "objectID": "slides/SQL_0.html#définition-de-la-division",
    "href": "slides/SQL_0.html#définition-de-la-division",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Définition de la division",
    "text": "Définition de la division\n\n\n\n\n\n\nFormalisation\n\n\nSoient \\(R\\) de schéma \\(R(A_1,A_2,\\dots,A_k)\\), \\(S\\) de schéma \\(S(A_{p+1},\\dots ,A_k)\\)\nest la relation \\(T= R ÷ S\\) de schéma \\(T(A_1, \\dots, A_p)\\).\nT ← Π(R, A) ∖ Π((Π(R, A) × S ∖ R), A)\n\n\n\n\n\nDans la définition de R ÷ S, on utilise en deux endroits Π(R, A). Il serait utile, lors de l’évaluation de R ÷ S de n’évaluer Π(R, A) qu’une seule fois."
  },
  {
    "objectID": "slides/SQL_0.html#depuis-wikipedia",
    "href": "slides/SQL_0.html#depuis-wikipedia",
    "title": "BD I: Algèbre Relationnelle",
    "section": "Depuis Wikipedia",
    "text": "Depuis Wikipedia\n\nIn the 1960s and 1970s he [Codd] worked out his theories of data arrangement, issuing his paper “A Relational Model of Data for Large Shared Data Banks” in 1970.[ To his disappointment, IBM proved slow to exploit his suggestions until commercial rivals started implementing them.\n\n\nInitially, IBM refused to implement the relational model to preserve revenue from IMS/DB. Codd then showed IBM customers the potential of the implementation of its model, and they in turn pressured IBM. Then IBM included in its Future Systems project a System R subproject – but put in charge of it developers who were not thoroughly familiar with Codd’s ideas, and isolated the team from Codd. As a result, they did not use Codd’s own Alpha language but created a non-relational one, SEQUEL. Even so, SEQUEL was so superior to pre-relational systems that it was copied, in 1979, based on pre-launch papers presented at conferences, by Larry Ellison, of Relational Software Inc, in his Oracle Database, which actually reached market before SQL/DS – because of the then-already proprietary status of the original name, SEQUEL had been renamed SQL.\n\n\nCodd continued to develop and extend his relational model, sometimes in collaboration with Christopher J. Date. One of the normalised forms, the Boyce–Codd normal form, is named after him.\n\n\nCodd’s theorem, a result proven in his seminal work on the relational model, equates the expressive power of relational algebra and relational calculus."
  },
  {
    "objectID": "slides/DF_norm_3.html#projection-dun-ensemble-de-df",
    "href": "slides/DF_norm_3.html#projection-dun-ensemble-de-df",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Projection d’un ensemble de DF",
    "text": "Projection d’un ensemble de DF\nSoientt \\(\\mathcal{A}\\) un schéma de relation (\\(\\mathcal{A}\\) est un ensemble d’attributs) et \\(\\Sigma\\) un ensemble de DF sur \\(\\mathcal{A}\\)\nSoit \\(\\mathcal{A}_1\\subset  \\mathcal{A}\\) un sous-ensemble d’attributs\n\n\n\n\n\n\nDéfinition\n\n\n\\[\\pi_{\\mathcal{A}_1}(\\Sigma)=\\left\\{ X\\to Y \\mid \\Sigma\\models X\\to Y \\text{ et } X,Y\\subset \\mathcal{A}_1\\right\\}\\]\n\n\n\n\n\n\n\n\n\n\nCaractérisation\n\n\nSi \\(X\\subset {\\mathcal{A}}_1\\) on a l’équivalence \\[X\\to Y \\in \\pi_{{\\mathcal{A}}_1}(\\Sigma) \\iff Y\\subset\\left\\{X\\right\\}^+∩{\\mathcal{A}}_1\\]\n\n\n\n\n\\(\\pi_{\\mathcal{A}_1}(\\Sigma)\\) est l’ensemble des DF de la forme \\(X\\to Y\\) impliquées par \\(\\Sigma\\) et telles que \\(X\\subset \\mathcal{A}_1\\) et \\(Y\\subset \\mathcal{A}_1\\)"
  },
  {
    "objectID": "slides/DF_norm_3.html#exemple",
    "href": "slides/DF_norm_3.html#exemple",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Exemple",
    "text": "Exemple\n\n\\({\\mathcal{A}}=\\left\\{A,B,C\\right\\}\\) et \\(\\Sigma=\\left\\{A\\to B, B\\to C, C\\to A\\right\\}\\)\n\\(\\pi^{}_{\\left\\{A,B\\right\\}}(\\Sigma)\\) est équivalent à \\(\\left\\{A\\to B, B\\to A\\right\\}\\)"
  },
  {
    "objectID": "slides/DF_norm_3.html#calcul-de-pi_mathcala_1sigma",
    "href": "slides/DF_norm_3.html#calcul-de-pi_mathcala_1sigma",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Calcul de \\(\\pi_{{\\mathcal{A}}_1}(\\Sigma)\\)",
    "text": "Calcul de \\(\\pi_{{\\mathcal{A}}_1}(\\Sigma)\\)\nOn calcule un ensemble de DF équivalent à \\(\\pi_{\\mathcal{A}_1}(\\Sigma)\\)\n\n\n\\begin{algorithm} \\caption{Projection de DF} \\begin{algorithmic} \\Procedure{Projection}{$\\mathcal{A}_1, Σ$} \\State P ← ∅ \\For{$X ⊂ \\mathcal{A}_1$, $X ≠ ∅$, $X ≠ \\mathcal{A}_1$} \\State Y ← $X^+ ∩ \\mathcal{A}_1$ \\State P ← P ∪ $\\{ X → Y\\}$ \\EndFor \\Return P \\EndProcedure \\end{algorithmic} \\end{algorithm}\n\n\n\n\nL’ensemble de DF obtenu est équivalent à \\(\\pi_{{\\mathcal{A}}_1}(\\Sigma)\\)\nTrès coûteux ! Le nombre de sous-ensembles \\(X\\) considérés est \\(2^{\\#{\\mathcal{A}}_1}-2\\)"
  },
  {
    "objectID": "slides/DF_norm_3.html#exemple-1",
    "href": "slides/DF_norm_3.html#exemple-1",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Exemple",
    "text": "Exemple\n\n\\({\\mathcal{A}}=\\left\\{A,B,C,D,E\\right\\}\\) et \\(\\Sigma=\\left\\{A\\to C, BC\\to D, AD\\to E\\right\\}\\)\n\n\n\n\\(\\pi_{AC}(\\Sigma)\\) est équivalent à \\(\\left\\{A\\to C\\right\\}\\) car\n\\(\\left\\{A\\right\\}^+=\\left\\{A,C\\right\\}\\) et \\(\\left\\{C\\right\\}^+=\\left\\{C\\right\\}\\)\n\n\n\n\n\\(\\pi_{ABD}(\\Sigma)\\) est équivalent à \\(\\left\\{AB\\to D\\right\\}\\) car\n\\(\\left\\{A\\right\\}^+=\\left\\{A,C\\right\\}\\), \\(\\left\\{B\\right\\}^+=\\left\\{D\\right\\}\\), \\(\\left\\{D\\right\\}^+=\\left\\{D\\right\\}\\),\n\\(\\left\\{A,B\\right\\}^+=\\left\\{A,B,C,D,E\\right\\}\\), \\(\\left\\{A,D\\right\\}^+=\\left\\{A,D,C,E\\right\\}\\), \\(\\left\\{B,D\\right\\}^+=\\left\\{B,D\\right\\}\\)\n\n\n\n\n\\(\\pi_{ABCE}(\\Sigma)\\) est équivalent à \\(\\left\\{A\\to C, AB \\to CE, AE\\to C, ABC\\to E, ABE\\to C\\right\\}\\)\n\\(A^+=AC \\quad B^+=B \\quad C^+=C \\quad E^+=E\\)\n\\(AB^+=ABCDE \\quad AC^+=AC \\quad AE^+=AEC\\)\n\\(BC^+=BCD \\quad BE^+=BE \\quad CE^+=CE\\)\n\\(ABC^+=ABCDE \\quad ABE^+=ABECD\\)\n\\(BCE^+=BCED \\quad ACE^+=ACE\\)\n\n\n\n\nSimplification : \\(\\pi_{ABCE}(\\Sigma)\\) équivaut à \\(\\left\\{A\\to C, AB\\to E\\right\\}\\)"
  },
  {
    "objectID": "slides/DF_norm_3.html#préservation-de-dépendances-fonctionnelles",
    "href": "slides/DF_norm_3.html#préservation-de-dépendances-fonctionnelles",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Préservation de dépendances fonctionnelles",
    "text": "Préservation de dépendances fonctionnelles\n\n\n\n\n\n\nDéfinition\n\n\nSoit \\(\\mathcal{A}\\) un schéma de relation et \\(\\Sigma\\) un ensemble de DF sur \\(\\mathcal{A}\\).\nSoit \\(\\left\\{ \\mathcal{A}_1,\\dots, \\mathcal{A}_k\\right\\}\\) une décomposition du schéma \\(\\mathcal{A}\\) (\\(\\mathcal{A}_i\\neq \\emptyset, 1\\leq i\\leq k\\) et \\(\\mathcal{A}= \\bigcup_{i=1}^k \\mathcal{A}_i\\))\nLa décomposition \\(\\left\\{\\mathcal{A}_1,\\dots, \\mathcal{A}_k\\right\\}\\) préserve \\(\\Sigma\\) si l’ensemble des dépendances fonctionnelles locales \\(\\bigcup_{i=1}^k \\pi_{\\mathcal{A}_i}(\\Sigma)\\) est équivalent à \\(\\Sigma\\)\n\n\n\n\n\nPuisque \\(\\Sigma ⊧ \\bigcup_{i=1}^k \\pi_{\\mathcal{A}_i}(\\Sigma)\\), la décomposition préserve \\(\\Sigma\\) si et seulement si toutes les DF de \\(\\Sigma\\) sont impliquées par les DF locales"
  },
  {
    "objectID": "slides/DF_norm_3.html#exemple-perte-de-dépendance-fonctionnelle",
    "href": "slides/DF_norm_3.html#exemple-perte-de-dépendance-fonctionnelle",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Exemple : perte de dépendance fonctionnelle",
    "text": "Exemple : perte de dépendance fonctionnelle"
  },
  {
    "objectID": "slides/DF_norm_3.html#algorithme-pour-tester-si-bigcup_i1k-pi_mathcala_isigma-models-x-rightarrow-y",
    "href": "slides/DF_norm_3.html#algorithme-pour-tester-si-bigcup_i1k-pi_mathcala_isigma-models-x-rightarrow-y",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Algorithme pour tester si \\(\\bigcup_{i=1}^k \\pi_{\\mathcal{A}_i}(\\Sigma) \\models X \\rightarrow Y\\)",
    "text": "Algorithme pour tester si \\(\\bigcup_{i=1}^k \\pi_{\\mathcal{A}_i}(\\Sigma) \\models X \\rightarrow Y\\)\n\n\n\\begin{algorithm} \\caption{X → Y est-elle impliquée par les dépendances projetées?} \\begin{algorithmic} \\Procedure{Implique}{$\\left\\{ \\mathcal{A}_1,\\dots, \\mathcal{A}_k\\right\\}, Σ, X, Y$} \\State Z ← X \\State continuer ← \\True \\While{continuer} \\State $W ← Z$ \\For{i ∈ 1, ..., k} \\State $W ← W ∪ \\bigl((W ∩ \\mathcal{A}_i)^+ ∩ \\mathcal{A}_i\\bigr)$ \\EndFor \\If{W ≠ Z} \\State Z ← W \\Else \\State continuer ← \\False \\EndIf \\EndWhile \\If{Y ⊆ Z} \\Return \\True \\Else \\Return \\False \\EndIf \\EndProcedure \\end{algorithmic} \\end{algorithm}"
  },
  {
    "objectID": "slides/DF_norm_3.html#section",
    "href": "slides/DF_norm_3.html#section",
    "title": "Normalisation II : Décomposition FN3",
    "section": "",
    "text": "\\(\\mathcal{A} =\\) {Ville, Rue, Numéro, #Bureau_vote}\nΣ = { Ville, Nom, Rue → #Bureau_vote,  #Bureau_vote  →  Ville }\n\nDeux clés Ville, Nom, Rue et #Bureau_vote, Nom, Rue\n\n\n#Bureau_vote  →  Ville ne satisfait pas le critère FNBC\n\n\nL’algorithme de décomposition en FNBC conduit à la décomposition {#Bureau_vote,Ville} et {#Bureau_vote, Nom, Rue}\nLa DF Ville, Nom, Rue → #Bureau_vote n’est pas préservée\nLa décomposition préserve l’information (SPI) mais pas les dépendances fonctionnelles."
  },
  {
    "objectID": "slides/DF_norm_3.html#exemple-i",
    "href": "slides/DF_norm_3.html#exemple-i",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Exemple I",
    "text": "Exemple I\n\n\\(\\mathcal{A}=\\left\\{A,B,C,D\\right\\}\\),\n\\(\\mathcal{A}_1=\\left\\{A,B\\right\\}\\), \\(\\mathcal{A}_2=\\left\\{B,C\\right\\}\\), \\(\\mathcal{A}_3=\\left\\{C,D\\right\\}\\)\n\\(\\Sigma=\\left\\{A\\to B, B\\to C, C\\to D, D\\to A\\right\\}\\)\nEst-ce que la décomposition \\(\\left\\{\\mathcal{A}_1,\\mathcal{A}_2,\\mathcal{A}_3\\right\\}\\) préserve \\(\\Sigma\\) ?\n\n\n\nLes DF locales impliquent \\(A\\to B\\), \\(B\\to C\\), \\(C\\to D\\) (ce sont DF locales)\n\n\n\n\nEst-ce que les DF locales impliquent \\(D\\to A\\) ?\n\n\n\nCommencer avec \\(Z ← \\{D\\}\\)\n\n\n\\((\\{D\\}∩\\{CD\\})^+ ∩ \\{CD\\}=\\{D\\}^+ ∩\\{CD\\}=\\{DABC\\} ∩ \\{CD\\}=\\{CD\\}\\), ajouter \\(C\\)\n\\((\\{DC\\}∩ \\{BC\\})^+ ∩ \\{BC\\}=\\{C\\}^+ ∩ \\{BC\\}=\\{CDAB\\}∩ \\{BC=B\\}\\), ajouter \\(B\\)\n\\((\\{DCB\\}∩ \\{AB\\})^+ ∩ \\{AB\\}=\\{B\\}^+ ∩ \\{AB\\}=\\{BCDA\\} ∩ \\{AB\\}\\), ajouter \\(A\\)\n\\(\\{DCBA\\}\\) contient \\(A\\) donc \\(D\\to A\\) est préservée"
  },
  {
    "objectID": "slides/DF_norm_3.html#exemple-ii",
    "href": "slides/DF_norm_3.html#exemple-ii",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Exemple II",
    "text": "Exemple II\n\n\\(\\mathcal{A}=\\) {Ville, CP, Rue, Numero}\n\\(\\Sigma=\\) { CP →  Ville, {Ville, Rue, Numero} → CP}\n\\(\\mathcal{A}_1=\\) {Ville, CP} \\(\\mathcal{A}_2=\\) {Rue, Numero, CP}\nEst-ce que la décomposition \\(\\{\\mathcal{A}_1, \\mathcal{A}_2 \\}\\) préserve \\(\\Sigma\\) ?\n\n\n\nCP →  Ville est préservée car elle est locale à \\(\\mathcal{A}_1\\)\n\n\n\n\nEst-ce que {Ville, Rue, Numero} → CP est préservée par \\(\\mathcal{A}_1, \\mathcal{A}_2\\) ?\n\n\n\nZ ← {Ville, Rue, Numero}\n\n\\((\\texttt{Z} ∩ \\texttt{{Ville, CP}})^+\\) ∩ {Ville, CP} = {Ville} rien à ajouter\n\\((\\texttt{Z} ∩ \\texttt{{Rue, Numero, CP}})^+\\) ∩ {Rue, Numero, CP} = {Rue, Numero}, rien à ajouter\n\n\n\nDonc Ville, Rue, Numero → CP n’est pas préservée"
  },
  {
    "objectID": "slides/DF_norm_3.html#rappels",
    "href": "slides/DF_norm_3.html#rappels",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Rappels",
    "text": "Rappels\n\n\n\n\n\n\nDéfinition\n\n\nTODO\n\n\n\n\n\n\n\n\n\nProposition\n\n\nTODO"
  },
  {
    "objectID": "slides/DF_norm_3.html#limites-de-la-décomposition-fnbc",
    "href": "slides/DF_norm_3.html#limites-de-la-décomposition-fnbc",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Limites de la décomposition FNBC",
    "text": "Limites de la décomposition FNBC\n\n\n\n\n\n\nNote\n\n\nIl existe des couples schéma/Ensemble de DFs (\\(\\mathcal{A}, \\Sigma\\)) pour lesquels toute décomposition FNBC entraine une perte de Dépendance Fonctionnell"
  },
  {
    "objectID": "slides/DF_norm_3.html#section-1",
    "href": "slides/DF_norm_3.html#section-1",
    "title": "Normalisation II : Décomposition FN3",
    "section": "",
    "text": "\\(\\mathcal{A} =\\) {Ville, Rue, Numéro, #Bureau_vote}\nΣ = { Ville, Nom, Rue → #Bureau_vote,  #Bureau_vote  →  Ville }\n\nDeux clés Ville, Nom, Rue et #Bureau_vote, Nom, Rue\n\n\n#Bureau_vote  →  Ville ne satisfait pas le critère FNBC\n\n\nL’algorithme de décomposition en FNBC conduit à la décomposition {#Bureau_vote,Ville} et {#Bureau_vote, Nom, Rue}\nLa DF Ville, Nom, Rue → #Bureau_vote n’est pas préservée\nLa décomposition préserve l’information (SPI) mais pas les dépendances fonctionnelles."
  },
  {
    "objectID": "slides/DF_norm_3.html#limites-de-la-décomposition-fnbc-suite",
    "href": "slides/DF_norm_3.html#limites-de-la-décomposition-fnbc-suite",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Limites de la décomposition FNBC (suite)",
    "text": "Limites de la décomposition FNBC (suite)\n\n\n\n\n\n\n\nÀ noter\n\n\nOn peut vérifier que toute décomposition FNBC de \\(\\mathcal{A}\\) ne préserve pas les dépendances fonctionnelles."
  },
  {
    "objectID": "slides/DF_norm_3.html#définition-forme-normale-3-fn3",
    "href": "slides/DF_norm_3.html#définition-forme-normale-3-fn3",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Définition : forme normale 3 (FN3)",
    "text": "Définition : forme normale 3 (FN3)\n\n\n\n\n\n\nImportant\n\n\nUn schéma relationnel \\(\\mathcal{A}\\) est en forme normale 3 (FN3) relativement à un ensemble de DF Σ ssi pour toute dépendance non triviale X → Yde Σ, on a\n\nle membre gauche X est une super-clé ou\nle membre droit Y fait partie d’une clé\n\n\n\n\n\n\nLe schéma \\(\\mathcal{A} =\\) {Ville, Rue, Numéro, #Bureau_vote} est en FN3 relativement à Σ = { Ville, Nom, Rue → #Bureau_vote,  #Bureau_vote  →  Ville }\nMais ce schéma n’est pas en FNBC."
  },
  {
    "objectID": "slides/DF_norm_3.html#pourquoi-deux-notions-de-forme-normale",
    "href": "slides/DF_norm_3.html#pourquoi-deux-notions-de-forme-normale",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Pourquoi deux notions de forme normale ?",
    "text": "Pourquoi deux notions de forme normale ?\n\n\n\n\n\n\nProposition\n\n\nSi un schéma \\(\\mathcal{A}\\) est en forme normale Boyce-Codd (FNBC) relativement à un ensemble de DF Σ, alors \\(\\mathcal{A}\\) est en forme normale 3 (FN3) relativement à Σ\n\n\n\n\n\nLa réciproque est fausse"
  },
  {
    "objectID": "slides/DF_norm_3.html#exercice",
    "href": "slides/DF_norm_3.html#exercice",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Exercice",
    "text": "Exercice\n\\(\\mathcal{A}=\\) (A, B, C, D, E) et Σ={A → C, BC → D, AD → E}\n\nQuelles sont les clés ?\nLe schéma est-il en FNBC ?\nSi non, propopsez une décomposition SPI en FNBC. Est-elle sans perte de DF?\nLe schéma est-il en FN3 ?"
  },
  {
    "objectID": "slides/DF_norm_3.html#intérêt-de-la-forme-normale-3-fn3",
    "href": "slides/DF_norm_3.html#intérêt-de-la-forme-normale-3-fn3",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Intérêt de la forme normale 3 (FN3)",
    "text": "Intérêt de la forme normale 3 (FN3)\nRedondance limitée\n\nPossibilité de décomposition SPI et sans perte de Dépendances Fonctionnelles"
  },
  {
    "objectID": "slides/DF_norm_3.html#algorithme",
    "href": "slides/DF_norm_3.html#algorithme",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Algorithme",
    "text": "Algorithme\n\n\n\\begin{algorithm} \\caption{Décomposition FNBC} \\begin{algorithmic} \\Procedure{DecompositionFNBC}{$\\mathcal{A}, Σ$} \\State \\Comment{Initialisation de la décomposition} \\State $D ← \\{\\mathcal{A}\\}$ \\State \\While{Exists some $\\mathcal{B} \\in D$ which is not in BCNF w.r.t. $\\Sigma \\models X → X^+ \\cap \\mathcal{B}$, $X \\subsetneq \\mathcal{B}$} \\State $Y \\leftarrow X^+ \\cap \\mathcal{B} \\setminus X$ \\State $D \\leftarrow D \\setminus \\{\\mathcal{B}\\} \\cup \\{ X \\cup Y, \\mathcal{B} \\setminus Y \\}$ \\EndWhile \\State \\Return $D$ \\EndProcedure \\end{algorithmic} \\end{algorithm}"
  },
  {
    "objectID": "slides/DF_norm_3.html#proposition-2",
    "href": "slides/DF_norm_3.html#proposition-2",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Proposition",
    "text": "Proposition\n\n\n\n\n\n\nProposition\n\n\nL’algorithme termine en un nombre fini d’itérations\nLa décomposition produite par l’algorithme est\n\nen FN3\nsans perte d’information\nsans perte de dépendances fonctionnelles"
  },
  {
    "objectID": "slides/DF_norm_3.html#preuve-terminaison",
    "href": "slides/DF_norm_3.html#preuve-terminaison",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Preuve (terminaison)",
    "text": "Preuve (terminaison)"
  },
  {
    "objectID": "slides/DF_norm_3.html#preuve-fn3",
    "href": "slides/DF_norm_3.html#preuve-fn3",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Preuve (FN3)",
    "text": "Preuve (FN3)"
  },
  {
    "objectID": "slides/DF_norm_3.html#preuve-sans-pi",
    "href": "slides/DF_norm_3.html#preuve-sans-pi",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Preuve (sans PI)",
    "text": "Preuve (sans PI)"
  },
  {
    "objectID": "slides/DF_norm_3.html#preuve-sans-perte-de-df",
    "href": "slides/DF_norm_3.html#preuve-sans-perte-de-df",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Preuve (sans perte de DF)",
    "text": "Preuve (sans perte de DF)"
  },
  {
    "objectID": "slides/SQL_1.html#sql-structured-query-language",
    "href": "slides/SQL_1.html#sql-structured-query-language",
    "title": "BD II: SQL I",
    "section": "SQL : Structured Query Language",
    "text": "SQL : Structured Query Language\nSQL est langage permettant :\n\ninterrogation des données (requêtes)\ndéfinition des données et des contraintes structurelles sur celles-ci\nmanipulation des données (insertion, suppression, mise à jour)\ndéfinition des vues et des index\nadministration des bases de données"
  },
  {
    "objectID": "slides/SQL_1.html#plusieurs-fois-normalisés-par-liso",
    "href": "slides/SQL_1.html#plusieurs-fois-normalisés-par-liso",
    "title": "BD II: SQL I",
    "section": "Plusieurs fois normalisés par l’ISO …",
    "text": "Plusieurs fois normalisés par l’ISO …\n\nSQL-86,\nSQL-89,\nSQL-92,\nSQL-99.\n…\nSQL-2003\nSQL-2008\nSQL-2011\nSQL-2016\n…\n\nNous utiliserons le dialecte PostgreSQL\nA standard is reviewed every 5 years (roughly)\nISO/IEC 9075 from www.iso.org"
  },
  {
    "objectID": "slides/SQL_1.html#sql",
    "href": "slides/SQL_1.html#sql",
    "title": "BD II: SQL I",
    "section": "SQL",
    "text": "SQL\n\n\nUne instruction SQL permet de combiner :\n\nrestriction/filtrage (sélection) \\(\\sigma\\)\nprojection \\(\\pi\\)\nrenommage \\(\\rho\\)\n…\n\n. . .\nL’instruction\nSELECT &lt;liste attribut&gt;\n\nFROM &lt;table&gt;\n\nWHERE &lt;condition&gt; ;\ntraduit l’expression\n\\(\\Pi_{\\text{&lt;liste attribut&gt;}}(\\sigma_{\\text{&lt;condition&gt;}}(\\text{&lt;table&gt;}))\\)\nOu σ(R, Condition) |&gt; Π(&lt;liste attribut&gt;)"
  },
  {
    "objectID": "slides/SQL_1.html#syntaxe---requêtes-simples",
    "href": "slides/SQL_1.html#syntaxe---requêtes-simples",
    "title": "BD II: SQL I",
    "section": "Syntaxe - requêtes simples",
    "text": "Syntaxe - requêtes simples\n\n\nSELECT [DISTINCT] * | &lt;liste attribut&gt;\n\nFROM &lt;liste de tables&gt;\n\n[WHERE &lt;condition&gt;] ;\n\n\n* : sélection de tous les attributs (le schéma reste inchangé)\n[...] : clause, expression facultative.\nDISTINCT : supprime les doublons.\n\n\n--| connection:  con\n--| eval: false\nSET search_path TO world ;"
  },
  {
    "objectID": "slides/SQL_1.html#requêtes-simples-sur-exemple-jouet",
    "href": "slides/SQL_1.html#requêtes-simples-sur-exemple-jouet",
    "title": "BD II: SQL I",
    "section": "Requêtes simples sur exemple jouet",
    "text": "Requêtes simples sur exemple jouet\n\n\nEmploye(Nu, NomE, Annee, Tel, Nudept)\n\nFournisseur (NomF, Ville, Adresse)\n\nPiece(NomP, Prix, Couleur)\n\n--| connection:  con\n--| eval: false\n--| echo: true\n\nSELECT co.name_country, co.region\nFROM country co\nWHERE co.continent='Europe' \nLIMIT 5 ;\nEquivalent à :\n\\[\\Pi_{\\text{NomF, region}}(\\text{country})\\]"
  },
  {
    "objectID": "slides/SQL_1.html#structure-de-base",
    "href": "slides/SQL_1.html#structure-de-base",
    "title": "BD II: SQL I",
    "section": "Structure de base",
    "text": "Structure de base\nLa structure de base d’une requête s’appuie sur les trois mots clés suivants :\n\nSELECT correspond à l’opérateur de projection sur la liste d’attributs demandée, il peut aussi être suivi de fonctions d’attributs\nFROM indique la ou les relations concernées\nWHERE précise une condition et correspond à l’opération de restriction/sélection en algèbre relationnelle."
  },
  {
    "objectID": "slides/SQL_1.html#syntaxe-de-la-condition-de-filtrage-where-...",
    "href": "slides/SQL_1.html#syntaxe-de-la-condition-de-filtrage-where-...",
    "title": "BD II: SQL I",
    "section": "Syntaxe de la condition de filtrage (WHERE ...)",
    "text": "Syntaxe de la condition de filtrage (WHERE ...)\nUne condition se construit à l’aide des opérations suivantes :\n\nComparaison avec opérateurs : =, &lt;&gt;, &gt;,&lt;, &gt;=, &lt;=\n\nSELECT *\n\nFROM Employe\n\nWHERE NomE &lt;&gt;'Durand'  ;"
  },
  {
    "objectID": "slides/SQL_1.html#syntaxe-de-la-condition-de-filtrage-where-...-1",
    "href": "slides/SQL_1.html#syntaxe-de-la-condition-de-filtrage-where-...-1",
    "title": "BD II: SQL I",
    "section": "Syntaxe de la condition de filtrage (WHERE ...)",
    "text": "Syntaxe de la condition de filtrage (WHERE ...)\nCombinaison de conditions à l’aide des opérateurs logiques: AND, OR, NOT\nSELECT DISTINCT NomF\n\nFROM Fournisseur\n\nWHERE (Ville='Londres') OR (Ville='Paris');  \n Attention aux priorités dans l’évaluation des expressions logiques\n Attention aux valeurs manquantes"
  },
  {
    "objectID": "slides/SQL_1.html#syntaxe-de-la-condition-where-...-suite",
    "href": "slides/SQL_1.html#syntaxe-de-la-condition-where-...-suite",
    "title": "BD II: SQL I",
    "section": "Syntaxe de la condition WHERE ... (suite)",
    "text": "Syntaxe de la condition WHERE ... (suite)\nTest BETWEEN permettant de vérifier si la valeur d’un attribut est comprise entre deux constantes\nSELECT NomE\n\nFROM Employe\n\nWHERE Annee BETWEEN '22/06/03' AND '25/09/03';   \n Éviter de manipuler les dates et heures comme des chaînes de caractères"
  },
  {
    "objectID": "slides/SQL_1.html#syntaxe-de-la-condition-where-...-suite-1",
    "href": "slides/SQL_1.html#syntaxe-de-la-condition-where-...-suite-1",
    "title": "BD II: SQL I",
    "section": "Syntaxe de la condition WHERE ... (suite)",
    "text": "Syntaxe de la condition WHERE ... (suite)\n\nTest à NULL signifiant que la valeur est égale à NULL (c-à-d est inconnue)\n\nSELECT *\n\nFROM Employe\n\nWHERE Tel IS NULL;    \n Attention aux valeurs manquantes"
  },
  {
    "objectID": "slides/SQL_1.html#syntaxe-de-la-condition-where-...-suite-2",
    "href": "slides/SQL_1.html#syntaxe-de-la-condition-where-...-suite-2",
    "title": "BD II: SQL I",
    "section": "Syntaxe de la condition WHERE ... (suite)",
    "text": "Syntaxe de la condition WHERE ... (suite)\nTest d’appartenance IN qui permet de vérifier si la valeur d’un attribut appartient à une liste de constantes,\nSELECT *\n\nFROM Fournisseur\n\nWHERE Ville IN ('Paris', 'Londres');"
  },
  {
    "objectID": "slides/SQL_1.html#syntaxe-de-la-condition-where-...-suite-3",
    "href": "slides/SQL_1.html#syntaxe-de-la-condition-where-...-suite-3",
    "title": "BD II: SQL I",
    "section": "Syntaxe de la condition WHERE ... (suite)",
    "text": "Syntaxe de la condition WHERE ... (suite)\nTest LIKE permettant de vérifier si un attribut de type chaîne de caractères contient une ou plusieurs sous-chaînes\n\\(\\_\\) : remplace n’importe quel caractère\n\\(\\%\\) : remplace n’importe quelle chaîne de caractères.\nSELECT Ville\n\nFROM Fournisseur\n\nWHERE Ville LIKE 'Saint%';"
  },
  {
    "objectID": "slides/SQL_1.html#requêtes-multi-relations-1",
    "href": "slides/SQL_1.html#requêtes-multi-relations-1",
    "title": "BD II: SQL I",
    "section": "Requêtes multi-relations",
    "text": "Requêtes multi-relations\nQuand l’information est dispersée sur plusieurs tables, on utilise des jointures"
  },
  {
    "objectID": "slides/SQL_1.html#on-peut",
    "href": "slides/SQL_1.html#on-peut",
    "title": "BD II: SQL I",
    "section": "On peut :",
    "text": "On peut :\n\nutiliser plusieurs tables dans la clause FROM\nfaire intervenir des conditions complexes impliquant ces tables dans la clause WHERE"
  },
  {
    "objectID": "slides/SQL_1.html#détails-du-schema-world",
    "href": "slides/SQL_1.html#détails-du-schema-world",
    "title": "BD II: SQL I",
    "section": "Détails du schema World",
    "text": "Détails du schema World\nImages et tables créées grâce à DbSchema"
  },
  {
    "objectID": "slides/SQL_1.html#diagramme-en-pattes-de-corbeau",
    "href": "slides/SQL_1.html#diagramme-en-pattes-de-corbeau",
    "title": "BD II: SQL I",
    "section": "Diagramme en pattes de corbeau",
    "text": "Diagramme en pattes de corbeau\n\nimg"
  },
  {
    "objectID": "slides/SQL_1.html#table-world.city",
    "href": "slides/SQL_1.html#table-world.city",
    "title": "BD II: SQL I",
    "section": "Table world.city",
    "text": "Table world.city\n\n\n\n* 🔑 ⬋\nid\ninteger\n\n\n*\nname\ntext\n\n\n*\ncountrycode\nchar(3)\n\n\n*\ndistrict\ntext\n\n\n*\npopulation\ninteger"
  },
  {
    "objectID": "slides/SQL_1.html#table-world.country",
    "href": "slides/SQL_1.html#table-world.country",
    "title": "BD II: SQL I",
    "section": "Table world.country",
    "text": "Table world.country\n\n\n\n* 🔑 ⬋\ncode\nchar(3)\n\n\n*\nname\ntext\n\n\n*\ncontinent\ntext\n\n\n*\nregion\ntext\n\n\n*\nsurfacearea\nreal\n\n\n\nindepyear\nsmallint\n\n\n*\npopulation\ninteger\n\n\n\nlifeexpectancy\nreal\n\n\n\ngnp\nnumeric(10,2)\n\n\n\ngnpold\nnumeric(10,2)\n\n\n*\nlocalname\ntext\n\n\n*\ngovernmentform\ntext\n\n\n\nheadofstate\ntext\n\n\n⬈\ncapital\ninteger\n\n\n*\ncode2\nchar(2)\n\n\n\nForeign Keys\n\n\n\n\ncountry_capital_fkey\n( capital ) ref world.city (id)\n\n\n\nConstraints\n\n\n\n\n\n\n\ncountry_continent_check\n((continent = ‘Asia’::text) OR (continent = ‘Europe’::text) OR (continent = ‘North America’::text) OR (continent = ‘Africa’::text) OR (continent = ‘Oceania’::text) OR (continent = ‘Antarctica’::text) OR (continent = ‘South America’::text))"
  },
  {
    "objectID": "slides/SQL_1.html#table-world.countrylanguage",
    "href": "slides/SQL_1.html#table-world.countrylanguage",
    "title": "BD II: SQL I",
    "section": "Table world.countrylanguage",
    "text": "Table world.countrylanguage\n\n\n\n* 🔑 ⬈\ncountrycode\nchar(3)\n\n\n* 🔑\nlanguage\ntext\n\n\n*\nisofficial\nboolean\n\n\n*\npercentage\nreal\n\n\n\nForeign Keys\n\n\n\n\ncountrylanguage_countrycode_fkey\n( countrycode ) ref world.country (code)"
  },
  {
    "objectID": "slides/SQL_1.html#première-jointure-sur-schéma-world",
    "href": "slides/SQL_1.html#première-jointure-sur-schéma-world",
    "title": "BD II: SQL I",
    "section": "Première jointure sur schéma world",
    "text": "Première jointure sur schéma world\nQuels sont les pays qui portent le même nom que leur capitale ?\n\nSELECT name_country\n\nFROM country, city    \n\nWHERE capital=id AND name_country=name_city;\n\n\nqui correspond à\n\\[\\pi_{\\text{name\\_country}}(\\sigma_{\\text{capital}=\\text{id} \\wedge \\text{name\\_country}=\\text{name\\_city}}(\\text{country}\\times \\text{city}))\\]\nautrement dit à\n\\[\\pi_{\\text{name\\_country}}(\\text{country} \\bowtie_{\\text{capital}=\\text{id} \\wedge  \\text{name\\_country}=\\text{name\\_city}} \\text{city}))\\]"
  },
  {
    "objectID": "slides/SQL_1.html#syntaxe-normalisée-pour-les-jointures-join-et-on",
    "href": "slides/SQL_1.html#syntaxe-normalisée-pour-les-jointures-join-et-on",
    "title": "BD II: SQL I",
    "section": "Syntaxe normalisée pour les jointures : JOIN et ON",
    "text": "Syntaxe normalisée pour les jointures : JOIN et ON\nQuels sont les pays qui portent le même nom que leur capitale ?\nSELECT name_country\n\nFROM country JOIN city   \n\nON capital=id    \n\nWHERE name_country=name_city;\nqui correspond à\n\\[\\pi_{\\text{name\\_country}}(\\sigma_{\\text{capital}=id \\wedge  \\text{name\\_country}=\\text{name\\_city}}(\\text{country} \\times \\text{city}))\\]"
  },
  {
    "objectID": "slides/SQL_1.html#renommage",
    "href": "slides/SQL_1.html#renommage",
    "title": "BD II: SQL I",
    "section": "Renommage",
    "text": "Renommage\nSi on veut faire une jointure d’une table avec elle-même, on utilise AS pour obtenir deux tables de noms différents\n\nQuels sont les noms de ville qui apparaissent dans deux pays différents~?\n\nSELECT DISTINCT c1.name_city, c1.countrycode, c2.countrycode\n\nFROM city AS c1 JOIN city AS c2   \n\n  ON c1.countrycode!=c2.countrycode AND c1.name_city=c2.name_city  \n\nORDER BY c1.name_city;"
  },
  {
    "objectID": "slides/SQL_1.html#jointure-naturelle",
    "href": "slides/SQL_1.html#jointure-naturelle",
    "title": "BD II: SQL I",
    "section": "Jointure naturelle",
    "text": "Jointure naturelle\nQuels sont les noms des pays où le français est parlé ?\nSELECT name_country\n\nFROM country, countrylanguage\n\nWHERE country.countrycode=countrylanguage.countrycode\n      AND language='French';\nSyntaxe normalisée pour la jointure naturelle~: NATURAL JOIN\nSELECT name_country\n\nFROM country NATURAL JOIN countrylanguage    \n\nWHERE language='French';"
  },
  {
    "objectID": "slides/SQL_1.html#jointure-naturelle-suite",
    "href": "slides/SQL_1.html#jointure-naturelle-suite",
    "title": "BD II: SQL I",
    "section": "Jointure naturelle (suite)",
    "text": "Jointure naturelle (suite)\nQuels sont les pays dont une ville a le même nom qu’une langue parlée dans ce pays~?\nSELECT DISTINCT name_country, name_city, language\n\nFROM country NATURAL JOIN  \n     city natural JOIN     \n     countrylanguage       \n\nWHERE language=name_city;"
  },
  {
    "objectID": "slides/SQL_1.html#jointure-externe",
    "href": "slides/SQL_1.html#jointure-externe",
    "title": "BD II: SQL I",
    "section": "Jointure externe",
    "text": "Jointure externe\n\nLEFT OUTER JOIN (resp. RIGHT OUTER JOIN) : on garde les tuples de la table de gauche (resp. droite) qui n’ont pas de complément dans l’autre table, la condition étant spécifiée dans la clause ON\nFULL OUTER JOIN : on garde les tuples de chacune des tables qui n’ont pas de complément.\nOn complète les valeurs non renseignées par NULL"
  },
  {
    "objectID": "slides/SQL_1.html#exemple-de-jointure-externe",
    "href": "slides/SQL_1.html#exemple-de-jointure-externe",
    "title": "BD II: SQL I",
    "section": "Exemple de jointure externe",
    "text": "Exemple de jointure externe\n\nCertains pays n’ont pas de capitale : la requête\n\nSELECT name_country\n\nFROM country\n\nWHERE capital IS NULL;\nrenvoie 8 lignes.\n\nQuels sont les pays qui n’ont pas de capitale ou portent le même nom que leur capitale~?\n\nSELECT name_country, name_city\n\nFROM country LEFT OUTER JOIN city   \n     ON capital=id                  \n\nWHERE name_city IS NULL OR name_country=name_city ;"
  },
  {
    "objectID": "slides/SQL_7.html#table-babynames",
    "href": "slides/SQL_7.html#table-babynames",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Table babynames",
    "text": "Table babynames\n\nstopifnot(\n  require(dplyr),\n  require(tibble),\n  require(babynames),\n  require(gt)\n)\n\n\nbabynames |&gt; \n  glimpse()\n\nRows: 1,924,665\nColumns: 5\n$ year &lt;dbl&gt; 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880,…\n$ sex  &lt;chr&gt; \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", …\n$ name &lt;chr&gt; \"Mary\", \"Anna\", \"Emma\", \"Elizabeth\", \"Minnie\", \"Margaret\", \"Ida\",…\n$ n    &lt;int&gt; 7065, 2604, 2003, 1939, 1746, 1578, 1472, 1414, 1320, 1288, 1258,…\n$ prop &lt;dbl&gt; 0.07238359, 0.02667896, 0.02052149, 0.01986579, 0.01788843, 0.016…"
  },
  {
    "objectID": "slides/SQL_7.html#petit-rappel-sur-lalgèbre-relationnelle",
    "href": "slides/SQL_7.html#petit-rappel-sur-lalgèbre-relationnelle",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Petit rappel sur l’algèbre relationnelle",
    "text": "Petit rappel sur l’algèbre relationnelle\n\n\n\n\n\n\nPrincipe\n\n\nUne opération de l’algèbre relationnelle accepte des opérandes (des relations) et parfois une expression.\nUne opération de l’algèbre relationnelle retourne une relation/table.\n\n\n\n\n\n\n\n\n\n\nEn passant\n\n\nUne relation c’est un schéma (définition des colonnes/attributs) et une instance (une collection de lignes qui obéissent au schéma).\nUne opération de l’algèbre relationnelle définit le schéma de la table résultat à partir des schémas des tables opérandes\nUne opération de l’algèbre relationnelle définit l’instance du schéma résultat à partir des instances des tables opérandes (et peut-être de l’expression)."
  },
  {
    "objectID": "slides/SQL_7.html#opérateurs-de-base",
    "href": "slides/SQL_7.html#opérateurs-de-base",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Opérateurs de base",
    "text": "Opérateurs de base\n\n\n\n\n\n\nListe des opérateurs\n\n\nL’algèbre relationnelle est d’abord un *Langage de Manipulation de Données& (LMD)}.\n\nUnion: \\(\\Large{\\cup}\\)\nIntersection: \\(\\Large{\\cap}\\)\nDifférence: \\(\\Large{\\backslash}\\)\nProjection: \\(\\Large{\\Pi}\\) (avec une expression formée par la liste des attributs de projection)\nSélection: \\(\\Large{\\sigma}\\) (avec une expression qui définit la condition de filtrage)\nProduit cartésien: \\(\\Large{\\times}\\)\nRenommage: \\(\\Large{\\rho}\\) (avec une expression formée par la liste des renommages)\n\ns’appliquent à des relations (les opérandes) pour produire d’autres relations (le résultat)."
  },
  {
    "objectID": "slides/SQL_7.html#union-cup-et-intersection-cap",
    "href": "slides/SQL_7.html#union-cup-et-intersection-cap",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Union \\(\\cup\\) et intersection \\(\\cap\\)",
    "text": "Union \\(\\cup\\) et intersection \\(\\cap\\)\n\n\n\n\n\n\nDéfinition\n\n\n\nL’union et l’intersection sont des opérations portant sur deux relations \\(R_1\\) et \\(R_2\\) de même schéma\n\\(T=R_1\\cup R_2\\) est constituée des tuples appartenant à \\(R_1\\) ou à \\(R_2\\).\n\\(T=R_1\\cap R_2\\) est constituée des tuples appartenant à \\(R_1\\) et à \\(R_2\\).\nLe schémas de \\(R_1\\cup R_2\\), \\(R_1\\cap R_2\\) sont les mêmess que ceux de \\(R_1\\) et \\(R_2\\)"
  },
  {
    "objectID": "slides/SQL_7.html#union-et-intersection",
    "href": "slides/SQL_7.html#union-et-intersection",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Union et intersection",
    "text": "Union et intersection"
  },
  {
    "objectID": "slides/SQL_7.html#exemple",
    "href": "slides/SQL_7.html#exemple",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Exemple",
    "text": "Exemple\n\n\nTrain 1\n\n\n\nh-dep\ndest\nnum\n\n\n\n\n13h15\nLyon\n213\n\n\n13h29\nMarseille\n1024\n\n\n14h15\nLyon\n214\n\n\n\nTrain 2\n\n\n\nh-dep\ndest\nnum\n\n\n\n\n13h39\nAvignon\n43\n\n\n14h15\nLyon\n214\n\n\n\n\nTrain 1 \\(\\cup\\) Train 2\n\n\n\nh-dep\ndest\nnum\n\n\n\n\n13h15\nLyon\n213\n\n\n13h29\nMarseille\n1024\n\n\n14h15\nLyon\n214\n\n\n13h39\nAvignon\n43\n\n\n\nTrain 1 \\(\\cap\\) Train 2\n\n\n\nh-dep\ndest\nnum\n\n\n\n\n14h15\nLyon\n214"
  },
  {
    "objectID": "slides/SQL_7.html#différence",
    "href": "slides/SQL_7.html#différence",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Différence",
    "text": "Différence\n\n\n\n\n\n\nDéfinition\n\n\n\nLa différence de deux relations \\(R_1\\) et \\(R_2\\) (de même schéma) est une relation \\(T\\)\nde même schéma que \\(R_1\\) et \\(R_2\\)\nconstituée des tuples appartenant à \\(R_1\\) et n’appartenant pas à \\(R_2\\).\nOn note \\(T = R_1 - R_2\\).\n\n\n\n\n\n\n\n\n\n\n\nOpération non commutative !\n\n\nR_1 - R_2R_2 - R_1$ (en général)."
  },
  {
    "objectID": "slides/SQL_7.html#différence-exemple",
    "href": "slides/SQL_7.html#différence-exemple",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Différence : exemple",
    "text": "Différence : exemple"
  },
  {
    "objectID": "slides/SQL_7.html#produit-cartésien",
    "href": "slides/SQL_7.html#produit-cartésien",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Produit Cartésien",
    "text": "Produit Cartésien\n\n\n\n\n\n\nDéfinition\n\n\n\nSoient:\n\n\\(R_1\\) de schéma \\(R_1(A_1,A_2,...,A_k)\\)\n\\(R_2\\) de schéma \\(R_2(B_1,B_2,...,B_\\ell)\\)\navec \\(A_i\\neq B_j\\), pour tout \\(i=1,...,k\\), \\(j=1,..,\\ell\\)\n\nDans le contexte “classique” : \\(R_1 \\times R_2= \\{(e_1,e_2): e_1\\in R_1, e_2\\in R_2\\}\\)\n\\(R=R_1 \\times R_2\\) de schéma \\(R(A_1,A_2,...,A_k,B_1,B_2,...,B_\\ell)\\). Le schéma de \\(R\\) est l’union des schémas de \\(R_1\\) et \\(R_2\\)\n\n\n\n\n\n\n\n\n\n\nAttention\n\n\nEn algèbre relationnelle, cette opération est commutative ( \\(R_1\\times R_2 = R_2\\times R_1\\) ) et associative (parce que l’on nomme des attributs/colonnes, on ne les désigne pas par une position)"
  },
  {
    "objectID": "slides/SQL_7.html#produit-cartésien-1",
    "href": "slides/SQL_7.html#produit-cartésien-1",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Produit cartésien :",
    "text": "Produit cartésien :\n\n\n\n\n\n\nDéfinition formelle\n\n\n\\(R=R_1\\times R_2\\) est la relation de schéma \\(R(A_1,A_2,...,A_k,B_1,B_2,...,B_\\ell)\\) vérifiant~:\n\nPour tout \\(t\\in R\\), il existe \\(t_1\\in R_1\\), \\(t_2\\in R_2\\) (\\(\\forall t \\in R, \\exists t_1 \\in R_1, \\exists t_2 \\in R_2, \\ldots\\)) tels que :\n\n\\[t.A_1=t_1.A_1, \\ldots, t.A_k=t_1.A_k,\\quad t.B_1=t_2.B_1, \\ldots, t.B_\\ell=t_2.B_\\ell\\]\n\nRéciproquement, pour tout \\(t_1\\in R_1\\), \\(t_2\\in R_2\\) , il existe \\(t\\in R\\) tels que :\n\n\\[t.A_1=t_1.A_1, \\ldots, t.A_k=t_1.A_k,\\quad \\text{et} \\quad t.B_1=t_2.B_1, \\ldots, t.B_\\ell=t_2.B_\\ell\\]\n\\[\\forall t_1 \\in R_1, \\forall t_2 \\in R_2, \\exists t \\in R, \\qquad  t.A_1=t_1.A_1, \\ldots, t.A_k=t_1.A_k,\\quad \\text{et} \\quad t.B_1=t_2.B_1, \\ldots, t.B_\\ell=t_2.B_\\ell\\]"
  },
  {
    "objectID": "slides/SQL_7.html#produit-cartésien-avec-dplyr-dplyrcross_join",
    "href": "slides/SQL_7.html#produit-cartésien-avec-dplyr-dplyrcross_join",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Produit cartésien avec dplyr: dplyr::cross_join()",
    "text": "Produit cartésien avec dplyr: dplyr::cross_join()\n\\(R \\times S\\) se traduit en\ncross_join(R, S)"
  },
  {
    "objectID": "slides/SQL_7.html#projection-largepi",
    "href": "slides/SQL_7.html#projection-largepi",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Projection ( \\(\\Large{\\pi}\\) )",
    "text": "Projection ( \\(\\Large{\\pi}\\) )\n\n\n\n\n\n\nDéfinition\n\n\n\nLa projection d’une relation \\(R\\) de schéma \\(R(A_1,\\dots, A_k)\\) sur les attributs \\(A_{i_1}, \\dots, A_{i_p}\\), \\(i_1,..., i_p\\in \\{1,...,k\\}\\), est la relation \\(S\\)\n\nde schéma \\(S(A_{i_1}, \\dots,A_{i_p})\\)\ndont les tuples sont obtenus par élimination des attributs non mentionnés dans \\(A_{i_1}, \\dots, A_{i_p}\\) (et par élimination des doublons).\nOn note \\(S = \\pi_{A_{i_1}, \\dots, A_{i_p}} (R)\\).\n\nDéfinition formelle :\n\n\\[s\\in S\\quad  \\iff \\quad \\exists t\\in R, \\forall n\\in\\left\\{1,\\dots,p\\right\\}\\qquad s.A_{i_n}=t.A_{i_n}\\]\n\n\n\nImplicitement, on a élimination des doublons car une projection peut produire plusieurs fois le même tuple."
  },
  {
    "objectID": "slides/SQL_7.html#projection-avec-dplyrselect",
    "href": "slides/SQL_7.html#projection-avec-dplyrselect",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Projection avec dplyr::select()",
    "text": "Projection avec dplyr::select()\n\\(S = \\pi_{A_{i_1}, \\dots, A_{i_p}} (R)\\) se traduit en\nS &lt;- dplyr::select(R, Ai1, Ai2, ..., Aip)"
  },
  {
    "objectID": "slides/SQL_7.html#projection-exemples",
    "href": "slides/SQL_7.html#projection-exemples",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Projection : Exemples",
    "text": "Projection : Exemples"
  },
  {
    "objectID": "slides/SQL_7.html#projection-vitaminée-tidy-selection",
    "href": "slides/SQL_7.html#projection-vitaminée-tidy-selection",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Projection vitaminée (tidy selection)",
    "text": "Projection vitaminée (tidy selection)\nSélection bien tempérée"
  },
  {
    "objectID": "slides/SQL_7.html#sélection-σ",
    "href": "slides/SQL_7.html#sélection-σ",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Sélection (σ)",
    "text": "Sélection (σ)\n\n\n\n\n\n\nDéfinition\n\n\n\nLa sélection d’une relation \\(R\\) par une condition \\(C\\) est une relation \\(S\\)\n\nde même schéma que \\(R\\)\ndont les tuples sont ceux de \\(R\\) qui satisfont la condition \\(C\\).\n\nOn note \\(S = σ(R, C)\\).\nLa condition \\(C\\)\n\ns’exprime à l’aide des noms d’attributs de la relation ou de constantes (pour les opérandes)\non peut utiliser des opérateurs arithmétiques de comparaison ( \\(=, \\neq, \\leq, \\geq, &lt;, &gt;\\) ) ainsi que des connecteurs logiques (¬, ∧, ∨)..\ns’évalue pour chaque ligne de \\(R\\)"
  },
  {
    "objectID": "slides/SQL_7.html#sélection-avec-dplyrfilter",
    "href": "slides/SQL_7.html#sélection-avec-dplyrfilter",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Sélection avec dplyr::filter",
    "text": "Sélection avec dplyr::filter\n\\(S = σ(R, C)\\) se traduit en\nS &lt;- filter(R, C)"
  },
  {
    "objectID": "slides/SQL_7.html#sélection-exemple",
    "href": "slides/SQL_7.html#sélection-exemple",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Sélection : Exemple",
    "text": "Sélection : Exemple"
  },
  {
    "objectID": "slides/SQL_7.html#renommage",
    "href": "slides/SQL_7.html#renommage",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Renommage",
    "text": "Renommage\n\n\n\n\n\n\nDéfinition\n\n\n\nSoit \\(R\\) de schéma \\(R(A_1,\\dots, A_k)\\), le renommage d’un attribut \\(A_i\\), \\(i\\leq k\\), en \\(B\\) est une relation \\(S\\) :\n\nde même contenu (mêmes lignes)\nde schéma \\(S(A_1,...,A_{i-1},B,A_{i+1},..., A_k)\\)\nOn le note \\(S=ρ(R, A_i\\mapsto B)\\)"
  },
  {
    "objectID": "slides/SQL_7.html#renommage-avec-dplyrrename",
    "href": "slides/SQL_7.html#renommage-avec-dplyrrename",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Renommage avec dplyr::rename()",
    "text": "Renommage avec dplyr::rename()\n\\(S=ρ(R, A_i\\mapsto B)\\) se traduit en\nS &lt;- rename(R, B=Ai)"
  },
  {
    "objectID": "slides/SQL_7.html#exemple-1",
    "href": "slides/SQL_7.html#exemple-1",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Exemple",
    "text": "Exemple\nr$&gt; rename(flights, destination=dest) |&gt; \n    select(flight,tailnum, origin, destination, carrier, time_hour) |&gt;\n    head()\n# A tibble: 6 × 6\n  flight tailnum origin destination carrier time_hour          \n   &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;       &lt;chr&gt;   &lt;dttm&gt;             \n1   1545 N14228  EWR    IAH         UA      2013-01-01 05:00:00\n2   1714 N24211  LGA    IAH         UA      2013-01-01 05:00:00\n3   1141 N619AA  JFK    MIA         AA      2013-01-01 05:00:00\n4    725 N804JB  JFK    BQN         B6      2013-01-01 05:00:00\n5    461 N668DN  LGA    ATL         DL      2013-01-01 06:00:00\n6   1696 N39463  EWR    ORD         UA      2013-01-01 05:00:00\nUtilité Va permettre d’étendre certains opérateurs pour des relations de schémas non-disjoints"
  },
  {
    "objectID": "slides/SQL_7.html#les-opérateurs-comme-fonctions",
    "href": "slides/SQL_7.html#les-opérateurs-comme-fonctions",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Les opérateurs comme fonctions",
    "text": "Les opérateurs comme fonctions\n\\(\\pi_{Ai1, Aip}\\left(\\sigma_C(R)\\right)\\)\nse traduit en\nselect(filter(R, C), Ai1, ..., Aip)\nqui s’avère difficile à lire, surtout si on compose plus d’opérations élémentaires\nLa composition de fonctions se conçoit facilement mais l’expression correspondante est difficile à lire"
  },
  {
    "objectID": "slides/SQL_7.html#réécriture-de-la-composition-avec",
    "href": "slides/SQL_7.html#réécriture-de-la-composition-avec",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Réécriture de la composition avec |>",
    "text": "Réécriture de la composition avec |&gt;\nS &lt;- select(filter(R, C), Ai1, ..., Aip)\npeut être réécrite en\nS &lt;- R |&gt; \n  filter(C) |&gt;\n  select(Ai1,.., Aip)"
  },
  {
    "objectID": "slides/SQL_7.html#exemple-2",
    "href": "slides/SQL_7.html#exemple-2",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Exemple",
    "text": "Exemple\nLes origines et destinations des vols avec un retard au départ d’au moins 30 minutes e\n\n\nflights |&gt;\n  filter(dep_delay&gt;30) |&gt;\n  select(origin, dest) |&gt;\n  distinct()\n\nou directement\nflights |&gt;\n  filter(dep_delay&gt;30) |&gt;\n  distinct(origin, dest)"
  },
  {
    "objectID": "slides/SQL_7.html#les-jointures",
    "href": "slides/SQL_7.html#les-jointures",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Les jointures",
    "text": "Les jointures\nOn va définir des opérations pratiques pour la manipulation de données~: les jointures\n\nJointure\nJointure naturelle\n\\(\\theta\\)-jointure et équi-jointure"
  },
  {
    "objectID": "slides/SQL_7.html#jointure",
    "href": "slides/SQL_7.html#jointure",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Jointure",
    "text": "Jointure\n\n\n\n\n\n\nDéfinition\n\n\nLa jointure \\(T=R_1\\bowtie_C R_2\\) de deux relations \\(R_1\\) et \\(R_2\\) de schémas disjoints sous la condition \\(C\\) est la relation \\(T\\):\n\nde schéma la concaténation des schémas de \\(R_1\\) et \\(R_2\\)\nformée des tuples du produit cartésien \\(R_1  \\times R_2\\) qui satisfont la condition \\(C\\)\n\nRègles de formation de la condition de jointure : comme pour la sélection\n\n\n\n\n\n\n\n\n\nDéfinition formelle\n\n\n\\[R_1 \\bowtie_C R_2 = \\sigma_C(R_1\\times R_2)\\]"
  },
  {
    "objectID": "slides/SQL_7.html#exemple-3",
    "href": "slides/SQL_7.html#exemple-3",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Exemple",
    "text": "Exemple\nTrDep\n\n\n\nhdep\ndest\nnumdep\n\n\n\n\n13h15\nLyon\n213\n\n\n13h29\nMarseille\n1024\n\n\n\nTrArr\n\n\n\nharr\nprov\nnumarr\n\n\n\n\n13h39\nAvignon\n43\n\n\n15h15\nParis\n213\n\n\n\n\\(\\texttt{TrDep} \\bowtie_{\\text{numdep} &gt; \\text{numar}} \\texttt{TrArr}\\)\n\n\n\n\n\n\n\n\n\n\n\nhdep\ndest\nnumdep\nharr\nprov\nnumarr\n\n\n\n\n13h15\nLyon\n213\n13h39\nAvignon\n43\n\n\n13h29\nMarseille\n1024\n13h39\nAvignon\n43\n\n\n13h29\nMarseille\n1024\n15h15\nParis\n213"
  },
  {
    "objectID": "slides/SQL_7.html#équi-jointure-theta-jointure",
    "href": "slides/SQL_7.html#équi-jointure-theta-jointure",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Équi-jointure, \\(\\theta\\)-jointure",
    "text": "Équi-jointure, \\(\\theta\\)-jointure\n\n\n\n\n\n\nÉqui-jointure\n\n\nJointure avec égalité entre attributs de types comparables\n\n\n\n\\[\\texttt{TrDep} \\bowtie_{\\text{numdep} = \\text{numarr}} \\texttt{TrArr}\\]\n\n\n\n\n\n\n\n\n\n\n\nhdep\ndest\nnumdep\nharr\nprov\nnumarr\n\n\n\n\n13h15\nLyon\n213\n15h15\nParis\n213\n\n\n\n\n\n\n\n\n\n\n\\(\\theta\\)-jointure\n\n\nCondition de jointure entre attributs de types comparables et avec un opérateur différent de l’égalité, c’est-à-dire dans \\(\\left\\{&lt;,&gt;,\\leq,\\geq, \\neq\\right\\}\\).\n\\[\\text{TrDep} \\bowtie_{\\text{numdep} &gt; \\text{numarr}} \\text{TrArr}\\]"
  },
  {
    "objectID": "slides/SQL_7.html#jointure-naturelle",
    "href": "slides/SQL_7.html#jointure-naturelle",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Jointure naturelle",
    "text": "Jointure naturelle\n\n\n\n\n\n\nDéfinition\n\n\nC’est une équi-jointure concernant les attributs communs (même nom et même type) de deux relations\nOn ne garde dans le résultat qu’une copie des attributs communs \n\n\n\nOn considère\n\n\\(R_1\\) d’attributs \\(A_1,..,A_k,B_1,...,B_h\\)\n\\(R_2\\) d’attributs \\(A_1,..,A_k,B_{h+1},...,B_\\ell\\)\n\\(A_1,..., A_k\\) : attributs communs et \\(\\{B_1,...,B_h\\}\\cap \\{ B_{h+1},...,B_\\ell \\}=\\emptyset\\)\nSoit \\(A'_1, ...., A'_k\\) tels que \\(\\{A_1,..., A_k\\}\\cap \\{ A'_1, ...., A'_k \\}=\\emptyset\\)"
  },
  {
    "objectID": "slides/SQL_7.html#jointure-naturelle-formalisation",
    "href": "slides/SQL_7.html#jointure-naturelle-formalisation",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Jointure naturelle (formalisation)",
    "text": "Jointure naturelle (formalisation)\nConsidérons \\(S\\) d’attributs \\(A_1',..,A_k',B_{h+1},...,B_l\\) définie par :\n\\[S=\\rho_{A_1\\mapsto A_1'}(\\rho_{A_2\\mapsto A_2'}(\\cdots (\\rho_{A_k\\mapsto A_k'}(R_2)\\cdots ))\\]\nLa jointure naturelle sur deux relations \\(R_1\\) et \\(R_2\\) est la relation\n\nd’attributs \\(A_1,..,A_k,B_1,...,B_h, B_{h+1},...,B_\\ell\\)\ndéfinie par :\n\n\\[\\pi_{A_1,..,A_k,B_1,...,B_h, B_{h+1},...,B_\\ell}(R_1\\bowtie_{C} S)\\]\noù \\(C\\) est \\((A_1=A_1') \\wedge (A_2=A'_2) \\wedge \\ldots \\wedge (A_k=A_k')\\)\n on réalise une équi-jointure sur tous les attributs communs et on ne garde qu’un seul “exemplaire” de ces attributs communs par projection.\nOn note cette opération : \\(R_1 \\bowtie R_2\\).\n\nPour éviter le renommage, on peut décider de préfixer les noms des attributs par ceux de la relation. La condition \\(C\\) devient :\n\\[(R_1.A_1=R_2.A_1) \\wedge \\ldots \\wedge (R_1.A_k=R_2.A_k)\\]"
  },
  {
    "objectID": "slides/SQL_7.html#exemple-de-jointure-naturelle",
    "href": "slides/SQL_7.html#exemple-de-jointure-naturelle",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Exemple de Jointure naturelle",
    "text": "Exemple de Jointure naturelle\n\n\nTrDep\n\n\n\nhdep\ndest\nnum\n\n\n\n\n13h15\nLyon\n213\n\n\n13h29\nMarseille\n1024\n\n\n\nTrArr\n\n\n\nharr\nprov\nnum\n\n\n\n\n13h39\nAvignon\n43\n\n\n15h15\nParis\n213\n\n\n\n\n\\[\\text{TrDep} \\bowtie \\text{TrArr}\\]\n\n\n\n\n\n\n\n\n\n\nhdep\ndest\nnum\nharr\nprov\n\n\n\n\n13h15\nLyon\n213\n15h15\nParis"
  },
  {
    "objectID": "slides/SQL_7.html#exemples-de-requêtes",
    "href": "slides/SQL_7.html#exemples-de-requêtes",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Exemples de requêtes",
    "text": "Exemples de requêtes\nBase constituée des trois tables suivantes:\nfournisseurs(fno, nom, adresse, ville)\nproduits(pno, design, prix, poids, couleur)\ncommandes(cno, fno, pno, qte)"
  },
  {
    "objectID": "slides/SQL_7.html#exemples-de-requêtes-suite",
    "href": "slides/SQL_7.html#exemples-de-requêtes-suite",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Exemples de requêtes (suite)",
    "text": "Exemples de requêtes (suite)\n\ndéterminer les numéros des fournisseurs ayant comme nom “Durand”\n\n\\[\\pi_{\\text{fno}} \\bigl( \\sigma_{\\text{nom}=\\text{'Durand'}} (\\text{fournisseurs})\\bigr)\\]\n\ndéterminer les références, prix et quantités des produits commandés à plus de 10 exemplaires.\n\n\\[\\pi_{\\text{pno,prix,qte}} \\bigl( \\sigma_{\\text{qte}&gt;10} (\\text{commandes} \\bowtie \\text{produits})\\bigr)\\]"
  },
  {
    "objectID": "slides/SQL_7.html#jointure-externe",
    "href": "slides/SQL_7.html#jointure-externe",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Jointure externe",
    "text": "Jointure externe\n\n\n\n\n\n\nPerte d’information dans jointure naturelle\n\n\nLes tuples ne satisfaisant pas la condition (non appariés) disparaissent\n\n\n\n\n\n\n\n\n\nDéfinition\n\n\n\nOn ajoute symboliquement” une ligne dont les valeurs sont vides (ou avec valeur spéciale NULL) pour garder les tuples initiaux “non satisfaisants” après la jointure\nOn note cette opération entre deux relations \\(R\\) et \\(S\\) :\n\\[R \\bowtie^+ S\\]"
  },
  {
    "objectID": "slides/SQL_7.html#jointure-externe-exemple",
    "href": "slides/SQL_7.html#jointure-externe-exemple",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Jointure externe (exemple)",
    "text": "Jointure externe (exemple)\n\n\nTrDep\n\n\n\nhdep\ndest\nnum\n\n\n\n\n13h15\nLyon\n213\n\n\n13h29\nMarseille\n1024\n\n\n\nTrArr\n\n\n\nharr\nprov\nnum\n\n\n\n\n13h39\nAvignon\n43\n\n\n15h15\nParis\n213\n\n\n\n\n\\[\\text{TrDep} \\bowtie^+ \\text{TrArr}\\]\n\n\n\n\n\n\n\n\n\n\nhdep\ndest\nnum\nharr\nprov\n\n\n\n\n13h15\nLyon\n213\n15h15\nParis\n\n\n13h29\nMarseille\n1024\n-\n-\n\n\n-\n-\n43\n13h39\nAvignon"
  },
  {
    "objectID": "slides/SQL_7.html#inner_join",
    "href": "slides/SQL_7.html#inner_join",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "inner_join()",
    "text": "inner_join()"
  },
  {
    "objectID": "slides/SQL_7.html#join_by...",
    "href": "slides/SQL_7.html#join_by...",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "join_by(...)",
    "text": "join_by(...)\n\njoin_by() constructs a specification that describes how to join two tables using a small domain specific language.\n\nArguments\nExpressions specifying the join.\n. . .\nEach expression should consist of one of the following:\n\nEquality condition: ==\nInequality conditions: &gt;=, &gt;, &lt;=, or &lt;\nRolling helper: closest()\nOverlap helpers: between(), within(), or overlaps()\n\n\n\nOther expressions are not supported. If you need to perform a join on a computed variable, e.g. join_by(sales_date - 40 &gt;= promo_date), you’ll need to precompute and store it in a separate column."
  },
  {
    "objectID": "slides/SQL_7.html#left_join",
    "href": "slides/SQL_7.html#left_join",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "left_join()",
    "text": "left_join()"
  },
  {
    "objectID": "slides/SQL_7.html#division",
    "href": "slides/SQL_7.html#division",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Division",
    "text": "Division\n\n\n\n\n\n\nDéfinition\n\n\nLa division ou quotient\n\nd’une relation \\(R\\) de schéma \\(R(A_1,A_2,\\dots,A_k)\\)\npar une relation \\(S\\) de schéma \\(S(A_{p+1},\\dots ,A_k)\\)\n\nest la relation \\(T\\) de schéma \\(T(A_1, \\dots, A_p)\\) formée des tuples qui complétés par chaque tuple de \\(S\\) donnent un tuple de \\(R\\).\nAutrement dit\n\\[\\begin{array}{l} t\\in T(A_1,\\dots,A_p)  \\quad \\Longleftrightarrow \\\\\n\\forall s\\in S(A_{p+1},\\dots ,A_k) \\quad \\exists r\\in R \\quad \\begin{cases}\nt.A_1=r.A_1, \\dots, t.A_p=r.A_p\\\\ s.A_{p+1}=r.A_{p+1},\\dots, s.A_{k}=r.A_{k} \\end{cases} \\end{array}\\]\nOn note \\[T = R \\div S\\]"
  },
  {
    "objectID": "slides/SQL_7.html#division-exemple",
    "href": "slides/SQL_7.html#division-exemple",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Division (exemple)",
    "text": "Division (exemple)\n\n\nVoyage : contient pour chaque numéro de client la ville de départ et d’arrivée des voyages qu’il a effectué\n\n\n\nnumclient\nvdep\nvarr\n\n\n\n\n1\nParis\nMarseille\n\n\n3\nMarseille\nLyon\n\n\n1\nParis\nNantes\n\n\n5\nMarseille\nAvignon\n\n\n4\nParis\nNantes\n\n\n3\nParis\nMarseille\n\n\n2\nCaen\nLe Mans\n\n\n3\nParis\nNantes\n\n\n\n\nVilles contient des couples villes de départ/villes d’arrivée\n\n\n\nvdep\nvarr\n\n\n\n\nParis\nMarseille\n\n\nParis\nNantes"
  },
  {
    "objectID": "slides/SQL_7.html#division-exemple-suite",
    "href": "slides/SQL_7.html#division-exemple-suite",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Division (exemple, suite)",
    "text": "Division (exemple, suite)\n\\[\\texttt{Voyage} \\div \\texttt{Villes}\\]\n\n\n\nnumclient\n\n\n\n\n1\n\n\n3\n\n\n\nRésultat : numéros des clients ayant effectué tous les voyages entre les villes de la table Villes (i.e. à la fois un Paris-Marseille et un Paris-Nantes.)"
  },
  {
    "objectID": "slides/SQL_7.html#interdéfinissabilité-des-opérateurs",
    "href": "slides/SQL_7.html#interdéfinissabilité-des-opérateurs",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Interdéfinissabilité des opérateurs",
    "text": "Interdéfinissabilité des opérateurs\n\nL’union, la différence, le produit cartésien, la sélection et la projection et le renommage sont suffisants pour définir tous les opérateurs que l’on a vu.\nMais avoir un panier plus large d’opérateurs simplifie l’écriture des requêtes.\n\nQuelques définitions\n\nPour la Jointure : \\(R \\bowtie_C S \\equiv \\sigma_C (R \\times S)\\)\nPour l’intersection : \\(A \\cap B = A \\cup B - ((B - A) \\cup (A - B))\\)"
  },
  {
    "objectID": "slides/SQL_7.html#définition-de-la-division",
    "href": "slides/SQL_7.html#définition-de-la-division",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Définition de la division",
    "text": "Définition de la division\n\n\n\n\n\n\nFormalisation\n\n\nSoient \\(R\\) de schéma \\(R(A_1,A_2,\\dots,A_k)\\), \\(S\\) de schéma \\(S(A_{p+1},\\dots ,A_k)\\)\nest la relation \\(T= R \\div S\\) de schéma \\(T(A_1, \\dots, A_p)\\)."
  },
  {
    "objectID": "slides/SQL_7.html#from-wikipedia-smaller",
    "href": "slides/SQL_7.html#from-wikipedia-smaller",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "From Wikipedia {smaller}",
    "text": "From Wikipedia {smaller}\n\nIn the 1960s and 1970s he worked out his theories of data arrangement, issuing his paper “A Relational Model of Data for Large Shared Data Banks”[14] in 1970, after an internal IBM paper one year earlier.[15] To his disappointment, IBM proved slow to exploit his suggestions until commercial rivals started implementing them.[16]\n\n\nInitially, IBM refused to implement the relational model to preserve revenue from IMS/DB.[citation needed] Codd then showed IBM customers the potential of the implementation of its model, and they in turn pressured IBM. Then IBM included in its Future Systems project a System R subproject – but put in charge of it developers who were not thoroughly familiar with Codd’s ideas, and isolated the team from Codd.[citation needed] As a result, they did not use Codd’s own Alpha language but created a non-relational one, SEQUEL. Even so, SEQUEL was so superior to pre-relational systems that it was copied, in 1979, based on pre-launch papers presented at conferences, by Larry Ellison, of Relational Software Inc, in his Oracle Database, which actually reached market before SQL/DS – because of the then-already proprietary status of the original name, SEQUEL had been renamed SQL.\n\n\nCodd continued to develop and extend his relational model, sometimes in collaboration with Christopher J. Date. One of the normalised forms, the Boyce–Codd normal form, is named after him.\n\n\nCodd’s theorem, a result proven in his seminal work on the relational model, equates the expressive power of relational algebra and relational calculus.[14]"
  },
  {
    "objectID": "slides/SQL_7.html#summarizedqta-...-byexpr-dans-dplyr",
    "href": "slides/SQL_7.html#summarizedqta-...-byexpr-dans-dplyr",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "summarize(dqta, ... , by=expr) dans dplyr()",
    "text": "summarize(dqta, ... , by=expr) dans dplyr()"
  },
  {
    "objectID": "slides/SQL_7.html#summarize-avec-sélection-bien-tempérée-avec-across...-...",
    "href": "slides/SQL_7.html#summarize-avec-sélection-bien-tempérée-avec-across...-...",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "summarize() avec sélection bien tempérée avec across(..., ...)",
    "text": "summarize() avec sélection bien tempérée avec across(..., ...)"
  },
  {
    "objectID": "slides/SQL_7.html#le-problème-group-by-en-sql",
    "href": "slides/SQL_7.html#le-problème-group-by-en-sql",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Le problème GROUP BY en SQL",
    "text": "Le problème GROUP BY en SQL"
  },
  {
    "objectID": "slides/SQL_7.html#des-tables-avec-des-domaines-tabulaires",
    "href": "slides/SQL_7.html#des-tables-avec-des-domaines-tabulaires",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Des tables avec des domaines tabulaires",
    "text": "Des tables avec des domaines tabulaires"
  },
  {
    "objectID": "slides/SQL_7.html#group_by-et-les-grouped-tibbles",
    "href": "slides/SQL_7.html#group_by-et-les-grouped-tibbles",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "group_by() et les grouped tibbles",
    "text": "group_by() et les grouped tibbles"
  },
  {
    "objectID": "slides/SQL_7.html#ungroup",
    "href": "slides/SQL_7.html#ungroup",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "ungroup()",
    "text": "ungroup()"
  },
  {
    "objectID": "slides/SQL_7.html#nest-et-unnest",
    "href": "slides/SQL_7.html#nest-et-unnest",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "nest() et unnest()",
    "text": "nest() et unnest()"
  },
  {
    "objectID": "slides/SQL_7.html#enframe",
    "href": "slides/SQL_7.html#enframe",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "enframe()",
    "text": "enframe()"
  },
  {
    "objectID": "slides/SQL_7.html#références-sur-les-tqbles-partitionnées",
    "href": "slides/SQL_7.html#références-sur-les-tqbles-partitionnées",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Références sur les tqbles partitionnées",
    "text": "Références sur les tqbles partitionnées\ndplyr sur le groupement"
  },
  {
    "objectID": "slides/SQL_7.html#types-de-mises-à-jour-de-tables-en-sql",
    "href": "slides/SQL_7.html#types-de-mises-à-jour-de-tables-en-sql",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Types de mises à jour de tables en SQL",
    "text": "Types de mises à jour de tables en SQL\n\nmodification du schéma ALTER TABLE ...\n\najout de colonnes\nsuppression de colonnes\nmodification de domaines\n\nmodification des lignes\n\nmises à jour d’attributs sur certaines lignes\nsuppression de lignes\ninsertions de lignes"
  },
  {
    "objectID": "slides/SQL_7.html#point-de-vue-fonctionnel",
    "href": "slides/SQL_7.html#point-de-vue-fonctionnel",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Point de vue fonctionnel",
    "text": "Point de vue fonctionnel"
  },
  {
    "objectID": "slides/SQL_7.html#mutate",
    "href": "slides/SQL_7.html#mutate",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "mutate()",
    "text": "mutate()\n\najout de colonnes\nmodification de domaines\nmises à jour d’attributs sur certaines lignes"
  },
  {
    "objectID": "slides/SQL_7.html#ajout-de-lignes",
    "href": "slides/SQL_7.html#ajout-de-lignes",
    "title": "BD : dplyr une mise oeuvre de l’Algèbre Relationnelle",
    "section": "Ajout de lignes",
    "text": "Ajout de lignes"
  },
  {
    "objectID": "slides/LDD_2.html#schema-de-world",
    "href": "slides/LDD_2.html#schema-de-world",
    "title": "BD VII: Corriger le schéma World",
    "section": "Schema de world",
    "text": "Schema de world\n\nSchema World en pattes de corbeau"
  },
  {
    "objectID": "slides/LDD_2.html#conraintes-sur-la-table-country",
    "href": "slides/LDD_2.html#conraintes-sur-la-table-country",
    "title": "BD VII: Corriger le schéma World",
    "section": "Conraintes sur la table country",
    "text": "Conraintes sur la table country\n\nUn pays est identifié par son countrycode\nDeux pays ne devraient pas avoir le même nom\nUne région ne devrait appartenir qu’à un seul continent\nLa capitale d’un pays devrait être une ville connue dans city\nLa capitale d’un pays devrait être une ville de ce pays\nLes capitales de deux pays différents devraient être des villes différentes\n…\n\n Ce ne sont pas les seules contraintes possibles"
  },
  {
    "objectID": "slides/LDD_2.html#mise-en-œuvre-des-contraintes",
    "href": "slides/LDD_2.html#mise-en-œuvre-des-contraintes",
    "title": "BD VII: Corriger le schéma World",
    "section": "Mise en œuvre des contraintes",
    "text": "Mise en œuvre des contraintes\n\nUn pays est identifié par son countrycode : PRIMARY KEY\nDeux pays ne devraient pas avoir le même nom : UNIQUE\nUne région ne devrait appartenir qu’à un seul continent : ???\nLa capitale d’un pays devrait être une ville connue dans city : REFERENCES\nLa capitale d’un pays devrait être une ville de ce pays : ???\nLes capitales de deux pays différents devraient être des villes différentes : UNIQUE\nDeux pays différents ne peuvent avoir le même code2 : UNIQUE"
  },
  {
    "objectID": "slides/LDD_2.html#examen-du-schema-de-country",
    "href": "slides/LDD_2.html#examen-du-schema-de-country",
    "title": "BD VII: Corriger le schéma World",
    "section": "Examen du schema de country",
    "text": "Examen du schema de country\n+--------------------+---------------+-----------+----------+--------------+-------------+\n| Column             | Type          | Modifiers | Storage  | Stats target | Description |\n|--------------------+---------------+-----------+----------+--------------+-------------|\n| countrycode        | character(3)  |  not null | extended | &lt;null&gt;       | &lt;null&gt;      |\n| name_country       | text          |  not null | extended | &lt;null&gt;       | &lt;null&gt;      |\n| continent          | text          |  not null | extended | &lt;null&gt;       | &lt;null&gt;      |\n| region             | text          |  not null | extended | &lt;null&gt;       | &lt;null&gt;      |\n| surfacearea        | real          |  not null | plain    | &lt;null&gt;       | &lt;null&gt;      |\n| indepyear          | smallint      |           | plain    | &lt;null&gt;       | &lt;null&gt;      |\n| population_country | integer       |  not null | plain    | &lt;null&gt;       | &lt;null&gt;      |\n| lifeexpectancy     | real          |           | plain    | &lt;null&gt;       | &lt;null&gt;      |\n| gnp                | numeric(10,2) |           | main     | &lt;null&gt;       | &lt;null&gt;      |\n| gnpold             | numeric(10,2) |           | main     | &lt;null&gt;       | &lt;null&gt;      |\n| localname          | text          |  not null | extended | &lt;null&gt;       | &lt;null&gt;      |\n| governmentform     | text          |  not null | extended | &lt;null&gt;       | &lt;null&gt;      |\n| headofstate        | text          |           | extended | &lt;null&gt;       | &lt;null&gt;      |\n| capital            | integer       |           | plain    | &lt;null&gt;       | &lt;null&gt;      |\n| code2              | character(2)  |  not null | extended | &lt;null&gt;       | &lt;null&gt;      |\n+--------------------+---------------+-----------+----------+--------------+-------------+\n Un schéma de table ne se réduit pas à la données des noms et domaines des colonnes"
  },
  {
    "objectID": "slides/LDD_2.html#continued",
    "href": "slides/LDD_2.html#continued",
    "title": "BD VII: Corriger le schéma World",
    "section": "(continued)",
    "text": "(continued)\nIndexes:\n    \"country_pkey\" PRIMARY KEY, btree (countrycode)\nCheck constraints:\n    \"country_continent_check\" CHECK (continent = 'Asia'::text OR \n                                     continent = 'Europe'::text OR \n                                     continent = 'North America'::text OR \n                                     continent = 'Africa'::text OR\n                                     continent = 'Oceania'::text OR\n                                     continent = 'Antarctica'::text OR\n                                     continent = 'South America'::text),\nForeign-key constraints:\n    \"country_capital_fkey\" FOREIGN KEY (capital) REFERENCES city(id)\n    \"country_fk\" FOREIGN KEY (continent) REFERENCES code_continent(continent)"
  },
  {
    "objectID": "slides/LDD_2.html#ddl-pour-country",
    "href": "slides/LDD_2.html#ddl-pour-country",
    "title": "BD VII: Corriger le schéma World",
    "section": "DDL pour country",
    "text": "DDL pour country\nCREATE TABLE world.country (\n    countrycode bpchar(3) NOT NULL,\n    name_country text NOT NULL,\n    continent text NOT NULL,\n    region text NOT NULL,\n    surfacearea float4 NOT NULL,\n    indepyear int2 NULL,\n    population_country int4 NOT NULL,\n    lifeexpectancy float4 NULL,\n    gnp numeric(10, 2) NULL,\n    gnpold numeric(10, 2) NULL,\n    localname text NOT NULL,\n    governmentform text NOT NULL,\n    headofstate text NULL,\n    capital int4 NULL,\n    code2 bpchar(2) NOT NULL,\n    CONSTRAINT country_continent_check CHECK (((continent = 'Asia'::text) \n    OR (continent = 'Europe'::text) \n    OR (continent = 'North America'::text) \n    OR (continent = 'Africa'::text) \n    OR (continent = 'Oceania'::text)\n    OR (continent = 'Antarctica'::text) \n    OR (continent = 'South America'::text))),\n    CONSTRAINT country_pkey PRIMARY KEY (countrycode)\n);"
  },
  {
    "objectID": "slides/LDD_2.html#ajout-de-contraintes-référentielles",
    "href": "slides/LDD_2.html#ajout-de-contraintes-référentielles",
    "title": "BD VII: Corriger le schéma World",
    "section": "Ajout de contraintes référentielles",
    "text": "Ajout de contraintes référentielles\n-- world.country foreign keys\n\nALTER TABLE world.country ADD CONSTRAINT \n  country_capital_fkey FOREIGN KEY (capital) REFERENCES world.city(id);\n\nALTER TABLE world.country ADD CONSTRAINT \n  country_fk FOREIGN KEY (continent) REFERENCES world.code_continent(continent);\n\nLes contraintes country_capital_fkey et country_fk sont émises par la table country"
  },
  {
    "objectID": "slides/LDD_2.html#contraintes-ajoutées",
    "href": "slides/LDD_2.html#contraintes-ajoutées",
    "title": "BD VII: Corriger le schéma World",
    "section": "Contraintes ajoutées",
    "text": "Contraintes ajoutées\n-- world.country foreign keys\n\nALTER TABLE world.country ADD CONSTRAINT \n  country_capital_fkey FOREIGN KEY (capital) REFERENCES world.city(id);\n\nALTER TABLE world.country ADD CONSTRAINT \n  country_fk FOREIGN KEY (continent) REFERENCES world.code_continent(continent);\n La contrainte country_fk sur continent remplit la même fonction que la contrainte country_continent_check\n\n Conseil:\n\nSi le domaine est de grande cardinalité, utiliser une table pour représenter le domaine, et une contrainte référentielle\nSi le domaine est de petite cardinalité, une contrainte CHECK est aussi pratique (et sans doute plus efficace)\n\n\n\n Comment procéder pour mettre en œuvre une contrainte de domaine sur region ?"
  },
  {
    "objectID": "slides/LDD_2.html#une-région-nappartient-quà-un-seul-continent",
    "href": "slides/LDD_2.html#une-région-nappartient-quà-un-seul-continent",
    "title": "BD VII: Corriger le schéma World",
    "section": "Une région n’appartient qu’à un seul continent",
    "text": "Une région n’appartient qu’à un seul continent\nCette contrainte signifie que le résultat de la requête suivante est vide :\nSELECT *\nFROM \n  world.country c1 \nJOIN \n  world.country c2 ON (c1.continent&lt;&gt; c2.continent AND c1.region=c2.region);\n\nOn exclut l’existence de deux lignes qui coïncideraient sur region mais pas sur continent\nNous postulons l’existence d’une dépendance fonctionnelle\n\\[\\texttt{region} \\longrightarrow \\texttt{continent}\\]"
  },
  {
    "objectID": "slides/LDD_2.html#deux-attitudes",
    "href": "slides/LDD_2.html#deux-attitudes",
    "title": "BD VII: Corriger le schéma World",
    "section": "Deux attitudes",
    "text": "Deux attitudes\nDans sa forme actuelle, la table country de world contient des informations redondantes: on répète plusieurs fois que la région Western Europe est située dans le continent Europe\nCes redondances représentent un gaspillage de mémoire (très modeste ici) et un risque pour le maintien de la cohérence de la base : chaque insertion, mise-à-jour est susceptible de mettre en défaut la dépendance fonctionnelle\nOn peut considérer qu’il s’agit d’une anomalie de schéma et normaliser le schéma.\nLa normalisation suppose une révision du schéma. Si le schéma est muni de vues et de fonctions, il faudra éventuellement réécrire ces vues et ces fonctions.\n\n On peut mettre en place une contrainte d’exclusion avec EXCLUDE.\nDe cette façon, on ne touchera pas au schéma, les vues et les fonctions resteront utilisables. La contrainte d’exclusion permettra de maintenir la dépendance fonctionnelle."
  },
  {
    "objectID": "slides/LDD_2.html#les-contraintes-dexclusion",
    "href": "slides/LDD_2.html#les-contraintes-dexclusion",
    "title": "BD VII: Corriger le schéma World",
    "section": "Les contraintes d’exclusion",
    "text": "Les contraintes d’exclusion\n\n\n\n\n\n\nObjectifs\n\n\n\nMise en place des dépendances fonctionnelles\nMise en place de contraintes de non-recouvrement (données spatiales ou temporelles)\nMise en place de contraintes très diverses\n\n\n\n\n\n\n\n\n\n\nComment ?\n\n\nL’ajout d’une contrainte d’exclusion crée automatiquement un index du type spécifié dans déclaration de constrainte\n\n\n\nDocumentation"
  },
  {
    "objectID": "slides/LDD_2.html#détails-syntaxiques",
    "href": "slides/LDD_2.html#détails-syntaxiques",
    "title": "BD VII: Corriger le schéma World",
    "section": "Détails syntaxiques",
    "text": "Détails syntaxiques\nEXCLUDE \n  [ USING index_method ] \n  ( exclude_element WITH operator [, ... ] ) \n  index_parameters \n  [ WHERE ( predicate ) ] \n\n\n\n\n\n\nNote\n\n\nLa clause EXCLUDE définit une contrainte d’exclusion qui garantit que si deux lignes sont comparées sur la ou les colonnes spécifiées ou des expressions utilisant le ou les opérateurs spécifiés, seulement certaines de ces comparaisons, mais pas toutes, renverront TRUE."
  },
  {
    "objectID": "slides/LDD_2.html#remarques",
    "href": "slides/LDD_2.html#remarques",
    "title": "BD VII: Corriger le schéma World",
    "section": "Remarques",
    "text": "Remarques\nSi tous les opérateurs spécifiés testent une égalité, ceci est équivalent à une contrainte UNIQUE bien qu’une contrainte unique ordinaire sera plus rapide.\nNéanmoins, ces contraintes d’exclusion peuvent spécifier des contraintes qui sont plus générales qu’une simple égalité.\nVous pouvez spécifier qu’il n’y a pas deux lignes/tuples dans la table contenant des cercles se recouvrant surcharge en utilisant l’opérateur &&.\n Le(s) opérateur(s) doivent être commutatif(s)."
  },
  {
    "objectID": "slides/LDD_2.html#mise-en-œuvre",
    "href": "slides/LDD_2.html#mise-en-œuvre",
    "title": "BD VII: Corriger le schéma World",
    "section": "Mise en œuvre",
    "text": "Mise en œuvre\nLes contraintes d’exclusion sont implantées en utilisant un index qui a le même nom que la contrainte, donc chaque opérateur précisé doit être associé avec une classe d’opérateurs appropriée pour la méthode d’accès par index, nommée méthode_index.\nChaque élément_exclusion définit une colonne de l’index, donc il peut spécifier en option une collation, une classe d’opérateur, des paramètres pour la classe d’opérateurs, et/ou des options de tri\nEn pratique, la méthode d’accès sera toujours GiST ou SP-GiST (GIST est un acronyme qui renvoie à Generalized Search Tree)."
  },
  {
    "objectID": "slides/LDD_2.html#zoologie-des-index-b-tree-hash-gin",
    "href": "slides/LDD_2.html#zoologie-des-index-b-tree-hash-gin",
    "title": "BD VII: Corriger le schéma World",
    "section": "Zoologie des index B-tree, hash, GIN",
    "text": "Zoologie des index B-tree, hash, GIN\nUne stratégie d’indexation permet de gérer efficacement des conditions de la forme\n&lt;colonne indexée&gt; &lt;opérateur&gt; &lt;valeur de comparaison&gt;\nLes index de type B-tree sont appropriés pour les types ordonnés et les opérateurs =, &lt;=, =&gt;\nLes index de type B-tree sont souvent utilisés pour réaliser les équi-jointures."
  },
  {
    "objectID": "slides/LDD_2.html#méthodes-daccès-index-gist",
    "href": "slides/LDD_2.html#méthodes-daccès-index-gist",
    "title": "BD VII: Corriger le schéma World",
    "section": "Méthodes d’accès (Index) GiST",
    "text": "Méthodes d’accès (Index) GiST\nGiST: une infrastructure qui permet la mise en œuvre de différentes stratégies d’indexation.\nLes opérateurs susceptibles d’utiliser un index GiST peuvent varier selon la stratégie d’indexation\n\nLa distribution standard de PostgreSQL comprend des classes d’opérateurs GiST pour plusieurs types de données géométriques (bidimensionnelles), qui permettent d’effectuer des requêtes indexées à l’aide de ces opérateurs\n&lt;&lt;   &&lt;   &&gt;   &gt;&gt;   &lt;&lt;|   &&lt;|   |&&gt;   |&gt;&gt;   @&gt;   &lt;@   ~=   &&"
  },
  {
    "objectID": "slides/LDD_2.html#dans-world.country",
    "href": "slides/LDD_2.html#dans-world.country",
    "title": "BD VII: Corriger le schéma World",
    "section": "Dans world.country",
    "text": "Dans world.country\nALTER TABLE world.country\nADD CONSTRAINT xcl_country_region_continent \nEXCLUDE  USING GIST  (\n    region WITH =, \n    continent with &lt;&gt;\n) ;\nAvec cette contrainte d’exclusion, on interdit la présence de deux tuples dand la table country, coïncidant sur la colonne region mais pas sur la colonne continent."
  },
  {
    "objectID": "slides/LDD_2.html#autre-exemple",
    "href": "slides/LDD_2.html#autre-exemple",
    "title": "BD VII: Corriger le schéma World",
    "section": "Autre exemple",
    "text": "Autre exemple\nCREATE TABLE public.zoo (\n  zoo_id INTEGER DEFAULT nextval('public.zoo_zoo_id_seq'::regclass) NOT NULL,\n  PRIMARY KEY, \n  cage   INTEGER,\n  animal TEXT,\n  CONSTRAINT zoo_pkey PRIMARY KEY ( zoo_id )\n  EXCLUDE USING GIST (\n    cage WITH =, \n    animal WITH &lt;&gt;)\n);"
  },
  {
    "objectID": "slides/LDD_2.html#question",
    "href": "slides/LDD_2.html#question",
    "title": "BD VII: Corriger le schéma World",
    "section": "Question",
    "text": "Question\n Comment utiliser les contraintes d’exclusion pour préciser que deux colonnes sont liées par une relation de monotonie ?"
  },
  {
    "objectID": "slides/LDD_2.html#section",
    "href": "slides/LDD_2.html#section",
    "title": "BD VII: Corriger le schéma World",
    "section": "",
    "text": "La normalisation des bases de données relationnelles est une activité en soi, guidée par des principes codifiés et des algorithmes établis (voir Normalisation I, Normalisation II)\nIci, nous profitons de la simplicité du schéma world pour normaliser country à la main."
  },
  {
    "objectID": "slides/LDD_2.html#éclatement-de-la-table-country",
    "href": "slides/LDD_2.html#éclatement-de-la-table-country",
    "title": "BD VII: Corriger le schéma World",
    "section": "Éclatement de la table country",
    "text": "Éclatement de la table country\n\nMise en place d’une table region_continent(region, continent)\nÉmission d’une contrainte référentielle de country vers region_continent"
  },
  {
    "objectID": "slides/LDD_2.html#préparation",
    "href": "slides/LDD_2.html#préparation",
    "title": "BD VII: Corriger le schéma World",
    "section": "Préparation",
    "text": "Préparation\nCREATE SCHEMA monde AUTHORIZATION superdupont ;\n\nGRANT ALL ON SCHEMA monde TO superdupont ;\n\nCREATE TABLE monde.code_continent AS \n       TABLE world.code_continent ;\n\nALTER TABLE monde.code_continent ADD CONSTRAINT \n  code_continent_pk PRIMARY KEY (codecontinent);\nALTER TABLE monde.code_continent ADD CONSTRAINT \n  code_continent_un UNIQUE (continent);"
  },
  {
    "objectID": "slides/LDD_2.html#création-de-region_continent",
    "href": "slides/LDD_2.html#création-de-region_continent",
    "title": "BD VII: Corriger le schéma World",
    "section": "Création de region_continent",
    "text": "Création de region_continent\nCREATE TABLE monde.region_continent AS \n  SELECT DISTINCT \n    region, continent \n  FROM \n    world.country c ;\nLa requête suivante renvoie une table vide:\nSELECT * \nFROM \n  monde.region_continent rc1 \nJOIN \n  monde.region_continent rc2 \nON (\n    rc1.region=rc2.region AND \n  rc1.continent&lt;&gt; rc2.continent\n) ;\nALTER TABLE monde.region_continent ADD CONSTRAINT \n    region_continent_pk PRIMARY KEY (region);\n\nALTER TABLE mode.region_continent ADD CONSTRAINT \n  region_continent_fk FOREIGN KEY (continent) \n  REFERENCES monde.code_continent(continent);"
  },
  {
    "objectID": "slides/LDD_2.html#création-de-la-table-monde.country",
    "href": "slides/LDD_2.html#création-de-la-table-monde.country",
    "title": "BD VII: Corriger le schéma World",
    "section": "Création de la table monde.country",
    "text": "Création de la table monde.country\nCREATE TABLE monde.country AS  \n  SELECT  \n    countrycode, name_country, region, surfacearea, \n    indepyear, population_country, \n    lifeexpectancy, gnp, gnpold, localname,\n    governmentform, headofstate, capital,  code2            \n  FROM \n    world.country ;\n sans colonne continent"
  },
  {
    "objectID": "slides/LDD_2.html#mise-en-place-des-contraintes-sur-monde.country",
    "href": "slides/LDD_2.html#mise-en-place-des-contraintes-sur-monde.country",
    "title": "BD VII: Corriger le schéma World",
    "section": "Mise en place des contraintes sur monde.country",
    "text": "Mise en place des contraintes sur monde.country\nALTER TABLE monde.country ADD CONSTRAINT \n  country_pk PRIMARY KEY (countrycode);\n\nALTER TABLE monde.country ADD CONSTRAINT \n  country_un_name UNIQUE (name_country);\n\nALTER TABLE monde.country ADD CONSTRAINT \n  country_un_code2 UNIQUE (code2);\n\nALTER TABLE monde.country ADD CONSTRAINT \n  country_un_capital UNIQUE (capital);\n\nALTER TABLE monde.country ADD CONSTRAINT country_fk \n  FOREIGN KEY (region) REFERENCES monde.region_continent(region) \n  ON DELETE SET NULL \n  ON UPDATE CASCADE;"
  },
  {
    "objectID": "slides/LDD_2.html#copie-de-city",
    "href": "slides/LDD_2.html#copie-de-city",
    "title": "BD VII: Corriger le schéma World",
    "section": "Copie de city",
    "text": "Copie de city\nCREATE TABLE monde.city AS \n  TABLE world.city;\n On a copié le schéma a minima (sans les contraintes)"
  },
  {
    "objectID": "slides/LDD_2.html#dans-un-pays-plusieurs-villes-peuvent-elles-porter-le-même-nom",
    "href": "slides/LDD_2.html#dans-un-pays-plusieurs-villes-peuvent-elles-porter-le-même-nom",
    "title": "BD VII: Corriger le schéma World",
    "section": "Dans un pays plusieurs villes peuvent elles porter le même nom ?",
    "text": "Dans un pays plusieurs villes peuvent elles porter le même nom ?\nSELECT *\nFROM \n  monde.city c \nJOIN \n  monde.city c2 \nON (c.name_city = c2.name_city AND \n    c.countrycode = c2.countrycode  AND \n    c.id &lt;&gt; c2.id) ;\nrenvoie 48 lignes\n\nSELECT *\nFROM \n  monde.city c \nJOIN \n  monde.city c2 \nON (c.name_city = c2.name_city AND \n    c.countrycode = c2.countrycode  AND\n    c.district = c2.district  AND\n    c.id &lt;&gt; c2.id) ;\nrenvoie 2 lignes"
  },
  {
    "objectID": "slides/LDD_2.html#existe-t-il-un-pays-dont-la-capitale-est-dans-un-autre-pays",
    "href": "slides/LDD_2.html#existe-t-il-un-pays-dont-la-capitale-est-dans-un-autre-pays",
    "title": "BD VII: Corriger le schéma World",
    "section": "Existe-t-il un pays dont la capitale est dans un autre pays ?",
    "text": "Existe-t-il un pays dont la capitale est dans un autre pays ?\nSELECT c. countrycode, c.name_country, cc.name_city, cc.countrycode\nFROM \n  world.country c \nJOIN \n  world.city cc \nON (c.capital = cc.id  AND \n    cc.countrycode &lt;&gt; c.countrycode) ;\nrenvoie 0 lignes"
  },
  {
    "objectID": "slides/LDD_2.html#blocages-possibles",
    "href": "slides/LDD_2.html#blocages-possibles",
    "title": "BD VII: Corriger le schéma World",
    "section": " Blocages possibles",
    "text": "Blocages possibles\nSi\n\ncity emet une contrainte référentielle sur country (countrycode)\ncountry emet une contrainte référentielle sur city (capital \\(\\rightarrow\\) id)\n\nRisque de blocage : qui précède la capitale ou le pays ?"
  },
  {
    "objectID": "slides/LDD_2.html#émission-de-la-contrainte-de-city-vers-country",
    "href": "slides/LDD_2.html#émission-de-la-contrainte-de-city-vers-country",
    "title": "BD VII: Corriger le schéma World",
    "section": "Émission de la contrainte de city vers country",
    "text": "Émission de la contrainte de city vers country\nALTER TABLE monde.city \n  ADD CONSTRAINT city_fk FOREIGN KEY (countrycode) \n      REFERENCES monde.country(countrycode) \n  ON DELETE SET NULL ON UPDATE CASCADE;"
  },
  {
    "objectID": "slides/LDD_2.html#table-countrylanguage",
    "href": "slides/LDD_2.html#table-countrylanguage",
    "title": "BD VII: Corriger le schéma World",
    "section": "Table countrylanguage",
    "text": "Table countrylanguage\nCREATE TABLE monde.countrylanguage  AS \n  TABLE world.countrylanguage ;\n\nALTER TABLE monde.countrylanguage \n  ADD CONSTRAINT countrylanguage_fk \n        FOREIGN KEY (countrycode) REFERENCES monde.country(countrycode) \n        ON DELETE CASCADE \n      ON UPDATE CASCADE;\n\nALTER TABLE monde.countrylanguage \n  ADD CONSTRAINT countrylanguage_pk \n    PRIMARY KEY (\"language\",countrycode);\n\nALTER TABLE monde.countrylanguage \n  ADD CONSTRAINT countrylanguage_check \n    CHECK (percentage &lt;= 100.0 AND percentage &gt;=0.0 );"
  },
  {
    "objectID": "slides/LDD_2.html#synthèse-régionale",
    "href": "slides/LDD_2.html#synthèse-régionale",
    "title": "BD VII: Corriger le schéma World",
    "section": "Synthèse régionale",
    "text": "Synthèse régionale\nCREATE OR REPLACE VIEW monde.regionale AS (\nSELECT C.region, \n       SUM(c.population_country) AS population_region,\n       SUM(COALESCE(c.surfacearea, 0)) AS surfacearea_region,\n       SUM(c.gnp) AS gnp_region,\n       SUM(c.gnpold) AS gnpold_region\nFROM monde.country c \nGROUP BY c.region ) ;"
  },
  {
    "objectID": "slides/LDD_2.html#synthèse-continentale",
    "href": "slides/LDD_2.html#synthèse-continentale",
    "title": "BD VII: Corriger le schéma World",
    "section": "Synthèse continentale",
    "text": "Synthèse continentale\nSELECT r.* \nFROM \n  monde.regionale r \nJOIN \n  monde.region_continent rc \nON (r.region=rc.region AND rc.continent='Europe') ;\n\nSELECT r.* \nFROM \n  monde.regionale r \nWHERE \n  r.region IN (\n    SELECT \n      region\n    FROM \n      monde.region_continent\n    WHERE \n      continent='Europe'\n  ) ;\n\n\n+----------------+-----------------+------------------+----------+-------------+\n|region          |population_region|surfacearea_region|gnp_region|gnpold_region|\n+----------------+-----------------+------------------+----------+-------------+\n|Western Europe  |        183247600|         1108456.5|4673272.00|   4578420.00|\n|Southern Europe |        144674200|         1316392.4|2012289.00|   1944737.00|\n|Baltic Countries|          7561900|          175117.0|  22418.00|     18595.00|\n|Nordic Countries|         24166400|         1321901.0| 676655.00|    677698.00|\n|British Islands |         63398500|          313173.0|1454251.00|   1369962.00|\n|Eastern Europe  |        307026000|          18814094| 659980.00|    792589.00|"
  },
  {
    "objectID": "slides/LDD_2.html#synthèse-continentale-1",
    "href": "slides/LDD_2.html#synthèse-continentale-1",
    "title": "BD VII: Corriger le schéma World",
    "section": "Synthèse continentale",
    "text": "Synthèse continentale\nCREATE OR REPLACE VIEW monde.continentale AS (\nSELECT rc.continent, \n       SUM(r.population_region) AS population,\n       SUM(r.surfacearea_region) AS surfacearea,\n       SUM(r.gnp_region) AS gcp,\n       SUM(r.gnpold_region) AS gcpold\nFROM monde.regionale r JOIN monde.region_continent rc \n     ON (r.region=rc.region) \nGROUP BY rc.continent;) ;\n\n+-------------+----------+-----------+----------+----------+\n|continent    |population|surfacearea|gcp       |gcpold    |\n+-------------+----------+-----------+----------+----------+\n|South America| 345780000|   17864926|1511874.00|1520641.00|\n|North America| 482993000|   24214472|9688627.20|9288175.00|\n|Oceania      |  30401150|  8564294.0| 419774.70| 469058.00|\n|Antarctica   |         0|   13132101|      0.00|          |\n|Africa       | 784475000|   30250376| 580375.00| 553264.00|\n|Europe       | 730074600|   23049132|9498865.00|9382001.00|\n|Asia         |3705025700|   31881006|7655392.00|8251969.00|"
  },
  {
    "objectID": "slides/SQL_5.html#trois-objectifs",
    "href": "slides/SQL_5.html#trois-objectifs",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Trois objectifs",
    "text": "Trois objectifs\n\nAutomatisation de taches répétitives (administration)\n\n\nOn veut répéter une même tache sur une collection de schémas\nOn veut traiter une collection de roles\n\n\n\nCalculs impossibles à réaliser en SQL :\n\n\nCalculer la fermeture transitive d’une relation comme film_actors\n\nL’algèbre relationnelle est un modèle de calculabilité restreint·\n\n\nTriggers\n\n\nCertaines contraintes ne peuvent pas être mises en place avec les seules constructions primary key , unique, foreign key, check et exclude (notamment des contraintes d’exclusion qui mettent en jeu plusieurs tables).\nOn peut les maintenir à l’aide de traitements spéciaux : les triggers\nLes triggers reposent sur des fonctions spéciales\n\n\nExtensions procédurales de SQL\nplpgsql : Programming Language PostGres SQL"
  },
  {
    "objectID": "slides/SQL_5.html#automatisation-des-tâches-répétitives-deux-outils-nécessaires",
    "href": "slides/SQL_5.html#automatisation-des-tâches-répétitives-deux-outils-nécessaires",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Automatisation des tâches répétitives : deux outils nécessaires",
    "text": "Automatisation des tâches répétitives : deux outils nécessaires\nLorsqu’on administre une base, on doit souvent engendrer des requêtes dynamiques à l’intérieur d’une fonction PL/pgSQL, c’est à dire des commandes qui vont concerner des tables ou des types différents à chaque exécution\nLes requêtes préparées sont alors très utilement combinées avec les structures de contrôle (itérations, alternatives) pour automatiser les tâches !\n\n 2 outils (pour étendre SQL) :\n\nrequêtes dynamiques EXECUTE, PREPARE\nstructures de contrôles IF, LOOP, ... Transforment SQL en un langage de programmation"
  },
  {
    "objectID": "slides/SQL_5.html#fonction-inventory_in_stock",
    "href": "slides/SQL_5.html#fonction-inventory_in_stock",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Fonction inventory_in_stock()",
    "text": "Fonction inventory_in_stock()\nObjectif : calculer si un dvd est en stock ou pas\nUn DVD est en stock\n\ns’il n’a jamais été loué\n\nOU\n\nsi toutes les locations de ce DVD sont déjà terminées (return_date n’est pas nul)\n\n-- AN ITEM IS IN-STOCK IF THERE ARE EITHER NO ROWS IN THE rental TABLE\n-- FOR THE ITEM OR ALL ROWS HAVE return_date POPULATED"
  },
  {
    "objectID": "slides/SQL_5.html#fonction-inventory_in_stock-1",
    "href": "slides/SQL_5.html#fonction-inventory_in_stock-1",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Fonction inventory_in_stock",
    "text": "Fonction inventory_in_stock\nCREATE OR REPLACE FUNCTION sakila.inventory_in_stock(p_inventory_id integer)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\nDECLARE                 \n    v_rentals INTEGER;  #&lt;&lt;\n    v_out     INTEGER;  #&lt;&lt;\nBEGIN\n    SELECT count(*) INTO v_rentals  #&lt;&lt;\n    FROM rental\n    WHERE inventory_id = p_inventory_id;\n\n    IF v_rentals = 0 THEN   #&lt;&lt;\n      RETURN TRUE;          #&lt;&lt; \n    END IF;                 #&lt;&lt;\n\n    SELECT COUNT(rental_id) INTO v_out     #&lt;&lt; \n    FROM inventory LEFT JOIN rental USING(inventory_id)\n    WHERE inventory.inventory_id = p_inventory_id AND rental.return_date IS NULL;\n\n    IF v_out &gt; 0 THEN\n      RETURN FALSE;\n    ELSE\n      RETURN TRUE;\n    END IF;\nEND $function$ ;"
  },
  {
    "objectID": "slides/SQL_5.html#section",
    "href": "slides/SQL_5.html#section",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "",
    "text": "SELECT ... INTO ...\n\nLe résultat de la requête est ici un entier, il est affecté à une variable locale comme v_rentals, v_out, …\nEn plpgsql, le résultat d’une requête doit être mémorisé ou explicitement négligé en utilisant PERFORM plutôt que SELECT\n\nIF ... THEN ...\n\nAlternative, comme dans un langage de programmation ordinaire\n\nRETURN\n\nRetourne le résultat et termine l’exécution de la fonction"
  },
  {
    "objectID": "slides/SQL_5.html#une-tâche-de-surveillancemaintenance",
    "href": "slides/SQL_5.html#une-tâche-de-surveillancemaintenance",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Une tâche de surveillance/maintenance",
    "text": "Une tâche de surveillance/maintenance\n\nDéterminer pour chaque usager (schéma) le nombre de tuples dans la table ville_pays de cet usager.\nPour chaque schéma schema, on veut évaluer une requête\nSELECT COUNT(*) \nFROM schema.ville_pays ;\nIci schema doit être calculé en interrogeant le SGBD\n\nSituation inédite :\n\ncomment déterminer les schémas pertinents ?"
  },
  {
    "objectID": "slides/SQL_5.html#la-métabase-information_schema-et-pg_catalog",
    "href": "slides/SQL_5.html#la-métabase-information_schema-et-pg_catalog",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "La métabase : information_schema et pg_catalog",
    "text": "La métabase : information_schema et pg_catalog\nOn va s’aider des tables d’administration du SGBD\nChaque usager correspond à un role et ce rôle correspond dans notre cas à un schema créé à partir du rôle via l’instruction\nCREATE SCHEMA AUTHORIZATION user_name ;\nOn a envie d’écrire une requête comme\nSELECT COUNT(*) FROM username.tournaments ; \noù username est collectée à partir de\nSELECT usename  FROM pg_catalog.pg_user ;"
  },
  {
    "objectID": "slides/SQL_5.html#deux-schémas-pour-ladministration-la-métabase",
    "href": "slides/SQL_5.html#deux-schémas-pour-ladministration-la-métabase",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Deux schémas pour l’administration : la métabase",
    "text": "Deux schémas pour l’administration : la métabase\n\ninformation_schema\n\nCe schema contient l’information sur les schémas du cluster/catalogue :\n\nles définitions de tables, de vues, de colonnes, les contraintes, …\nil est formé de tables et surtout de (très nombreuses) vues\nles instructions, CREATE, ALTER,  DROP modifient le contenu de ce schéma (une seule instruction ALTER  TABLE peut engendrer plusieurs mises à jours dans les tables de information_schema\n\n\npg_catalog\n\nCe schema contient lui aussi beaucoup de tables et de vues utiles au fonctionnement du serveur"
  },
  {
    "objectID": "slides/SQL_5.html#exemple-de-vue-de-pg_catalog-pg_user",
    "href": "slides/SQL_5.html#exemple-de-vue-de-pg_catalog-pg_user",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Exemple de vue de pg_catalog : pg_user",
    "text": "Exemple de vue de pg_catalog : pg_user\n\n\nSchéma\n+--------------+---------+-------------+\n| Column       | Type    | Modifiers   |\n|--------------+---------+-------------|\n| usename      | name    |             |\n| usesysid     | oid     |             |\n| usecreatedb  | boolean |             |\n| usesuper     | boolean |             |\n| userepl      | boolean |             |\n| usebypassrls | boolean |             |\n| passwd       | text    |             |\n| valuntil     | abstime |             |\n| useconfig    | text[]  |             |\n+--------------+---------+-------------+\n\npg_user nous renseigne sur :\n\n les usagers (usename)\n leur statut (usesuper : super-utilisateur ou pas)\n leurs privilèges (createdb : peut créer une base ou non)"
  },
  {
    "objectID": "slides/SQL_5.html#autre-exemple-dusage-de-la-métabase",
    "href": "slides/SQL_5.html#autre-exemple-dusage-de-la-métabase",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Autre exemple d’usage de la métabase",
    "text": "Autre exemple d’usage de la métabase\nSELECT datname, application_name, client_addr, backend_start, state \nFROM pg_catalog.pg_stat_activity psa \nWHERE datname='bd_2023';                                               \n\n+-----------+-------------------------------------------+---------------+-------------------------------+---------+\n| datname   | application_name                          | client_addr   | backend_start                 | state   |\n|-----------+-------------------------------------------+---------------+-------------------------------+---------|\n| bd_2023   | DBeaver 22.2.0 - Main &lt;bd_2023&gt;           | 127.0.0.1     | 2022-10-04 22:48:59.57231+02  | idle    |\n| bd_2023   | DBeaver 22.2.0 - Metadata &lt;bd_2023&gt;       | 127.0.0.1     | 2022-10-04 22:48:59.693656+02 | idle    |\n| bd_2023   | DBeaver 22.2.0 - SQLEditor &lt;Script-4.sql&gt; | 127.0.0.1     | 2022-10-04 22:48:59.958616+02 | idle    |\n| bd_2023   | pgcli                                     | &lt;null&gt;        | 2022-10-04 23:23:19.739258+02 | active  |\n| bd_2023   | pgcli                                     | &lt;null&gt;        | 2022-10-04 23:23:19.770006+02 | idle    |\n+-----------+-------------------------------------------+---------------+-------------------------------+---------+"
  },
  {
    "objectID": "slides/SQL_5.html#tentative",
    "href": "slides/SQL_5.html#tentative",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Tentative",
    "text": "Tentative\nOn engendre dynamiquement une série de requêtes par une instruction de la forme :\nSELECT \n    'SELECT ' || quote_literal(usename) || ', COUNT(*)  FROM ' || usename || '.ville_pays ;'\nFROM pg_catalog.pg_user  ;\n A quoi sert quote_literal() ?"
  },
  {
    "objectID": "slides/SQL_5.html#le-résultat-est-une-table-de-chaines-de-caractères",
    "href": "slides/SQL_5.html#le-résultat-est-une-table-de-chaines-de-caractères",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Le résultat est une table de chaines de caractères",
    "text": "Le résultat est une table de chaines de caractères\nrqt                                                      |\n---------------------------------------------------------+\nSELECT 'postgres', COUNT(*)  FROM postgres.ville_pays ;  |\nSELECT 'shinken', COUNT(*)  FROM shinken.ville_pays ;    |\nSELECT 'aalahy99', COUNT(*)  FROM aalahy99.ville_pays ;  |\nSELECT 'etemam', COUNT(*)  FROM etemam.ville_pays ;      |\nSELECT 'durand', COUNT(*)  FROM durand.ville_pays ;      |\n...\n\nTel quel, cela ne fonctionnera pas !\n\nIl faut pouvoir confier ces chaines de caractères à l’évaluateur de requêtes\nIl faut pouvoir le faire pour chacune des chaines de caractères produites par la requête (itérer)"
  },
  {
    "objectID": "slides/SQL_5.html#mode-opératoire",
    "href": "slides/SQL_5.html#mode-opératoire",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Mode opératoire",
    "text": "Mode opératoire\nCREATE OR REPLACE FUNCTION taille_ville_pays()\nLANGUAGE plpgsql RETURNS  TEXT AS\n$$\nDECLARE\n  stmt CHARACTER VARYING ;\n  usename CHARACTER VARYING ;\n  result CHARACTER VARYING    := '' ;\n  resp CHARACTER VARYING := '' ;\nBEGIN\nFOR usename IN SELECT u.usename  #&lt;&lt;\n  FROM pg_catalog.pg_user AS u JOIN\n  information_schema.tables t ON\n  (u.usename=t.table_schema and t.table_name ='ville_pays')\nLOOP\n  stmt = 'SELECT CAST(COUNT(*) AS VARCHAR) FROM '|| usename||'.ville_pays #&lt;&lt;\n  result:=result || usename || ': ' ||resp| '; ';   #&lt;&lt; \nEND LOOP ;\nRETURN result ; #&lt;&lt; \nEND;$$ ;"
  },
  {
    "objectID": "slides/SQL_5.html#extension-de-sql",
    "href": "slides/SQL_5.html#extension-de-sql",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Extension de SQL",
    "text": "Extension de SQL\nA travers ces deux exemples, on a vu quelques particularités des extensions possible de SQL en un langage procédural pgplSQL. Le principe est le même dans la plupart des SGBD permettant une telle extension (Oracle, SQL Server, …). Il repose sur la norme SQL.\nOn a besoin :\n\nd’instructions conditionnelles (si … alors … sinon)\nd’instruction itératives (boucles)\nde la capacité à définir des variables\nde mécanismes d’articulations entre SQL et son extension procédurale :\n\nPouvoir stocker le résultat d’une requête (avec résultat unique) dans une variable\nPouvoir stocker, les uns après les autres, les résultats d’une requêtes complexes pour traitement, définir un curseur (CURSOR)"
  },
  {
    "objectID": "slides/SQL_5.html#extension-de-sql-1",
    "href": "slides/SQL_5.html#extension-de-sql-1",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Extension de SQL",
    "text": "Extension de SQL\nOn doit avoir un mécanisme qui permet conserver les programmes écrits pour les utiliser lors de sessions futures\nLe langage plpgsql permet :\n\nde définir des fonctions et procédures stockées…\nqui vont avoir la même persistence que les tables, vues, etc\nL’existence de ces fonctions, leurs codes, etc, seront conservés dans des tables et vue d’administration (information_schema.routines)."
  },
  {
    "objectID": "slides/SQL_5.html#exemple",
    "href": "slides/SQL_5.html#exemple",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Exemple",
    "text": "Exemple\nSELECT routine_catalog, routine_schema, routine_name, data_type, security_type\nFROM information_schema.routines    #&lt;&lt; \nWHERE routine_type='FUNCTION' AND specific_schema='sakila'   #&lt;&lt; \n\nroutine_catalog|routine_schema|routine_name              |data_type   |security_type|\n---------------+--------------+--------------------------+------------+-------------+\nbd_2023        |sakila        |_group_concat             |text        |INVOKER      |\nbd_2023        |sakila        |film_in_stock             |integer     |INVOKER      |\nbd_2023        |sakila        |film_not_in_stock         |integer     |INVOKER      |\nbd_2023        |sakila        |get_customer_balance      |numeric     |INVOKER      |\nbd_2023        |sakila        |inventory_held_by_customer|integer     |INVOKER      |\nbd_2023        |sakila        |inventory_in_stock        |boolean     |INVOKER      |\nbd_2023        |sakila        |last_day                  |date        |INVOKER      |\nbd_2023        |sakila        |last_updated              |trigger     |INVOKER      |\nbd_2023        |sakila        |rewards_report            |USER-DEFINED|DEFINER      |"
  },
  {
    "objectID": "slides/SQL_5.html#rewards_report-signature",
    "href": "slides/SQL_5.html#rewards_report-signature",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "rewards_report signature",
    "text": "rewards_report signature\nCREATE OR REPLACE FUNCTION \n    sakila.rewards_report(min_monthly_purchases integer, \n                          min_dollar_amount_purchased numeric)\n RETURNS SETOF sakila.customer\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    last_month_start DATE;\n    last_month_end DATE;\nrr RECORD;\ntmpSQL TEXT;\nBEGIN\n...\nEND $$ ;\nDétermine la liste des bons clients qui beaucoup consommé durant le dernier mois écoulé"
  },
  {
    "objectID": "slides/SQL_5.html#section-1",
    "href": "slides/SQL_5.html#section-1",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "",
    "text": "la signature comporte une déclaration de type originale\nla déclaration des variables locales mentionne un type fourre-tout\n\nSETOF customer\nTable de même schéma que customer (mêmes colonnes)\nConstruction très très utile : SETOF nom_de_table\nRECORD\nUn type générique (fourre-tout) pour désigner les types composés (en particulier comme les types définis à partir des tables)"
  },
  {
    "objectID": "slides/SQL_5.html#rewards_report-corps-i",
    "href": "slides/SQL_5.html#rewards_report-corps-i",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "rewards_report corps (I)",
    "text": "rewards_report corps (I)\nBEGIN\n    /* Some sanity checks... */\n    IF min_monthly_purchases = 0 THEN\n        RAISE EXCEPTION 'Minimum monthly purchases parameter must be &gt; 0';\n    END IF;\n    IF min_dollar_amount_purchased = 0.00 THEN\n        RAISE EXCEPTION 'Minimum monthly dollar amount purchased parameter must be &gt; $0.00';  #&lt;&lt; \n    END IF;\n\n    last_month_start := CURRENT_DATE - '3 month'::interval;\n    last_month_start := to_date((extract(YEAR FROM last_month_start) || '-' || extract(MONTH FROM last_month_start) || '-01'),'YYYY-MM-DD');\n    last_month_end := LAST_DAY(last_month_start);\n...\n\n RAISE EXCEPTION 'msg'\ntermine (en erreur) l’exécution de la fonction envoie un message d’erreur"
  },
  {
    "objectID": "slides/SQL_5.html#rewards_report-corps-ii",
    "href": "slides/SQL_5.html#rewards_report-corps-ii",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "rewards_report corps (II)",
    "text": "rewards_report corps (II)\n/*\n    Create a temporary storage area for Customer IDs.\n    */\n    CREATE TEMPORARY TABLE tmpCustomer (customer_id INTEGER NOT NULL PRIMARY KEY);\n\n    /*\n    Find all customers meeting the monthly purchase requirements\n    */\n\n    tmpSQL := 'INSERT INTO tmpCustomer (customer_id)\n        SELECT p.customer_id\n        FROM payment AS p\n        WHERE DATE(p.payment_date) BETWEEN '|| quote_literal(last_month_start) ||' AND '|| quote_literal(last_month_end) || '\n        GROUP BY customer_id\n        HAVING SUM(p.amount) &gt; ' || min_dollar_amount_purchased || \n        'AND COUNT(customer_id) &gt; ' || \n        min_monthly_purchases ;\n\n    EXECUTE tmpSQL;  #&lt;&lt;"
  },
  {
    "objectID": "slides/SQL_5.html#create-temporary-table-...",
    "href": "slides/SQL_5.html#create-temporary-table-...",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": " CREATE TEMPORARY TABLE ...",
    "text": "CREATE TEMPORARY TABLE ...\nCrée une table (très simple ici) qui sera détruite avant la fin de l’exécution de la fonction.\nSi l’exécution de la fonction devait être interrompue, cette table ne survivrait pas à la session qui a invoqué la fonction"
  },
  {
    "objectID": "slides/SQL_5.html#pourquoi-utiliser-une-requête-créée-dynamiquement",
    "href": "slides/SQL_5.html#pourquoi-utiliser-une-requête-créée-dynamiquement",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "Pourquoi utiliser une requête créée dynamiquement ?",
    "text": "Pourquoi utiliser une requête créée dynamiquement ?\n\nEst ce une nécessité ici ?\nSi non, quel est l’intérêt ?"
  },
  {
    "objectID": "slides/SQL_5.html#rewards_report-corps-iii",
    "href": "slides/SQL_5.html#rewards_report-corps-iii",
    "title": "BD : Fonctions et extension PlpgSQL de SQL",
    "section": "rewards_report corps III",
    "text": "rewards_report corps III\n/*\n    Output ALL customer information of matching rewardees.\n    Customize output as needed.\n    */\n    FOR rr IN EXECUTE 'SELECT c.* FROM tmpCustomer AS t INNER JOIN customer AS c ON t.customer_id = c.customer_id' LOOP\n        RETURN NEXT rr;   #&lt;&lt;\n    END LOOP;\n\n    /* Clean up */\n    tmpSQL := 'DROP TABLE tmpCustomer';\n    EXECUTE tmpSQL;\n\nRETURN;   #&lt;&lt;\nEND\n$function$ ;"
  },
  {
    "objectID": "slides/Modelisation_2.html#entre-modèle-ea-et-modèle-relationnel",
    "href": "slides/Modelisation_2.html#entre-modèle-ea-et-modèle-relationnel",
    "title": "Modélisation II :",
    "section": "Entre modèle EA et modèle relationnel",
    "text": "Entre modèle EA et modèle relationnel\nDans le modèle EA\n\nPlusieurs types de briques de bases : Entités (noms) et Associations (verbes)\nPas a priori de moyen de représenter les schémas EA dans le formatlisme EA\nUn formalisme accessible (en principe) aux usagers du système d’information\n\nDans le modèles relationnel\n\nUne seule brique de base : les tables\nUn schéma est décrit par des tuples insérés dans les tables de la métabase"
  },
  {
    "objectID": "slides/Modelisation_2.html#objectifs",
    "href": "slides/Modelisation_2.html#objectifs",
    "title": "Modélisation II :",
    "section": "Objectifs",
    "text": "Objectifs\nUne technique de traduction du formalisme EA vers le formalisme relationnel\nTraduction des associations selon l’arité et les cardinalités\nVisualisation des contraintes référentielles via les pattes de corbeaux\nUn formalisme graphique très proche du modèle relationnel\nUn formalisme graphique utilisé en rétro-ingénierie\nUn formalisme graphique utilisé pour documenter les bases de données relationnelles"
  },
  {
    "objectID": "slides/Modelisation_2.html#origines",
    "href": "slides/Modelisation_2.html#origines",
    "title": "Modélisation II :",
    "section": "Origines",
    "text": "Origines\nCréé par Gordon Everest (fin des années 1970)\nNormalisé par Finkelstein et Martin"
  },
  {
    "objectID": "slides/Modelisation_2.html#diagrammes",
    "href": "slides/Modelisation_2.html#diagrammes",
    "title": "Modélisation II :",
    "section": "Diagrammes",
    "text": "Diagrammes\n\n\n\n\n\n\nDeux briques de base\n\n\nLes diagrammes en pattes de corbeau sont formés de tables et de liens entre tables.\n\n\n\n\n\n\n\n\n\nLes tables \n\n\nreprésentent :\n\ndes entités fortes\ndes entités faibles issues de la traduction d’associations \\(n\\)-aires et/ou d’associations plusieurs-vers-plusieurs\n\n\n\n\n\n\n\n\n\n\nLes liens \n\n\nreprésentent des associations binaires un-un, ou un-vers-plusieurs\nLes cardinalités sont visualisées par les extrémités des liens"
  },
  {
    "objectID": "slides/Modelisation_2.html#les-cardinalités",
    "href": "slides/Modelisation_2.html#les-cardinalités",
    "title": "Modélisation II :",
    "section": "Les cardinalités",
    "text": "Les cardinalités\n\n\n\n\nSymbole (gauche)\n\n\nSymbole (droite)\n\n\nInterprétation\n\n\n\n\n\n\n|o\n\n\no|\n\n\nZero ou un\n\n\n\n\n||\n\n\n||\n\n\nExactement un\n\n\n\n\n}o\n\n\no{\n\n\nZero ou plus (pas de borne supérieure)\n\n\n\n\n}|\n\n\n|{\n\n\nun ou plus (pas de borne supérieure)"
  },
  {
    "objectID": "slides/Modelisation_2.html#aliases",
    "href": "slides/Modelisation_2.html#aliases",
    "title": "Modélisation II :",
    "section": "Aliases",
    "text": "Aliases\n\n\n\n\nSymbole (gauche)\n\n\nSymbole (droite)\n\n\nAlias for\n\n\n\n\n\n\nun or zero\n\n\nun or zero\n\n\nZero ou un\n\n\n\n\nzero ou un\n\n\nzero ou un\n\n\nZero ou un\n\n\n\n\nun ou plus\n\n\nun ou plus\n\n\nun ou plus\n\n\n\n\nun or plusieurs\n\n\nun or plusieurs\n\n\nun ou plus\n\n\n\n\nplusieurs(1)\n\n\nplusieurs(1)\n\n\nun ou plus\n\n\n\n\n1+\n\n\n1+\n\n\nun ou plus\n\n\n\n\nzero ou plus\n\n\nzero ou plus\n\n\nZero ou plus\n\n\n\n\nzero or plusieurs\n\n\nzero or plusieurs\n\n\nZero ou plus\n\n\n\n\nplusieurs(0)\n\n\nplusieurs(0)\n\n\nZero ou plus\n\n\n\n\n0+\n\n\n0+\n\n\nZero ou plus\n\n\n\n\nonly un\n\n\nonly un\n\n\nExactement un\n\n\n\n\n1\n\n\n1\n\n\nExactement un"
  },
  {
    "objectID": "slides/Modelisation_2.html#liens-non-identifiants-exemples",
    "href": "slides/Modelisation_2.html#liens-non-identifiants-exemples",
    "title": "Modélisation II :",
    "section": "Liens non-identifiants : exemples",
    "text": "Liens non-identifiants : exemples\n\n\n\n\n\n\n\nerDiagram\n    COUNTRY ||..o{ CITY : contains\n    COUNTRY {\n      string(3) countrycode PK\n      string name_country\n      numeric population_country\n      integer capital  FK\n    }\n    CITY {\n      integer id PK\n      string(3) countrycode FK\n      string name\n      numeric population\n    }\n    CITY |o..o| COUNTRY : is-capital\n\n\n\n\n\n\n\n\nUne instance de COUNTRY contient entre \\(0\\) et un nombre non borné d’instances de CITY (patte de corbeau côté CITY)\nUne instance de CITY est toujours située sur une et une seule instance de COUNTRY\nUne instance de CITY est la capitale de \\(0\\) ou \\(1\\) intance de COUNTRY\nUne instance de COUNTRY possède \\(0\\) ou \\(1\\) capitale"
  },
  {
    "objectID": "slides/Modelisation_2.html#liens-identifiants",
    "href": "slides/Modelisation_2.html#liens-identifiants",
    "title": "Modélisation II :",
    "section": "Liens identifiants",
    "text": "Liens identifiants\n\n\n\n\n\n\nNote\n\n\nUn lien est identifiant si la clé primaire de l’émetteur contient une référence à la clé primaire de la table destinataire.\n\n\n\n\n\n\n\nExemple\n\nDans le schéma world le lien entre countrylanguage et country est identifiant : la clé primaire de countrylanguage est formée par (countrycode, language). L’attribut countrycode de countrylanguage fait référence à l’attribut countrycode de country (clé primaire de country)\n\n\n\n\n\n\n\n\nerDiagram\n    COUNTRY ||--|{ COUNTRYLANGUAGE : speaks\n    COUNTRY {\n      string countrycode\n      string name_country\n      numeric population_country\n    }\n    COUNTRYLANGUAGE {\n      string countrycode\n      string language\n      boolean isofficial\n      numeric percentage\n    }"
  },
  {
    "objectID": "slides/Modelisation_2.html#les-pattes-de-corbeau-comme-variante-du-modèle-entité-association",
    "href": "slides/Modelisation_2.html#les-pattes-de-corbeau-comme-variante-du-modèle-entité-association",
    "title": "Modélisation II :",
    "section": "Les pattes de corbeau comme variante du modèle Entité-Association ?",
    "text": "Les pattes de corbeau comme variante du modèle Entité-Association ?\n\n\n\n\n\n\nRemarque\n\n\nLa notation en pattes de corbeau est parfois/souvent présentée comme un variante de la modélisation Entité-Association (de Chen)\nC’est le cas dans l’outil de dessin mermaid\n\n\n\n\n\n\n\n\n\n\nObjection I :\n\n\nUn lien en notation pattes de corbeau définit une relation entre deux tables. Un lien en pattes de corbeau ne peut pas représenter directement un association d’arité supérieure à 2\n\n\n\n\n\n\n\n\n\n\n\nObjection II :\n\n\nUn lien en notation pattes de corbeau ne porte pas d’attributs propres\n\n\n\n\n\n\n\n\n\n\n\nConvention\n\n\nDans ce cours, la notation en pattes de corbeau est utilisée pour visualiser le modèle relationnel. Les liens permettent de souligner/visualiser les contraintes référentielles"
  },
  {
    "objectID": "slides/Modelisation_2.html#exemple-association-binaire-plusieurs-un-dans-schéma-world",
    "href": "slides/Modelisation_2.html#exemple-association-binaire-plusieurs-un-dans-schéma-world",
    "title": "Modélisation II :",
    "section": "Exemple association binaire plusieurs-un dans schéma world",
    "text": "Exemple association binaire plusieurs-un dans schéma world\n\n\n\n\n\n\nER\n\n\n\ncountry\n\ncountry\n\n\n\niso\n\niso3\n\n\n\ncountry--iso\n\n\n\n\ncity\n\ncity\n\n\n\nname1\n\nname\n\n\n\ncity--name1\n\n\n\n\nid\n\nid\n\n\n\ncity--id\n\n\n\n\nis-in\n\nis-in\n\n\n\ncity--is-in\n\n1:1\n\n\n\nname0\n\nname\n\n\n\nname0--country\n\n\n\n\npopulation\n\npopulation\n\n\n\npopulation--country\n\n\n\n\ngovernmentForm\n\ngovernmentForm\n\n\n\ngovernmentForm--country\n\n\n\n\nheadOfState\n\nheadOfState\n\n\n\nheadOfState--country\n\n\n\n\nis-in--country\n\n0:n"
  },
  {
    "objectID": "slides/Modelisation_2.html#traduction",
    "href": "slides/Modelisation_2.html#traduction",
    "title": "Modélisation II :",
    "section": "Traduction",
    "text": "Traduction\n\n\n\n\n\n\n\nerDiagram\n    COUNTRY ||..o{ CITY : contains\n    COUNTRY {\n      string(3) iso3 PK\n      string name_country\n      numeric population_country\n      string governmentForm\n      string headOfState\n    }\n    CITY {\n      integer id PK\n      string(3) iso3 FK\n      string name\n      numeric population\n    }\n\n\n\n\n\n\n\nUn lien non-identifiant depuis la table représentant l’entité de cardinalité \\(0:1\\) (CITY) vers la table représentant la cardinalité \\(0:n\\) (COUNTRY)\nLes éventuels attributs propres de l’association sont représentés par des attributs de la table représentant l’entité de cardinalité \\(0:1\\)\n\n\n\n\n\n\nMise en garde\n\n\nLa patte de corbeau 0{ est placée du côté de la table représentant l’entité de cardinalité \\(0:1\\) (CITY)"
  },
  {
    "objectID": "slides/Modelisation_2.html#une-association-plusieurs-plusieurs",
    "href": "slides/Modelisation_2.html#une-association-plusieurs-plusieurs",
    "title": "Modélisation II :",
    "section": "Une association plusieurs-plusieurs",
    "text": "Une association plusieurs-plusieurs\n\n\n\n\n\n\nER\n\n\n\ncountry\n\ncountry\n\n\n\niso\n\niso3\n\n\n\ncountry--iso\n\n\n\n\nlanguage\n\nlanguage\n\n\n\nname2\n\nname\n\n\n\nlanguage--name2\n\n\n\n\nisol\n\niso\n\n\n\nlanguage--isol\n\n\n\n\nis-spoken-in\n\nis-spoken-in\n\n\n\nlanguage--is-spoken-in\n\n0:n\n\n\n\nname0\n\nname\n\n\n\nname0--country\n\n\n\n\npopulation\n\npopulation\n\n\n\npopulation--country\n\n\n\n\ngovernmentForm\n\ngovernmentForm\n\n\n\ngovernmentForm--country\n\n\n\n\nheadOfState\n\nheadOfState\n\n\n\nheadOfState--country\n\n\n\n\npercentage\n\npercentage\n\n\n\nisofficial\n\nisofficial\n\n\n\nis-spoken-in--country\n\n0:n\n\n\n\nis-spoken-in--percentage\n\n\n\n\nis-spoken-in--isofficial"
  },
  {
    "objectID": "slides/Modelisation_2.html#transformation-préalable-à-laide-dune-entité-faible",
    "href": "slides/Modelisation_2.html#transformation-préalable-à-laide-dune-entité-faible",
    "title": "Modélisation II :",
    "section": "Transformation préalable à l’aide d’une entité faible",
    "text": "Transformation préalable à l’aide d’une entité faible\n\n\n\n\n\n\nER\n\n\n\ncountry\n\ncountry\n\n\n\niso\n\niso3\n\n\n\ncountry--iso\n\n\n\n\nspeaks\n\n\nspeaks\n\n\n\ncountry--speaks\n\n0:n\n\n\n\nlanguage\n\nlanguage\n\n\n\nname2\n\nname\n\n\n\nlanguage--name2\n\n\n\n\nisol\n\niso\n\n\n\nlanguage--isol\n\n\n\n\nis-spoken\n\n\nis-spoken\n\n\n\nlanguage--is-spoken\n\n0:n\n\n\n\nname0\n\nname\n\n\n\nname0--country\n\n\n\n\npopulation\n\npopulation\n\n\n\npopulation--country\n\n\n\n\ngovernmentForm\n\ngovernmentForm\n\n\n\ngovernmentForm--country\n\n\n\n\nheadOfState\n\nheadOfState\n\n\n\nheadOfState--country\n\n\n\n\npercentage\n\npercentage\n\n\n\nisofficial\n\nisofficial\n\n\n\ncountrylanguage\n\n\ncountrylanguage\n\n\n\ncountrylanguage--percentage\n\n\n\n\ncountrylanguage--isofficial\n\n\n\n\nspeaks--countrylanguage\n\n1:1\n\n\n\nis-spoken--countrylanguage\n\n1:1"
  },
  {
    "objectID": "slides/Modelisation_2.html#traduction-1",
    "href": "slides/Modelisation_2.html#traduction-1",
    "title": "Modélisation II :",
    "section": "Traduction",
    "text": "Traduction\n\n\n\n\n\n\n\nerDiagram\n    COUNTRY ||--o{ COUNTRYLANGUAGE : speaks\n    COUNTRY {\n      string(3) iso3 PK\n      string name_country\n      numeric population_country\n      string governmentForm\n      string headOfState\n    }\n    LANGUAGE ||--o{ COUNTRYLANGUAGE : is-spoken\n    LANGUAGE {\n      string(3) iso PK\n      string name\n    }\n    COUNTRYLANGUAGE {\n      string(3) iso PK, FK\n      string(3) iso3 PK, FK\n      boolean isofficial\n      numeric percentage\n    }\n\n\n\n\n\n\n\nLa table obtenue par traduction de l’entité faible est appelée table intermédiaire\nLa table intermédiaire COUNTRYLANGUAGE comporte les attributs propres (percentage, isofficial) de l’association originelle (qui sont aussi ceux de l’entité faible)\nLes deux associations faibles issues de l’entité faible sont traduites en liens identifiants entre l’entité intermédiaire et les tables traduisant les entités (ici COUNTRY et LANGUAGE)"
  },
  {
    "objectID": "slides/Modelisation_2.html#liens-identifiants-1",
    "href": "slides/Modelisation_2.html#liens-identifiants-1",
    "title": "Modélisation II :",
    "section": "Liens identifiants",
    "text": "Liens identifiants\nLes liens identifiants correspondent à des contraintes référentielles (comme les liens non-identifiants).\nLes liens identifiants témoignent du fait que les constituants de la clé primaire de la table intermédiaire (ici iso3 et isol) font référence aux clés primaires des tables COUNTRY (iso3) et LANGUAGE (isol)."
  },
  {
    "objectID": "slides/Modelisation_2.html#table-intermédiaire",
    "href": "slides/Modelisation_2.html#table-intermédiaire",
    "title": "Modélisation II :",
    "section": "Table intermédiaire",
    "text": "Table intermédiaire\n\n\n\n\n\n\n\n\n\nCaractérisation\n\n\nLes tables intermédiaires sont caractérisées par le fait que certaines composantes de leur clé primaire sont la source de contraintes référentielles vers la clé primaire d’une autre table.\n\n\n\n\n\n\n\n\n\n\n\n\nUsages\n\n\n\ntraduction des associations plusieurs-plusieurs\ntraduction des associations d’arité supérieure ou égale à 3\ntraduction des entités faibles\ntraduction des spécialisations"
  },
  {
    "objectID": "slides/Modelisation_2.html#exemple-de-lassociation-flight",
    "href": "slides/Modelisation_2.html#exemple-de-lassociation-flight",
    "title": "Modélisation II :",
    "section": "Exemple de l’association flight",
    "text": "Exemple de l’association flight\n\n\n\n\n\n\n\n\n\n\n\n\nER\n\n\n\nairport\n\nairport\n\n\n\nflight\n\nflight\n\n\n\nairport--flight\n\norig\n0:n\n\n\n\nplane\n\nplane\n\n\n\nairline\n\nairline\n\n\n\nflight--airport\n\ndest\n0:n\n\n\n\nflight--plane\n\n0:n\n\n\n\nflight--airline\n\n0:n"
  },
  {
    "objectID": "slides/Modelisation_2.html#transformation-de-lassociation-quarternaire-en-quatre-associations-binaires-faibles",
    "href": "slides/Modelisation_2.html#transformation-de-lassociation-quarternaire-en-quatre-associations-binaires-faibles",
    "title": "Modélisation II :",
    "section": "Transformation de l’association quarternaire en quatre associations binaires (faibles)",
    "text": "Transformation de l’association quarternaire en quatre associations binaires (faibles)\n\n\n\n\n\n\n\n\n\n\n\n\nER\n\n\n\nairport\n\nairport\n\n\n\norig\n\n\norig\n\n\n\nairport--orig\n\n0:n\n\n\n\ndest\n\n\ndest\n\n\n\nairport--dest\n\n0:n\n\n\n\nplane\n\nplane\n\n\n\nairline\n\nairline\n\n\n\nflight\n\n\nflight\n\n\n\noperates\n\n\noperates\n\n\n\nflight--operates\n\n1:1\n\n\n\nuses\n\n\nuses\n\n\n\nflight--uses\n\n1:1\n\n\n\norig--flight\n\n1:1\n\n\n\ndest--flight\n\n1:1\n\n\n\noperates--airline\n\n0:n\n\n\n\nuses--plane\n\n0:n\n\n\n\n\n\n\n\n\n\nL’association quarternaire est transformée en\n\nune entité faible. Chaque instance de cette entité faible représente une instance de l’association quaternaire\nquatre associations binaires faibles. Une instance de l’association binaire faible relie une instance de l’entité faible (association quaternaire) à l’instance de entité participante concernée\n\nEntre l’entité faible et une association faible, la cardinalité est toujours 1:1"
  },
  {
    "objectID": "slides/Modelisation_2.html#traduction-en-pattes-de-corbeau",
    "href": "slides/Modelisation_2.html#traduction-en-pattes-de-corbeau",
    "title": "Modélisation II :",
    "section": "Traduction en pattes de corbeau",
    "text": "Traduction en pattes de corbeau\n\n\n\n\n\n\n\n\n\n\n\nerDiagram\n    AIRPORT ||--o{ FLIGHT : takes-off\n    AIRPORT ||--o{ FLIGHT : lands-at\n    AIRLINE ||--o{ FLIGHT : operates\n    PLANE   ||--o{ FLIGHT : uses\n    AIRPORT {\n      string(3) faa PK\n      string name \n      numeric lat\n      numeric lon\n    }\n    AIRLINE {\n      string(3) faa PK\n      string name \n    }\n    PLANE {\n      string(3) tailnum PK \n      string model\n      string manufacturer\n      int year\n    }\n    FLIGHT {\n      string(3) origin  PK, FK\n      string(3) dest PK, FK\n      string tailnum PK, FK\n      string carrier PK, FK\n      int num PK\n      datetime dep_time PK\n    }\n\n\n\n\n\n\n\n\n\nUne fois la transformation de l’association quaternaire en une entité faible et quatre associations binaires un-plusieurs, la traduction ressemble à la traduction des associations binaires un-plusieurs\nL’entité faible est traduite en une table intermédiaire\nLes associations faibles sont traduites en liens identifiants"
  },
  {
    "objectID": "slides/Modelisation_2.html#un-traduction-immédiate",
    "href": "slides/Modelisation_2.html#un-traduction-immédiate",
    "title": "Modélisation II :",
    "section": "Un traduction immédiate ",
    "text": "Un traduction immédiate \nChaque table du modèle en pattes de corbeau correspond à une table/relation du modèle relationnel.\nLes liens du modèle en pattes de corbeau se traduisent en contraintes référentielles\n\n La proximité entre le modèle relationnel et les diagrammes en pattes de corbeau ouvrent la voie à la rétro-ingénierie"
  },
  {
    "objectID": "slides/Modelisation_2.html#rétro-ingénierie-reverse-engineering",
    "href": "slides/Modelisation_2.html#rétro-ingénierie-reverse-engineering",
    "title": "Modélisation II :",
    "section": "Rétro-ingénierie (reverse engineering)",
    "text": "Rétro-ingénierie (reverse engineering)\nL’ingénierie directe est normalement le processus de création d’un nouveau système (d’information) à partir de rien.\nLa rétro-ingénierie est le processus d’analyse d’un système existant pour comprendre sa conception et ses usages.\n\nUn SGBD mémorise la définition des schémas comme world dans un schéma particulier la métabase (information_schema + pg_catalog)\nLa rétro-ingénierie consiste à construire un diagramme en pattes de corbeau à partir des données de la métabase\nDe nombreux outils (plus ou moins payants) sont disponibles"
  },
  {
    "objectID": "slides/Modelisation_2.html#schéma-world",
    "href": "slides/Modelisation_2.html#schéma-world",
    "title": "Modélisation II :",
    "section": "Schéma world",
    "text": "Schéma world\n\nschema world"
  },
  {
    "objectID": "slides/Modelisation_2.html#ldd-create-schema-if-not-exists-world",
    "href": "slides/Modelisation_2.html#ldd-create-schema-if-not-exists-world",
    "title": "Modélisation II :",
    "section": "LDD CREATE SCHEMA IF NOT EXISTS world;",
    "text": "LDD CREATE SCHEMA IF NOT EXISTS world;\nCREATE  TABLE world.region_continent ( \n    region               text  NOT NULL  ,\n    continent            text    ,\n    CONSTRAINT pk_region_continent PRIMARY KEY ( region )\n );\n\nCREATE  TABLE world.city ( \n    id                   integer  NOT NULL  ,\n    name                 text  NOT NULL  ,\n    countrycode          char(3)  NOT NULL  ,\n    district             text  ,\n    population           integer ,\n    CONSTRAINT city_pkey PRIMARY KEY ( id )\n );"
  },
  {
    "objectID": "slides/Modelisation_2.html#créations-de-tables-suite",
    "href": "slides/Modelisation_2.html#créations-de-tables-suite",
    "title": "Modélisation II :",
    "section": "Créations de tables (suite)",
    "text": "Créations de tables (suite)\nCREATE  TABLE world.country ( \n    countrycode          char(3)  NOT NULL  ,\n    name_country         text  NOT NULL  ,\n    region               text  ,  \n    surfacearea          real   ,\n    indepyear            smallint    ,\n    population_country   integer     ,\n    lifeexpectancy       real    ,\n    gnp                  numeric(10,2)    ,\n    gnpold               numeric(10,2)    ,\n    localname            text  NOT NULL  ,\n    governmentform       text  NOT NULL  ,\n    headofstate          text    ,\n    capital              integer    ,\n    code2                char(2)  NOT NULL  ,\n    CONSTRAINT country_pkey PRIMARY KEY ( countrycode )\n );\n\n\nCREATE  TABLE world.countrylanguage ( \n    countrycode          char(3)  NOT NULL  ,\n    \"language\"           text  NOT NULL  ,\n    isofficial           boolean  NOT NULL  ,\n    percentage           real  NOT NULL  ,\n    CONSTRAINT countrylanguage_pkey PRIMARY KEY ( countrycode, \"language\" )\n );"
  },
  {
    "objectID": "slides/Modelisation_2.html#les-contraintes-référentielles",
    "href": "slides/Modelisation_2.html#les-contraintes-référentielles",
    "title": "Modélisation II :",
    "section": "Les contraintes référentielles",
    "text": "Les contraintes référentielles\nALTER TABLE world.city \n  ADD CONSTRAINT city_country_fk \n  FOREIGN KEY ( countrycode ) \n  REFERENCES world.country( countrycode ) \n  ON DELETE SET NULL ON UPDATE CASCADE DEFERRABLE;\n\nALTER TABLE world.country \n  ADD CONSTRAINT country_capital_fkey \n  FOREIGN KEY ( capital ) REFERENCES world.city( id ) \n  ON DELETE SET NULL ON UPDATE CASCADE;\n\nALTER TABLE world.country \n  ADD CONSTRAINT country_region_fk \n  FOREIGN KEY ( region ) REFERENCES world.region_continent( region ) \n  ON DELETE SET NULL ON UPDATE CASCADE DEFERRABLE;\n\nALTER TABLE world.countrylanguage \n  ADD CONSTRAINT countrylanguage_countrycode_fkey \n  FOREIGN KEY ( countrycode ) \n  REFERENCES world.country( countrycode );"
  },
  {
    "objectID": "slides/Modelisation_2.html#la-modélisation-un-exercice-très-général",
    "href": "slides/Modelisation_2.html#la-modélisation-un-exercice-très-général",
    "title": "Modélisation II :",
    "section": "La modélisation : un exercice très général",
    "text": "La modélisation : un exercice très général\nEn Informatique, la modélisation concerne aussi la conception des interfaces humains-machines, des sites WWW, des traitements divers, des entrepots de données, des lacs de données, ….\nChaque situation a suscité une méthode apropriée\n\nQuelques exemples :\n\nModèles Relation-Objet (Object Relational Model ORM)\nUML (Universal Modeling Language)\n\n\n\nLes modèles EA et pattes de corbeau ne sont que la partie émergée d’un iceberg"
  },
  {
    "objectID": "slides/LDD_0.html#définition-de-données",
    "href": "slides/LDD_0.html#définition-de-données",
    "title": "BD II: SQL LDD",
    "section": "Définition de données",
    "text": "Définition de données\nSQL est un monde à part entière\nOn peut :\n\nInterroger des données par des requêtes (déjà vu en partie)\nAdministrer les bases de données :\n\nCréer celles-ci : définition des tables (schémas, etc), contraintes..\nCréer de nouvelles données, en insérer, supprimer, mettre à jour, etc\nCréer et gérer les utilisateurs, leurs droits sur les objets de la base,\n…\n\n\n\nDans ce cours : création des tables (version simplifiée) et des données"
  },
  {
    "objectID": "slides/LDD_0.html#création-de-tables-1",
    "href": "slides/LDD_0.html#création-de-tables-1",
    "title": "BD II: SQL LDD",
    "section": "Création de tables",
    "text": "Création de tables\n\nInstruction : CREATE TABLE ...\n\nPermet de définir :\n\nLes noms et les domaines (type) des attributs ainsi que des contraintes d’intégrité comme :\n\nContraintes de clés primaires (PRIMARY KEY)\nContraintes référentielles (clés étrangères FOREIGN KEY, par exemple)\n\nDes contraintes assez générales (de contrôle des données)\nDes index (pour la recherche et l’exécution efficaces)"
  },
  {
    "objectID": "slides/LDD_0.html#création-de-tables-noms-et-domaines-dattributs",
    "href": "slides/LDD_0.html#création-de-tables-noms-et-domaines-dattributs",
    "title": "BD II: SQL LDD",
    "section": "Création de tables : noms et domaines d’attributs",
    "text": "Création de tables : noms et domaines d’attributs\nChaque relation est définie par un nom de relation et une liste d’attributs\nCREATE TABLE &lt;nom_relation&gt; (\n  &lt;element de relation&gt;\n  &lt;,element de relation&gt;*\n  &lt;,contrainte de relation&gt;* );\n\nChaque attribut est défini par un nom d’attribut et un type de données\n&lt;element de relation&gt; ::= &lt;nom_attrib&gt;&lt;type_donnees&gt;[&lt;contrainte_attrib&gt;*]\n\n\n\n\n\n\n\n\nExemples de types\n\n\n&lt;type_donnees&gt; ::=  VARCHAR &lt;longueur&gt;| INT | REAL | DATE"
  },
  {
    "objectID": "slides/LDD_0.html#exemple",
    "href": "slides/LDD_0.html#exemple",
    "title": "BD II: SQL LDD",
    "section": "Exemple",
    "text": "Exemple\nSchéma:\nfournisseur(nomf, villef),\npiece(nomp, prix, couleur),\nlivraison(numliv, nomf, nomp, dateliv, quantite)\n\nCREATE TABLE fournisseur(\n    nomf VARCHAR(20),\n    villef VARCHAR(20)\n);\n\nCREATE TABLE piece(\n    nomp VARCHAR(20),\n    prix REAL,\n    couleur VARCHAR(15)\n);"
  },
  {
    "objectID": "slides/LDD_0.html#exemple-avec-valeurs-par-défaut",
    "href": "slides/LDD_0.html#exemple-avec-valeurs-par-défaut",
    "title": "BD II: SQL LDD",
    "section": "Exemple avec valeurs par défaut",
    "text": "Exemple avec valeurs par défaut\n\nCREATE TABLE livraison(\n    numLiv INT,\n    nomf VARCHAR(20),\n    nomp VARCHAR(20),\n    dateliv DATE DEFAULT NOW(),\n    quantite INT DEFAULT 1\n);\n\n\n\n\n\n\n\n\nValeurs par défaut\n\n\n\nPour dateliv, c’est la date courante lors de l’insertion de la ligne dans la table\nPour quantite, c’est une constante"
  },
  {
    "objectID": "slides/LDD_0.html#exemple-schéma-world",
    "href": "slides/LDD_0.html#exemple-schéma-world",
    "title": "BD II: SQL LDD",
    "section": "Exemple : schéma world",
    "text": "Exemple : schéma world\n\nCREATE TABLE world.city (\n    id int4 NOT NULL,\n    name_city text NOT NULL,\n    countrycode bpchar(3) NOT NULL,\n    district text NOT NULL,\n    population_city int4 NOT NULL,\n    CONSTRAINT city_pkey\n        PRIMARY KEY (id)\n);\n\n\nCREATE TABLE world.code_continent (\n    continent name NOT NULL,\n    codecontinent int4 NOT NULL,\n    CONSTRAINT code_continent_pk\n        PRIMARY KEY (codecontinent)\n);"
  },
  {
    "objectID": "slides/LDD_0.html#exemple-schéma-world-avec-clé-primaire-composée",
    "href": "slides/LDD_0.html#exemple-schéma-world-avec-clé-primaire-composée",
    "title": "BD II: SQL LDD",
    "section": "Exemple : schéma world avec clé primaire composée",
    "text": "Exemple : schéma world avec clé primaire composée\n\nCREATE TABLE world.countrylanguage (\n    countrycode bpchar(3) NOT NULL,\n    \"language\" text NOT NULL,\n    isofficial bool NOT NULL,\n    percentage float4 NOT NULL,\n    CONSTRAINT countrylanguage_pkey\n        PRIMARY KEY (countrycode, language)\n);\n\n\n\n\n\n\n\n\nAttention\n\n\nUne clé peut être composée de plusieurs attributs"
  },
  {
    "objectID": "slides/LDD_0.html#exemple-schéma-world-suite",
    "href": "slides/LDD_0.html#exemple-schéma-world-suite",
    "title": "BD II: SQL LDD",
    "section": "Exemple: schéma world (suite)",
    "text": "Exemple: schéma world (suite)\n\nCREATE TABLE world.country (\n    countrycode bpchar(3) NOT NULL,\n    name_country text NOT NULL,\n    continent text NOT NULL,\n    region text NOT NULL,\n    surfacearea float4 NOT NULL,\n    indepyear int2 NULL,\n    population_country int4 NOT NULL,\n    lifeexpectancy float4 NULL,\n    gnp numeric(10, 2) NULL,\n    gnpold numeric(10, 2) NULL,\n    localname text NOT NULL,\n    governmentform text NOT NULL,\n    headofstate text NULL,\n    capital int4 NULL,\n    code2 bpchar(2) NOT NULL,\n    CONSTRAINT country_continent_check CHECK (\n        ((continent = 'Asia'::text) OR (\n            continent = 'Europe'::text) OR\n            (continent = 'North America'::text) OR\n            (continent = 'Africa'::text) OR\n            (continent = 'Oceania'::text) OR\n            (continent = 'Antarctica'::text) OR\n            (continent = 'South America'::text))),\n    CONSTRAINT country_pkey PRIMARY KEY (countrycode)\n);"
  },
  {
    "objectID": "slides/LDD_0.html#suppression-dune-table",
    "href": "slides/LDD_0.html#suppression-dune-table",
    "title": "BD II: SQL LDD",
    "section": "Suppression d’une table",
    "text": "Suppression d’une table\nDROP TABLE fournisseur;\nDROP TABLE piece;\nDROP TABLE livraison;\n\n\n\n\n\n\nSuppression n’est pas vidange\n\n\nSupprimer une table, c’est supprimer son contenu (vidange) mais aussi son schéma"
  },
  {
    "objectID": "slides/LDD_0.html#contenu-des-relations",
    "href": "slides/LDD_0.html#contenu-des-relations",
    "title": "BD II: SQL LDD",
    "section": "Contenu des relations",
    "text": "Contenu des relations\nOn peut gérer le contenu des tables directement dans le langage SQL.\nOn peut donc :\n\n\nAjouter des tuples à une table : INSERT INTO ...\nMettre à jour des tuples d’une relation : UPDATE ...\nSupprimer des tuples : DELETE FROM ..."
  },
  {
    "objectID": "slides/LDD_0.html#insertion-de-tuples-syntaxe",
    "href": "slides/LDD_0.html#insertion-de-tuples-syntaxe",
    "title": "BD II: SQL LDD",
    "section": "Insertion de tuples : syntaxe",
    "text": "Insertion de tuples : syntaxe\n\nINSERT INTO &lt;nom_relation&gt;\n    [(nom_attrib [, nom_attrib]*)]\n    VALUES (valeur [, valeur]*);\n\n\n\nINSERT INTO piece VALUES('x21', 1.51, 'rouge');\n\nINSERT INTO piece (nomp,couleur) VALUES('x22', 'vert');\n\n+--------+--------+-----------+\n| nomp   | prix   | couleur   |\n|--------+--------+-----------|\n| x21    | 1.51   | rouge     |\n| x22    | &lt;null&gt; | vert      |\n+--------+--------+-----------+\n\n\n\n\n\n\n\nAttention\n\n\n\nLes valeurs doivent être fournies dans l’ordre de déclaration des attributs\nLes valeurs non spécifiées sont affectées à NULL"
  },
  {
    "objectID": "slides/LDD_0.html#insertion-exemple-suite",
    "href": "slides/LDD_0.html#insertion-exemple-suite",
    "title": "BD II: SQL LDD",
    "section": "Insertion, exemple (suite)",
    "text": "Insertion, exemple (suite)\nINSERT INTO world.Country\n  (countrycode, name_country, continent,\n   region, surfacearea, indepyear, population_country,\n   lifeexpectancy, gnp, gnpold,\n   localname, governmentform, headofstate, capital, code2)\nVALUES(\n    'SYL', 'Syldavia', 'Europe',\n    'Eastern Europe', 200000, 1918, 21345717, 81.2, 25213, 24878,\n    'Syldavie', 'Constitutional Monarchy', 'Ottokar II', 0, 'SY'\n);"
  },
  {
    "objectID": "slides/LDD_0.html#remarques",
    "href": "slides/LDD_0.html#remarques",
    "title": "BD II: SQL LDD",
    "section": "Remarques",
    "text": "Remarques\nLa dernière partie du constructeur multiligne, qui commence avec VALUES est souvent appelée la liste de valeurs.\n\nUne liste de valeurs peut être définie sans référene à une table existante et définir à la volée une nouvelle table virtuelle/éphémère.\n\n\n\nSELECT *\nFROM (\n  VALUES\n    ('robe', 'logged in', '2011-01-10 10:15 AM EST'::timestamptz),\n    ('lhsu', 'logged out', '2011-01-11 10:20 AM EST'::timestamptz)\n) AS l (user_name, description, log_ts);\n\n\n\n\nQuand on utilise VALUES pour définir une table virtuelle, il faut spécifier le nom des colonnes.\nPar défaut, les types des colonnes sont inférés. Si l’inférence de type n’est pas possible, il faut effectuer explicitement des conversions de type comme ici avec ::timestamptz."
  },
  {
    "objectID": "slides/LDD_0.html#exemple-insertion-de-tuples-suite",
    "href": "slides/LDD_0.html#exemple-insertion-de-tuples-suite",
    "title": "BD II: SQL LDD",
    "section": "Exemple : Insertion de tuples (suite)",
    "text": "Exemple : Insertion de tuples (suite)\nINSERT INTO livraison\n    VALUES\n    (1, 'fournisseur1', 'x21', '2019-07-13', 2);\n\n-- Avec des colonnes pas renseignées\n\nINSERT INTO livraison\n   (numliv, dateliv, quantite)\n    VALUES\n   (2, '2018-07-29', 10);\n\n\n+----------+--------------+--------+------------+------------+\n| numliv   | nomf         | nomp   | dateliv    | quantite   |\n|----------+--------------+--------+------------+------------|\n| 1        | fournisseur1 | x21    | 2019-07-13 | 2          |\n| 2        | &lt;null&gt;       | &lt;null&gt; | 2018-07-29 | 10         |\n+----------+--------------+--------+------------+------------+\n\n\n\n\n\n\nRappel\n\n\n\nLes valeurs doivent être fournies dans l’ordre de déclaration des attributs\nLes valeurs non spécifiées sont affectées à NULL."
  },
  {
    "objectID": "slides/LDD_0.html#insertion-de-tuples-par-requête",
    "href": "slides/LDD_0.html#insertion-de-tuples-par-requête",
    "title": "BD II: SQL LDD",
    "section": "Insertion de tuples par requête",
    "text": "Insertion de tuples par requête\n\nOn peut faire une insertion par le biais d’une requête\nLa clause VALUES est remplacée par une requête\nLes résultats de la requête sont insérés comme valeurs dans la table\n\n\n\n\n\n\n\n\nAlimentation d’une nouvelle table à l’aide des données d’une autre\n\n\nINSERT INTO FournisseursParisiens (\n  SELECT *\n  FROM Fournisseur\n  WHERE VilleF='Paris'\n);"
  },
  {
    "objectID": "slides/LDD_0.html#exemple-1",
    "href": "slides/LDD_0.html#exemple-1",
    "title": "BD II: SQL LDD",
    "section": "Exemple",
    "text": "Exemple\nCREATE TABLE chaprot.city () \n  INHERITS (world.city) ;\n\nCREATE TABLE chaprot.country () \n  INHERITS (world.country) ;\n\nINSERT INTO chaprot.country (\n    SELECT * \n    FROM world.country\n    WHERE continent = 'Europe' \n);\n\nINSERT INTO chaprot.city (\n    SELECT ci.*  \n    FROM world.city ci NATURAL JOIN \n      world.country co\n    WHERE co.continent = 'Europe'\n) ;"
  },
  {
    "objectID": "slides/LDD_0.html#mise-à-jour-de-colonnes-ed-cellules",
    "href": "slides/LDD_0.html#mise-à-jour-de-colonnes-ed-cellules",
    "title": "BD II: SQL LDD",
    "section": "Mise à jour de colonnes, ed cellules",
    "text": "Mise à jour de colonnes, ed cellules\n\nOn peut mettre à jour des tuples existants par le biais d’une requête\n\nSoit tous les tuples de la table,\nSoit l’ensemble des tuples vérifiants une condition donnée\n\n\n\nUPDATE nom_relation\nSET nom_attribut = &lt;expression de valeur&gt; \n    [ , nom_attribut = &lt;expression de valeur&gt; ]*\n[WHERE &lt;condition de recherche&gt; ];"
  },
  {
    "objectID": "slides/LDD_0.html#mise-à-jour-conditionnelle-de-tuples",
    "href": "slides/LDD_0.html#mise-à-jour-conditionnelle-de-tuples",
    "title": "BD II: SQL LDD",
    "section": "Mise à jour conditionnelle de tuples",
    "text": "Mise à jour conditionnelle de tuples\nLe WHERE permet de sélectionner les tuples à mettre à jour\nUPDATE Fournisseur\nSET VilleF='St.Petersburg'\nWHERE VilleF='Leningrad';\nOn peut aussi effectuer des opérations sur les tuples à mettre à jour.\n\n\n\n\n\n\nLa clause &lt;expression de valeur&gt; peut être :\n\n\n\nNULL\nUne constante (explicite ou via une requête)\nUne expression arithmétique sur les attributs de la table à modifier"
  },
  {
    "objectID": "slides/LDD_0.html#mise-à-jour-de-tuples-exemple",
    "href": "slides/LDD_0.html#mise-à-jour-de-tuples-exemple",
    "title": "BD II: SQL LDD",
    "section": "Mise à jour de tuples (exemple)",
    "text": "Mise à jour de tuples (exemple)\nAugmentation du prix d’une pièce\nUPDATE Piece\nSET Prix = Prix * 1.05\nWHERE NomP = 'x21';"
  },
  {
    "objectID": "slides/LDD_0.html#mise-à-jour-par-requête",
    "href": "slides/LDD_0.html#mise-à-jour-par-requête",
    "title": "BD II: SQL LDD",
    "section": "Mise à jour par requête",
    "text": "Mise à jour par requête\nUPDATE Piece\nSET Prix = (\n    SELECT Prix\n    FROM Piece\n    WHERE NomP = 'x21'\n)\nWHERE Prix &lt;= 1000;"
  },
  {
    "objectID": "slides/LDD_0.html#suppression-de-tuples-syntaxe",
    "href": "slides/LDD_0.html#suppression-de-tuples-syntaxe",
    "title": "BD II: SQL LDD",
    "section": "Suppression de tuples : syntaxe",
    "text": "Suppression de tuples : syntaxe\nDELETE FROM &lt;nom_relation&gt;\n[WHERE &lt;condition de recherche&gt;];\n\nExemple\nDELETE FROM Fournisseur\nWHERE NomF = 'FastDelivery';\nOn supprime dans Fournisseur les tuples correspondant au fournisseur nommé 'FastDelivery'"
  },
  {
    "objectID": "slides/LDD_0.html#suppression-de-tuples-avec-requête-imbriquée",
    "href": "slides/LDD_0.html#suppression-de-tuples-avec-requête-imbriquée",
    "title": "BD II: SQL LDD",
    "section": "Suppression de tuples avec requête imbriquée",
    "text": "Suppression de tuples avec requête imbriquée\nDELETE FROM Livraison\nWHERE NomP IN (\n    SELECT NomP\n    FROM Piece\n    WHERE Couleur='Rouge'\n);"
  },
  {
    "objectID": "slides/LDD_0.html#delete-from-table-using-t-where-...",
    "href": "slides/LDD_0.html#delete-from-table-using-t-where-...",
    "title": "BD II: SQL LDD",
    "section": "DELETE FROM <table> USING <t> WHERE ...",
    "text": "DELETE FROM &lt;table&gt; USING &lt;t&gt; WHERE ...\n\n\n\n\n\n\nNote\n\n\nSouvent, lorsque vous supprimez des données d’une table, vous souhaitez supprimer ces données en fonction de leur présence dans un autre ensemble de données.\nSpécifiez cet ensemble supplémentaire avec le prédicat USING"
  },
  {
    "objectID": "slides/LDD_0.html#delete-from-table-using-t-where-...-1",
    "href": "slides/LDD_0.html#delete-from-table-using-t-where-...-1",
    "title": "BD II: SQL LDD",
    "section": "DELETE FROM <table> USING <t> WHERE ...",
    "text": "DELETE FROM &lt;table&gt; USING &lt;t&gt; WHERE ...\n\n\n\n\n\n\nAstuce\n\n\nSouvent, lorsque vous supprimez des données d’une table, vous souhaitez supprimer ces données en fonction de leur présence dans un autre ensemble de données.\nSpécifiez cet ensemble supplémentaire avec le prédicat USING\n\n\n\n\nDELETE FROM chaprot.city \nUSING chaprot.country AS co\nWHERE \n  city.countrycode = co.countrycode AND \n  co.region= 'Eastern Europe' AND \n  co.indepyear = 1991 ;"
  },
  {
    "objectID": "solutions/td6.html",
    "href": "solutions/td6.html",
    "title": "TD 6 : Contraintes",
    "section": "",
    "text": "Avec solutions"
  },
  {
    "objectID": "solutions/td6.html#contraintes-check.",
    "href": "solutions/td6.html#contraintes-check.",
    "title": "TD 6 : Contraintes",
    "section": "Contraintes CHECK.",
    "text": "Contraintes CHECK.\nCette contrainte permet de vérifier que les colonnes d’une ligne donnée vérifient une certaine condition. Par exemple, on pourrait vouloir vérifier que la valeur de la colonne percentage de la table countrylanguage est inférieure à 100 ou que la valeur de la colonne return_date de la table rental est soit NULL ou supérieure à rental_date. Ces contraintes se définissent lors de la création de la table. Par exemple :\nCREATE TABLE solde(\n    produit TEXT,\n    reduc_pourcentage INT,\n    CHECK (reduc_pourcentage&lt;=100 AND reduc_pourcentage%10=0)\n);\nOn peut ajouter une contrainte CHECK à une table qui existe déjà. Par exemple :\nALTER TABLE solde ADD \n    CHECK (reduc_pourcentage &gt;=0);\nou bien en nommant la contrainte :\nALTER TABLE solde \n    ADD CONSTRAINT reduc_positive \n    CHECK (reduc_pourcentage &gt;=0);"
  },
  {
    "objectID": "solutions/td6.html#contraintes-default-not-null-unique",
    "href": "solutions/td6.html#contraintes-default-not-null-unique",
    "title": "TD 6 : Contraintes",
    "section": "Contraintes DEFAULT / NOT NULL / UNIQUE",
    "text": "Contraintes DEFAULT / NOT NULL / UNIQUE\nCes contraintes s’appliquent à une colonne en particulier. La contrainte DEFAULT spécifie une valeur par défaut pour remplir une colonne lorsque sa valeur n’est pas spécifiée, NOT NULL que la valeur de la colonne ne peut pas être NULL et UNIQUE que deux lignes différentes de la table ne peuvent pas avoir la même valeur sur les colonnes indiquées. Par exemple:\nCREATE TABLE membre(\n    nom VARCHAR(50) NOT NULL,\n    prenom VARCHAR(50) NOT NULL,\n    date_inscription DATE DEFAULT NOW(),\n    UNIQUE(nom, prenom)  \n);"
  },
  {
    "objectID": "solutions/td6.html#contraintes-primaryforeign-key.",
    "href": "solutions/td6.html#contraintes-primaryforeign-key.",
    "title": "TD 6 : Contraintes",
    "section": "Contraintes PRIMARY/FOREIGN KEY.",
    "text": "Contraintes PRIMARY/FOREIGN KEY.\nFormellement, la contrainte PRIMARY KEY est équivalente à UNIQUE et NOT NULL. C’est un moyen d’identifier de façon unique chaque ligne. Chaque table est censée avoir une clé primaire. La contrainte FOREIGN KEY spécifie que la valeur d’une (ou de plusieurs) colonne contient des valeurs présentes dans une autre table. Par exemple, la colonne capital de country contient une valeur qui doit apparaître dans la colonne id de city. Par exemple:\nCREATE TABLE membre(\n    nom VARCHAR(50) NOT NULL, \n    prenom VARCHAR(50) NOT NULL, \n    id INT, \nPRIMARY KEY (id)\n);\n\nCREATE TABLE amis(\n    id1 INT, \n    id2 INT,\n  FOREIGN KEY (id1) REFERENCES membre (id)\n);\nOn peut aussi ajouter une seconde clef étrangère comme ceci :\nALTER TABLE amis ADD \n    FOREIGN KEY (id2) REFERENCES membre;"
  },
  {
    "objectID": "solutions/td6.html#contraintes-exclude.",
    "href": "solutions/td6.html#contraintes-exclude.",
    "title": "TD 6 : Contraintes",
    "section": "Contraintes EXCLUDE.",
    "text": "Contraintes EXCLUDE.\nLes contraintes NOT NULL, DEFAULT, KEY, CHECK portent uniquement sur une ligne tandis que la contrainte UNIQUE permet uniquement de tester des égalités entre lignes. On veut parfois vérifier une condition plus riche sur deux lignes. Par exemple, si notre table contient des réservations d’une salle entre start_date et end_date, on ne veut pas que deux réservations se chevauchent. On écrira:\nCREATE TABLE reservation(\n    start_date DATE, \n    end_date DATE,\n\n    EXCLUDE USING gist (\n        daterange(start_date, end_date) WITH &&)\n);"
  },
  {
    "objectID": "solutions/td-recap-sql.html",
    "href": "solutions/td-recap-sql.html",
    "title": "TD Récapitulatif SQL",
    "section": "",
    "text": "Avec solutions"
  },
  {
    "objectID": "solutions/td-recap-sql.html#schéma-world",
    "href": "solutions/td-recap-sql.html#schéma-world",
    "title": "TD Récapitulatif SQL",
    "section": "Schéma world",
    "text": "Schéma world\n\n\n\n\n\n\nQuestion\n\n\n\nQuel est le pays qui a le plus de villes recensées dans la table world.city? Combien de villes ? (363 villes)\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH country_city AS\n    (SELECT name_country , COUNT(name_city) nbrcity\n    FROM world.country NATURAL JOIN world.city\n    GROUP BY name_country)\n\nSELECT name_country, nbrcity\nFROM country_city\nWHERE nbrcity = (SELECT MAX(nbrcity) \n                 FROM country_city) ;\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuels sont les pays qui ont \\(3\\) ou plus langues officielles ? (8 lignes)\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT name_country\nFROM world.country NATURAL JOIN world.countrylanguage\nWHERE isofficial\nGROUP BY name_country HAVING COUNT(*) &gt; 2 ;\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuels sont les pays dont plus de \\(1.000.000\\) d’habitants parlent une langue non officielle ? (72 lignes)\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT DISTINCT name_country\nFROM world.country NATURAL JOIN world.countrylanguage\nWHERE (NOT isofficial) AND \n      (percentage / 100) * population_country &gt;= 1000000 ;\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuelles sont les langues qui sont officielles dans tous les continents où au moins une langue est parlée ? (1 ligne)\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS\n    (SELECT count(DISTINCT continent)\n    FROM world.country NATURAL JOIN world.countrylanguage)\nSELECT language, count(DISTINCT continent) as nbcon\nFROM world.country NATURAL JOIN world.countrylanguage WHERE isofficial\nGROUP BY language\n    HAVING count(DISTINCT continent) in (SELECT * FROM R)\nORDER BY nbcon DESC ;\n\n\nou\n\n\n\n\n\n\nSolution\n\n\n\nWITH continent_language AS\n    (SELECT DISTINCT language , continent\n    FROM country NATURAL JOIN countrylanguage\n    WHERE isofficial),\nall_continent_language AS\n    (SELECT DISTINCT l.language , c.continent\n    FROM countrylanguage l , continent_language c),\nnot_continent_language AS\n    ((SELECT * FROM all_continent_language)\n    EXCEPT\n    (SELECT * FROM continent_language))\nSELECT DISTINCT language\nFROM countrylanguage\nWHERE language NOT IN (SELECT language FROM not_continent_language) ;\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuels sont les pays pour lesquels une langue non officielle est parlée par strictement plus de monde (dans le pays) qu’il n’y a d’habitants dans la capitale ? (118 lignes)\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT DISTINCT name_country\nFROM (country c JOIN city ON id = capital)\n    JOIN countrylanguage l ON c.countrycode = l.countrycode\nWHERE NOT isofficial\nAND percentage / 100 * population_country &gt; population_city ;\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuels est le nombre de villes par region ?\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT region , COUNT(id) AS nbr_city\nFROM country NATURAL JOIN city\nGROUP BY region ;"
  },
  {
    "objectID": "solutions/td-recap-sql.html#schéma-pagila",
    "href": "solutions/td-recap-sql.html#schéma-pagila",
    "title": "TD Récapitulatif SQL",
    "section": "Schéma pagila",
    "text": "Schéma pagila\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuel est l’acteur (actor_id) présent sur le plus de DVD (inventory_id) ?\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH actor_dvd AS\n    (SELECT actor_id , count(inventory_id) nbrdvd\n    FROM actor NATURAL JOIN film_actor NATURAL JOIN inventory\n    GROUP BY actor_id)\nSELECT first_name , last_name\nFROM actor NATURAL JOIN actor_dvd\nWHERE nbrdvd = (SELECT MAX(nbrdvd) FROM actor_dvd) ;\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuel est le prix moyen d’une location de DVD ?\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT AVG(amount) \nFROM payment ;\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuel est le DVD qui a rapporté le plus d’argent ? Le film (film_id)?\n\n\n\n\n\n\n\n\nSolution\n\n\n\nPour le DVD:\nWITH inventory_amount AS\n    (SELECT inventory_id , SUM(amount) AS dollar\n    FROM inventory NATURAL JOIN rental NATURAL JOIN payment\n    GROUP BY inventory_id)\nSELECT inventory_id , dollar\nFROM  inventory_amount\nWHERE dollar &gt;= ALL (SELECT dollar FROM inventory_amount) ;\n\n\n\n\n\n\n\n\nSolution\n\n\n\nEt pour le film:\nWITH film_amount AS\n    (SELECT film_id , SUM(amount) AS dollar\n    FROM inventory NATURAL JOIN rental NATURAL JOIN payment\n    GROUP BY film_id)\nSELECT film_id , dollar\nFROM  inventory_amount\nWHERE dollar &gt;= ALL (SELECT dollar FROM film_amount) ;\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuels sont les employés (staff_id) qui travaillent dans une autre ville que celle dans laquelle ils vivent ? (4 lignes)\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH staff_maison AS\n    (SELECT staff_id , city_id\n    FROM (staff NATURAL JOIN address)),\nstaff_travail AS\n    (SELECT staff_id , city_id\n    FROM (staff p JOIN store s ON p.store_id = s.store_id) , address a\n    WHERE a.address_id = s.address_id)\nSELECT staff_id FROM staff_travail NATURAL JOIN staff_maison ;"
  },
  {
    "objectID": "solutions/td1.html",
    "href": "solutions/td1.html",
    "title": "TD 1: Algèbre relationnelle",
    "section": "",
    "text": "Avec solutions"
  },
  {
    "objectID": "solutions/td1.html#schémas",
    "href": "solutions/td1.html#schémas",
    "title": "TD 1: Algèbre relationnelle",
    "section": "Schémas",
    "text": "Schémas\nLes schémas sont une abstraction spécifique à PostgreSQL. Les schémas permettent de faire cohabiter sur une même base de données (ou catalogue dans le jargon PostgreSQL) plusieurs ensembles d’informations de nature différentes. On peut indiquer à pgcli, psql ou un autre client (dbeaver ou autre) quels schémas on veut utiliser par défaut.\nDans ce TP, nous allons nous concentrer sur le schéma world qui contient des informations concernant des villes et des pays/territoires du monde entier. Au cours de ce semestre, nous serons amenés à utiliser d’autres schémas : pagila qui contient des informations concernant des films, …\nPour lister et modifier les schémas de votre environnement de travail:\nbd_2023-24&gt; SHOW search_path ;                  -- lister\nbd_2023-24&gt; SET search_path TO world, public ;  -- modifier\nbd_2023-24&gt; SHOW search_path ;       -- visualiser \nLister les schémas du catalogue bd_2023-24.\n\\dn\nPour lister les tables des schemas inscrits sur votre search_path.\nbd_2023-24&gt; \\d\n+----------+---------------------+--------+----------+\n| Schema   | Name                | Type   | Owner    |\n|----------+---------------------+--------+----------|\n| world    | city                | table  | postgres |\n| world    | country             | table  | postgres |\n| world    | countrylanguage     | table  | postgres |\n+----------+---------------------+--------+----------+\nVue d’ensemble du schéma world"
  },
  {
    "objectID": "solutions/td1.html#suggestion",
    "href": "solutions/td1.html#suggestion",
    "title": "TD 1: Algèbre relationnelle",
    "section": "Suggestion",
    "text": "Suggestion\nSi vous travaillez avec pgcli/psql, utilisez en local votre éditeur préféré (emacs, vi, sublime text, visual studio code, …), transférez votre script sql grâce à scp, et chargez le script dans votre session psql/pgcli à l’aide de \\\\i."
  },
  {
    "objectID": "solutions/td1.html#tables",
    "href": "solutions/td1.html#tables",
    "title": "TD 1: Algèbre relationnelle",
    "section": "Tables",
    "text": "Tables\nPour voir la définition (c’est-à-dire les différentes colonnes) d’une table:\nbd_2023-24&gt; \\d world.country\n\n+--------------------+---------------+-------------+\n| Column             | Type          | Modifiers   |\n|--------------------+---------------+-------------|\n| countrycode        | character(3)  |  not null   |\n| name_country       | text          |  not null   |\n| continent          | text          |  not null   |\n| region             | text          |  not null   |\n| surfacearea        | real          |  not null   |\n| indepyear          | smallint      |             |\n| population_country | integer       |  not null   |\n| lifeexpectancy     | real          |             |\n| gnp                | numeric(10,2) |             |\n| gnpold             | numeric(10,2) |             |\n| localname          | text          |  not null   |\n| governmentform     | text          |  not null   |\n| headofstate        | text          |             |\n| capital            | integer       |             |\n| code2              | character(2)  |  not null   |\n+--------------------+---------------+-------------+"
  },
  {
    "objectID": "solutions/td1.html#explorer-les-possibilités-de-psql-ou-de-pgcli",
    "href": "solutions/td1.html#explorer-les-possibilités-de-psql-ou-de-pgcli",
    "title": "TD 1: Algèbre relationnelle",
    "section": "Explorer les possibilités de psql ou de pgcli",
    "text": "Explorer les possibilités de psql ou de pgcli\nbd_2023-24&gt; \\?\nDans la deuxième partie du TP, on s’intéresse aux requêtes, c’est-à-dire, les moyens d’extraire une information pertinente d’une base de données."
  },
  {
    "objectID": "solutions/td3.html",
    "href": "solutions/td3.html",
    "title": "TD 3: SQL",
    "section": "",
    "text": "Avec solutions\nObjectifs de la séance:\nEn plus du schéma world, nous allons utiliser le schéma pagila qui contient des informations utilisées par un chaîne fictive de magasins de location de DVD.\nLe schéma pagila est visible ici.\nSous psql ou pgli, vous pouvez aussi inspecter les tables comme d’habitude avec"
  },
  {
    "objectID": "solutions/td3.html#requêtes-imbriquées",
    "href": "solutions/td3.html#requêtes-imbriquées",
    "title": "TD 3: SQL",
    "section": "Requêtes imbriquées",
    "text": "Requêtes imbriquées\nLes requêtes imbriquées permettent d’utiliser le résultat d’une requête dans la clause WHERE.\nOn utilisera essentiellement les opérateurs suivants: IN, EXISTS, ALL, ANY.\nIN permet de tester la présence d’une valeur dans le résultat d’une requête.\nEXISTS renvoie True si la requête donnée est non-vide et False sinon. On peut les combiner avec NOT pour inverser leur comportement: NOT IN et NOT EXISTS. Par exemple, pour connaître les régions sans monarchie, on pourra écrire:\nSELECT DISTINCT region \nFROM world.country\nWHERE region NOT IN (\n  SELECT region\n  FROM world.country\n  WHERE governmentform like '%Monarchy%'\n);\nPour connaître les régions qui ont au moins une langue officielle, on pourra écrire:\nSELECT DISTINCT region \nFROM world.country AS co\nWHERE EXISTS (\n  SELECT *\n  FROM world.countrylanguage AS cl\n  WHERE co.countrycode = cl.countrycode AND \n    cl.isofficial\n);\nRemarquez que dans ce dernier exemple, la sous-requête fait intervenir des attributs de la requête principale, c’est pourquoi on parle de requêtes imbriquées.\nANY et ALL sont deux autres opérateurs. Par exemple\nSELECT * \nFROM table \nWHERE col &lt; ALL(\n  requete\n)\nsélectionnera les lignes de table telles que la valeur de col est plus petite que toutes les valeurs retournées par la requête requete. Ainsi, la requête\nSELECT * \nFROM world.country\nWHERE population_country &gt;= ALL(\n  SELECT population_country \n  FROM world.country\n);\nretournera la liste des pays les plus peuplés.\nSELECT * \nFROM table \nWHERE col &lt; ANY(\n  requete\n)\nsélectionnera les lignes de table telles que la valeur de col est strictement plus petite qu’au moins une des valeurs retournées par la requête requete.\nPour connaître les régions où l’on ne trouve qu’une seule forme de gouvernement, on pourra écrire:\nSELECT DISTINCT region \nFROM world.country as c1\nWHERE c1.governmentform = ALL(\n  SELECT c2.governmentform \n  FROM world.country as c2\n  WHERE c2.countrycode!=c1.countrycode AND \n    c2.region=c1.region\n);\n\n\n\n\n\n\nOn remarque que dans EXISTS ou IN on peut utiliser des attributs de notre requête globale, ce qui les rend plus puissants que\nWITH ... AS (\n  ...\n)"
  },
  {
    "objectID": "solutions/td3.html#jointure-externe",
    "href": "solutions/td3.html#jointure-externe",
    "title": "TD 3: SQL",
    "section": "Jointure externe",
    "text": "Jointure externe\nLa jointure externe est une jointure un peu particulière. On a vu la semaine dernière que lorsqu’on faisait une jointure, les lignes de la table de droit étaient recollées aux lignes de la table de gauche. Si une ligne a gauche ne pouvaient pas être recollée, elle disparaissait de la jointure. La jointure extérieure permet de garder ces lignes-là malgré tout.\nOn utilisera LEFT JOIN et RIGHT JOIN. Par exemple, la requête suivante renvoie la liste des pays et leur langages. Les pays qui ne se trouvent pas dans la table countrylanguage (il y en a, l’Antarctique par exemple) seront listés quand même et les informations manquantes seront remplies avec des valeurs NULL.\nSELECT * \nFROM world.country AS p LEFT JOIN \n  world.countrylanguage AS l ON \n  p.countrycode = l.countrycode;\nOn peut utiliser cette requête pour trouver les pays qui n’ont pas de langue officielle par exemple:\nSELECT * \nFROM world.country as p LEFT JOIN \n  world.countrylanguage AS l ON \n  p.countrycode = l.countrycode AND l.isofficial\nWHERE l.countrycode IS NULL;"
  },
  {
    "objectID": "solutions/td3.html#requêtes",
    "href": "solutions/td3.html#requêtes",
    "title": "TD 3: SQL",
    "section": "Requêtes",
    "text": "Requêtes\n\nQuels sont les langues qui ne sont officielles dans aucun pays ? (355 lignes)\n\nÉcrivez une version avec EXCEPT, une avec NOT IN et une autre avec LEFT JOIN.\n\n\n\n\n\n\nSolution\n\n\n\n(\n  SELECT DISTINCT language \n  FROM  world.countrylanguage\n)\n\nEXCEPT \n\n(\n  SELECT language \n  FROM world.countrylanguage \n  WHERE isofficial\n);\n\n\nPremière version\n\n\n\n\n\n\nSolution\n\n\n\nSELECT DISTINCT language \nFROM world.countrylanguage\nWHERE language NOT IN\n      (SELECT language \n       FROM world.countrylanguage \n       WHERE isofficial);\n\n\nDeuxième version:\n\n\n\n\n\n\nSolution\n\n\n\nSELECT DISTINCT l1.language \nFROM world.countrylanguage AS l1\n     LEFT JOIN world.countrylanguage AS l\n     ON (l1.language = l.language AND l.isofficial)\nWHERE l.language IS NULL;\n\n\nTroisième version:\n\n\n\n\n\n\nSolution\n\n\n\nSELECT DISTINCT cl.language \nFROM world.countrylanguage cl\nWHERE  NOT EXISTS (\n  SELECT cl1.language \n  FROM world.countrylanguage cl1\n  WHERE cl1.language=cl.language AND\n  cl1.isofficial\n);\n\n\n\n\n\n\n\n\nEn calcul relationnel\n\\[\\begin{align*}\n\\Big\\{l.\\texttt{language} :  & \\texttt{countrylanguage}(l) \\wedge \\\\\n& \\neg \\big( \\exists t \\quad \\texttt{countrylanguage}(t)  \\wedge\\\\\n&\\phantom{\\neg\\big(}l.\\texttt{language}=t.\\texttt{language}\\wedge t.\\texttt{isofficial}\\big)\\Big\\}\n\\end{align*}\\]\n\n\n\n\nQuelles sont les régions où au moins deux pays ont la même forme de gouvernement ? (21 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT DISTINCT region \nFROM world.country AS c1\nWHERE c1.governmentform = ANY(\n  SELECT c2.governmentform\n  FROM world.country AS c2 \n  WHERE c2.countrycode!=c1.countrycode AND c2.region=c1.region\n);\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT DISTINCT c1.region \nFROM world.country AS c1 JOIN world.country AS c2\n  ON c1.region=c2.region AND \n    c1.countrycode!=c2.countrycode AND \n    c1.governmentform=c2.governmentform;\n\n\n\nQuels sont les films qui n’ont jamais été loués ? (42 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nLà encore, plusieurs possibilités. Avec ce que l’on sait déjà :\nWITH DejaLoue AS (\n  SELECT film_id \n  FROM pagila.rental JOIN pagila.inventory USING (inventory_id)\n), NonLoue AS (\n  SELECT film_id \n  FROM pagila.film \n  EXCEPT \n  SELECT * \n  FROM DejaLoue\n)\n\nSELECT title \nFROM pagila.film NATURAL JOIN NonLoue;\nAvec les requêtes imbriquées :\nSELECT title,film_id FROM pagila.film\n                     WHERE film_id NOT IN (\n                      SELECT film_id \n                      FROM pagila.rental JOIN pagila.inventory USING (inventory_id)\n);\n\n\n\n\n\n\n\n\nEn calcul relationnel\n\\[\\begin{align*}\n\\Big\\{ f.\\texttt{title} : & \\texttt{film}(f) \\wedge \\\\\n& \\neg \\big( \\exists t, t_1  \\quad \\texttt{inventory}(t)  \\wedge  \\exists t_1  \\quad \\texttt{rental}(t_1)  \\wedge\\\\\n&\\phantom{\\neg\\big(} f.\\texttt{film\\_id}=t.\\texttt{film\\_id}\\wedge t.\\texttt{inventory\\_id}=t_1.\\texttt{inventory\\_id}\\big)\\Big\\}\n\\end{align*}\\]\n\n\n\n\n\n\n\n\n\nCette question est exactement du même type que la précédente. On y répond de la même manière : pour trouver 1 les objets d’un certain type qui ne possèdent pas une propriété, on cherche dans la base tous les objets de ce type et on fait la différence avec l’ensemble des objets de ce type qui possèdent la propriété dans la base.\n\n\n\n\nQuels sont les acteurs qui ont joué dans toutes les catégories de film ? (11 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH ActCat AS (SELECT actor_id, category_id FROM pagila.film_actor fa\n                 JOIN pagila.film_category fc ON (fa.film_id=fc.film_id)),\nActNot AS (SELECT actor_id FROM pagila.actor,pagila.category\n    WHERE (actor_id,category_id) NOT IN (SELECT * FROM ActCat)),\nActId AS (SELECT actor_id FROM pagila.actor\n    EXCEPT SELECT * FROM ActNot)\n\nSELECT first_name,last_name FROM pagila.actor NATURAL JOIN ActId  ;\n\n\n\n\n\n\n\n\nCette requête réalise une opération sophistiquée de l’algèbre relationnelle la division ou \\(\\div\\). Il ne s’agit pas d’une opération primitive comme \\(\\sigma,\\pi, \\times\\).\n\\[\\pi_{\\texttt{actor\\_id},\\texttt{category\\_id}} \\left(\\texttt{film\\_actor} \\bowtie \\texttt{film\\_category}\\right)  \\div \\pi_{\\texttt{category}} (\\texttt{film\\_category})\\]\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\nLa version suivante calcule le même résultat, et suit fidèlement le plan d’exécution le plus élémentaire pour réaliser la division.\nWITH \n  ActCat AS (\n    SELECT actor_id, category_id \n    FROM pagila.film_actor fa JOIN pagila.film_category fc ON (fa.film_id=fc.film_id)),\n  ActCrosCat AS (\n    SELECT  actor_id, category_id \n    FROM  pagila.actor, pagila.category),\n  ActNotCat AS (\n    SELECT * \n    FROM ActCrosCat\n    EXCEPT \n    SELECT *\n    FROM ActCat),\n  ActId AS (\n    SELECT actor_id \n    FROM pagila.actor \n    EXCEPT\n    SELECT actor_id \n    FROM ActNotCat)\n\nSELECT first_name,last_name \nFROM pagila.actor NATURAL JOIN ActId  ;\nEn comptant le nombre \\(n\\) de catégories de films dans une première requête, on peut aussi sélectionner les acteurs qui apparaissent dans au moins \\(n\\) catégories de film.\n\n\n\nExiste-t-il des acteurs qui ne jouent avec aucun autre acteur ? (0 ligne)\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH Copain AS\n  (SELECT \n    R1.actor_id \n   FROM \n    pagila.film_actor as R1\n  JOIN \n    pagila.film_actor as R2\n  ON \n    (R1.film_id = R2.film_id AND \n     R1.actor_id != R2.actor_id)\n)\n\nSELECT \n  actor_id \nFROM \n  pagila.actor\nWHERE \n  actor_id NOT IN (\n    SELECT * \n    FROM Copain\n);\nou avec NOT EXISTS\nSELECT actor_id \nFROM \n  pagila.actor a\nWHERE \n  NOT EXISTS (\n    SELECT fa2.actor_id\n    FROM \n      pagila.film_actor fa1 \n    JOIN \n      pagila.film_actor fa2\n    ON\n     (fa1.actor_id=a.actor_id AND\n      fa2.actor_id&lt;&gt; a.actor_id AND\n      fa1.film_id=fa2.film_id)\n)\n\n\n\n\n\n\n\n\nSolution\n\n\n\nChatGPT fecit:\nWITH ActorFilmCounts AS (\n    -- Pour chaque acteur, chaque film, nombre de co-acteurs dans le film\n    SELECT \n        fa1.actor_id,\n        fa1.film_id,\n        COUNT(fa2.actor_id) AS other_actors_count\n    FROM \n        film_actor fa1\n    LEFT JOIN \n        film_actor fa2 \n    ON \n        fa1.film_id = fa2.film_id \n        AND fa1.actor_id &lt;&gt; fa2.actor_id\n    GROUP BY \n        fa1.actor_id, fa1.film_id\n)\nSELECT \n    a.actor_id,\n    a.first_name,\n    a.last_name\nFROM \n    ActorFilmCounts afc\nJOIN \n    actor a \nON \n    afc.actor_id = a.actor_id\nGROUP BY \n    a.actor_id, a.first_name, a.last_name\nHAVING \n    -- garder les acteurs qui n'ont pas de co-acteurs\n    SUM(afc.other_actors_count) = 0;\n\n\n\n\n\n\n\n\nUne erreur\n\n\n\n La requête suivante ne répond pas à la question posée:\nSELECT \n    fa.actor_id \nFROM \n    film_actor fa\nLEFT JOIN \n    film_actor fa2 \nON \n  (fa.film_id = fa2.film_id AND fa.actor_id&lt;&gt;fa2.actor_id)\nWHERE \n  fa2.actor_id IS NULL;\nElle liste les identifiants d’acteurs qui ont joué au moins une fois dans un film ne comportant qu’un seul acteur, alors qu’on ne cherche les acteurs qui n’ont joué que dans des films ne comportant qu’un seul acteur.\nCette requête renvoie 31 lignes.\n\n\n\nNom, prénom des clients installés dans des villes sans magasin ? (599 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH \n  CustomerCity AS (\n    SELECT \n      cu.first_name, \n      cu.last_name,\n      cu.customer_id, \n      ad.city_id\n    FROM \n      pagila.customer cu \n    JOIN \n      pagila.address ad \n    ON \n      (cu.address_id=ad.address_id)),\n  StoreCity AS (\n    SELECT \n      ad.city_id \n    FROM \n      pagila.store st \n    JOIN p\n      agila.address ad \n    ON \n      (st.address_id= ad.address_id)\n)\n\nSELECT \n  first_name,\n  last_name \nFROM \n  CustomerCity\nWHERE \n  city_id NOT IN (\n      SELECT * FROM StoreCity\n  );\n\n\n\nLister les pays pour lesquels toutes les villes ont au moins un magasin. (1 ligne)\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT country_id from pagila.country C \nWHERE NOT EXISTS (\n  SELECT * \n  FROM pagila.city C2 \n  WHERE C.country_id=C2.country_id AND C2.city_id NOT IN (\n    SELECT address.city_id \n    FROM pagila.store \n    JOIN pagila.address USING (address_id)\n    )\n);\n\n\n\nDéterminer la liste des films disponibles dans toutes les langues.\n\n\n\n\n\n\n\nSolution\n\n\n\nComme pour les acteurs “toutes catégories”, il s’agit d’une division. Dans la base installée, le résultat est vide.\n\n\nUn même dvd (inventory_id) peut bien sûr être loué plusieurs fois, mais pas simultanément. Proposer une requête qui vérifie que les dates de location d’un dvd donné sont compatibles.\n\n\n\n\n\n\nSolution\n\n\n\nSQL en général et PostGres en particulier proposent beaucoup de types et d’opérations sophistiquées pour représenter et manipuler les données temporelles. Plusieurs types de données permettent de représenter les instants (timestamp), les dates, les intervalles de temps, les durées, et de calculer sur le temps (ajouter une durée à une date, extraire une information calendaire d’une date ou d’un instant, …). Même si l’API varie d’un cadre à l’autre, on retrouve ces types et ces opérations dans tous les environnements de sciences des données : ,"
  },
  {
    "objectID": "solutions/td3.html#vues",
    "href": "solutions/td3.html#vues",
    "title": "TD 3: SQL",
    "section": "Vues",
    "text": "Vues\nLes vues permettent de donner un nom à une requête afin de pouvoir l’appeler plus tard sans la réécrire à chaque fois. Une vue s’enregistre dans un schéma. Par exemple, dans le schéma World, on pourrait créer une vue VillesRepublic qui contient toutes les villes de la table city qui sont dans une république.\nOn crée une vue avec CREATE VIEW nom AS requete. Étant donné que vous ne pouvez écrire que dans votre schéma personnel, il faudra nommer vos vues entid.nom où entid est votre identifiant ENT. Ainsi\nCREATE VIEW entid.VillesRepublic AS\n  SELECT \n    B.* \n  FROM \n      world.country as A \n  NATURAL JOIN \n      world.city as B\n  WHERE \n      A.governmentform like '%Republic%';\ncrée une vue dans votre schéma personnel. Désormais, si on veut sélectionner les villes qui sont dans une république et dont la population est supérieure à \\(1000000\\), on pourra simplement écrire :\nSELECT * \nFROM \n    entid.VillesRepublic \nWHERE \n    population_city&gt;=1000000;\n\n\n\n\n\n\nRemarquez la différence entre WITH et une vue. WITH nomme une requête temporairement, seulement à l’échelle de la requête courante tandis qu’une vue est enregistrée de façon permanente. Cependant, chaque fois que vous appelez votre vue, elle est réévaluée par le système de base de données.\n\n\n\nNotez aussi que SQL n’est pas sensible à la casse. La vue entid.VillesRepublic peut être aussi désignée par entid.villesrepublic.\nPour supprimer une vue existante on utilise la commande DROP VIEW suivie du nom de la vue à supprimer. Par exemple l’instruction\nDROP VIEW entid.VillesRepublic ;\nsupprime la vue créée précédemment.\nDans votre schéma personnel (qui porte le nom de votre identifiant ENT), écrire une vue film_id_horror qui renvoie la liste des films de catégorie ‘Horror’.\n\n\n\n\n\n\nSolution\n\n\n\nCREATE VIEW entid.film_id_horror\nAS\n( SELECT pagila.film_id \n  FROM \n    pagila.film_category JOIN \n    pagila.category USING(category_id) \n  WHERE \n    category.name='Horror'\n) ;"
  },
  {
    "objectID": "solutions/td3.html#fonctions-sql",
    "href": "solutions/td3.html#fonctions-sql",
    "title": "TD 3: SQL",
    "section": "Fonctions SQL",
    "text": "Fonctions SQL\nDans votre schéma personnel (qui porte le nom de votre identifiant ENT), écrire une fonction SQL film_id_cat qui prend en paramètre une chaîne de caractère s et renvoie la liste des films de catégorie s. On rappelle la syntaxe :\nCREATE OR REPLACE FUNCTION entid.film_id_cat(s TEXT)\nRETURNS TABLE(film_id INTEGER)\nLANGUAGE 'sql' AS\n$$\nrequete\n$$\net l’usage\nCREATE OR REPLACE FUNCTION \n  entid.film_id_cat(s text)\nRETURNS TABLE(film_id smallint) AS \n$$\n    SELECT fc.film_id \n    FROM \n        pagila.film_category fc\n  JOIN \n        pagila.category ca\n  ON (fc.category_id=ca.category_id)\n    WHERE \n    ca.name=s ;\n$$ LANGUAGE sql ;\nUtilisez votre fonction pour écrire les requêtes suivantes:\nQuels sont les acteurs qui ont déjà joué dans un film d’horreur (catégorie ‘Horror’) ?\n\n\n\n\n\n\nSolution\n\n\n\nLes solutions sont données en utilisant la fonction suivante\nCREATE OR REPLACE FUNCTION \n  entid.film_id_cat(s pagila.category.name%TYPE)\nRETURNS TABLE(film_id pagila.film.film_id%TYPE) \nAS $$\nSELECT fc.film_id \nFROM \n    pagila.film_category fc \nJOIN \n    pagila.category ca\nON (fc.category_id=ca.category_id)\nWHERE \n  ca.name=s ;\n$$ LANGUAGE sql;\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT DISTINCT ac.* \nFROM \n    pagila.actor ac \nNATURAL JOIN\n  (SELECT fa.actor_id\n     FROM \n    pagila.film_actor fa\n   WHERE \n    fa.film_id IN (\n      SELECT * \n          FROM entid.film_id_cat('Horror')\n    )\n  );\n\n\nou\n\n\n\n\n\n\nSolution\n\n\n\nSELECT DISTINCT ac.*\nFROM \n  pagila.actor ac \nJOIN\n  pagila.film_actor fa ON (ac.actor_id=fa.actor_id)\nNATURAL JOIN\n  entid.film_id_cat('Horror') ;\n(156 tuples renvoyés).\n\n\nQuels sont les acteurs qui n’ont jamais joué dans une comédie (Comedy) ? (53 lignes)\n\n\n\n\n\n\n Attention ! Cette requête ne répond pas à la question :\n\n\n\nSELECT DISTINCT ac.*\nFROM pagila.actor ac NATURAL JOIN\n     (SELECT * FROM pagila.film_actor\n      WHERE film_id NOT IN\n        (SELECT * FROM pagila.film_id_cat('Comedy') )\n      ) as X;\nElle répond à la question : Quels sont les acteurs qui ont joué dans un film qui n’est pas une comédie ?\n\n\n\n\n\n\n\n\nSolution\n\n\n\nUne réponse correcte est\nSELECT DISTINCT last_name, first_name\nFROM \n  pagila.actor A1 \nWHERE \n  NOT EXISTS \n  (SELECT * \n  FROM \n    pagila.film_actor A2, \n    (pagila.film_category JOIN pagila.category using (category_id)) C \n  WHERE \n      A1.actor_id=A2.actor_id AND \n      name='Comedy' AND \n      A2.film_id=C.film_id\n  ); \n\n\nou encore\n\n\n\n\n\n\nSolution\n\n\n\nSELECT \n  DISTINCT ac.last_name, ac_first_name\nFROM \n  pagila.actor ac\nWHERE NOT EXISTS\n  (SELECT * \n   FROM \n    pagila.film_actor fa\n   WHERE film_id IN\n     (SELECT * \n      FROM \n        entid.film_id_cat('Comedy')\n     ) AND \n    fa.actor_id = ac.actor_id\n  )  ;\n\n\n\n\n\n\n\n\nEn calcul relationnel, en considérant film_id_cat('Comedy') comme une relation (ce qui est cohérent avec la définition de la fonction) cette requête s’exprime\n\\[\\begin{align*}\n  \\left\\{ a.\\texttt{last\\_name,}  \\right. & a.\\texttt{first\\_name}\n  :\n  \\texttt{actor}(a) \\wedge \\\\\n  & \\neg\n  \\left(\\exists \\mathrm{fa}\\quad \\texttt{film\\_actor}(\\mathrm{fa}) \\right.  \\wedge  \\mathrm{fa}.\\texttt{actor\\_id}=a.\\texttt{actor\\_id}  \\\\\n& \\left. \\left.   \\wedge \\texttt{film\\_id\\_cat}(\\mathrm{'Comedy'})(\\mathrm{fa}.\\texttt{film\\_id}) \\right) \\right\\}\n\\end{align*}\\]\nLe calcul relationnel traduit presque littéralement la démarche que nous suivons lorsqu’il faut construire le résultat à la main : pour trouver les actor_id des acteurs qui n’ont jamais joué dans une comédie, nous examinons toutes les valeurs \\(a\\) de actor_id présentes dans la table actor (ou film_actor), et pour chacune de ces valeurs, nous verifions qu’il n’existe pas de tuple de la table film_actor où l’attribut actor_id soit égal à \\(a\\) et où l’attribut film_id désigne un film qui apparaît dans le résultat de film_id_cat('Comedy').\nNous décrivons/explicitons ainsi les propriétés du résultat de la requête Quels sont les acteurs qui n’ont jamais joué dans une comédie (‘Comedy’) ?.\nSi maintenant nous cherchons à 1 ce résultat, nous pouvons d’abord calculer la liste des actor_id des acteurs qui ont joué dans une comédie, calculer la liste de tous les actor_id connus dans le schema et faire la différence, en algèbre relationnelle, cela se résume à\n\\[\\pi_{\\texttt{actor\\_id}}\\left(\\texttt{film\\_actor}\\right) \\setminus \\pi_{\\texttt{actor\\_id}} \\left( \\texttt{film\\_actor} \\bowtie\\texttt{film\\_id\\_cat}(\\texttt{'Comedy'}) \\right)\\]\n\n\n\nQuels sont les acteurs qui ont joué dans un film d’horreur (‘Horror’) et dans un film pour enfant (‘Children’)? (130 lignes)\n\n\n\n\n\n\nIci l’erreur la plus fréquente consiste à écrire\nSELECT \n  actor_id \nFROM \n  pagila.film_actor AS fa\nWHERE \n  fa.film_id IN (\n    SELECT * \n    FROM entid.film_id_cat('Children')\n  ) AND \n  fa.film_id IN (\n    SELECT * \n    FROM entid.film_id_cat('Horror')\n  );\nLe résultat est vide et la requête ne correspond pas à la question posée.\nElle calcule les actor_id des acteurs qui ont dans au moins un film qui relève simultanément des catégories Horror et Children (ce genre de film est assez rare).\nPour calculer un résultat correct, il faut pour chaque valeur \\(a\\) de actor_id rechercher deux tuples (pas nécessairement distincts) de film_actor où l’attribut actor_id vaut \\(a\\) et ou dans un cas film_id désigne un film pour enfants et dans l’autre un film d’horreur. En calcul relationnel, cela donne\n\\[\\begin{align*}\n  \\left\\{ a.\\texttt{last\\_name,}  \\right. & a.\\texttt{first\\_name}\n  :\n  \\texttt{actor}(a) \\wedge \\\\\n  &\n  \\left(\\exists \\mathrm{fa}\\quad \\texttt{film\\_actor}(\\mathrm{fa}) \\right.  \\wedge  \\mathrm{fa}.\\texttt{actor\\_id}=a.\\texttt{actor\\_id}  \\\\\n& \\left.   \\wedge \\texttt{film\\_id\\_cat}(\\mathrm{'Children'})(\\mathrm{fa}.\\texttt{film\\_id}) \\right) \\\\\n&  \\left(\\exists \\mathrm{fa}\\quad \\texttt{film\\_actor}(\\mathrm{fa}) \\right.  \\wedge  \\mathrm{fa}.\\texttt{actor\\_id}=a.\\texttt{actor\\_id}  \\\\\n& \\left. \\left.   \\wedge \\texttt{film\\_id\\_cat}(\\mathrm{'Horror'})(\\mathrm{fa}.\\texttt{film\\_id}) \\right)\\right\\}\n\\end{align*}\\]\nEn algèbre relationnelle\n\\[\\begin{align*}\n\\pi_{\\texttt{last\\_name,}\\texttt{first\\_name}} \\bigg( &  \\texttt{actor} \\bowtie  \\\\\n     & \\Big(\\pi_{\\texttt{actor\\_id}} \\left( \\texttt{film\\_actor} \\bowtie\n                                 \\texttt{film\\_id\\_cat}(\\texttt{'Children'}) \\right) \\bigcap\\\\\n     & \\; \\pi_{\\texttt{actor\\_id}} \\left( \\texttt{film\\_actor} \\bowtie\n                                 \\texttt{film\\_id\\_cat}(\\texttt{'Horror'}) \\right) \\Big)\n                                 \\bigg)\n\\end{align*}\\]\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\nEn SQL, cela peut donner\nSELECT DISTINCT a.first_name, a.last_name  FROM pagila.actor a\nWHERE EXISTS (SELECT film_id\n              FROM film_actor AS fa1 NATURAL JOIN\n                   entid.film_id_cat('Children')\n              WHERE  fa1.actor_id = a.actor_id) AND\n      EXISTS (SELECT film_id\n              FROM film_actor AS fa2 NATURAL JOIN\n                   entid.film_id_cat('Horror')\n              WHERE  fa2.actor_id = a.actor_id) ;\nqui renvoie 129 tuples."
  },
  {
    "objectID": "solutions/td8.html",
    "href": "solutions/td8.html",
    "title": "TD 8 : Modélisation",
    "section": "",
    "text": "Avec solutions"
  },
  {
    "objectID": "solutions/td8.html#exercice-supermarché",
    "href": "solutions/td8.html#exercice-supermarché",
    "title": "TD 8 : Modélisation",
    "section": "Exercice (Supermarché)",
    "text": "Exercice (Supermarché)\n\n\n\n\n\n\nQuestion\n\n\n\nProduire un schéma E/R qui décrit des informations concernant les produits d’un supermarché.\n\n\nChaque produit a un nom et un prix et appartient à une catégorie.\nLe supermarché a plusieurs rayons, un rayon étant caractérisé par un étage et un numéro de rangée. On veut maintenir l’emplacement des produits dans les rayons. Les produits d’une même catégorie sont placés dans le même rayon, mais un rayon peut contenir des produits de plusieurs catégories.\n\n\n\n\n\n\nQuestion\n\n\n\nTraduire le schéma EA dans le formalisme des pattes de corbeau\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nDéfinir le schéma relationnel correspondant en SQL"
  },
  {
    "objectID": "solutions/td8.html#exercice-location-de-voitures",
    "href": "solutions/td8.html#exercice-location-de-voitures",
    "title": "TD 8 : Modélisation",
    "section": "Exercice (Location de voitures)",
    "text": "Exercice (Location de voitures)\n\n\n\n\n\n\nQuestion\n\n\n\nProduire un schéma E/R qui décrit des informations concernant des voitures à louer.\n\n\nChaque voiture a une plaque d’immatriculation, une couleur et une marque. Le prix de la location dépend de la catégorie, où chaque catégorie est identifiée par un nom.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\n\nER\n\n\n\nVoiture\n\nVoiture\n\n\n\nfabriqué-par\n\nfabriqué-par\n\n\n\nVoiture--fabriqué-par\n\n1:1\n\n\n\nappartient-à\n\nappartient-à\n\n\n\nVoiture--appartient-à\n\n1:1\n\n\n\nMarque\n\nMarque\n\n\n\nCatégorie\n\nCatégorie\n\n\n\nprix_location\n\nprix location\n\n\n\nCatégorie--prix_location\n\n\n\n\nname1\n\nnom\n\n\n\nname1--Catégorie\n\n\n\n\nname2\n\nnom\n\n\n\nname2--Marque\n\n\n\n\nimmatriculation\n\nimmatriculation\n\n\n\nimmatriculation--Voiture\n\n\n\n\ncouleur\n\ncouleur\n\n\n\ncouleur--Voiture\n\n\n\n\nfabriqué-par--Marque\n\n0:n\n\n\n\nappartient-à--Catégorie\n\n0:n\n\n\n\n\n\n\n\nPas d’entités faibles car chaque entité a son propre identifiant.\nÀ discuter : pourrait-on utiliser un lien est-un ( ◃ ) pour modéliser le fait qu’un véhicule relève d’une catégorie ?\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nModifier ensuite le schéma pour représenter les modèles de voitures.\n\n\nUn modèle a un nom, une marque et un nombre de sièges.\nToutes les voitures du même modèle doivent appartenir à la même catégorie de prix.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\n\nER\n\n\n\nVoiture\n\nVoiture\n\n\n\nrelève-de\n\nrelève-de\n\n\n\nVoiture--relève-de\n\n1:1\n\n\n\nMarque\n\nMarque\n\n\n\nCatégorie\n\nCatégorie\n\n\n\nprix_location\n\nprix location\n\n\n\nCatégorie--prix_location\n\n\n\n\nModèle\n\nModèle\n\n\n\nfabriqué-par\n\nfabriqué-par\n\n\n\nModèle--fabriqué-par\n\n1:1\n\n\n\nappartient-à\n\nappartient-à\n\n\n\nModèle--appartient-à\n\n1:1\n\n\n\nname1\n\nnom\n\n\n\nname1--Catégorie\n\n\n\n\nname2\n\nnom\n\n\n\nname2--Marque\n\n\n\n\nname3\n\nnom\n\n\n\nname3--Modèle\n\n\n\n\nimmatriculation\n\nimmatriculation\n\n\n\nimmatriculation--Voiture\n\n\n\n\ncouleur\n\ncouleur\n\n\n\ncouleur--Voiture\n\n\n\n\nnbre_sieges\n\nnombre de sièges\n\n\n\nnbre_sieges--Modèle\n\n\n\n\nfabriqué-par--Marque\n\n0:n\n\n\n\nappartient-à--Catégorie\n\n0:n\n\n\n\nrelève-de--Modèle\n\n0:n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nDe plus, on veut distinguer les voitures disponibles des voitures en location. Pour les voitures disponibles on représente l’emplacement. Pour les voitures en location on représente la date et la durée de la location, ainsi que le nom du client.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\n\nER\n\n\n\nVoiture\n\nVoiture\n\n\n\nrelève-de\n\nrelève-de\n\n\n\nVoiture--relève-de\n\n1:1\n\n\n\nMarque\n\nMarque\n\n\n\nCatégorie\n\nCatégorie\n\n\n\nprix_location\n\nprix location\n\n\n\nCatégorie--prix_location\n\n\n\n\nModèle\n\nModèle\n\n\n\nfabriqué-par\n\nfabriqué-par\n\n\n\nModèle--fabriqué-par\n\n1:1\n\n\n\nappartient-à\n\nappartient-à\n\n\n\nModèle--appartient-à\n\n1:1\n\n\n\nDisponible\n\nDisponible\n\n\n\nemplacement\n\nemplacement\n\n\n\nDisponible--emplacement\n\n\n\n\nestun1\n\nEst Un\n\n\n\nDisponible--estun1\n\n\n\n\nEn location\n\nEn location\n\n\n\nnom client\n\nnom client\n\n\n\nEn location--nom client\n\n\n\n\ndate\n\ndate\n\n\n\nEn location--date\n\n\n\n\ndurée\n\ndurée\n\n\n\nEn location--durée\n\n\n\n\nestun2\n\nEst Un\n\n\n\nEn location--estun2\n\n\n\n\nname1\n\nnom\n\n\n\nname1--Catégorie\n\n\n\n\nname2\n\nnom\n\n\n\nname2--Marque\n\n\n\n\nname3\n\nnom\n\n\n\nname3--Modèle\n\n\n\n\nimmatriculation\n\nimmatriculation\n\n\n\nimmatriculation--Voiture\n\n\n\n\ncouleur\n\ncouleur\n\n\n\ncouleur--Voiture\n\n\n\n\nnbre_sieges\n\nnombre de sièges\n\n\n\nnbre_sieges--Modèle\n\n\n\n\nfabriqué-par--Marque\n\n0:n\n\n\n\nappartient-à--Catégorie\n\n0:n\n\n\n\nrelève-de--Modèle\n\n0:n\n\n\n\nestun1--Voiture\n\n\n\n\nestun2--Voiture\n\n\n\n\n\n\n\n\nOn utilise ici les liens Est Un pour décrire le statut des voitures (spécialisation).\nIl faudrait ajouter une contrainte d’exclusion totale : une voiture est soit en location, soit disponible.\nOn pourrait aussi passer par des attributs statut, emplacement et une entité faible Location.\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nTraduire le schéma EA dans le formalisme des pattes de corbeau\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\nerDiagram\n    VOITURE\n    MODELE \n    CATEGORIE\n    MARQUE\n    LOCATION\n    MODELE ||..o{ VOITURE : \"releve de\"\n    VOITURE {\n      string  immatriculation  PK\n      string couleur\n      boolean disponible \n      string emplacement \n      string nom_modele FK\n    }\n    MARQUE ||..o{ MODELE : \"fabrique par\"\n    MODELE {\n      string nom PK\n      integer nombre_de_sieges \n      string nom_marque FK\n      string nom_categorie FK\n    }\n    MARQUE {\n      string nom PK\n    }\n    CATEGORIE ||..o{ MODELE : \"appartient a\"\n    CATEGORIE {\n      string nom PK\n      numeric prix_location\n    }\n    LOCATION |o--|| VOITURE : concerne\n    LOCATION {\n      string date \n      integer immatriculation PK, FK\n      string duree\n      integer numero_client\n    }\n\n\n\n\n\n\nContraintes externes:\n\nDans VOITURE, disponible si et seulement si emplacement est NOT NULL\nDans VOITURE et LOCATION, NOT disponible si et seulement si dans LOCATION, il existe une instance qui réfère à l’instance de VOITURE.\n\n Trouver une meilleure modélisation pour la spécialisation DISPONIBLE/EN LOCATION.\n\n\n\n\n\n\n\n\nSolution avec dbSchema\n\n\n\n\n\n\nSchema Avis d’après dbSchema\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nDéfinir le schéma relationnel correspondant en SQL\n\n\n\n\n\n\n\n\nSolution\n\n\n\nCREATE SCHEMA IF NOT EXISTS schema_avis;\n\nCREATE  TABLE schema_avis.categorie ( \n    nom                  text  NOT NULL  ,\n    prix_location        numeric    ,\n    CONSTRAINT pk_categorie PRIMARY KEY ( nom )\n );\n\nCREATE  TABLE schema_avis.marque ( \n    nom                  text  NOT NULL  ,\n    CONSTRAINT pk_marque PRIMARY KEY ( nom )\n );\n\nCREATE  TABLE schema_avis.modele ( \n    nom                  text  NOT NULL  ,\n    nombre_sieges        bigint    ,\n    nom_marque           text    ,\n    name_categorie       text    ,\n    CONSTRAINT pk_modele PRIMARY KEY ( nom )\n );\n\n\n\n\n\n\n\n\nsuite\n\n\n\nCREATE  TABLE schema_avis.voiture ( \n    immatriculation      bigint  NOT NULL  ,\n    name_modele          text    ,\n    couleur              text    ,\n    disponible           boolean  NOT NULL  ,\n    emplacement          text    ,\n    CONSTRAINT pk_voiture PRIMARY KEY ( immatriculation )\n );\n\nCREATE  TABLE schema_avis.location ( \n    immatriculation      bigint  NOT NULL  ,\n    \"date\"               date  NOT NULL  ,\n    duree                bigint  NOT NULL  ,\n    numero_client        bigint  NOT NULL  ,\n    CONSTRAINT pk_location PRIMARY KEY ( immatriculation )\n );\n\n\n\n\n\n\n\n\nsuite\n\n\n\n\nALTER TABLE schema_avis.location \nADD CONSTRAINT \n  fk_location_voiture \nFOREIGN KEY ( immatriculation ) \nREFERENCES schema_avis.voiture( immatriculation );\n\nALTER TABLE schema_avis.modele \nADD CONSTRAINT \n  fk_modele_marque \nFOREIGN KEY ( nom_marque ) \nREFERENCES schema_avis.marque( nom ) \nON DELETE CASCADE ON UPDATE CASCADE;\n\nALTER TABLE schema_avis.modele \nADD CONSTRAINT \n  fk_modele_categorie \nFOREIGN KEY ( name_categorie ) \nREFERENCES schema_avis.categorie( nom );\n\nALTER TABLE schema_avis.voiture \nADD CONSTRAINT \n  fk_voiture_modele \nFOREIGN KEY ( name_modele ) \nREFERENCES schema_avis.modele( nom ) \nON DELETE CASCADE ON UPDATE CASCADE;"
  },
  {
    "objectID": "solutions/td8.html#exercice-gestion-du-personnel-dune-entreprise",
    "href": "solutions/td8.html#exercice-gestion-du-personnel-dune-entreprise",
    "title": "TD 8 : Modélisation",
    "section": "Exercice (Gestion du personnel d’une entreprise)",
    "text": "Exercice (Gestion du personnel d’une entreprise)\nDans une entreprise, chaque employé (identifié par un numéro) est attaché à un département de l’entreprise. Il occupe un bureau et participe à un ou plusieurs projets développés par l’entreprise.\nDe chaque employé, on connait : le nom, le prénom, les emplois qu’il a occupés à différentes dates et les salaires qu’il a perçus dans ces emplois.\nChaque département est identifié par un numéro, a son budget propre et est dirigé par un directeur faisant partie du personnel de l’entreprise.\nChaque bureau est identifié par un numéro, est rattaché à un département et est caractérisé par sa surface en mètres carrés. Il possède un numéro de téléphone associé.\nChaque projet est identifié par un numéro, possède un certain budget et emploie plusieurs personnes appartenant à différents départements. Chaque employé est affecté pour un certain nombre d’heures à un projet.\n\n\n\n\n\n\nQuestion\n\n\n\nDonner un modèle entité-association correspondant à la description ci-dessus.\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nModifier votre modélisation pour tenir compte de l’évolution dans le temps de la vie de l’entreprise : les projets ont des durées de vie limitées, chaque employé est affecté à un projet (mais aussi un département) pendant une certaines durée, etc\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nTraduire le schéma EA dans le formalisme des pattes de corbeau\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nDéfinir le schéma relationnel correspondant en SQL"
  },
  {
    "objectID": "solutions/td2.html",
    "href": "solutions/td2.html",
    "title": "TD 2: SQL",
    "section": "",
    "text": "Avec solutions"
  },
  {
    "objectID": "solutions/td2.html#schéma-world-rappel",
    "href": "solutions/td2.html#schéma-world-rappel",
    "title": "TD 2: SQL",
    "section": "Schéma world (rappel)",
    "text": "Schéma world (rappel)\nUtiliser les commandes suivantes pour retrouver les schémas de tables country, countrylanguage et city.\nbd_2023&gt; \\d world.\"nom de table\"\nVue d’ensemble du schéma world"
  },
  {
    "objectID": "solutions/td2.html#écriture-de-requêtes",
    "href": "solutions/td2.html#écriture-de-requêtes",
    "title": "TD 2: SQL",
    "section": "Écriture de requêtes",
    "text": "Écriture de requêtes\nPour extraire des informations d’une base de données, on utilise l’algèbre relationnelle (pour la théorie) et le langage SQL (pour la pratique).\n\n\n\n\n\n\n\n\nOpération\nAlgèbre rel.\nSQL\n\n\n\n\nProjection\n\\(\\Pi_{\\text{liste d'attributs}}(R)\\)\nSELECT attributs FROM  R\n\n\nSélection\n\\({\\Large \\sigma}_{\\text{condition}}{R}\\)\nSELECT * FROM R WHERE condition\n\n\nRenommage\n\\(\\rho_{\\text{nom1} \\rightarrow \\text{nom2}}(R)\\)\nSELECT nom1 AS nom2 FROM table1 AS table2\n\n\nUnion\n\\(R \\cup S\\)\n(SELECT * FROM R) UNION (SELECT * FROM S)\n\n\nDifférence\n\\(R - S\\)\n(SELECT * FROM R) EXCEPT (SELECT * FROM S)\n\n\nProduit\n\\(R \\times S\\)\nSELECT * FROM R,S\n\n\nIntersection\n\\(R \\cap S\\)\n(SELECT * FROM R) INTERSECT (SELECT * FROM S)"
  },
  {
    "objectID": "solutions/td2.html#opérations-avancées",
    "href": "solutions/td2.html#opérations-avancées",
    "title": "TD 2: SQL",
    "section": "Opérations avancées",
    "text": "Opérations avancées\n\nJointures\nLa jointure est une opération qui permet de recoller deux relations ensemble. On la note avec le signe \\(\\bowtie_C\\) où \\(C\\) est une condition. Formellement, ce n’est qu’une sélection selon la condition \\(C\\) d’un produit cartésien, c’est-à-dire, par définition : \\[R {\\Large \\bowtie}_C S = {\\Large \\sigma}_{C}{(R \\times S)}.\\]\nCette opération est très courante dans les requêtes. Cela vient du fait que les bases de données sont conçues pour ne pas avoir d’information redondante.\nPrenons l’exemple du schéma world et des tables world.country et world.city. La table world.country possède une colonne capital qui contient le numéro d’identification d’une ville de la table world.city. Par exemple, pour la France, la colonne capital vaut 2974 et la ville numéro 2974 est Paris:\nbd_2023-24&gt; SELECT capital \nFROM world.country \nWHERE countrycode='FRA';\nbd_2023-24&gt; SELECT name \nFROM world.city \nWHERE id = 2974;\nPour lister les noms des capitales mondiales, on va avoir besoin de recoller les deux tables en prenant soin de respecter la condition d’égalité entre la capitale et le numéro d’identification de la ville. Cela peut s’écrire en SQL comme suit:\nSELECT name\nFROM world.city AS V JOIN \n     world.country AS P ON \n     V.id = P.capital;\nParfois, on veut recoller deux tables avec la condition que les colonnes qui ont le même nom doivent être égales. Cela arrive souvent si la base de données a bien été conçue. On appelle cette jointure une jointure naturelle, qu’on peut écrire avec NATURAL JOIN. La requête\nSELECT name \nFROM world.city NATURAL JOIN world.country\nWHERE continent = 'Oceania';\nrenvoie la liste des villes d’Océanie. La jointure est faite implicitement sur la condition\nworld.city.countrycode = world.country.countrycode\nla table résultante n’aura qu’une seule colonne countrycode. Si l’on souhaite ne faire la jointure naturelle que sur un sous-ensemble a1,...,ak des attributs communs, on peut utiliser JOIN ... USING (a1,...,ak).\n\n\nRequêtes nommées : utilisation de WITH\nLorsque les requêtes se compliquent, il est parfois commode de la découper en plusieurs requêtes qu’on manipulera par la suite. Par exemple, trouver le nom des capitales européennes ayant plus d’un million d’habitants peut se découper ainsi: on résout la requête CAP qui contient le nom, le continent et la population des capitales. Puis on résout la requête finale en filtrant CAP. Cela peut s’écrire avec l’opérateur WITH:\nWITH CAP AS (\n  SELECT name, continent, population\n  FROM world.city AS V JOIN \n    world.country AS P ON  V.id=P.capital\n)\n\nSELECT name\nFROM CAP\nWHERE continent = 'Europe' AND population &gt; 1000000;"
  },
  {
    "objectID": "solutions/td2.html#requêtes",
    "href": "solutions/td2.html#requêtes",
    "title": "TD 2: SQL",
    "section": "Requêtes",
    "text": "Requêtes\n\nQuels sont les noms des capitales Sud-Américaines ? (14 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT name\nFROM world.city JOIN \n  world.country ON capital=id\nWHERE continent = 'South America';\n\n\n\nQuels sont les noms des pays où le français est langue officielle ? (18 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT name_country\nFROM world.country NATURAL JOIN world.countrylanguage\nWHERE isofficial AND language='French';\n\n\n\nQuels sont les pays dont le gouvernement est monarchique (constitutionnelle ou pas) ? (43 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT name_country \nFROM world.country \nWHERE governmentform LIKE '%Monarchy%';\n\n\n\nQuelles sont les monarchies d’Europe dont la capitale compte moins d’un million d’habitants ? (8 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH T1 AS (\n  SELECT *\n  FROM world.country\n  WHERE governmentform LIKE '%Monarchy%' AND continent='Europe' )\n\nSELECT name_country\nFROM T1 JOIN world.city ON capital=id\nWHERE population &lt; 1000000;\n\n\n\nQuelles sont les régions où on ne trouve pas de monarchie ? (9 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH monarchy AS (\n  SELECT region\n  FROM world.country\n  WHERE governmentform LIKE '%Monarchy%')\n\n(SELECT region \n FROM world.country) \nEXCEPT \n(SELECT * \n FROM monarchy);\n\n\n\nQuelles sont les langues qui ne sont langues officielles dans aucun pays ? (355 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS (\n  SELECT language \n  FROM world.countrylanguage \n  WHERE isofficial\n)\n\n(SELECT DISTINCT language \nFROM world.countrylanguage) \nEXCEPT \n(SELECT * \nFROM R);\n\n\n\nQuels sont les pays qui n’ont pas de langue officielle ? (49 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS (\n  SELECT countrycode \n  FROM world.countrylanguage\n  WHERE isofficial\n),\nS AS (\n  SELECT countrycode \n  FROM world.country\n  EXCEPT \n  SELECT * FROM R\n)\n\nSELECT name_country \nFROM world.country NATURAL JOIN S;\n\n\n\nQuels sont les pays dont la seule langue officielle est le français ? (9 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS(\n  SELECT DISTINCT T1.countrycode \n  FROM world.countrylanguage as T1 JOIN\n      world.countrylanguage as T2 ON \n      T1.countrycode = T2.countrycode\n  WHERE T1.language &lt;&gt; T2.language AND\n      T1.isofficial AND\n      T2.isofficial),\nS AS (\n  SELECT countrycode \n  FROM world.countrylanguage\n  WHERE language='French' AND isofficial\n  EXCEPT \n  (SELECT * FROM R)\n)\n\nSELECT name_country \nFROM world.country NATURAL JOIN S;\nEn utilisant EXCEPT :\nWITH OnlyFrench AS (\n  (SELECT countrycode\n  FROM countrylanguage\n  WHERE isofficial AND language = 'French')\n  EXCEPT\n  (SELECT countrycode\n  FROM countrylanguage\n  WHERE isofficial AND language &lt;&gt; 'French')\n)\n\nSELECT name_country \nFROM world.country NATURAL JOIN OnlyFrench;\n\n\n\nLes noms des pays où le français n’est pas la seule langue officielle. (9 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS (\nSELECT DISTINCT T1.countrycode FROM world.countrylanguage as T1\n                     JOIN world.countrylanguage as T2\n                     ON T1.countrycode = T2.countrycode\nWHERE T1.language &lt;&gt; T2.language AND\n     T1.language = 'French' AND\n     T1.isofficial AND\n     T2.isofficial)\n\nSELECT name_country FROM R NATURAL JOIN world.country;\nEn utilisant INTERSECT :\nWITH AlsoFrench AS (\n  (SELECT countrycode\n  FROM world.countrylanguage\n  WHERE isofficial AND language = 'French')\n  INTERSECT\n  (SELECT countrycode\n  FROM world.countrylanguage\n  WHERE isofficial AND language &lt;&gt; 'French')\n)\n\nSELECT name_country \nFROM world.country NATURAL JOIN \n     AlsoFrench;\n\n\n\nQuelles sont les régions qui ne comportent qu’une seule forme de gouvernement ? (3 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS (\n  SELECT T1.region \n  FROM world.country AS T1 JOIN \n       world.country AS T2 ON \n       T1.region = T2.region\n  WHERE T1.governmentform &lt;&gt; T2.governmentform)\n\nSELECT region \nFROM world.country \nEXCEPT \nSELECT * \nFROM R;\n\n\n\nQuelles sont les langues officielles des pays dont la capitale compte plus de 5 000 000 d’habitants ? (12 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT DISTINCT language\nFROM world.countrylanguage NATURAL JOIN \n     world.city JOIN world.country ON capital=id\nWHERE population &gt; 5000000 and isofficial;\n\n\n\nQuels sont les pays où au moins trois langues sont parlées chacune par strictement plus de \\(10\\%\\) de la population ? (35 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS (\n  SELECT T1.countrycode \n  FROM  world.countrylanguage AS T1 JOIN \n        world.countrylanguage AS T2 ON T1.countrycode = T2.countrycode JOIN \n        world.countrylanguage AS T3 ON T1.countrycode = T3.countrycode\n  WHERE T1.language &lt;&gt; T2.language AND\n        T2.language &lt;&gt; T3.language AND\n        T1.language &lt;&gt; T3.language AND\n        T1.percentage &gt; 10 AND\n        T2.percentage &gt; 10 AND\n        T3.percentage &gt; 10\n)\n\nSELECT DISTINCT name_country \nFROM world.country NATURAL JOIN R;\nou\nWITH tpc AS (\n  SELECT *\n  FROM world.countrylanguage\n  WHERE percentage &gt; 10), \nthree AS (\n    SELECT DISTINCT t1.countrycode\n    FROM tpc AS t1 JOIN \n         tpc AS t2 ON (t1.countrycode=t2.countrycode AND t1.language &lt; t2.language) JOIN\n         tpc AS t3 ON (t1.countrycode=t3.countrycode AND t3.language &gt; t2.language)\n)\n\nSELECT co.*\nFROM world.country co NATURAL JOIN three ;\n\n\n\nQuelles sont les régions où il existe deux pays dont les espérances de vie diffèrent par au moins \\(10\\) ans ? (16 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT DISTINCT T1.region\nFROM world.country AS T1 JOIN \n     world.country AS T2 ON T1.region = T2.region\nWHERE T1.countrycode &lt;&gt; T2.countrycode AND \n      (T1.lifeexpectancy - T2.lifeexpectancy &gt;= 10 OR \n       T2.lifeexpectancy - T1.lifeexpectancy &gt;= 10);\n\n\n\nQuels sont les pays où l’anglais et le français sont des langues officielles ? (3 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS (\n  SELECT T1.countrycode\n  FROM world.countrylanguage AS T1 JOIN \n       world.countrylanguage AS T2 USING (countrycode)\n  WHERE T1.language='French' AND \n        T2.language='English' AND \n        T1.isofficial AND \n        T2.isofficial)\n      \nSELECT name_country \nFROM R NATURAL JOIN \n     world.country;\n\n\n\nMontrer comment calculer l’intersection de deux tables avec une jointure (sous certaines conditions).\n\n\n\n\n\n\n\nSolution\n\n\n\nSi R et S sont deux tables de même schéma, une jointure naturelle des deux tables devrait (en première approximation) calculer l’intersection des deux tables.\nPourtant\n(SELECT * FROM R)\nINTERSECT\n(SELECT * FROM S)   ;\nne donne pas toujours le même résultat que\nSELECT *\nFROM    R NATURAL JOIN S ;\nEssayez par exemple pour l’intersection de la table country avec elle-même :\n(SELECT * FROM country) \nINTERSECT \n(SELECT * FROM country);\nretourne la table country, soit 239 lignes.\nLa jointure naturelle\nSELECT * \nFROM country AS c1 NATURAL JOIN \n     country AS c2;\nne donne que 167 lignes. On peut réconcilier les deux résultats en ne conservant que les lignes pour lesquelles aucune colonne ne prend la valeur NULL.\nEn vérifiant quels attributs peuvent prendre la valeur NULL dans le schéma, on peut tester cela par la requête\nSELECT * \nFROM world.country\nWHERE indepyear IS NOT NULL AND \n      lifeexpectancy IS NOT NUL AND \n      gnp IS NOT NULL AND \n      gnpold IS NOT NULL AND \n      headofstate IS NOT NULL AND \n      capital IS NOT NULL;\nqui retourne bien 167 lignes."
  },
  {
    "objectID": "solutions/td10.html",
    "href": "solutions/td10.html",
    "title": "TD 10: Normalisation",
    "section": "",
    "text": "Avec solutions\n\n\n\n\n\n\n\n\n\n\n\n\n\nL3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2024-2025\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\n\nExercice\nSoit \\(\\mathcal{A}=\\left\\{A,B,C,D,E\\right\\}\\) un schéma et soit \\(\\mathcal{A}_1=\\left\\{A,B,C\\right\\}\\). Pour chaque ensemble \\(\\Sigma\\) de dépendances fonctionnelles ci-dessous, déterminer un ensemble de DF équivalent à \\(\\pi_{\\mathcal{A}_1}(\\Sigma)\\).\n\n\\(\\Sigma=\\left\\{AB\\to DE, C\\to E, D\\to C, E\\to A\\right\\}\\)\n\\(\\Sigma=\\left\\{A\\to D, BD\\to E, AC\\to E, DE\\to B\\right\\}\\)\n\\(\\Sigma=\\left\\{AB\\to D, AC\\to E, BC\\to D, D\\to A, E\\to B\\right\\}\\)\n\\(\\Sigma=\\left\\{A\\to B, B\\to C, C\\to D, D\\to E, E\\to A\\right\\}\\)\n\n\n\n\n\n\n\nSolution\n\n\n\nRappelons que \\(\\pi_{\\mathcal{A}_1}(\\Sigma)\\) est l’ensemble des DF de la forme \\(X\\to Y\\), avec \\(X\\subset\\mathcal{A}_1\\) et \\(Y\\subset\\mathcal{A}_1\\), qui sont impliquées par \\(\\Sigma\\). Un ensemble de DF équivalent à \\(\\pi_{\\mathcal{A}_1}(\\Sigma)\\) est l’ensemble des DF \\(X\\to (X^+\\cap\\mathcal{A}_1)\\setminus X\\) où \\(X\\subset\\mathcal{A}_1\\), \\(X\\not=\\emptyset\\) et \\(X\\not=\\mathcal{A}_1\\).\n\n\\(A^+=A\\), \\(B^+=B\\), \\(C^+=CEA\\) donc on ajoute \\(\\boxed{C\\to A}\\)\\ \\(AB^+=ABDEC\\) donc on ajoute \\(\\boxed{AB\\to C}\\)\\ \\(AC^+=ACE\\), \\(BC^+=BCEAD\\) donc on ajoute \\(\\boxed{BC\\to A}\\)\\ Donc \\(\\pi_{\\mathcal{A}_1}(\\Sigma)\\) est équivalent à \\(\\left\\{C\\to A, AB\\to C, BC\\to A\\right\\}\\) lui-même équivalent à \\(\\left\\{AB\\to C, C\\to A\\right\\}\\).\n\\(A^+=AD\\), \\(B^+=B\\), \\(C^+=C\\) rien à ajouter\\ \\(AB^+=ABDE\\), \\(AC^+=ACDEB\\) donc on ajoute \\(\\boxed{AC \\to B}\\)\\ \\(BC^+=BC\\)\\ Donc \\(\\pi_{\\mathcal{A}_1}(\\Sigma)\\) est équivalent à \\(\\left\\{aC \\to B\\right\\}\\).\n\\(A^+=A\\), \\(B^+=B\\), \\(C^+=C\\) rien à ajouter\\ \\(AB^+=ABD\\), \\(AC^+=ACEBD\\) donc on ajoute \\(\\boxed{AC \\to B}\\)\\ \\(BC^+=BCDAE\\) donc on ajoute \\(\\boxed{BC \\to A}\\) \\ Donc \\(\\pi_{\\mathcal{A}_1}(\\Sigma)\\) est équivalent à \\(\\left\\{aC \\to B, BC\\to A\\right\\}\\).\nTout attribut est une clef, donc c’est aussi le cas pour \\(\\mathcal{A}_1\\). \\(\\pi_{\\mathcal{A}_1}(\\Sigma)\\) est donc équivalent à \\(\\left\\{a\\to B, B\\to C, C\\to A\\right\\}\\).\n\n\n\n\n\nExercice\nSoit \\(\\mathcal{A}=\\left\\{A,B,C,D,E\\right\\}\\) un schéma et soit la décomposition \\(\\left\\{\\mathcal{A}_1,\\mathcal{A}_2,\\mathcal{A}_3\\right\\}\\) où \\[\\mathcal{A}_1=\\left\\{A,B,C\\right\\}\\quad \\mathcal{A}_2=\\left\\{B,C,D\\right\\}\\quad \\mathcal{A}_3=\\left\\{A,C,E\\right\\}\\] Pour chaque ensemble \\(\\Sigma\\) de dépendances fonctionnelles ci-dessous, déterminer quelles dépendances sont préservées par cette décomposition, c’est-à-dire quelles DF de \\(\\Sigma\\) sont impliquées par \\(\\bigcup_{i=1}^3 \\pi_{\\mathcal{A}_i}(\\Sigma)\\).\n\n\\(\\Sigma=\\left\\{b\\rightarrow E, CE\\rightarrow A\\right\\}\\)\n\\(\\Sigma=\\left\\{aC\\rightarrow E, BC\\to D\\right\\}\\)\n\\(\\Sigma=\\left\\{a\\rightarrow D, D\\to E, B\\to D\\right\\}\\)\n\\(\\Sigma=\\left\\{a\\rightarrow D, CD\\to E, E\\to D\\right\\}\\)\n\n\n\n\n\n\n\nSolution\n\n\n\nLa DF \\(X\\to Y\\) est préservée si et seulement la fermeture de \\(X\\) par rapport aux DF locales \\(\\bigcup_{i=1}^3 \\pi_{\\mathcal{A}_i}(\\Sigma)\\) contient \\(Y\\). Pour calculer la fermeture de \\(X\\) par rapport aux DF locales \\(\\bigcup_{i=1}^3 \\pi_{\\mathcal{A}_i}(\\Sigma)\\) on peut utiliser l’algorithme suivant~:\n\nInitialisation \\(Z \\leftarrow X\\)\nTant que \\(Z\\) grandit : pour \\(i=1,2,3\\), \\(Z \\leftarrow Z \\cup\\bigl( (Z\\cap \\mathcal{A}_i)^+_\\Sigma\\cap \\mathcal{A}_i\\bigr)\\)\n\nL’ensemble \\(Z\\) obtenu est la fermeture recherchée\nL’intérêt de cet algorithme est qu’on ne calcule pas toutes les DF locales. Si au cours du calcul on obtient que \\(Y\\subset Z\\), on peut conclure immédiatement que \\(X\\to Y\\) est préservée.\n\n\\(\\Sigma=\\left\\{B\\rightarrow E, CE\\rightarrow A\\right\\}\\)\n\n\\(CE\\to A\\) est préservée puisqu’elle est locale à \\(\\mathcal{A}_3\\).\n\\(B\\to E\\) n’est pas préservée puisque\n\\((B\\cap\\mathcal{A}_1)^+\\cap\\mathcal{A}_1=B^+\\cap\\mathcal{A}_1=BE\\cap\\mathcal{A}_1=B\\)\n\\((B\\cap\\mathcal{A}_2)^+\\cap\\mathcal{A}_2=B^+\\cap\\mathcal{A}_2=BE\\cap\\mathcal{A}_2=B\\)\n\\((B\\cap\\mathcal{A}_3)^+\\cap\\mathcal{A}_3=\\emptyset\\)\n\n\\(\\Sigma=\\left\\{AC\\rightarrow E, BC\\to D\\right\\}\\) est préservé puisqu’il ne contient que des DF locales.\n\\(\\Sigma=\\left\\{A\\rightarrow D, D\\to E, B\\to D\\right\\}\\)\n\\(B\\to D\\) est préservée\n\\(\\Sigma=\\left\\{A\\rightarrow D, CD\\to E, E\\to D\\right\\}\\)\nAucune DF n’est préservée\n\n\n\n\n\nExercice\nOn considère le schéma de relation suivant concernant la gestion de rendez-vous d’un service d’intervention hospitaliers. \\[\n\\mathcal{A}=\\left\\{\\texttt{IdM,NomM,PrenomM,DateRV,HeureRV,IdP,NomP,PrenomP,IdInterV}\\right\\}\n\\]\nChaque rendez-vous implique un médecin et un patient. Chaque médecin est identifié par un numéro, IdM, un nom NomM et un prénom PrenomM. Le rendez-vous est à une date, DateRV, et à une heure, HeureRV données. Chaque patient est identifié par un numéro, IdP, un nom NomP et un prénom PrenomP. Chaque rv est programmé pour un type d’intervention médical, IdInterV. On suppose que chaque jour, un médecin ne peut pratiquer qu’un seul type d’intervention médicale (consultation, type de chirurgie donnée).\nOn a les dépendances fonctionnelles \\(\\Sigma\\) suivantes:\nIdM, DateRV,HeureRV, IdInterV → IdP\nIdM, DateRV →  IdInterV\nIdM → NomM, PrenomM\nIdP → NomP, PrenomP\nIdP,DateRV,HeureRV → IdInterV\nIdP,DateRV,HeureRV →  IdM,NomM\n\nQuels sont les inconvénients d’une telle modélisation par une seule table en terme d’anomalies d’insertion ou de suppression ?\n\n\n\n\n\n\n\nSolution\n\n\n\nA chaque nouveau rv inséré dans \\(R\\), il faut rappeler les noms, prénoms des médecins et patients. Ce qui peut se traduire par des incohérences si cela n’est pas respecté. En cas de suppression d’un groupe de rv, on peut faire disparaitre l’ensemble des informations concernant un patient ou un médecin.\n\n\n\nCalculer \\([\\texttt{IdM}]^+_{\\Sigma}\\)\n\n\n\n\n\n\n\nSolution\n\n\n\n\\([IdM]^+_{\\Sigma}= \\{  \\texttt{IdM, NomM, PrenomM}\\}\\)\n\n\n\nProposez un ensemble d’attributs formant une clé de la relation.\n\n\n\n\n\n\n\nSolution\n\n\n\nIl y a plusieurs clés possibles. Par exemple, {IdM, DateRV, HeureRV} mais aussi {IdP, DateRV, HeureRV}.\n\n\n\nDonner un ensemble de dépendances fonctionnelles \\(\\Sigma'\\) équivalent à \\(\\Sigma\\) qui soit minimal (i.e. sans règles redondantes, notamment). Justifiez\n\n\n\n\n\n\n\nSolution\n\n\n\nIdM, DateRV, HeureRV → IdP\nIdP, DateRV, HeureRV → IdM\nIdM, DateRV → IdInterV\nIdM → NomM\nIdM → PrenomM\nIdP → NomP\nIdP → PrenomP\n\n\n\n\nOn se donne la décomposition de \\(\\mathcal{A}\\) suivante~: \\[\n\\begin{array}{l}\n    \\mathcal{A}_1=\\left\\{\\texttt{IdM,HeureRV,DateRV,IdP,NomP,PrenomP}\\right\\},\\\\\n     \\mathcal{A}_2=\\left\\{\\texttt{IdM,DateRV,IdInterV}\\right\\},\\\\\n     \\mathcal{A}_3=\\left\\{\\texttt{IdM,NomM,PrenomM}\\right\\}\n\\end{array}\n\\]\n\nToutes les dépendances fonctionnelles sont-elles préservées par cette décomposition ?\nEst-elle sans perte d’information ?\nPour \\(i=1,2,3\\), déterminer si \\(\\mathcal{A}_i\\) est en forme normale de Boyce-Codd.\n\n\n\n\n\n\n\nSolution\n\n\n\nPréservation des DF\nLes dépendances de Σ’ sont locales aux \\(\\mathcal{A}_i\\), elles sont donc préservées.\n\nDécomposition SPI ?\nOui, en utilisant seulement (b) et (c) dans l’algorithme de poursuite\\\n\\(\\mathcal{A}_i\\) est en FNBC~?\\\nRappelons que, par définition, \\(\\mathcal{A}_i\\) est en FNBC si et seulement pour toute DF \\(X\\to Y\\) dans un ensemble équivalent à \\(\\pi_{\\mathcal{A}_i}(\\Sigma)\\), soit \\(Y\\subset X\\) (DF triviale) soit \\(Y\\) est une super-clef pour \\(\\mathcal{A}_i\\) relativement à \\(\\pi_{\\mathcal{A}_i}(\\Sigma)\\).\nDonc \\(\\mathcal{A}_i\\) est en FNBC si et seulement si pour tout \\(X\\subset \\mathcal{A}_i\\), pour la DF locale \\(X\\to (X\\cap\\mathcal{A}_i)^+\\cap \\mathcal{A}_i\\) on a \\((X\\cap\\mathcal{A}_i)^+\\cap \\mathcal{A}_i = X\\) (DF triviale) ou \\((X\\cap\\mathcal{A}_i)^+\\cap \\mathcal{A}_i=\\mathcal{A}_i\\) (càd \\(X\\) est une super-clef pour \\(\\mathcal{A}_i\\)).\nDe plus, on n’a pas besoin d’examiner les cas \\(X=\\emptyset\\) ou \\(X=\\mathcal{A}_i\\) ou \\(cardinal(X)=cardinal(\\mathcal{A}_i)-1\\) (dans le dernier cas \\((X\\cap\\mathcal{A}_i)^+\\cap \\mathcal{A}_i=X\\) ou \\((X\\cap\\mathcal{A}_i)^+\\cap \\mathcal{A}_i=\\mathcal{A}_i\\))\n\\(\\mathcal{A}_1\\) n’est pas en FNBC car IdP → NomP, PrenomP est locale à \\(\\mathcal{A}_1\\) et IdP n’est pas une super-clef de \\(\\mathcal{A}_1\\).\n\\(\\mathcal{A}_2\\) est en FNBC car:\n\nIdM^+ ∩ \\mathcal{A}_2 = {idM, NomM, PrenomM} ∩ \\mathcal{A}_2 =IdM\n\\(DateRV^+\\cap\\mathcal{A}_2=\\left\\{dateRV\\right\\}\\cap\\mathcal{A}_2=DateRV\\)\n\\(IdInterV^+\\cap\\mathcal{A}_2=\\left\\{idInterV\\right\\}\\cap\\mathcal{A}_2=IdInterV\\)\\\n\n\\(\\mathcal{A}_3\\) est en FNBC car :\n\n\\(IdM^+\\cap\\mathcal{A}_3=\\left\\{idM,NomM,PrenomM\\right\\}\\cap\\mathcal{A}_3=\\mathcal{A}_3\\)\\\n\\(NomM^+\\cap\\mathcal{A}_3=\\left\\{nomM\\right\\}\\cap\\mathcal{A}_3=NomM\\)\\\n\\(PrenomM^+\\cap\\mathcal{A}_3=\\left\\{prenomM\\right\\}\\cap\\mathcal{A}_3=PrenomM\\)\n\n\n\n\nMêmes questions pour la décomposition :\n\n\\[\n\\begin{array}{rl}\n\\mathcal{A}_1 &=\\left\\{\\texttt{IdM,HeureRV,DateRV,IdP}\\right\\}\\\\\n\\mathcal{A}_2 &=\\left\\{\\texttt{IdP,NomP,PrenomP}\\right\\}, \\\\\n\\mathcal{A}_3 &=\\left\\{\\texttt{IdM,DateRV,IdInterV}\\right\\},\\\\\n\\mathcal{A}_4 &=\\left\\{\\texttt{IdM,NomM,PrenomM}\\right\\}\n\\end{array}\n\\]\n\n\n\n\n\n\nSolution\n\n\n\nLa décomposition est SPI. \\[\n\\begin{array}{|c|c|c|c|c|c|c|c|c|c|}\n\\hline  & IdM & NomM & PrenomM & DateRV & HeureRV & IdP & NomP & PrenomP & IdInterV \\\\\\hline\n\\hline \\mathcal{A}_1  & a & b_1 &  c_1& d & e & f & g_1 & h_1 & i_1 \\\\\n\\hline  \\mathcal{A}_2 & a_2 & b_2 & c_2 & d_2 & e_2 & f & g & h & i_2 \\\\\n\\hline \\mathcal{A}_3 & a & b_3 & c_3 & d & e_3 & f_3 & g_3 & h_3 & i \\\\\n\\hline \\mathcal{A}_4 & a & b & c & d_4 & e_4 & f_4 & g_4 & h_4 & i_4\\\\\n\\hline\n\\end{array}\n\\] (c) donne \\(b_1=b\\) et \\(c_1=c\\). (d) donne \\(g_1=g\\) et \\(h_1=h\\). (b) donne \\(i_1=i\\). La première ligne est \\((a,b,\\dots,i)\\).\\ \\ (b), (c), (d) sont préservées puisque locales.\\ Est-ce que (e) est préservée~? Initialisation \\(Z:=\\left\\{idP,DateRV,HeureRV\\right\\}\\)\\ \\((Z\\cap\\mathcal{A}_1)^+\\cap\\mathcal{A}_1=\\left\\{idP,DateRV,HeureRV\\right\\}^+\\cap\\mathcal{A}_1=\\mathcal{A}\\cap\\mathcal{A}_1=\\mathcal{A}_1\\), donc \\(Z:=\\mathcal{A}_1\\).\\ \\((Z\\cap\\mathcal{A}_3)^+\\cap\\mathcal{A}_3=\\left\\{idM,DateRV\\right\\}^+\\cap\\mathcal{A}_3=\\mathcal{A}_3\\) qui contient \\(IdInterV\\). On conclut que (e) est préservée.\\ (f) est préservée car (f) est impliquée par \\(IdP,DateRV,HeureRV\\to IdM\\) (locale à \\(\\mathcal{A}_1\\)) et (c). Est-ce que (a) est préservée~? Initialisation \\(Z:=\\left\\{idM,DateRV,HeureRV,IdInterV\\right\\}\\)\\ \\((Z\\cap\\mathcal{A}_1)^+\\cap\\mathcal{A}_1=\\left\\{idM,DateRV,HeureRV\\right\\}^+\\cap\\mathcal{A}_1=ALL\\cap\\mathcal{A}_1=\\mathcal{A}_1\\) qui contient \\(IdP\\). Donc (a) est préservée.\\ \\ car\\ \\(IdM^+\\cap\\mathcal{A}_1=IdM\\), \\(HeureRV^+\\cap\\mathcal{A}_1=HeureRV\\), \\(DateRV^+\\cap\\mathcal{A}_1=DateRV\\), \\(IdP^+\\cap\\mathcal{A}_1=IdP\\)\\ \\(\\left\\{idM,HeureRV\\right\\}^+\\cap\\mathcal{A}_1=\\left\\{idM,HeureRV\\right\\}\\), \\(\\left\\{idM,DateRV\\right\\}^+\\cap\\mathcal{A}_1=\\left\\{idM,DateRV\\right\\}\\), \\(\\left\\{idM,IdP\\right\\}^+\\cap\\mathcal{A}_1=\\left\\{idM,IdP\\right\\}\\), \\(\\left\\{heureRV,DateRV\\right\\}^+\\cap\\mathcal{A}_1=\\left\\{heureRV,DateRV\\right\\}\\), \\(\\left\\{heureRV,IdP\\right\\}^+\\cap\\mathcal{A}_1=\\left\\{heureRV,IdP\\right\\}\\), \\(\\left\\{dateRV, IdP\\right\\}^+\\cap\\mathcal{A}_1=\\left\\{dateRV, IdP\\right\\}\\)\\ car\\ \\(IdP^+\\cap\\mathcal{A}_2=\\mathcal{A}_2\\), \\(NomP^+\\cap\\mathcal{A}_2=NomP\\), \\(PrenomP^+\\cap\\mathcal{A}_2=PrenomP\\)\\ car\\ \\(IdM^+\\cap\\mathcal{A}_3=IdM\\), \\(DateRV^+\\cap\\mathcal{A}_3=DateRV\\), \\(IdInterV^+\\cap\\mathcal{A}_3=IdInterV\\)\\ car\\ \\(IdM^+\\cap\\mathcal{A}_4=\\mathcal{A}_4\\), \\(NomM^+\\cap\\mathcal{A}_4=NomM\\), \\(PrenomM^+\\cap\\mathcal{A}_4=PrenomM\\)\n\n\n\n\nExercice\nSoit une relation concernant des personnes résidant en France avec les attributs suivants:\nNom, Numéro de sécurité sociale, Commune, Département, Code postal, Numéro de téléphone\navec l’ensemble \\(\\Sigma\\) de DF suivantes~:\nNuméro de sécurité sociale → Nom, Commune, Département, Code postal, Numéro de téléphone \nCommune → Département \nCode postal → Commune, Département\n\nCe schéma est-il en forme normale de Boyce-Codd ?\n\nSoit la décomposition \\[\\mathcal{A}_1=\\left\\{\\texttt{Code postal}, \\texttt{Commune}, \\texttt{Département}\\right\\}\\] et \\[\\mathcal{A}_2=\\left\\{\\texttt{Numéro de sécurité sociale}, \\texttt{Nom}, \\texttt{Code postal},\\texttt{Numéro de téléphone}\\right\\}\\]\n\nChaque \\(\\mathcal{A}_i\\) est-elle en forme normale de Boyce-Codd ?\nCette décomposition préserve-t-elle les dépendances fonctionnelles ?\nCette décomposition est-elle sans perte d’information ?\nMêmes questions pour la décomposition \\[\\mathcal{A}_1=\\left\\{\\texttt{Commune}, \\texttt{Département}\\right\\}\\]\n\n\\[\\mathcal{A}_2=\\left\\{\\texttt{Numéro de sécurité sociale}, \\texttt{Nom}, \\texttt{Commune}, \\texttt{Code postal},\\texttt{Numéro de téléphone}\\right\\}\\]\n\n\n\n\n\n\nSolution\n\n\n\n\nNon, car on a \\(\\texttt{Commune} \\to \\texttt{Département}\\) et \\(\\texttt{Commune}\\) n’est pas une clef.\n\\(\\mathcal{A}_1\\) n’est pas en FNBC car \\(\\texttt{Commune} \\to \\texttt{Département}\\) est locale à \\(\\mathcal{A}_1\\) et \\(\\texttt{Commune}\\) n’est pas une clef de \\(\\mathcal{A}_1\\).\\ \\(\\mathcal{A}_2\\) est en FNBC puisque \\(\\pi_{\\mathcal{A}_2}(\\Sigma)\\) est équivalent à\\ \\(\\left\\{\\texttt{Numéro de sécurité sociale}\\to \\texttt{Nom, Code postal, Numéro de téléphone }\\right\\}\\)\\ Les DF sont préservées car \\(\\Sigma\\) est équivalent à\\ \\[\\{\\texttt{Numéro de sécurité sociale}\\to \\texttt{Nom, Code postal, Numéro de téléphone }\\};\\] \\[\\texttt{Commune}\\to\\texttt{Département} ;\\texttt{Code postal}\\to\\{\\texttt{Commune, Département}\\}\\] qui ne contient que des DF locales.\\ La décomposition est SPI.\n\\(\\mathcal{A}_1\\) est en FNBC car \\(\\mathcal{A}_2\\) est de cardinal 2.\\ \\(\\mathcal{A}_2\\) n’est pas en FNBC car \\(\\texttt{CodePostal} \\to \\texttt{Département}, \\texttt{Commune}\\) est locale et \\(\\texttt{CodePostal}\\) n’est pas une clé de \\(\\mathcal{A}_2\\)\\ La décomposition est SPI et préserve les DF.\n\n\n\n\n\nExercice\nSoit un schéma d’attributs \\(A_1, A_2,\\dots A_n\\) et un ensemble de dépendances fonctionnelles. Calculer le nombre de super-clefs (en fonction de \\(n\\)) dans les cas suivants~:\n\nLa seule clef est \\(\\left\\{A_1\\right\\}\\).\nLes seules clefs sont \\(\\left\\{A_1\\right\\}\\) et \\(\\left\\{A_2\\right\\}\\).\nLes seules clefs sont \\(\\left\\{A_1,A_2\\right\\}\\) et \\(\\left\\{A_3,A_4\\right\\}\\).\nLes seules clefs sont \\(\\left\\{A_1,A_2\\right\\}\\) et \\(\\left\\{A_1,A_3\\right\\}\\).\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\\(2^{n-1}\\)\n\\(2^{n-2} + 2^{n-2} + 2^{n-2}\\)\n\\(2^{n-4}Titremes 3Titremes 2 + 2^{n-4}\\)\n\\(3Titremes 2^{n-3}\\)\n\n\n\n\n\nExercice\nSoit le schéma \\(\\mathcal{A}=\\{A,B,C,D\\}\\) et l’ensemble de dépendances fonctionnelles \\[\\Sigma = \\{ A \\to B, B \\to C\\} \\]\n\nQuelle est la fermeture \\(\\{A\\}^+\\) de \\(\\{A\\}\\) ?\n\n\n\n\n\n\n\nSolution\n\n\n\nInitialisation : \\(X  =\\{A\\}\\)\nEtape 1 : Il existe une DF dont la partie gauche est incluse dans $ X$ : \\(A \\to B\\). On rajoute les attributs en partie droite.\nD’où \\(X  = \\{A, B\\}\\)\nEtape 2: Il existe une DF dont la partie gauche est incluse dans $ X$ : \\(B \\to C\\). On rajoute les attributs en partie droite.\nD’où \\(X  = \\{A,B,C\\}\\).\nC’est fini, plus de DF à utiliser. Conclusion \\(\\left\\{A\\right\\}^+=\\left\\{A,B,C\\right\\}\\)\n\n\n\nQuelles sont les super-clés ? Les clés ?\n\n\n\n\n\n\n\nSolution\n\n\n\nUne clef doit contenir \\(\\left\\{A,D\\right\\}\\) puis ces deux attributs ne sont à droite d’aucune DF de \\(\\Sigma\\). De plus \\(\\left\\{A,D\\right\\}^+=\\left\\{A,B,C,D\\right\\}\\). La seule clef est donc \\(\\{A,D\\}\\).\n\n\n\n\nExercice\nSoit le schéma \\(\\mathcal{A}=\\{A,B,C,D,E,F\\}\\) et l’ensemble de dépendances fonctionnelles \\[\\Sigma = \\Bigl\\{ \\left\\{A,B\\right\\}\\to C, \\left\\{B,C\\right\\}\\to \\left\\{A,D\\right\\}, D\\to E, \\left\\{C,F\\right\\}\\to B \\Bigr\\}\\]\n\nCalculer la fermeture \\(\\left\\{A,B\\right\\}^+\\) de \\(\\left\\{A,B\\right\\}\\).\nEst-ce que \\(\\Sigma\\) implique la dépendance fonctionnelle \\(\\left\\{A,B\\right\\}\\to D\\)~?\nEst-ce que \\(\\Sigma\\) implique la dépendance fonctionnelle \\(D\\to A\\)~?\n\n\n\n\n\n\n\nSolution\n\n\n\n\nOn obtient \\(\\left\\{A,B\\right\\}^+=\\left\\{A,B,C,D,E\\right\\}\\).\nOui car \\(D\\in\\left\\{A,B\\right\\}^+\\)\nNon car \\(\\left\\{D\\right\\}^+=\\left\\{D,E\\right\\}\\) ne contient pas \\(A\\).\n\n\n\n\n\n\nExercice\nOn considère une schéma \\(\\mathcal{A}\\) avec les attributs\nPropriétaire, Occupant, Adresse, Noapt, Nbpièces, Nbpersonnes\nUn nuplet/tuple (p, o, a, n, nb1, nb2) ayant la signification suivante : La personne o habite avec nb2 personnes l’appartement de numéro n ayant nb1 pièces dont le propriétaire est p.\nUne analyse de cette relation nous fournit un ensemble initial \\(\\Sigma\\) de dépendances fonctionnelles\nOccupant → Adresse\nOccupant → Noapt\nOccupant → Nbpersonnes\nAdresse, Noapt → Proprietaire\nAdresse, Noapt → Occupant\nAdresse, Noapt → Nbpieces\n\nDéterminer les clés du schémas\nLes schéma est-il en FN3 ?\nSi la réponse est Non, décomposer sans perte d’information et sans perte de dépendances fonctionnelles.\n\n\n\nExercice\n\nSoit le schéma \\[\\mathcal{A}=\\{\\texttt{IdLivre, Titre, Langue, Pays, IdTraducteur, Nom, Date}\\}\\] et l’ensemble de DF\nIdLivre → Titre \nLangue → Pays \nIdTraducteur → Nom \nIdLivre, IdTraducteur, Langue → Date\nIdLivre, IdTraducteur → Langue\nAppliquer l’algorithme de décomposition vu en cours pour obtenir une décomposition de \\(\\mathcal{A}\\) qui respecte la FNBC et est sans perte d’information. Déterminer quelles DF sont préservées.\n\n\n\n\n\n\nSolution\n\n\n\n\\(\\texttt{IdLivre}^+=\\texttt{IdLivre, Titre}\\) \\[ \\mathcal{A}_1=\\texttt{IdLivre,Titre} \\quad \\mathcal{A}_2=\\texttt{IdLivre, Langue, Pays, IdTraducteur, Nom, Date}\\] \\(\\texttt{Langue}^+= \\texttt{Langue, Pays}\\) \\[ \\mathcal{A}_{2,1}=\\texttt{Langue, Pays} \\quad \\mathcal{A}_{2,2}=\\texttt{IdLivre, Langue, IdTraducteur, Nom, Date} \\] \\(\\texttt{IdTraducteur}^+=\\texttt{IdTraducteur, Nom}\\) \\[ \\mathcal{A}_{221}=\\texttt{IdTraducteur, Nom} \\quad \\mathcal{A}_{222}=\\texttt{IdLivre,Langue, IdTraducteur, Date}\\] La décomposition FNBC obtenue est \\[ \\{\\texttt{IdLivre,Titre} \\}\\quad \\{\\texttt{Langue, Pays}\\} \\quad \\{\\texttt{IdTraducteur, Nom}\\} \\quad \\{\\texttt{IdLivre,Langue, IdTraducteur, Date}\\}\\] qui préserve toutes les DF.\n\n\n\n\nExercice\nSoit le schéma \\[\\mathcal{A}=\\left\\{\\texttt{A,B,C,D,E,F,G,H}\\right\\}\\] et l’ensemble de DF\nBE → AC  \nB → H  \nF → CD  \nD → G\n\nAppliquer l’algorithme de décomposition vu en cours pour obtenir une décomposition de \\(\\mathcal{A}\\) qui respecte la FNBC et est sans perte d’information. Déterminer quelles DF sont préservées.\nPeut-on, en ajoutant un sous-schéma à la décomposition, obtenir une décomposition FNBC sans perte d’information et sans perte de DF ?\n\n\n\n\n\n\n\nSolution\n\n\n\nRappelons l’algorithme pour décomposer un schéma \\(\\mathcal{A}\\)~:\n\nOn considère la décomposition initiale \\(\\rho=\\{\\mathcal{A}\\}\\).\nTant qu’il existe un sous-schéma \\(\\mathcal{B}\\in\\rho\\) et \\(X\\subset \\mathcal{B}\\) tels que \\(X^+\\cap\\mathcal{B}\\not=X\\) et \\(X^+\\cap\\mathcal{B}\\not=\\mathcal{B}\\) (ce qui signifie que la DF locale \\(X\\to X^+\\cap\\mathcal{B}\\) est une violation de FNBC pour \\(\\mathcal{B}\\)), on remplace \\(\\mathcal{B}\\) par les deux sous-schémas \\[\\mathcal{B}_1=X^+\\cap\\mathcal{B} \\text{ et } \\mathcal{B}_2=(\\mathcal{B}\\setminus X^+)\\cup X\\] De plus il n’y a pas besoin de considérer les parties \\(X\\subset\\mathcal{B}\\) telles que \\(card(X)=card(\\mathcal{B})-1\\) puisque dans ce cas on \\(X^+\\cap \\mathcal{B}=X\\) ou \\(X^+\\cap\\mathcal{B}=\\mathcal{B}\\).\n\nIl est garanti que la décomposition finale est en FNBC et SPI. Par contre toutes les DF ne sont pas préservées en général. De plus on obtient, en général, des décompositions différentes si on change les DF (violant FNBC) utilisées. } - \\(BE^+=BEACH\\) donc on remplace \\(\\mathcal{A}\\) par \\[ \\mathcal{A}_1=BEACH \\quad \\mathcal{A}_2=BDEFG\\] \\(B^+=BH\\) donc on remplace \\(\\mathcal{A}_1\\) par \\[\\mathcal{A}_{11}=BH \\quad \\mathcal{A}_{12}=BEAC\\] \\(\\mathcal{A}_{11}\\) est en FNBC car de cardinal 2. \\(\\mathcal{A}_{12}\\) est en FNBC car \\[B^+\\cap\\mathcal{A}_{12}=B, E^+\\cap\\mathcal{A}_{12}=E, A^+\\cap\\mathcal{A}_{12}=A, C^+\\cap\\mathcal{A}_{12}=C \\] \\[BE^+\\cap\\mathcal{A}_{12}=BEAC, BA^+\\cap\\mathcal{A}_{12}=BA, BC^+\\cap\\mathcal{A}_{12}=BC, EA^+\\cap\\mathcal{A}_{12}=EA, EC^+\\cap\\mathcal{A}_{12}=EC\\] \\[ AC^+\\cap\\mathcal{A}_{12}=AC\\] \\(D^+=DG\\) donc on remplace \\(\\mathcal{A}_2\\) par \\[\\mathcal{A}_{21}=DG \\quad \\mathcal{A}_{22}=BDEF\\] \\(\\mathcal{A}_{21}\\) est en FNBC car de cardinal 2. \\(F^+=CD\\) donc on remplace \\(\\mathcal{A}_{22}\\) par \\[\\mathcal{A}_{221}=FD \\quad \\mathcal{A}_{222}=BEF\\] qui sont tous deux en FNBC\nDécomposition obtenue~:\nBH  BEAC  DG  FD  BEF\nLa seule DF qui n’est pas préservée est \\(F\\to C\\). Toutes les variantes (en changeant les DF utilisées) que j’ai testées, donne une décomposition qui ne préserve pas toutes les DF. Bien sûr ce n’est pas une preuve que l’algorithme ne peut pas donner une décomposition sans perte de DF. - En ajoutant \\(FC\\) à la décomposition précédente, on obtient\nBH   BEAC   DG   FD   BEF   FC\nqui est en FNBC et préserve les DF. De plus elle est SPI puisque la décomposition initiale est SPI. (\\(R \\bowtie \\pi_{FC}(R)=R\\) pour toute relation \\(R\\))\n\n\n\n\nExercice\nReprendre les questions de l’exercice précédent pour le schéma \\[\\mathcal{A}=\\left\\{\\texttt{A,B,C,D,E,F,G,H}\\right\\}\\] et l’ensemble de DF\nBE → AC  \nB → H\nF → CD\nD → G\nA→ E\n\n\n\n\n\n\nSolution\n\n\n\n\nDe manière similaire à l’exercice précédent on arrive à\n\nBH   BEAC   DG   FD   BEF\nmais, ici, BEAC n’est pas en FNBC (les autres le sont). A^+=AE donc on remplace BEAC par AE et ABC. Une décomposition FNBC est donc BH   AE   ABC   DG   FD   BEF Les DF BE → AC et F → C ne sont pas préservées. Les autres sont préservées.\n\nIl n’existe de décomposition FNBC qui préserve BE → A. En effet, si BE → A est préservée, il existe une DF locale à un sous-schéma \\(\\mathcal{B}\\) de la forme X → A. Cela implique que BE ⊂ X et donc BEA ⊂ B. Par suite \\(\\mathcal{B}\\) n’est pas en FNBC à cause de \\(A^+=AE\\)."
  },
  {
    "objectID": "solutions/td4.html",
    "href": "solutions/td4.html",
    "title": "TD 4: SQL",
    "section": "",
    "text": "Avec solutions\nDocumentation Postgres\nDocumentation Postgres en Français"
  },
  {
    "objectID": "solutions/td4.html#count",
    "href": "solutions/td4.html#count",
    "title": "TD 4: SQL",
    "section": "Count",
    "text": "Count\nPour compter les pays en Europe, on écrira :\nSELECT COUNT(countrycode)\nFROM world.country\nWHERE continent='Europe';\nCette requête renvoie une table ayant une ligne et une colonne contenant le nombre de lignes dans le résultat de la requête."
  },
  {
    "objectID": "solutions/td4.html#sum-max-min-avg",
    "href": "solutions/td4.html#sum-max-min-avg",
    "title": "TD 4: SQL",
    "section": "Sum, Max, Min, Avg",
    "text": "Sum, Max, Min, Avg\nUne autre fonction importante est la fonction SUM(col) qui effectue la somme des valeurs (numériques) d’une colonne :\nSELECT SUM(population_country)\nFROM world.country;\nrenvoie la population mondiale.\nOn peut de même utiliser GROUP BY pour faire des paquets :\nSELECT \n  continent, SUM(population_country)\nFROM \n  world.country\nGROUP BY continent;\nrenvoie la population de chaque continent.\nOn peut même faire des opérations sur la colonne à l’intérieur de SUM. Par exemple: SUM(percentage/100).\n\n\n\n\n\n\nQuestion\n\n\n\nÉcrire une requête qui renvoie le nombre de langues officielles par pays\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\nWITH s AS(\n    SELECT L.countrycode, sum(CAST (isofficial AS INTEGER)) AS n_official\n    FROM  world.countrylanguage as L\n    GROUP BY L.countrycode)\nSELECT s.*, c.name_country\nFROM world.country c NATURAL JOIN s\nORDER BY s.n_official DESC, s.countrycode;"
  },
  {
    "objectID": "solutions/td5.html",
    "href": "solutions/td5.html",
    "title": "TD 5: SQL",
    "section": "",
    "text": "Avec solutions"
  },
  {
    "objectID": "solutions/td5.html#over-partition-by",
    "href": "solutions/td5.html#over-partition-by",
    "title": "TD 5: SQL",
    "section": "OVER (PARTITION BY …)",
    "text": "OVER (PARTITION BY …)\nCette construction peut être combinée avec n’importe quelle fonction d’aggrégation.\nCette requête indique pour chaque ville, la “population moyenne” des villes de ce pays (cette moyenne n’a aucun sens).\nSELECT id, name_city, population_city, \n       avg(population_city) OVER (PARTITION BY countrycode)  AS avg_pop\nFROM world.city;  \nSans le mécanisme de fenêtrage, on pourrait obtenir le résultat au prix d’une jointure\n WITH tmp AS (\n  SELECT c.countrycode, AVG(c.population_city) AS avg_pop\n  FROM world.city c\n  GROUP BY c.countrycode\n ) \n  SELECT cc.id, cc.name_city, cc.population_city, tmp.avg_pop\n  FROM world.city cc NATURAL JOIN tmp;"
  },
  {
    "objectID": "solutions/td5.html#over-partition-by-order-by",
    "href": "solutions/td5.html#over-partition-by-order-by",
    "title": "TD 5: SQL",
    "section": "OVER (PARTITION BY … ORDER BY)",
    "text": "OVER (PARTITION BY … ORDER BY)\nOn peut partitioner et trier.\nCette construction est très pratique pour ranger les tuples d’un sous-groupe.\nDans world, si on veut ranger les langues parlées dans un pays par popularité décroissante, on peut procéder ainsi.\nSELECT countrycode, LANGUAGE, \nRANK() OVER (PARTITION BY countrycode ORDER BY percentage DESC)  AS rnk\nFROM world.countrylanguage ;"
  },
  {
    "objectID": "solutions/td5.html#rank-over",
    "href": "solutions/td5.html#rank-over",
    "title": "TD 5: SQL",
    "section": "RANK() OVER ()",
    "text": "RANK() OVER ()\nOn peut ne pas partitionner en utilisant l’expression OVER (). Par exemple, si on veut obtenir le rang des tuples d’une table sur un tri particulier.\nSELECT countrycode, name_country, \n       RANK() OVER (ORDER BY population_country DESC)  AS rnk\nFROM world.country ;"
  },
  {
    "objectID": "solutions/td5.html#autres-types-de-fenêtres",
    "href": "solutions/td5.html#autres-types-de-fenêtres",
    "title": "TD 5: SQL",
    "section": "Autres types de fenêtres",
    "text": "Autres types de fenêtres\nLa construction OVER ( ...) n’est pas utilisée exclusivement avec des partitions (peut-être triviales), on peut aussi définir des fenêtres glissantes.\nLes fonctions fenêtre ne sont autorisées que dans la liste SELECT et la clause ORDER BY de la requête. Elles sont interdites ailleurs, par exemple dans les clauses GROUP BY, HAVING et WHERE."
  },
  {
    "objectID": "solutions/td5.html#forme-générale",
    "href": "solutions/td5.html#forme-générale",
    "title": "TD 5: SQL",
    "section": "Forme générale",
    "text": "Forme générale\nCREATE OR REPLACE FUNCTION  schema_name.func_name(p_arg1 p_arg1_datatype, ..., [OUT o_arg1 o_arg1_datatype, ...])\nRETURNS some type | RECORD | SETOF some type | TABLE (..) \nLANGUAGE SQL AS\n$$\nSQL statement ;\nSQL statement ;\n...\nSQL statement ;\n$$ ;"
  },
  {
    "objectID": "solutions/td5.html#fonctions-qui-retournent-un-type-simple",
    "href": "solutions/td5.html#fonctions-qui-retournent-un-type-simple",
    "title": "TD 5: SQL",
    "section": "Fonctions qui retournent un type simple",
    "text": "Fonctions qui retournent un type simple\nDans le schéma world, on veut écrire une fonction qui prend en argument une région et renvoie la population maximale parmi les capitales de la région (voir td2 requête 1).\nCREATE OR REPLACE FUNCTION username.taille_max_capitale_region(p_region text)\nRETURNS INTEGER LANGUAGE SQL AS\n$$\nSELECT MAX(population_city) AS max_pop\nFROM world.country c JOIN world.city cc ON (c.capital=cc.id)\nWHERE c.region=p_region AND cc.population_city IS NOT NULL;\n$$ ;"
  },
  {
    "objectID": "solutions/td5.html#fonctions-qui-retournent-un-type-composé",
    "href": "solutions/td5.html#fonctions-qui-retournent-un-type-composé",
    "title": "TD 5: SQL",
    "section": "Fonctions qui retournent un type composé",
    "text": "Fonctions qui retournent un type composé\nDans le schéma world, on veut écrire une fonction qui prend en argument une région et renvoie le nom et la population de la capitale la plus peuplée de cette région (voir td2 requête 1).\nOn peut utiliser le qualifiant OUT pour désigner des paramètres de sortie.\nCREATE OR REPLACE FUNCTION username.capitale(p_region text, OUT o_name_capital TEXT, OUT o_population_capital INTEGER)\nRETURNS RECORD  LANGUAGE SQL AS\n$$\nWITH r AS(\n  SELECT cc.*, RANK() OVER (PARTITION BY c.region \n                            ORDER BY cc.population_city DESC) AS rnk\n  FROM world.country c JOIN world.city cc ON (c.capital=cc.id)\n  WHERE c.region=p_region)\nSELECT r.name_city,  r.population_city\nFROM r \nWHERE r.rnk = 1 ;\n$$ ;"
  },
  {
    "objectID": "solutions/td5.html#fonctions-qui-retournent-un-type-composé-défini-par-les-lignes-dune-table",
    "href": "solutions/td5.html#fonctions-qui-retournent-un-type-composé-défini-par-les-lignes-dune-table",
    "title": "TD 5: SQL",
    "section": "Fonctions qui retournent un type composé défini par les lignes d’une table",
    "text": "Fonctions qui retournent un type composé défini par les lignes d’une table\nDans le schéma world, on veut écrire une fonction qui prend en argument une région et renvoie la description de la capitale la plus peuplée de cette région (voir td2 requête 1).\nCREATE OR REPLACE FUNCTION username.capitale(p_region text)\nRETURNS world.city  LANGUAGE SQL AS\n$$\nWITH r AS(\n  SELECT cc.*, RANK() OVER (PARTITION BY c.region \n                            ORDER BY cc.population_city DESC) AS rnk\n  FROM world.country c JOIN world.city cc ON (c.capital=cc.id)\n  WHERE c.region=p_region\n)\nSELECT r.id, r.name_city, r.countrycode, r.district, r.population_city\nFROM r \nWHERE r.rnk = 1 ;\n$$ ;"
  },
  {
    "objectID": "solutions/td5.html#fonctions-qui-retournent-une-table",
    "href": "solutions/td5.html#fonctions-qui-retournent-une-table",
    "title": "TD 5: SQL",
    "section": "Fonctions qui retournent une table",
    "text": "Fonctions qui retournent une table\nDans le schéma world, on veut écrire une fonction qui prend en argument une région et renvoie la table des capitales de la région (voir td2 requête 1).\n\nTable de schéma explicite\nOn se contente d’abord de renvoyer le nom de la capitale. On explicite le schéma de la table résultat\nCREATE OR REPLACE FUNCTION username.capitales_region(p_region text)\nRETURNS TABLE (name_capital text) LANGUAGE SQL AS\n$$\nSELECT cc.name_city \nFROM world.country c JOIN world.city cc ON (c.capital=cc.id)\nWHERE c.region=p_region ;\n$$ ;\n\n\nTable de même schéma qu’une autre table\nDocumentation\nOn veut maintenant récupérer une table de même schéma que city.\n\n\n\n\n\n\nLa solution est très simple. On profite de ce qu’à chaque table correspond un type de même nom et on utilise le mot-clé SETOF.\n\n\n\nCREATE OR REPLACE FUNCTION username.capitales_region_large(p_region text)\nRETURNS SETOF world.city  LANGUAGE SQL AS\n$$\nSELECT cc.* \nFROM world.country c JOIN world.city cc ON (c.capital=cc.id)\nWHERE c.region=p_region ;\n$$ ;"
  },
  {
    "objectID": "solutions/td9.html",
    "href": "solutions/td9.html",
    "title": "TD 9: Normalisation et dépendances",
    "section": "",
    "text": "Avec solutions\n\n\n\n\n\n\n\n\n\n\n\n\nAvec solutions\n\n\n\n\n\n\n\n\n\n\n\n\n\nL3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2024-2025\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\n\nDéfinitions\nUne dépendance fonctionnelle est une expression de la forme \\[A_1,A_2,\\ldots,A_k \\rightarrow A_{k+1},\\ldots,A_n\\] où \\(A_1,A_2,\\ldots,A_k, A_{k+1},\\ldots,A_n\\) sont des attributs (colonnes) d’une base de données.\nElle signifie que deux tuples ayant la même valeur sur \\(A_1,\\ldots,A_k\\) doivent avoir la même valeur sur chaque colonnes \\(A_{k+1},\\ldots, A_n\\) (en français : \\(A_1,\\ldots,A_k\\) déterminent \\(A_{k+1},\\ldots,A_n\\). On dit que les attributs \\(A_{k+1},\\ldots, A_n\\) dépendent fonctionnellement de \\(A_1,A_2,\\ldots,A_k\\).\nLa notion de dépendance est transitive : si \\(A \\rightarrow B\\) et \\(B \\rightarrow C\\) alors \\(A \\rightarrow C\\).\nUn ensemble de dépendances fonctionnelles \\(\\mathcal{F}\\) est 1 si aucune dépendance ne peut être déduite des autres en utilisant les règles suivantes :\n\ntrivialité : si \\(Y\\subseteq X\\) alors \\(X\\rightarrow Y\\)\naugmentation : si \\(X\\rightarrow Y\\) alors \\(X,Z\\rightarrow Y,Z\\) pour toute suite d’attributs \\(Z\\).\ntransitivité : si \\(X\\rightarrow Y\\) et \\(Y\\rightarrow Z\\) alors \\(X\\rightarrow Z\\)\nunion : si \\(X\\rightarrow Y\\) et \\(X\\rightarrow Z\\) alors \\(X\\rightarrow Y,Z\\)\ndécomposition/séparation si \\(X\\rightarrow Y\\) et \\(Z\\subseteq Y\\) alors \\(X\\rightarrow Z\\)\n\nLa clôture transitive des attributs \\(A_1,\\ldots, A_k\\) pour un ensemble de dépendances fonctionnelles \\(\\mathcal F\\) est l’ensemble des attributs \\(B_1,\\ldots, B_{\\ell}\\) qui dépendent fonctionnellement de \\(A_1,\\ldots, A_k\\).\nOn la note \\[[A_1,\\ldots, A_k]^+_{\\mathcal{F}}\\] en oubliant \\(\\mathcal{F}\\) si le contexte est clair.\nUn ensemble d’attributs \\(A_1,\\ldots, A_k\\) est une super-clé pour une relation \\(R(B_1,\\ldots, B_{\\ell})\\) si ce sont des attributs de \\(R\\) et si sa clôture transitive contient \\(B_1,\\ldots, B_{\\ell}\\). C’est une clé si elle est minimale, c’est-à-dire, aucun sous-ensemble strict de cette super-clé n’est une clé.\nUn schéma est en :\n\n\\(\\text{FN}_1\\) si tout attribut est atomique.\n\\(\\text{FN}_2\\) si un attribut ne fait pas partie d’une clef, il ne peut pas dépendre d’une partie stricte d’une clef.\n\\(\\text{FN}_3\\) Pour toute dépendance fonctionnelle non triviale, le membre de gauche contient une clef ou tout attribut du membre de droit appartient à une clef.\n\nUn schéma et un ensemble de dépendances fonctionnelles peut se décomposer en une collection de schémas, dans le sens où chaque relation \\(R\\) peut se décomposer en \\(R_1,\\ldots, R_k\\) tels que \\(R_i = \\pi_i(R)\\) pour une certaine projection \\(\\pi_i\\).\nOn dit cette décomposition si toute relation \\(R\\) du schéma d’origine peut être retrouvée à partir des relations \\(R_1,\\ldots, R_k\\) : \\(R = \\pi_1(R) \\bowtie \\ldots \\bowtie \\pi_k(R)\\).\nOn dit que cette décomposition respecte les dépendances fonctionnelles si celles-ci sont toujours satisfaites par la nouvelle décomposition.\n\n\nExercice\nSoit une relation concernant des personnes en France avec les attributs suivants~:\\ Nom, Numéro de sécurité sociale, Commune, Département, Code postal, Numéro de téléphone\nQuelles sont les dépendances fonctionnelles censées être satisfaites~?\n\n\n\n\n\n\nSolution\n\n\n\n\nNuméro de sécurité sociale \\(\\to\\) Nom, Commune, Département, Code postal, Numéro de téléphone\nCommune, Département \\(\\longrightarrow\\) Code postal\nCode postal \\(\\to\\) Département\n\n\n\n\n\nExercice\nSoit un schéma d’attributs \\(A_1, A_2,\\dots A_n\\) et un ensemble de dépendances fonctionnelles. Calculer le nombre de super-clefs (en fonction de \\(n\\)) dans les cas suivants~:\n\nLa seule clef est \\(\\{A_1\\}\\).\nLes seules clefs sont \\(\\{A_1\\}\\) et \\(\\{A_2\\}\\).\nLes seules clefs sont \\(\\{A_1,A_2\\}\\) et \\(\\{A_3,A_4\\}\\).\nLes seules clefs sont \\(\\{A_1,A_2\\}\\) et \\(\\{A_1,A_3\\}\\).\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\\(2^{n-1}\\)\n\\(2^{n-2} + 2^{n-2} + 2^{n-2}\\)\n\\(2^{n-4}\\times 3\\times 2 + 2^{n-4}\\)\n\\(3\\times 2^{n-3}\\)\n\n\n\n\n\nExercice\nSoit le schéma \\(\\mathcal{A}=\\{A,B,C,D\\}\\) et l’ensemble de dépendances fonctionnelles \\[\\Sigma = \\{ A \\longrightarrow B, B \\longrightarrow C\\} \\]\n\nQuelle est la fermeture \\(\\{A\\}^+\\) de \\(\\{A\\}\\) ?\n\n\n\n\n\n\n\nSolution\n\n\n\nInitialisation : \\(X  =\\{A\\}\\)\nEtape 1 : Il existe une DF dont la partie gauche est incluse dans $ X$ : \\(A \\longrightarrow B\\). On rajoute les attributs en partie droite. D’où \\(X  = \\{A, B\\}\\)\nEtape 2: Il existe une DF dont la partie gauche est incluse dans $ X$ : \\(B \\longrightarrow C\\). On rajoute les attributs en partie droite. D’où \\(X  = \\{A,B,C\\}\\).\nC’est fini, plus de DF à utiliser. Conclusion \\(\\{A\\}^+=\\{A,B,C\\}\\)\n\n\n\nQuelles sont les super-clés ? Les clés ?\n\n\n\n\n\n\n\nSolution\n\n\n\nUne clef doit contenir \\(\\{A,D\\}\\) puisque ces deux attributs ne sont à droite d’aucune DF de \\(\\Sigma\\). De plus \\(\\{A,D\\}^+=\\{A,B,C,D\\}\\). La seule clef est donc \\(\\{A,D\\}\\).\n\n\n\n\nExercice\nSoit le schéma \\(\\mathcal{A}=\\{A,B,C,D,E,F\\}\\) et l’ensemble de dépendances fonctionnelles \\[\\Sigma = \\Bigl\\{ \\{A,B\\}\\to C, \\{B,C\\}\\to \\{A,D\\}, D\\to E, \\{C,F\\}\\to B \\Bigr\\}\\]\n\nCalculer la fermeture \\(\\{A,B\\}^+\\) de \\(\\{A,B\\}\\).\nEst-ce que \\(\\Sigma\\) implique la dépendance fonctionnelle \\(\\{A,B\\}\\to D\\)~?\nEst-ce que \\(\\Sigma\\) implique la dépendance fonctionnelle \\(D\\to A\\)~?\n\n\n\n\n\n\n\nSolution\n\n\n\n\nOn obtient \\(\\{A,B\\}^+=\\{A,B,C,D,E\\}\\).\nOui car \\(D\\in\\{A,B\\}^+\\)\nNon car \\(\\{D\\}^+=\\{D,E\\}\\) ne contient pas \\(A\\).\n\n\n\n\n\nExercice\nMontrer que les assertions suivantes sont fausses~:\n\n\\(A\\to B\\) implique \\(B\\to A\\).\nSi \\(\\{A,B\\}\\to C\\) et \\(A\\to C\\) alors \\(B\\to C\\).\nSi \\(\\{A,B\\}\\to C\\) alors \\(A\\to C\\) ou \\(B\\to C\\).\n\n\n\n\n\n\n\nSolution\n\n\n\n\nLa relation \\[\n\\begin{array}{|c|c|}\n\\hline A & B \\\\\\hline\n\\hline 1 & 2  \\\\\n\\hline 4 & 2  \\\\\n\\hline\n\\end{array}\n\\] satisfait \\(A\\to B\\) mais pas \\(B\\to A\\).\nLa relation \\[\n\\begin{array}{|c|c|c|}\n\\hline A & B & C\\\\\\hline\n\\hline 1 & 2 & 3 \\\\\n\\hline 4 & 2 & 4  \\\\\n\\hline\n\\end{array}\n\\] satisfait \\(\\{A,B\\}\\to C\\) et \\(A\\to C\\) mais pas \\(B\\to C\\).\nLa relation \\[\n\\begin{array}{|c|c|c|}\n\\hline A & B & C\\\\\\hline\n\\hline 1 & 2 & 3 \\\\\n\\hline 4 & 2 & 4  \\\\\n\\hline 1 & 3 & 1 \\\\\n\\hline\n\\end{array}\n\\] satisfait \\(\\{A,B\\}\\to C\\) mais ni \\(A\\to C\\) ni \\(B\\to C\\).\n\n\n\n\n\nExercice\n\nSoit le schéma \\(\\mathcal{A}=\\{A, B,C, D, E, F, G, H\\}\\) et soit \\[\\Sigma = \\{AB \\longrightarrow C; \\ B \\longrightarrow D;  \\ CD \\longrightarrow E;  \\ CE \\longrightarrow GH; \\  G \\longrightarrow A\\} \\] Est-ce que les dépendances\n\\(A,B \\longrightarrow E\\)\n\\(B,G \\longrightarrow C\\)\n\\(A,B \\longrightarrow G\\)\n\nsont déductibles de \\(\\Sigma\\)~?\n\n\n\n\n\n\nSolution\n\n\n\noui… Méthode à suivre : pour la première et la troisième, on calcule la fermeture de \\(\\{A,B\\}\\). On a \\(\\{A,B\\}^+=\\{A,B,C,D,E,G,H\\}\\).\nPour la seconde, on a \\(\\{B,G\\}^+=\\{A,B,C,D,E,G,H\\}\\).\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\nPour que \\(\\mathcal{F}\\) soit minimale, il y a 3 conditions à remplir :\n\nF est sous forme canonique, un seul attribut à droite.\nAucune DF redondante , i.e. ne pouvant être déduite des autres.\nAucune DF redondante à gauche.\n\nn’est pas minimale: $C,E H $ est redondante à gauche.\nOn la remplace par $C H $.\nDe même \\(A \\longrightarrow H\\) est redondante.\nUne version minimale est :\n\\[\\mathcal{F} = \\{A \\longrightarrow B ; C \\longrightarrow H ; C \\longrightarrow E ; A \\longrightarrow C\\}\\]\n\n\n\nSoit \\[\\Sigma_1 = \\{A \\longrightarrow B ; C,E \\longrightarrow H ; C \\longrightarrow E ; A \\longrightarrow C,H\\}\\] et \\[\\Sigma_2 = \\{A \\longrightarrow B,C ;  C \\longrightarrow E,H\\}\\] Les deux ensembles de dépendances fonctionnelles \\(\\Sigma_1\\) et \\(\\Sigma_2\\) sont-ils équivalents ?\n\n\n\n\n\n\n\nSolution\n\n\n\nMontrons que \\(\\Sigma_1\\) implique \\(\\Sigma_2\\). \\(A\\to B\\) et \\(C\\to E\\) sont dans \\(\\Sigma_1\\). \\(A\\to C\\) est impliqué par \\(A\\to CH \\in \\Sigma_1\\). Donc \\(A\\to BC\\) se déduit de \\(\\Sigma_1\\). De plus \\(\\Sigma_1\\) implique \\(C\\to H\\) (puisque \\(\\Sigma_1\\) contient \\(C\\to E\\) et \\(CE\\to H\\)). Donc \\(\\Sigma_1\\) implique \\(C\\to EH\\). On a montré que toutes les DF de \\(\\Sigma_2\\) sont impliquées par \\(\\Sigma_1\\).\\ Montrons que \\(\\Sigma_2\\) implique \\(\\Sigma_1\\).\\ \\(\\Sigma_2\\) contient \\(A\\to B\\).\\ \\(\\Sigma_2\\) contient \\(C\\to EH\\) qui implique \\(C\\to H\\) qui implique \\(CE\\to H\\).\\ \\(\\Sigma_2\\) contient \\(C\\to EH\\) qui implique \\(C\\to E\\).\\ \\(\\Sigma_2\\) implique \\(A\\to CH\\)…\n\n\n\n\nExercice : Décomposition et perte d’information\n\nOn considère le schéma de relation \\(\\mathcal{A}=\\{A,B,C\\}\\) et la dépendance fonctionnelle suivante:\n\n\\[\\Sigma=\\{  A,B \\longrightarrow C   \\}.\\]\nDéterminer si la décomposition suivante est sans perte d’information\n\\[\\mathcal{A}_1=\\{A,B\\} , \\quad \\mathcal{A}_2=\\{B,C\\}\\]\nen étudiant le cas de la table suivante :\n\n\n\n\n\nA\nB\nC\n\n\n\n\n1\n2\n3\n\n\n4\n2\n5\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\nCette relation satisfait \\(AB\\to C\\). De plus, la jointure naturelle des deux projections contient les deux nouveaux tuples (1,2,5) et (4,2,3). Donc il y a perte d’information.\n\n\n\nOn considère le schéma de relation \\(\\mathcal{A}=\\{A,B,C,D,E\\}\\) et les dépendances fonctionnelles suivantes:\n\n\\[\\Sigma=\\{  A \\longrightarrow C ; B \\longrightarrow C ; C \\longrightarrow D ; D,E \\longrightarrow C ; C,E \\longrightarrow A    \\}.\\]\nAppliquer l’algorithme de poursuite pour déterminer si la décomposition suivante est sans perte d’information :\n\\[ \\mathcal{A}_1=\\{A,D\\} , \\mathcal{A}_2=\\{A,B\\}    , \\mathcal{A}_3=\\{B,E\\} , \\mathcal{A}_4=\\{C,D,E\\}, \\mathcal{A}_5=\\{A,E\\} \\]\nMême question pour la décomposition: \\[ \\mathcal{A}_1=\\{A,D\\}, \\mathcal{A}_2=\\{A,B\\}, \\mathcal{A}_3=\\{B,E\\}, \\mathcal{A}_4=\\{C,D\\}, \\mathcal{A}_5=\\{D,E\\}, \\mathcal{A}_6=\\{A,E\\} \\]\n\n\n\n\n\n\nSolution\n\n\n\nLa première décomposition est SPI. On doit montrer que :\n\\(R=\\pi_{A,D}(R)\\bowtie \\pi_{A,B}(R)\\bowtie \\pi_{B,E}(R)\\bowtie \\pi_{C,D,E}(R) \\bowtie \\pi_{A,E}(R)\\).\nOn voit facilement que : \\(R \\subseteq\\pi_{A,D}(R)\\bowtie \\pi_{A,B}(R)\\bowtie \\pi_{B,E}(R)\\bowtie \\pi_{C,D,E}(R) \\bowtie \\pi_{A,E}(R)\\) et il faut montrer l’autre inclusion.\\ On considère un tuple \\(t=(a,b,c,d,e)\\) de la jointure naturelle. Pour \\(1\\le i\\le 5\\), comme \\(\\pi_{\\mathcal{A}_i}(t) \\in \\pi_{\\mathcal{A}_i}(R)\\) il existe un tuple \\(t_i\\in R\\) tel que \\(\\pi_{\\mathcal{A}_i}(t)=\\pi_{\\mathcal{A}_i}(t_i)\\), ce que l’on représente par le tableau \\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline A & B & C & D & E \\\\\\hline\n\\hline a & b_1 &  c_1& d & e_1 \\\\\n\\hline a & b & c_2 & d_2 & e_2 \\\\\n\\hline  a_3& b & c_3 & d_3 & e \\\\\n\\hline  a_4 & b_4 & c & d & e \\\\\n\\hline  a & b_5 & c_5 & d_5 & e \\\\\n\\hline\n\\end{array}\n\\]\nPar la dépendance \\(A \\longrightarrow C\\), on sait que deux tuples ayant la même valeur sur \\(A\\), ont la même sur \\(C\\). On remplace dans la table les valeurs indicées par la valeur \\(c\\) quand c’est possible, ou on unifie simplement les valeurs indicées sinon (ici on prendra \\(c_1\\)).\n\\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline A & B & C & D & E \\\\\\hline\n\\hline a & b_1 &  c_1& d & e_1 \\\\\n\\hline a & b & c_1 & d_2 & e_2 \\\\\n\\hline  a_3& b & c_3 & d_3 & e \\\\\n\\hline  a_4 & b_4 & c & d & e \\\\\n\\hline  a & b_5 & c_1 & d_5 & e \\\\\n\\hline\n\\end{array}\n\\]\n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\nOn traite maintenant \\(B \\longrightarrow C\\).\n\\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline A & B & C & D & E \\\\\\hline\n\\hline a & b_1 &  c_1& d & e_1 \\\\\n\\hline a & b & c_1 & d_2 & e_2 \\\\\n\\hline  a_3& b & c_1 & d_3 & e \\\\\n\\hline  a_4 & b_4 & c & d & e \\\\\n\\hline  a & b_5 & c_1 & d_5 & e \\\\\n\\hline\n\\end{array}\n\\]\nPour la dépendance \\(C \\longrightarrow D\\), on obtient :\n\\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline A & B & C & D & E \\\\\\hline\n\\hline a & b_1 &  c_1& d & e_1 \\\\\n\\hline a & b & c_1 & d & e_2 \\\\\n\\hline  a_3& b & c_1 & d & e \\\\\n\\hline  a_4 & b_4 & c & d & e \\\\\n\\hline  a & b_5 & c_1 & d & e \\\\\n\\hline\n\\end{array}\n\\]\n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\nPour \\(D,E \\longrightarrow C\\), on a cette fois (notez qu’on remplace tous les \\(c_1\\) du coup comme l’un d’entre eux devait l’être) :\n\\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline A & B & C & D & E \\\\\\hline\n\\hline a & b_1 &  c& d & e_1 \\\\\n\\hline a & b & c & d & e_2 \\\\\n\\hline  a_3& b & c & d & e \\\\\n\\hline  a_4 & b_4 & c & d & e \\\\\n\\hline  a & b_5 & c & d & e \\\\\n\\hline\n\\end{array}\n\\]\nEnfin, on termine avec \\(C,E \\longrightarrow A\\) :\n\\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline A & B & C & D & E \\\\\\hline\n\\hline a & b_1 &  c& d & e_1 \\\\\n\\hline a & b & c & d & e_2 \\\\\n\\hline  a& b & c & d & e \\\\\n\\hline  a & b_4 & c & d & e \\\\\n\\hline  a & b_5 & c & d & e \\\\\n\\hline\n\\end{array}\n\\]\nOn voit que le tuple \\((a,b,c,d,e)\\) apparait.  En d’autres termes : \\(R \\supset\\pi_{A,D}(R)\\bowtie \\pi_{A,B}(R)\\bowtie \\pi_{B,E}(R)\\bowtie \\pi_{C,D,E}(R) \\bowtie \\pi_{A,E}(R)\\). La décomposition est donc SPI.\n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\nLa seconde décomposition n’est pas SPI~: l’algorithme de poursuite échoue. Le tableau de départ s’écrit~: \\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline A & B & C & D & E \\\\\\hline\n\\hline a & b_1 &  c_1& d & e_1 \\\\\n\\hline a & b & c_2 & d_2 & e_2 \\\\\n\\hline  a_3& b & c_3 & d_3 & e \\\\\n\\hline  a_4 & b_4 & c & d & e_4 \\\\\n\\hline  a_5 & b_5 & c_5 & d & e \\\\\n\\hline  a & b_6 & c_6 & d_6 & e \\\\\n\\hline\n\\end{array}\n\\]\n\n\\(A\\to C\\) donc \\(c_1=c_2=c_6\\) \\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline A & B & C & D & E \\\\\\hline\n\\hline a & b_1 &  c_1& d & e_1 \\\\\n\\hline a & b & c_1 & d_2 & e_2 \\\\\n\\hline  a_3& b & c_3 & d_3 & e \\\\\n\\hline  a_4 & b_4 & c & d & e_4 \\\\\n\\hline  a_5 & b_5 & c_5 & d & e \\\\\n\\hline  a & b_6 & c_1 & d_6 & e \\\\\n\\hline\n\\end{array}\n\\]\n\n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\n\n\\(B\\to C\\) donc \\(c_3=c_1\\) \\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline A & B & C & D & E \\\\\\hline\n\\hline a & b_1 &  c_1& d & e_1 \\\\\n\\hline a & b & c_1 & d_2 & e_2 \\\\\n\\hline  a_3& b & c_1 & d_3 & e \\\\\n\\hline  a_4 & b_4 & c & d & e_4 \\\\\n\\hline  a_5 & b_5 & c_5 & d & e \\\\\n\\hline  a & b_6 & c_1 & d_6 & e \\\\\n\\hline\n\\end{array}\n\\]\n\\(C\\to D\\) donc \\(d_1=d_3=d_6=d\\) \\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline A & B & C & D & E \\\\\\hline\n\\hline a & b_1 &  c_1& d & e_1 \\\\\n\\hline a & b & c_1 & d & e_2 \\\\\n\\hline  a_3& b & c_1 & d & e \\\\\n\\hline  a_4 & b_4 & c & d & e_4 \\\\\n\\hline  a_5 & b_5 & c_5 & d & e \\\\\n\\hline  a & b_6 & c_1 & d & e \\\\\n\\hline\n\\end{array}\n\\]\n\n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\n\n\\(DE\\to C\\) donc \\(c_5=c1\\) \\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline A & B & C & D & E \\\\\\hline\n\\hline a & b_1 &  c_1& d & e_1 \\\\\n\\hline a & b & c_1 & d & e_2 \\\\\n\\hline  a_3& b & c_1 & d & e \\\\\n\\hline  a_4 & b_4 & c & d & e_4 \\\\\n\\hline  a_5 & b_5 & c_1 & d & e \\\\\n\\hline  a & b_6 & c_1 & d & e \\\\\n\\hline\n\\end{array}\n\\]\n\\(CE\\to A\\) donc \\(a_3=a_5=a\\) \\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline A & B & C & D & E \\\\\\hline\n\\hline a & b_1 &  c_1& d & e_1 \\\\\n\\hline a & b & c_1 & d & e_2 \\\\\n\\hline  a& b & c_1 & d & e \\\\\n\\hline  a_4 & b_4 & c & d & e_4 \\\\\n\\hline  a & b_5 & c_1 & d & e \\\\\n\\hline  a & b_6 & c_1 & d & e \\\\\n\\hline\n\\end{array}\n\\] Toutes les DF de \\(\\Sigma\\) sont satisfaites et aucune ligne n’est égale à \\((a,b,c,d,e)\\). Donc la décomposition n’est pas SPI.\\ Si on suppose que pour tout \\(1\\le i\\le 6\\), \\(a_i\\not=a\\), \\(b_i\\not=b\\), \\(c_i\\not=c\\), \\(d_i\\not=d\\), \\(e_i\\not=e\\), ce dernier tableau fournit un exemple de relation strictement plus petite que la jointure naturelle des projections. En effet \\(\\Sigma\\) est satisfait et \\((a,b,c,d,e)\\) est clairement dans la jointure naturelles des projections. Or \\((a,b,c,d,e)\\) n’est pas dans la relation.\n\n\n\n\n\nExercice\nSoit \\(\\mathcal{A}=\\{A,B,C,D,E\\}\\) un schéma et soit la décomposition \\(\\{\\mathcal{A}_1,\\mathcal{A}_2,\\mathcal{A}_3\\}\\) où \\[\\mathcal{A}_1=\\{A,B,C\\}\\quad \\mathcal{A}_2=\\{B,C,D\\}\\quad \\mathcal{A}_3=\\{A,C,E\\}\\] Pour chaque ensemble \\(\\Sigma\\) de dépendances fonctionnelles ci-dessous, appliquer l’algorithme de poursuite pour déterminer si la décomposition est sans perte d’information. Dans le cas où il y a perte d’information, donner une relation \\(R\\) de schéma \\(\\mathcal{A}\\) satisfaisant \\(\\Sigma\\) et telle que \\[ \\pi_{\\mathcal{A}_1}(R)\\bowtie\\pi_{\\mathcal{A}_2}(R)\\bowtie\\pi_{\\mathcal{A}_3}(R)\\not\\subset R\\]\n\n\\(\\Sigma=\\{B\\rightarrow E, CE\\rightarrow A\\}\\)\n\\(\\Sigma=\\{AC\\rightarrow E, BC\\to D\\}\\)\n\\(\\Sigma=\\{A\\rightarrow D, D\\to E, B\\to D\\}\\)\n\\(\\Sigma=\\{A\\rightarrow D, CD\\to E, E\\to D\\}\\)\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\\[\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline  & A & B & C & D & E \\\\\\hline\n\\hline \\{A,B,C\\}  & a & b &  c& d_1 & e_1 \\\\\n\\hline  \\{B,C,D\\} & a_2 & b & c & d & e_2 \\\\\n\\hline  \\{A,C,E\\} & a & b_3 & c & d_3 & e \\\\\n\\hline\n\\end{array}\n\\] \\(B\\to E\\) donc \\(e_1=e_2\\). Ensuite \\(CE\\to A\\) donc \\(a_2=a\\). On obtient \\[\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline  & A & B & C & D & E \\\\\\hline\n\\hline \\{A,B,C\\}  & a & b &  c& d_1 & e_1 \\\\\n\\hline  \\{B,C,D\\} & a & b & c & d & e_1 \\\\\n\\hline  \\{A,C,E\\} & a & b_3 & c & d_3 & e \\\\\n\\hline\n\\end{array}\n\\] Toutes les DF de \\(\\Sigma\\) sont satisfaites. Donc il y a perte d’information. Ce dernier tableau est une relation \\(R\\) qui satisfait \\(\\Sigma\\) et telle que \\[\\pi_{\\mathcal{A}_1}(R)\\bowtie\\pi_{\\mathcal{A}_2}(R)\\bowtie\\pi_{\\mathcal{A}_3}(R)\\not\\subset R\\] puisque \\((a,b,c,d,e)\\notin R\\).\n\n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\n\n\\[\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline  & A & B & C & D & E \\\\\\hline\n\\hline \\{A,B,C\\}  & a & b &  c& d_1 & e_1 \\\\\n\\hline  \\{B,C,D\\} & a_2 & b & c & d & e_2 \\\\\n\\hline  \\{A,C,E\\} & a & b_3 & c & d_3 & e \\\\\n\\hline\n\\end{array}\n\\] \\(AC\\to E\\) donc \\(e_1=e\\). Ensuite \\(BC\\to D\\) donc \\(d_1=d\\). On obtient \\[\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline  & A & B & C & D & E \\\\\\hline\n\\hline \\{A,B,C\\}  & a & b &  c& d & e \\\\\n\\hline  \\{B,C,D\\} & a_2 & b & c & d & e_2 \\\\\n\\hline  \\{A,C,E\\} & a & b_3 & c & d_3 & e \\\\\n\\hline\n\\end{array}\n\\] Le premier tuple est \\((a,b,c,d,e)\\). Donc la décomposition est SPI.\n\n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\n\n\\[\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline  & A & B & C & D & E \\\\\\hline\n\\hline \\{A,B,C\\}  & a & b &  c& d_1 & e_1 \\\\\n\\hline  \\{B,C,D\\} & a_2 & b & c & d & e_2 \\\\\n\\hline  \\{A,C,E\\} & a & b_3 & c & d_3 & e \\\\\n\\hline\n\\end{array}\n\\] \\(A\\to D\\) donc \\(d_3=d_1\\). \\[\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline  & A & B & C & D & E \\\\\\hline\n\\hline \\{A,B,C\\}  & a & b &  c& d_1 & e_1 \\\\\n\\hline  \\{B,C,D\\} & a_2 & b & c & d & e_2 \\\\\n\\hline  \\{A,C,E\\} & a & b_3 & c & d_1 & e \\\\\n\\hline\n\\end{array}\n\\] \\(D\\to E\\) donc \\(e_1=e\\) \\[\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline  & A & B & C & D & E \\\\\\hline\n\\hline \\{A,B,C\\}  & a & b &  c& d_1 & e \\\\\n\\hline  \\{B,C,D\\} & a_2 & b & c & d & e_2 \\\\\n\\hline  \\{A,C,E\\} & a & b_3 & c & d_1 & e \\\\\n\\hline\n\\end{array}\n\\] \\(B\\to D\\) donc \\(d_1=d\\) \\[\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline  & A & B & C & D & E \\\\\\hline\n\\hline \\{A,B,C\\}  & a & b &  c& d & e \\\\\n\\hline  \\{B,C,D\\} & a_2 & b & c & d & e_2 \\\\\n\\hline  \\{A,C,E\\} & a & b_3 & c & d_1 & e \\\\\n\\hline\n\\end{array}\n\\] La décomposition est donc SPI.\n\n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\n\n\\[\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline  & A & B & C & D & E \\\\\\hline\n\\hline \\{A,B,C\\}  & a & b &  c& d_1 & e_1 \\\\\n\\hline  \\{B,C,D\\} & a_2 & b & c & d & e_2 \\\\\n\\hline  \\{A,C,E\\} & a & b_3 & c & d_3 & e \\\\\n\\hline\n\\end{array}\n\\] \\(A\\to D\\) donc \\(d_3=d_1\\). \\[\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline  & A & B & C & D & E \\\\\\hline\n\\hline \\{A,B,C\\}  & a & b &  c& d_1 & e_1 \\\\\n\\hline  \\{B,C,D\\} & a_2 & b & c & d & e_2 \\\\\n\\hline  \\{A,C,E\\} & a & b_3 & c & d_1 & e \\\\\n\\hline\n\\end{array}\n\\] \\(CD\\to E\\) donc \\(e_1=e\\). \\[\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline  & A & B & C & D & E \\\\\\hline\n\\hline \\{A,B,C\\}  & a & b &  c& d_1 & e \\\\\n\\hline  \\{B,C,D\\} & a_2 & b & c & d & e_2 \\\\\n\\hline  \\{A,C,E\\} & a & b_3 & c & d_1 & e \\\\\n\\hline\n\\end{array}\n\\] \\(E\\to D\\) est satisfaite ainsi que les deux premières DF. Donc la décomposition n’est pas SPI.\n\n\n\n\n\nExercice : Normalisation\nOn considère le schéma de relation R(C,T,H,S,E,N) :\nR(Cours, Enseignant, Horaire, Salle, Étudiant, Note)\net les dépendances fonctionnelles suivantes:\n\\[\\mathcal{F}=\\{  \\texttt{C} \\to \\texttt{T}; \\quad \\texttt{H,S} \\to \\texttt{C}; \\quad \\texttt{H,T} \\to \\texttt{S}; \\quad \\texttt{C,E} \\to \\texttt{N}; \\quad \\texttt{H,E} \\to S \\}. \\]\n\nCalculer une clé.\n\n\n\n\n\n\n\nSolution\n\n\n\nH,E n’étant jamais à droite, ils font obligatoirement partis d’une clé. Or HE+ = ALL\n\n\n\nMettre en Boyce-Codd Normal Form (BCNF), donner plusieurs résultats possibles.\n\n\n\n\n\n\n\nSolution\n\n\n\n1er version:\nC -&gt; T donne T1(CT) et T2(CHSEN).\nCE -&gt; N donne T1(CT),T2(C,E,N) T3(CHSE)\nHE -&gt; S donne (HES ; HEC)\n2eme version:\nCE -&gt; N donne T1(CENT), T2(CEHS) ..."
  },
  {
    "objectID": "solutions/td11.html",
    "href": "solutions/td11.html",
    "title": "TD 11: Normalisation et dépendances",
    "section": "",
    "text": "Avec solutions\n\n\n\n\n\n\n\n\n\n\n\n\n\nL3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2024-2025\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\n\nExercice\nSoit le schéma \\[\\mathcal{A}=\\left\\{\\texttt{A,B,C,D,E,F,G,H}\\right\\}\\] et l’ensemble de DF\nBE → AC  \nB → H  \nF → CD  \nD → G\n\nAppliquer l’algorithme de décomposition vu en cours pour obtenir une décomposition de \\(\\mathcal{A}\\) qui respecte la FNBC et est sans perte d’information. Déterminer quelles DF sont préservées.\nPeut-on, en ajoutant un sous-schéma à la décomposition, obtenir une décomposition FNBC sans perte d’information et sans perte de DF ?\n\n\n\n\n\n\n\nSolution\n\n\n\nRappelons l’algorithme pour décomposer un schéma \\(\\mathcal{A}\\)~:\n\nOn considère la décomposition initiale \\(\\rho=\\{\\mathcal{A}\\}\\).\nTant qu’il existe un sous-schéma \\(\\mathcal{B}\\in\\rho\\) et \\(X\\subset \\mathcal{B}\\) tels que \\(X^+\\cap\\mathcal{B}\\not=X\\) et \\(X^+\\cap\\mathcal{B}\\not=\\mathcal{B}\\) (ce qui signifie que la DF locale \\(X\\to X^+\\cap\\mathcal{B}\\) est une violation de FNBC pour \\(\\mathcal{B}\\)), on remplace \\(\\mathcal{B}\\) par les deux sous-schémas \\[\\mathcal{B}_1=X^+\\cap\\mathcal{B} \\text{ et } \\mathcal{B}_2=(\\mathcal{B}\\setminus X^+)\\cup X\\] De plus il n’y a pas besoin de considérer les parties \\(X\\subset\\mathcal{B}\\) telles que \\(card(X)=card(\\mathcal{B})-1\\) puisque dans ce cas on \\(X^+\\cap \\mathcal{B}=X\\) ou \\(X^+\\cap\\mathcal{B}=\\mathcal{B}\\).\n\nIl est garanti que la décomposition finale est en FNBC et SPI. Par contre toutes les DF ne sont pas préservées en général. De plus on obtient, en général, des décompositions différentes si on change les DF (violant FNBC) utilisées. } - \\(BE^+=BEACH\\) donc on remplace \\(\\mathcal{A}\\) par \\[ \\mathcal{A}_1=BEACH \\quad \\mathcal{A}_2=BDEFG\\] \\(B^+=BH\\) donc on remplace \\(\\mathcal{A}_1\\) par \\[\\mathcal{A}_{11}=BH \\quad \\mathcal{A}_{12}=BEAC\\] \\(\\mathcal{A}_{11}\\) est en FNBC car de cardinal 2. \\(\\mathcal{A}_{12}\\) est en FNBC car \\[B^+\\cap\\mathcal{A}_{12}=B, E^+\\cap\\mathcal{A}_{12}=E, A^+\\cap\\mathcal{A}_{12}=A, C^+\\cap\\mathcal{A}_{12}=C \\] \\[BE^+\\cap\\mathcal{A}_{12}=BEAC, BA^+\\cap\\mathcal{A}_{12}=BA, BC^+\\cap\\mathcal{A}_{12}=BC, EA^+\\cap\\mathcal{A}_{12}=EA, EC^+\\cap\\mathcal{A}_{12}=EC\\] \\[ AC^+\\cap\\mathcal{A}_{12}=AC\\] \\(D^+=DG\\) donc on remplace \\(\\mathcal{A}_2\\) par \\[\\mathcal{A}_{21}=DG \\quad \\mathcal{A}_{22}=BDEF\\] \\(\\mathcal{A}_{21}\\) est en FNBC car de cardinal 2. \\(F^+=CD\\) donc on remplace \\(\\mathcal{A}_{22}\\) par \\[\\mathcal{A}_{221}=FD \\quad \\mathcal{A}_{222}=BEF\\] qui sont tous deux en FNBC\nDécomposition obtenue~:\nBH  BEAC  DG  FD  BEF\nLa seule DF qui n’est pas préservée est \\(F\\to C\\). Toutes les variantes (en changeant les DF utilisées) que j’ai testées, donne une décomposition qui ne préserve pas toutes les DF. Bien sûr ce n’est pas une preuve que l’algorithme ne peut pas donner une décomposition sans perte de DF. - En ajoutant \\(FC\\) à la décomposition précédente, on obtient\nBH   BEAC   DG   FD   BEF   FC\nqui est en FNBC et préserve les DF. De plus elle est SPI puisque la décomposition initiale est SPI. (\\(R \\bowtie \\pi_{FC}(R)=R\\) pour toute relation \\(R\\))\n\n\n\n\nExercice\nReprendre les questions de l’exercice précédent pour le schéma \\[\\mathcal{A}=\\left\\{\\texttt{A,B,C,D,E,F,G,H}\\right\\}\\] et l’ensemble de DF\nBE → AC  \nB → H\nF → CD\nD → G\nA→ E\n\n\n\n\n\n\nSolution\n\n\n\n\nDe manière similaire à l’exercice précédent on arrive à\n\nBH   BEAC   DG   FD   BEF\nmais, ici, BEAC n’est pas en FNBC (les autres le sont). A^+=AE donc on remplace BEAC par AE et ABC. Une décomposition FNBC est donc BH   AE   ABC   DG   FD   BEF Les DF BE → AC et F → C ne sont pas préservées. Les autres sont préservées.\n\nIl n’existe de décomposition FNBC qui préserve BE → A. En effet, si BE → A est préservée, il existe une DF locale à un sous-schéma \\(\\mathcal{B}\\) de la forme X → A. Cela implique que BE ⊂ X et donc BEA ⊂ B. Par suite \\(\\mathcal{B}\\) n’est pas en FNBC à cause de \\(A^+=AE\\)."
  },
  {
    "objectID": "solutions/td7.html",
    "href": "solutions/td7.html",
    "title": "TD 7 : Contraintes (suite)",
    "section": "",
    "text": "Avec solutions"
  },
  {
    "objectID": "solutions/td7.html#schéma-pagila",
    "href": "solutions/td7.html#schéma-pagila",
    "title": "TD 7 : Contraintes (suite)",
    "section": "Schéma pagila",
    "text": "Schéma pagila\n\n\n\n\n\n\nQuestion\n\n\n\nImposer la contrainte suivante : un client ne peut emprunter plusieurs DVD simultanément.\n\n\n\n\n\n\n\n\nÉcrire d’abord une requête correspondant à la contrainte.\nLa requête est facile à écrire si on est prêt à utiliser le type tsrange, l’opérateur de recouvrement && (overlap).\nPostgresql documentation on range types\nDans l’instance du schéma pagila disponible sur le serveur etu-pgsql, la contrainte est-elle vérifiée ?\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\nselect \n  r1.customer_id, \n  r1.inventory_id,\n  r1.rental_date, \n  r1.return_date, \n  r2.inventory_id,\n  r2.rental_date, \n  r2.return_date \nfrom \n  rental r1 \njoin \n  rental r2 \non (r1.customer_id=r2.customer_id AND r1.rental_id&lt;&gt;r2.rental_id)  \nwhere \n  tsrange(r1.rental_date, r1.return_date, '[)') && \n  tsrange(r2.rental_date, r2.return_date, '[)') ;\n La contrainte n’est pas du tout satisfaite par l’instance de pagila\nALTER TABLE \n  pagila.rental \nADD CONSTRAINT \n  xcl_simul_rental\nEXCLUDE USING gist (\n  customer_id with =,\n  rental_id with &lt;&gt;,\n  tsrange(rental_date, return_date) with &&\n) ;\n Sur l’instance disponible de pagila, cette contrainte ne peut pas être surimposée.\nERROR:  could not create exclusion constraint \"xcl_simul_rental\"\nDETAIL:  Key (customer_id, rental_id, tsrange(rental_date, return_date))=(408, 3, [\"2005-05-24 23:03:39\",\"2005-06-01 22:12:39\")) conflicts with key (customer_id, rental_id, tsrange(rental_date, return_date))=(408, 59, [\"2005-05-25 08:56:42\",\"2005-06-01 09:52:42\")).\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nImposer la contrainte : un film est identifié par son titre, son année de sortie et sa langue originale.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nLa requête correspondante est\nSELECT \n  COUNT(*)\nFROM \n  pagila.film AS f1 \nJOIN \n  pagila.film AS f2\nON (\n    f1.title = f2.title AND\n    f1.release_year = f2.release_year AND \n    f1.original_language_id = f2.original_language_id AND\n    f1.film_id &lt; f2.film_id)\nIl s’agit d’une contrainte d’unicité. Elle est satisfaite dans l’instance de pagila\nALTER TABLE pagila.film\nADD CONSTRAINT uq_film_title_release_year_original_language_id \nUNIQUE (title, release_year, original_language_id) ;\nLa description du schéma de pagila.film (\\d pagila.film) nous renvoie alors :\n...\nIndexes:\n    \"film_pkey\" PRIMARY KEY, btree (film_id)\n    \"film_fulltext_idx\" gist (fulltext)\n    \"idx_fk_language_id\" btree (language_id)\n    \"idx_fk_original_language_id\" btree (original_language_id)\n    \"idx_title\" btree (title)\n    \"uq_film_title_release_year_original_language_id\" UNIQUE CONSTRAINT, btree (title, release_year, original_language_id)\n...\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nImposer la contrainte : le prix de location doit être croissant en fonction de la durée du film\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT\n  COUNT(*)\nFROM\n  pagila.film AS f1 \nJOIN \n  pagila.film AS f2\nON (\n  f1.rental_rate &lt; f2.rental_rate AND\n  f1.length &gt; f2.length\n) ;\n La contrainte n’est pas satisfaite dans l’instance courante de pagila.\nLa contrainte devrait pouvoir être formulée comme une contrainte d’exclusion.\nALTER TABLE \n  pagila.film \nADD CONSTRAINT \n  xcl_anomalous_rental_rate\nEXCLUDE USING gist (\n  \"length\" with &lt;,\n  rental_rate with &gt;\n) ;\nmais :\nERROR:  operator &lt;(smallint,smallint) is not commutative\nDETAIL:  Only commutative operators can be used in exclusion constraints.\nEst-ce que l’impossiblité d’utiliser un opérateur non-commutatif est de principe ou technique ?\n On peut utiliser un contournement laborieux en utilisant une contrainte de ligne (CHECK) qui va simuler la contrainte de table (voir td6).\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nImposer la contrainte : un même DVD ne peut pas être loué simultanément à deux clients différents.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nALTER TABLE \n  pagila.rental \nADD CONSTRAINT \n  xcl_simul_rental_inventory\nEXCLUDE USING gist (\n  inventory_id with =,\n  rental_id with &lt;&gt;,\n  tsrange(rental_date, return_date) with &&\n) ;\nL’examen de la deéfinition de la table rental nous révèle maintenant :\nIndexes:\n    \"rental_pkey\" PRIMARY KEY, btree (rental_id)\n    \"idx_fk_inventory_id\" btree (inventory_id)\n    \"idx_unq_rental_rental_date_inventory_id_customer_id\" UNIQUE, btree (rental_date, inventory_id, customer_id)\n    \"xcl_simul_rental_inventory\" EXCLUDE USING gist (inventory_id WITH =, rental_id WITH &lt;&gt;, tsrange(rental_date, return_da\nte) WITH &&)\nForeign-key constraints:\n    \"rental_customer_id_fkey\" FOREIGN KEY (customer_id) REFERENCES customer(customer_id) ON UPDATE CASCADE ON DELETE RESTRICT\n    \"rental_inventory_id_fkey\" FOREIGN KEY (inventory_id) REFERENCES inventory(inventory_id) ON UPDATE CASCADE ON DELETE RESTRICT\n    \"rental_staff_id_fkey\" FOREIGN KEY (staff_id) REFERENCES staff(staff_id) ON UPDATE CASCADE ON DELETE RESTRICT"
  },
  {
    "objectID": "solutions/td7.html#schéma-nycflights",
    "href": "solutions/td7.html#schéma-nycflights",
    "title": "TD 7 : Contraintes (suite)",
    "section": "Schéma nycflights",
    "text": "Schéma nycflights\n\n\n\n\n\n\nQuestion\n\n\n\nDans flights et weather imposer les contraintes\nyear, month, day, hour ⟶ time_hour\ntime_hour  ⟶  year, month, day, hour\n\n\n\n\n\n\n\n\nSolution\n\n\n\nALTER TABLE nycflights_sandbox.weather \nADD CONSTRAINT weather_fd_1 \nEXCLUDE USING gist (\n  year WITH =,\n  month WITH =, \n  day WITH =, \n  hour WITH =,\n  time_hour WITH &lt;&gt;\n) ;\nALTER TABLE nycflights_sandbox.flights \nADD CONSTRAINT flights_fd_1 \nEXCLUDE USING gist (\n  year WITH =,\n  month WITH =, \n  day WITH =, \n  hour WITH =,\n  time_hour WITH &lt;&gt;\n) ;\n Nous sommes dans une situation où une colonne peut être calculée à partir d’autres colonnes. PostgreSQL propose des genrated columns pour traîter ce genre de situations.\n\nUne colonne générée est une colonne spéciale qui est toujours calculée à partir d’autres colonnes. Elle est donc pour les colonnes ce qu’une vue est pour les tables. Il existe deux types de colonnes générées : les colonnes stockées et les colonnes virtuelles. Une colonne générée stockée est calculée lorsqu’elle est écrite (insérée ou mise à jour) et occupe l’espace de stockage comme s’il s’agissait d’une colonne normale. Une colonne générée virtuelle n’occupe pas d’espace de stockage et est calculée lorsqu’elle est lue. Ainsi, une colonne générée virtuelle est similaire à une vue et une colonne générée stockée est similaire à une vue matérialisée (sauf qu’elle est toujours mise à jour automatiquement). PostgreSQL n’implémente actuellement que les colonnes générées stockées.\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nDans flights imposer la contrainte : un aéronef ne peut pas effectuer deux missions simultanément.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nALTER TABLE nycflights_sandbox.flights \nADD COLUMN t1 timestamp GENERATED ALWAYS AS (\n  make_timestamp(\n    year::int, \n    month::int, \n    day::int, \n    hour::int, \n    minute::int, \n    0.0::float)\n) STORED ;\nCREATE FUNCTION nycflights_sandbox.foo (\n  p_air_time float\n)\nRETURNS interval immutable \nLANGUAGE SQL AS \n$$\n  SELECT \n    CASE WHEN p_air_time IS NULL THEN '0 minutes'::interval\n       ELSE (p_air_time::text || ' minutes')::interval \n  END \n$$ ;\nALTER TABLE nycflights_sandbox.flights \nADD COLUMN dtt interval GENERATED ALWAYS AS (\n  CASE WHEN air_time IS NULL THEN '0 minutes'::interval\n       ELSE (air_time::text || ' minutes')::interval \n  END \n) STORED ;\nCREATE VIEW nycflights.flightspp AS (\n  SELECT \n    f.*,\n    make_timestamp(\n      year::int, \n      month::int, \n      day::int, \n      hour::int, \n      minute::int, \n      0.0::float)  as t1,\n    nycflights_sandbox.foo(air_time) as dt, \n    tsrange( make_timestamp(\n      year::int, \n      month::int, \n      day::int, \n      hour::int, \n      minute::int, \n      0.0::float),\n       make_timestamp(\n      year::int, \n      month::int, \n      day::int, \n      hour::int, \n      minute::int, \n      0.0::float) + nycflights_sandbox.foo(air_time,\n      '[]')) as in_ze_air_time\n  FROM nycflights.flights f\n) ;\nCREATE VIEW nycflights.flightspp AS (\n  SELECT \n    f.*,\n    make_timestamp(\n      year::int, \n      month::int, \n      day::int, \n      hour::int, \n      minute::int, \n      0.0::float)  as t1,\n    nycflights_sandbox.foo(air_time) as dt, \n    tsrange( \n      make_timestamp(\n        year::int, \n        month::int, \n        day::int, \n        hour::int, \n        minute::int, \n        0.0::float),\n      make_timestamp(\n        year::int, \n        month::int, \n        day::int, \n        hour::int, \n        minute::int, \n        0.0::float) + \n      nycflights_sandbox.foo(air_time), '[]'\n      ) as in_ze_air_time\n  FROM nycflights.flights f\n) ;\nALTER TABLE nycflights_sandbox.flights \nADD CONSTRAINT xcl_simul_flights \nEXCLUDE USING gist (\n  tailnum with =, \n  tsrange(t1, t1+nycflights_sandbox.foo(air_time), '[]') with &&\n);\nwith r as (\n  select \n    f.*, \n    make_timestamp(f.year::int, f.month::int, f.day::int, f.hour::int, f.minute::int, 0.0::float) as t1, \n    (f.air_time::text || ' minutes')::interval as dt  \n  from \n    nycflights.flights f \n)\n\nselect \n  r.t1, \n  r.dt, \n  tsrange(r.t1, r.t1+r.dt, '[]'), \n  r.* \nfrom \n  r ;\nALTER TABLE nycflights_sandbox.flights \nADD CONSTRAINT flights_exclusivity\nEXCLUDE USING gist (\n  tailnum WITH =,\n  month WITH =, \n  day WITH =, \n  hour WITH =,\n  time_hour WITH &lt;&gt;\n) ;\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nDans flights imposer la contrainte : un aéronef ne peut pas être exploité par deux compagnies différentes à la même date.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nDans planes, imposer les contraintes model ⟶ manufacturer et model ⟶ type\n\n\n\n\n\n\n\n\nSolution\n\n\n\ncreate function nycflights.lldistance(\n  p_lat_1 float8, \n  p_lon_1 float8, \n  p_lat_2 float8, \n  p_lon_2 float8\n) returns float8\nlanguage SQL AS \n$$\nselect\n  earth_distance(\n    ll_to_earth(p_lat_1, p_lon_1),\n    ll_to_earth(p_lat_2, p_lon_2)\n  ) ;\n$$ ;\nselect\n  A_1.faa, A_2.faa, nycflights.lldistance(A_1.lat, A_1.lon, A_2.lat, A_2.lon) as dista\nfrom \n  (select \n    *\n  from \n    nycflights.airports \n  where \n    faa in ('LGA', 'JFK', 'EWR')\n  ) A_1\ncross join \n  (select \n    *\n  from \n    nycflights.airports \n  where \n    not faa in ('LGA', 'JFK', 'EWR')\n  ) A_2 ;\nselect \n  a_1.faa, a_2.faa, \n  (point(a_1.lon, a_1.lat) &lt;@&gt; point(a_2.lon, a_2.lat))/1.609   \nFROM \n  nycflights.airports a_1 \ncross join \n  nycflights.airports a_2 \nwhere \n  a_1.faa in ('EWR', 'LGA', 'JFK')  AND \n  a_2.faa in ('LAX', 'ATL') \nORDER BY a_2.faa, a_1.faa ;"
  },
  {
    "objectID": "exams/cc3-2023-12-08.html",
    "href": "exams/cc3-2023-12-08.html",
    "title": "MA15Y030 - Automne 2024",
    "section": "",
    "text": "L3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2023-2024\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\n\n\n\n\n\n\nRappel de notation\n\n\n\nDans le formalisme Entité-Association, nous utilisons les pattes de corbeau (crowfoot) pour décrire les contraintes de cardinalités.\n\n\n\n\n\n\n\n\n\n\n\n\n\nerDiagram\n\nA }|..|{ B : foo\n\n\n\n\n\n\nL’entité A est reliée à l’entité B par l’association foo. Une instance de A peut apparaître de \\(1\\) à \\(n\\) fois parmi les instances de l’association foo, de même une instance de B peut apparaître de \\(1\\) à \\(n\\) fois parmi les instances de l’association foo.\n\n\n\n\n\n\n\nerDiagram\n\nA }|..o| B : bar\n\n\n\n\n\n\nL’entité A est reliée à l’entité B par l’association bar. Une instance de A peut apparaître de \\(0\\) à \\(1\\) fois parmi les instances de l’association bar, une instance de B peut apparaître de \\(1\\) à \\(n\\) fois parmi les instances de l’association bar.\n\n\n\n\n\n\n\n\n\nNotez que la contrainte portant sur le nombre de participations des instances d’une entité à une association apparaît à l’opposé de l’entité.\n\n\n\n\nUn système d’information pour l’administration\nUn pays (par exemple France) est organisé en régions (par exemple Bretagne, …). Les régions sont identifiées par leur nom. Ces régions sont-elles même divisées en départements (par exemple Finistère). Les départements sont identifiés par de numéros (par exemple 29 pour le Finistère). Les départments possèdent aussi un nom qui les distingue.\nDans chaque département, il y a des communes qui portent des noms, éventuellement précédés d’un article (par exemple Le Mans, Le Bourget, …). Pour chaque département, les communes sont numérotées à l’aide de leur rang dans l’ordre alphabétique construit sur les noms privés de l’éventuel article (dans la Sarthe, 72, Le Mans est au rang 181 entre Mamers et Mansigné).\nPour chaque commune et chaque année, on connaît le montant total perçu au titre de la taxe foncière.\nChaque année, on procède à un recensement dans chaque commune. On en connaît la population.\nChaque région a une préfecture de région, et chaque département a une préfecture de département.\nOn a cherché à modéliser cette description en formalisme Entité-Association comme suit.\n\n\n\n\n\n%%{init: { \"sequence\": { \"wrap\": true} } }%%\nerDiagram \n    DEPARTEMENT }|..|{ REGION : contient\n    DEPARTEMENT {\n        string nom\n        int departement \n    }\n    REGION ||..o| VILLE : prefecture\n    REGION {\n        string nom   \n    }\n    REGION ||..|{ VILLE : contient\n    DEPARTEMENT |o..|| VILLE : prefecture\n    VILLE {\n        string nom\n        string article\n        int numero       \n    }\n    \n    RECENSEMENT ||..|{ VILLE : concerne\n    RECENSEMENT {\n      int annee \n      int population\n    }\n    TAXE ||..|{ VILLE : rapporte\n    TAXE {\n      int annee\n      int valeur\n    }\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 1\n\n\n\n\nUn certain nombre d’erreurs se sont glissées dans ce schéma Entité-Association. Corrigez-le.\nProposez un identifiant pour chaque entité.\nDésignez les entités faibles.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\nerDiagram \n    REGION |o..|| VILLE : prefecture\n    REGION {\n        string nom  PK \n    }\n    REGION ||..|{ DEPARTEMENT : contient\n    DEPARTEMENT {\n        string nom\n        int departement PK \n    }\n    DEPARTEMENT ||--|{ VILLE : contient\n    DEPARTEMENT |o..|| VILLE : prefecture\n    VILLE {\n        string nom\n        string article\n        int numero PK      \n    }\n    RECENSEMENT }|--|| VILLE : concerne\n    RECENSEMENT {\n      int annee PK\n      int population\n    }\n    TAXEFONCIERE }|--|| VILLE : recoit\n    TAXEFONCIERE {\n      int annee PK\n      int montant\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\nLes numéros des communes sont des identifiants relatifs. Ils apparaissent sur nos numéros de sécurité sociale (chiffres en position 4, 5, 6).\nVILLE, RECENSEMENT et TAXE sont des entités faibles.\nL’identifiant de VILLE est le couple departement, numero\nL’identifiant de TAXE est le triplet departement, numero, annee. Idem pour RECENSEMENT.\nLes associations notées en trait plein sont dites identifiantes. L’identifiant d’une entité faible est formé en assemblant l’identifiant de l’entité de cardinalité \\(0:n\\) et l’identifiant relatif de l’entité faible (cardinalité \\(1:1\\)).\n\n\n\nSoit le schéma \\(\\mathcal{A}=\\left\\{\\texttt{A},\\texttt{B},\\texttt{C},\\texttt{D},\\texttt{E},\\texttt{F}\\right\\}\\) et l’ensemble \\(\\Sigma\\) de DF\n   A,B → C\n     B → F  \n   C,E → A  \n     F → E\n\n\n\n\n\n\nQuestion 2\n\n\n\nCalculer la clôture/fermeture \\(\\{\\texttt{A},\\texttt{B}\\} = [\\{\\texttt{A},\\texttt{B}\\}]_{\\Sigma}^+\\) de \\(\\{\\texttt{A},\\texttt{B}\\}\\) en utilisant l’ensemble de DF \\(\\Sigma\\).\n\n\n\n\n\n\n\n\nSolution 2\n\n\n\n\\(\\{\\texttt{A},\\texttt{B}\\}^+\\) contient forcément A et B. Par la DF A,B → C, elle contient aussi C. Comme B → F, elle contient F. Comme F → E, elle contient E. Donc elle contient les attributs : \\(\\{\\texttt{A},\\texttt{B}\\}^+=\\{\\texttt{A},\\texttt{B},\\texttt{C},\\texttt{E},\\texttt{F}\\}\\) (tous sauf D).\n\n\n\n\n\n\n\n\nQuestion 3\n\n\n\nQuelles sont les clefs du schéma \\(\\mathcal{A}\\) en utilisant l’ensemble de DF \\(\\Sigma\\) ?\n\n\n\n\n\n\n\n\nSolution 3\n\n\n\nComme D n’apparaît dans aucune DF (en membre gauche, ou en membre droit), toute clé est formée de la réunion de \\(\\{\\texttt{D}\\}\\) et d’une clé pour \\(\\mathcal{A} \\setminus \\{\\texttt{D}\\}\\) muni de \\(\\Sigma\\).\nOn vient de voir que \\(\\{\\texttt{A},\\texttt{B}\\}\\) est une super-clef de \\(\\mathcal{A} \\setminus \\{\\texttt{D}\\}\\) muni de \\(\\Sigma\\). C’est aussi une clef de \\(\\mathcal{A} \\setminus \\{\\texttt{D}\\}\\) puisque \\([\\{\\texttt{A}\\}]_\\Sigma^+=\\{\\texttt{A}\\}\\) et \\([\\{\\texttt{B}\\}]_{\\Sigma}^+=\\{\\texttt{B},\\texttt{E},\\texttt{F}\\}\\) pour ses deux sous-ensembles.\nDonc \\(\\{\\texttt{A},\\texttt{B}, \\texttt{D}\\}\\) est une clé.\nCe n’est pas la seule clef : \\(\\{\\texttt{B},\\texttt{C}\\}\\) en est aussi une.\nToutes les super-clefs doivent contenir B (qui ne dépend d’aucun autre attribut), et comme \\(\\texttt{B}^+=\\{\\texttt{B},\\texttt{E},\\texttt{F}\\}\\), E et F n’apportent rien par rapport à B seul.\nLes clefs sont donc \\(\\{\\texttt{A},\\texttt{B}, \\texttt{D}\\}\\) et \\(\\{\\texttt{B},\\texttt{C}, \\texttt{D}\\}\\).\n\n\n\nOn travaillera par la suite sur le schéma relationnel villes et les tables définies par le code SQL suivant.\n\n\n\n\nCREATE SCHEMA villes;\n\nCREATE TABLE villes.region (\n  nom varchar NOT NULL PRIMARY KEY,\n  prefecture_num int4 NULL,\n  prefecture_dep int4 NULL\n);\n\nCREATE TABLE villes.departement (\n  nom varchar NULL UNIQUE,\n  departement int4 NOT NULL PRIMARY KEY,\n  region varchar NULL REFERENCES villes.region(nom)\n    ON DELETE SET NULL ON UPDATE CASCADE,\n  numero int4 NULL\n);\n\nCREATE TABLE villes.ville (\n  nom varchar NULL,\n  article varchar NULL,\n  departement int4 NOT NULL REFERENCES villes.departement\n    ON DELETE RESTRICT ON UPDATE CASCADE,\n  numero int4 NOT NULL,\n  CONSTRAINT ville_pkey PRIMARY KEY (departement, numero)\n);\n\nALTER TABLE villes.region ADD \n  CONSTRAINT region_prefecture_fk FOREIGN KEY (prefecture_dep,prefecture_num) \n  REFERENCES villes.ville(departement,numero) \n  ON DELETE RESTRICT ON UPDATE CASCADE;\n\nALTER TABLE villes.departement ADD \n  CONSTRAINT departement_prefecture_fk FOREIGN KEY (departement,numero) \n  REFERENCES villes.ville(departement,numero) \n  ON DELETE SET NULL ON UPDATE CASCADE;\n\nCREATE TABLE villes.recensement (\n  annee year NOT NULL,\n  departement int4 NOT NULL,\n  numero int4 NOT NULL,\n  population int4 NULL,\n  CONSTRAINT recensement_pk PRIMARY KEY (annee, departement, numero),\n  CONSTRAINT recensement_fk FOREIGN KEY (departement,numero) \n    REFERENCES villes.ville(departement,numero) \n    ON DELETE RESTRICT ON UPDATE CASCADE\n);\n\nCREATE TABLE villes.taxe (\n  annee year NOT NULL,\n  departement int4 NOT NULL,\n  numero int4 NOT NULL,\n  valeur int4 NULL,\n  CONSTRAINT taxe_pk PRIMARY KEY (annee, departement, numero),\n  CONSTRAINT taxe_fk  FOREIGN KEY (departement,numero) \n    REFERENCES villes.ville(departement,numero) \n    ON DELETE RESTRICT ON UPDATE CASCADE\n);\n\n\n\n\n\n\n\nToutes les questions qui suivent se rapportent au schéma villes.\nPour chaque question, proposer une requête écrite en algèbre relationnelle ou en SQL.\n\n\n\n\n\n\n\n\n\nQuestion 4\n\n\n\nLister par région le nombre de communes.\n\n\n\n\n\n\n\n\nSolution 4\n\n\n\nSELECT departement.region, COUNT(*)\n  FROM villes.departement JOIN\n       villes.ville USING (departement)\n GROUP BY departement.region ;\n\n\n\n\n\n\n\n\nnom n’est pas une clé pour ville. COUNT(DISTINCT ville.nom) ne donnera pas nécessairement le résultat attendu.\n\n\n\n\n\n\n\n\n\nQuestion 5\n\n\n\nQuel département contient le plus de communes ?\n\n\n\n\n\n\n\n\nSolution 5\n\n\n\nVersion avec &gt;= ALL :\nWITH counts AS (\n  SELECT departement, COUNT(*)\n  FROM villes.ville\n  GROUP BY departement\n)        \n\nSELECT departement\nFROM counts\nWHERE count &gt;= ALL (SELECT count FROM counts);\nVersion avec RANK() :\nWITH counts AS (\n  SELECT departement.nom, departement, COUNT(ville.numero)\n    FROM villes.departement JOIN villes.ville USING (departement)\n   GROUP BY departement),\nrangs AS (\n  SELECT nom, departement,\n         RANK() OVER (PARTITION BY departement ORDER BY count DESC)\n    FROM counts)\nSELECT nom, departement\n  FROM rangs\n WHERE rank = 1;\n\n\n\n\n\n\n\n\nQuestion 6\n\n\n\nQuel département a connu la plus forte croissance démographique relative entre 2010 et 2020 ?\n\n\n\n\n\n\n\n\nSolution 6\n\n\n\nWITH dpop10 AS (SELECT departement, SUM(population) as pop10\n    FROM villes.ville NATURAL JOIN villes.recensement\n   WHERE annee = 2010\n   GROUP BY departement),\ndpop20 AS (SELECT departement, SUM(population) as pop20\n    FROM villes.ville NATURAL JOIN villes.recensement\n   WHERE annee = 2020\n   GROUP BY departement),\ncroissance AS (SELECT departement, (pop20 - pop10)/pop10 as delta\n    FROM dpop10 NATURAL JOIN dpop20)\nSELECT departement\n  FROM croissance\n WHERE delta &gt;= ALL (SELECT delta FROM croissance);\n\n\n\n\n\n\n\n\nQuestion 7\n\n\n\nPour chaque région, quelle est la proportion de la population qui vit dans des préfectures départementales en 2020 ?\n\n\n\n\n\n\n\n\nSolution 7\n\n\n\nWITH totalpop AS (\n  SELECT d.region, SUM(r.population) AS total\n  FROM villes.departement d JOIN\n       villes.recensement r ON (d.departement = r.departement)\n  WHERE r.annee = '2020'\n  GROUP BY d.region),\n\n  prefpop AS (\n  SELECT d.region, SUM(population) AS pref\n  FROM villes.departement d JOIN \n       villes.recensement r ON (d.departement=r.departement AND \n                                d.numero=r.numero)\n  WHERE annee = '2020'\n  GROUP BY region.nom)\n\nSELECT region, (pref + 0.0)/total\nFROM totalpop NATURAL JOIN \n     prefpop;"
  },
  {
    "objectID": "exams/cc2-2023-11-24.html",
    "href": "exams/cc2-2023-11-24.html",
    "title": "MA15Y030 - Automne 2024",
    "section": "",
    "text": "CC 2 2023-11-24 16h30-18h45\nL3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2023-2024\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\n\n\n\n\n\n\nPour chaque question, proposer une requête écrite en algèbre relationnelle ou en SQL.\n\n\n\n\n\n\n\n\n\nQuestion 1\n\n\n\nDans le schéma world, lister les pays où les dix plus grandes villes ont chacune au moins 10 millions d’habitants.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT \n  ci.countrycode\nFROM \n  world.city ci \nWHERE \n  ci.population_city &gt; 10000000\nGROUP BY \n  ci.countrycode \nHAVING \n  COUNT(ci.id) &gt;= 10 ;\n\n\n\n\n\n\n\n\nQuestion 2\n\n\n\nDans le schéma world, pour chaque pays, donner les trois langues les plus parlées.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS (\n  SELECT \n    cl.countrycode, cl.language, \n    RANK() OVER w AS rnk \n  FROM \n    world.countrylanguage cl \n  WINDOW \n    w AS (PARTITION BY cl.countrycode ORDER BY cl.percentage DESC)\n)\n\nSELECT \n  R.countrycode, R.language\nFROM \n  R\nWHERE \n  R.rnk &lt;= 3 ;\n\n\n\n\n\n\n\n\nQuestion 3\n\n\n\nDans le schéma world, lister les langues parlées sur tous les continents.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT\n  language\nFROM\n  country co\nNATURAL JOIN\n  countrylanguage cl\nGROUP BY\n  cl.language\nHAVING COUNT(DISTINCT co.continent) = (\n  SELECT COUNT(DISTINCT c.continent) FROM country c\n) ;\n\n\n\n\n\n\n\n\nQuestion 4\n\n\n\nDans le schéma world, lister par région le nombre de langues officielles distinctes.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT \n  co.region, \n  COUNT(DISTINCT cl.language) AS n\nFROM \n  world.countrylanguage cl \nNATURAL JOIN \n  world.country co \nWHERE \n  cl.isofficial\nGROUP BY \n  co.region\n\n\n\n\n\n\n\n\nQuestion 5\n\n\n\nDans le schéma world, lister pour chaque forme de gouvernement, la population des villes des pays qui subissent cette forme de gouvernement.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT \n  co.governmentform, \n  SUM(ci.population) AS pop\nFROM \n  world.country co \nJOIN \n  world.city ci  USING (countrycode)\nGROUP BY \n  co.governmentform ;\n\n\n\n\n\n\n\n\nQuestion 6\n\n\n\nDans le schéma world, lister les pays où la capitale est la ville la plus peuplée.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS (\n  SELECT \n    co.countrycode, co.name_country, ci. name, ci.id, ci.population,\n1    (co.capital=ci.id) AS capitale,\n2    RANK() OVER (PARTITION BY co.countrycode ORDER BY ci.population DESC) AS rnk\n  FROM \n      world.country co\n    JOIN\n      world.city ci  USING (countrycode) \n)\n\nSELECT \n  R.name_country, R. name, R.population\nFROM \n  R \nWHERE \n3  capitale AND rnk = 1\n;  \n\n1\n\nOn note les villes qui sont capitales\n\n2\n\nOn range les villes d’un pays par population décroissante\n\n3\n\nOn ne garde que les capitales qui sont aussi les villes les plus peuplées du royaume\n\n\n\n\n\n\n\n\n\n\nQuestion 7\n\n\n\nDans le schéma world, lister les pays où \\(90\\%\\) de la population parle une langue officielle (il peut y avoir plusieurs langues officielles, dont la somme des locuteurs et locutrices dépasse \\(90\\%\\) de la population).\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT \n  cl.countrycode\nFROM \n  world.countrylanguage cl \nWHERE \n  cl.isofficial\nGROUP BY cl.countrycode\nHAVING SUM(cl.percentage) &gt;= 90 ;\n\n\n\nToutes les questions portent sur le schéma world.\n\n\n\nSchéma world"
  },
  {
    "objectID": "exams/cc1-2024-10-25.html",
    "href": "exams/cc1-2024-10-25.html",
    "title": "MA15Y030 - Automne 2024",
    "section": "",
    "text": "L3 MIASHS/Ingémath/METIS\nUniversité Paris Cité\nAnnée 2024-2025\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\n\n\n\n\n\n\nToutes les questions portent sur le schéma pagila rappelé ci-dessous.\nPour chaque question, proposer une requête écrite en algèbre relationnelle OU en SQL.\n\n\n\n\n\n\nSchéma pagila, films\n\n\n\nDonner pour chaque film au catalogue, le titre et les prénoms des acteurs qui jouent dans ce film.\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT fi.title, string_agg(DISTINCT a.first_name, ', ') AS casting \nFROM  \n   pagila.film fi  \nJOIN  \n   pagila.film_actor fa ON (fi.film_id=fa.film_id)  \nJOIN \n   pagila.actor a ON (fa.actor_id=a.actor_id) \nGROUP BY fi.film_id;   \n Il n’est pas nécessaire d’effectuer un groupement et une aggrégation, mais c’est une occasion d’illustrer cette possibilité. string_agg() est une fonction proposée par PostgreSQL, analogue à paste() ou stringr::str_c() en R, ou à une invocation de functools.reduce() en Python:\n&gt;&gt;&gt; foo = lambda x,y : x + ', ' + y if x else y\n&gt;&gt;&gt; reduce(foo, ['Brad', 'Angelina', 'Romy', 'Ava'], '')\n'Brad, Angelina, Romy, Ava'\nDes fonctions d’aggrégations comme SUM(), MAX(), COUNT() sont de cette forme. Des fonctions d’aggrégations comme AVG(), VAR(), COUNT(DISTINCT ...) sont un peu plus compliquées à réaliser mais relève du même genre de calcul.\n\n\n\nLister les titres de films qui ne sont disponibles que dans une seule langue\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT fi.title \nFROM \n  pagila.film fi \nGROUP BY fi.title \nHAVING COUNT (DISTINCT fi.language_id)=1 ;\nIl n’est pas indispensable de passer par un groupement/aggrégation. On peut obtenir le résultat en utilisant simplement sélection, projection, jointure, opérations ensemblistes (\\(∩, ∪, ∖\\)).\n(\n SELECT \n    DISTINCT title \n FROM \n    pagila.film\n)\nEXCEPT \n(\n SELECT \n     DISTINCT f1.title\n FROM \n     pagila.film f1 \n JOIN \n     pagila.film f2\n ON (f1.title = f2.title AND f1.language_id &lt; f2.language_id)\n)\n on est parfois tenté de choisir comme condition de jointure dans la seconde sous-requête f1.film_id = f2.film_id AND f1.language_id &lt; f2.language_id. Cela conduira a un résultat sans intérêt. L’attribut film_id est clé primaire (primary key) de film (cela fait partie du schéma, cette contrainte s’impose à toutes les instances du schéma). Quelle que soit l’instance, on ne pourra pas trouver dans la table film, deux tuples qui coïncident sur film_id et diffèrent sur language_id.\nSELECT \n    f.title\nFROM \n    pagila.film f\nGROUP BY \n    f.title\nHAVING COUNT(DISTINCT language_id) = 1 ;\n\n\n\n\nPour chaque langue originale (original_language_id), chaque langue de diffusion (language_id), compter le nombre de titres tournés dans la langue originale et traduits dans la langue de diffusion (sans doublons).\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT \n2  original_language_id, language_id,\n3  count(title)\nFROM \n    pagila.film \nGROUP BY \n1    original_language_id, language_id\n;\n\n1\n\nPartitionnement sur le couple d’attributs original_language_id, language_id\n\n2\n\nProjection sur les attributs de partitionnement et\n\n3\n\nsur la/les aggrégations\n\n\n\n\n\n\nDonner pour chaque catégorie (de film), les noms des acteurs qui apparaissent dans le nombre maximal de films de la catégorie.\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH ActorFilmCount AS (\n    SELECT\n        c.name AS category_name,\n        a.actor_id,\n        a.first_name || ' ' || a.last_name AS actor_name,\n        COUNT(fa.film_id) AS film_count\n    FROM\n        actor a\n    JOIN\n        film_actor fa ON a.actor_id = fa.actor_id\n    JOIN\n        film f ON fa.film_id = f.film_id\n    JOIN\n        film_category fc ON f.film_id = fc.film_id\n    JOIN\n        category c ON fc.category_id = c.category_id\n    GROUP BY\n        c.name, a.actor_id, a.first_name, a.last_name\n),\n\nRankedActors AS (\n    SELECT\n        category_name,\n        actor_name,\n        film_count,\n        DENSE_RANK() OVER (PARTITION BY category_name ORDER BY film_count DESC) AS rank\n    FROM\n        ActorFilmCount\n)\nSELECT\n    category_name,\n    actor_name,\n    film_count\nFROM\n    RankedActors\nWHERE\n    rank = 1\nORDER BY\n    category_name;\n\n\nOn peut se passer des fonctions fenêtres.\n\n\n\n\n\n\nSolution\n\n\n\nWITH ActorFilmCount AS (\n    SELECT\n        c.name AS category_name,\n        a.actor_id,\n        a.first_name || ' ' || a.last_name AS actor_name,\n        COUNT(fa.film_id) AS film_count\n    FROM\n        actor a\n    JOIN\n        film_actor fa ON a.actor_id = fa.actor_id\n    JOIN\n        film f ON fa.film_id = f.film_id\n    JOIN\n        film_category fc ON f.film_id = fc.film_id\n    JOIN\n        category c ON fc.category_id = c.category_id\n    GROUP BY\n        c.name, a.actor_id, a.first_name, a.last_name\n),\n\n\nMaxPerCat AS (\n    SELECT\n        category_name,\n        MAX(film_count) as m_film_count\n    FROM \n        ActorFilmCount\n    GROUP BY \n        category_name    \n),\n\n\nSELECT \n    ac.category_name,\n    ac.actor_id,\n    ac.actor_name,\n    ac.film_count\nFROM \n    ActorFilmCount  ac\nJOIN\n    MaxPerCat  mpc\nUSING(category_name)\nWHERE \n    ac.film_count=mpc.m_film_count\nORDER BY\n    ac.category_name ;\n\n\nou encore\n\n\n\n\n\n\nSolution\n\n\n\nWITH ActorFilmCount AS (\n    SELECT\n        c.name AS category_name,\n        a.actor_id,\n        a.first_name || ' ' || a.last_name AS actor_name,\n        COUNT(fa.film_id) AS film_count\n    FROM\n        actor a\n    JOIN\n        film_actor fa ON a.actor_id = fa.actor_id\n    JOIN\n        film f ON fa.film_id = f.film_id\n    JOIN\n        film_category fc ON f.film_id = fc.film_id\n    JOIN\n        category c ON fc.category_id = c.category_id\n    GROUP BY\n        c.name, a.actor_id, a.first_name, a.last_name\n)\n\nSELECT\n    afc.*\nFROM \n    ActorFilmCount afc\nWHERE \n    afc.film_count &gt;= ALL (\n        SELECT \n            a.film_count\n        FROM\n            ActorFilmCount a\n        WHERE \n            a.category_name = afc.category_name\n    ) ;\n\n\n\n\nLister sans doublons les paires d’acteurs qui n’ont jamais joué dans un même film.\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH ActorPairs AS (\n    -- Generate all possible actor pairs (excluding pairing an actor with themselves)\n    SELECT\n        a1.actor_id AS actor1_id,\n        a2.actor_id AS actor2_id,\n        a1.first_name || ' ' || a1.last_name AS actor1_name,\n        a2.first_name || ' ' || a2.last_name AS actor2_name\n    FROM\n        actor a1\n    JOIN\n        actor a2 ON a1.actor_id &lt; a2.actor_id  -- Ensure actor1_id &lt; actor2_id to avoid duplicate pairs\n),\nActorsTogether AS (\n    -- Find all actor pairs who have acted together in at least one film\n    SELECT\n        fa1.actor_id AS actor1_id,\n        fa2.actor_id AS actor2_id\n    FROM\n        film_actor fa1\n    JOIN\n        film_actor fa2 ON fa1.film_id = fa2.film_id\n    WHERE\n        fa1.actor_id &lt; fa2.actor_id  -- Same condition to avoid duplicates\n),\nActorsNotTogether AS (\n    -- Left JOIN all possible pairs with the pairs that acted together\n    SELECT\n        ap.actor1_name,\n        ap.actor2_name\n    FROM\n        ActorPairs ap\n    LEFT JOIN\n        ActorsTogether at ON ap.actor1_id = at.actor1_id AND ap.actor2_id = at.actor2_id\n    WHERE\n        at.actor1_id IS NULL  -- Only return pairs that do not exist in the ActorsTogether result\n)\n-- Final result\nSELECT\n    actor1_name,\n    actor2_name\nFROM\n    ActorsNotTogether\nORDER BY\n    actor1_name, actor2_name;\n\n\n\n\nLister les acteurs (prénom, nom) qui ont joué dans des films tournés dans au moins deux langues différentes (langue de tournage : original_language_id)\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT\n    a.actor_id,\n    a.first_name || ' ' || a.last_name AS actor_name,\n    STRING_AGG(DISTINCT l.name, ', ') AS languages\nFROM\n    actor a\nJOIN\n    film_actor fa ON a.actor_id = fa.actor_id\nJOIN\n    film f ON fa.film_id = f.film_id\nJOIN\n    language l ON f.original_language_id = l.language_id\nGROUP BY\n    a.actor_id, a.first_name, a.last_name\nHAVING\n    COUNT(DISTINCT f.original_language_id) &gt; 1\nORDER BY\n    actor_name;\n\n\n\nPour chaque magasin (désigné par store_id), chaque langue, donnez le nombre de DVDs (physiques) disponibles dans cette langue, dans ce magasin.\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT\n    s.store_id,\n    l.name AS language_name,\n    COUNT(i.inventory_id) AS inventory_count\nFROM\n    store s\nJOIN\n    inventory i ON s.store_id = i.store_id\nJOIN\n    film f ON i.film_id = f.film_id\nJOIN\n    language l ON f.language_id = l.language_id\nWHERE\n    f.language_id IS NOT NULL\nGROUP BY\n    s.store_id, l.name\nORDER BY\n    s.store_id, l.name;"
  },
  {
    "objectID": "exams/cc1-2023-10-27.html",
    "href": "exams/cc1-2023-10-27.html",
    "title": "MA15Y030 - Automne 2024",
    "section": "",
    "text": "L3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2023-2024\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\nToutes les questions portent sur le schéma world rappelé ci-dessous.\n\n\n\nSchéma world\n\n\n\n\n\n\n\n\nLes territoires qui sont inscrits dans la table country ne sont pas tous des pays, et pour certaines lignes, population_country, gnp, governmentform, … ne sont pas renseignés.\n\n\n\n\n\n\n\n\n\nPour chaque question, proposer une requête écrite en algèbre relationnelle ou en SQL.\n\n\n\n\nDonner pour chaque pays, chaque district, la population totale qui réside dans des villes répertoriées dans city.\n\n\n\n\n\n\n\nSolution\n\n\n\nUn district est une unité territoriale incluse dans un territoire. Pour la France, les district correspondent aux régions, pour l’Allemagne aux Laender, …\nSELECT DISTINCT ci.district\nFROM world.city ci\nWHERE ci.countrycode='FRA' ;\nComme on doit sommer les populations des villes situées dans un district (et donc dans un pays), il faut partitionner city par district et pays.\n2SELECT ci.countrycode, ci.district,\n3       SUM(ci.population) as pop\nFROM world.city ci \n1GROUP BY ci.countrycode, ci.district\n\n1\n\nDeux colonnes pour le partitionnement (même si countrycode est peut-être déterminé par district)\n\n2\n\nOn ne peut projeter que sur les colonnes utilisées pour partitionner et …\n\n3\n\nSur des colonnes agrégées.\n\n\nAprès partition/aggrégation, la table résultat contient une ligne pour chaque combinaison des attributs/colonnes servant au partitionnement. Sur chaque ligne du résultat, on peut faire figurer des aggrégations.\nSi on veut disposer des totaux par pays en plus, on peut utiliser la construction GROUP BY ROLLUP(...)\nSELECT ci.countrycode, ci.district, \n       SUM(ci.population) as pop    \nFROM world.city ci \nGROUP BY ROLLUP(ci.countrycode, ci.district) \nORDER BY ci.countrycode, ci.district\nLIMIT 20 ; \nOn peut chercher à imiter le résultat de GROUP BY ROLLUP avec les constructions vues en cours.\nWITH r AS (\n  SELECT ci.countrycode, ci.district, \n       SUM(ci.population) as pop  \n  FROM world.city ci \n  GROUP BY ci.countrycode, ci.district\n), s AS (\n  SELECT r.countrycode, NULL AS district, sum(r.pop_district) AS pop\n  FROM r\n  GROUP BY r.countrycode\n)\n\n(SELECT * FROM s)\nUNION \n(SELECT * FROM r) \nORDER BY countrycode, district ;\nLa construction GROUP BY ROLLUP (...) ne permet pas définir des requêtes qui seraient hors de portée de GROUP BY ..., elle permet une écriture plus concise et plus claire.\n\n\n\nDonner pour chaque pays le nombre d’habitants qui ne parlent pas une langue officielle. On suppose ici que chaque habitant ne parle qu’une seule langue.\n\n\n\n\n\n\n\nSolution\n\n\n\n1WITH cc_pop_not_official AS (\n  SELECT countrycode, SUM(percentage) as percentage\n  FROM world.countrylanguage\n  WHERE NOT(isofficial)\n  GROUP BY countrycode\n)\n\nSELECT name_country, (population_country * percentage / 100)::INTEGER\n2FROM world.country NATURAL JOIN cc_pop_not_official;\n\n1\n\nLa requête intermédiaire cc_pop_not_official nous donne pour chaque pays le pourcentage de locuteurs des langues non-officielles du pays\n\n2\n\nGrâce à une jounture avec country, on peut combiner ce pourcentage avec la population du pays.\n\n\nOn peut chercher à vérifier la convention avancée dans l’énoncé:\nSELECT cl.countrycode, SUM(cl.percentage) AS total_percent\nFROM world.countrylanguage cl \nGROUP BY cl.countrycode\nHAVING SUM(cl.percentage) &gt; 100\nORDER BY total_percent DESC \nLIMIT 10 ;\n\n\n\nDonner, pour chaque région ayant au moins 50 millions d’habitants, le ou les pays les moins peuplés de la région.\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH r_minpop_g50M AS (\n  SELECT region, MIN(population_country) AS population_country\n  FROM world.country\n  GROUP BY region\n  HAVING SUM(population_country) &gt;= 50000000)\n\nSELECT co.region, co.name_country\n  FROM world.country co NATURAL JOIN r_minpop_g50M ;\n\n\n\n\n\n\nNe pas confondre les régions ayant au moins 50 millions d’habitants et les régions où au moins un pays a plus de 50 millions d’habitants.\n\n\n\n\n\n\nListe des pays où la langue la plus parlée n’est pas officielle\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH r AS (\n  SELECT cl.*, \n    co.name_country, \n    rank() OVER w AS rang\n    FROM world.countrylanguage cl NATURAL JOIN \n         world.country co\n  WINDOW w AS (PARTITION BY cl.countrycode ORDER BY cl.percentage DESC) \n)\n\nSELECT DISTINCT r.name_country\nFROM r\nWHERE r.rang=1 AND NOT r.isofficial ;\nL’usage d’une fonction fenêtre est commode, mais c’est un marteau-pilon pour casser un œuf.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nAlternatives sans fonction fenêtre :\nWITH langmax AS (\n  SELECT countrycode, \n         MAX(percentage) AS percentage\n  FROM world.countrylanguage\n  GROUP BY countrycode)\n\nSELECT DISTINCT name_country\nFROM world.country NATURAL JOIN \n     world.countrylanguage NATURAL JOIN \n     langmax\nWHERE NOT(isofficial);\nSELECT DISTINCT cl.countrycode\nFROM world.countrylanguage cl\nWHERE NOT cl.isofficial AND \n      NOT EXISTS (\n        SELECT *\n        FROM world.countrylanguage cl1\n        WHERE cl1.isofficial AND \n              cl1.countrycode = cl.countrycode\n              cl1.percentage &gt; cl.percentage\n) ;\n\n\n\n\n\n\n\n\nUne erreur fréquente consiste à lister les pays où il existe une langue officielle qui est moins parlée qu’une langue non-officelle. Ce n’est pas la même chose que la liste des pays où toutes les langues officielles sont moins parlées qu’une certaine langue non-officiele\n\n\n\n\n\n\n\n\n\nSolution en calcul des tuples\n\n\n\n\\[\\begin{array}{rl}\\left\\{ t : \\texttt{country}(t) \\right. & \\wedge \\exists s, s \\in \\texttt{countrylanguage} \\wedge \\neg  s.\\texttt{isofficial}  \\wedge \\\\ & \\left. \\phantom{\\wedge}\\forall u \\neg \\left(\\texttt{countrylanguage}(u)  \\wedge u.\\texttt{isofficial} \\wedge u.\\texttt{percentage} &gt; s.\\texttt{percentage} \\right) \\right\\}\n\\end{array}\\]\n\n\n\n\n\n\n\n\nUne autre erreur fréquente consiste à ne lister que les pays où il existe une langue non-officielle parlée par au moins la moitié de la population:\nSELECT cl.countrycode\nFROM world.countrylanguage cl\nWHERE cl.percentage &gt; 50 AND NOT c.isofficial ; \nIl est très possible que dans un pays, aucune langue ne soit parlée par la moitié de la population, que toutes les langues soient minoritaires, et que la langue la plus parlée ne soit pas officielle.\n\n\n\n\nListe des pays où aucune ville ne compte plus \\(3\\) millions d’habitants.\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH r AS (  \n    SELECT ci.countrycode, \n           SUM(CAST (ci.population &gt; 3000000 AS INTEGER)) AS nb\n    FROM world.city ci\n    GROUP BY ci.countrycode \n1)\n\nSELECT co.name_country, co.continent\nFROM world.country co LEFT JOIN \n     r ON (co.countrycode = r.countrycode)   \nWHERE r.nb IS NULL OR r.nb = 0\n2ORDER BY co.continent, co.name_country;\n\n1\n\nLa requête r collecte les codes de pays et pour chaque pays le nombre de villes de plus de \\(3000000\\) d’habitants.\n\n2\n\nEn effectuant la jointure externe entre country et r, on récupère les territoires sans villes et les territoires où toutes les villes comptent moins de \\(3000000\\) d’habitants.\n\n\nOn a ajouté continent parmi les colonnes de projection pour rendre plus lisibles les résultats.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nAlternative utilisant EXCEPT :\nWITH cc_no_big_city AS (\n  (SELECT countrycode\n   FROM world.country)\n   EXCEPT\n  (SELECT countrycode\n   FROM world.city\n   WHERE population &gt; 3000000))\n   \nSELECT name_country, continent\nFROM world.country NATURAL JOIN cc_no_big_city\nORDER BY continent, name_country;\nCette requête donne le même résultat que la précédente.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nAlternative utilisant NOT IN :\nSELECT name_country, continent\n  FROM world.country\n WHERE countrycode NOT IN (\n     SELECT countrycode\n       FROM world.city\n      WHERE population &gt; 3000000)\n ORDER BY continent, name_country;\nCette requête donne encore le même résultat que la précédente.\n\n\n\n\n\n\n\n\nSolution en calcul des tuples\n\n\n\nTraduction quasi-litérale de la question en formule du calcul des tuples: \\[\\left\\{ t :\\texttt{country}(t)  \\wedge \\left(\\not \\exists s \\quad \\texttt{city}(s) \\wedge   s.\\texttt{countrycode}=t.\\texttt{countrycode} \\wedge s.\\texttt{population} &gt; 3000000 \\right)\\right\\}\\]. Cette formule se traduit presque mécaniquement avec une requête imbriquée\nSELECT co.*\nFROM world.country co\nWHERE NOT EXISTS (\n     SELECT *\n     FROM world.city ci\n     WHERE ci.countrycode=co.countrycode AND ci.population &gt; 3000000) ;\non peut aussi réécrire la formule en \\[\\texttt{country} \\setminus \\left\\{ t : \\texttt{country}(t)  \\wedge \\left( \\exists s \\quad  \\texttt{city}(s) \\wedge   s.\\texttt{countrycode}=t.\\texttt{countrycode} \\wedge s.\\texttt{population} &gt; 3000000 \\right)\\right\\}\\]\n\n\n\nListe des formes de gouvernement (governmentform) pour lesquelles dans tous les pays possédant cette forme de gouvernement, aucune langue n’est officielle.\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH r AS (\n    SELECT DISTINCT cl.countrycode\n    FROM world.countrylanguage cl \n    WHERE cl.isofficial\n), s AS (\n\n    SELECT DISTINCT co.governmentform\n    FROM world.country co \n    WHERE co.countrycode IN (\n    SELECT r.countrycode FROM r)\n)\n\nSELECT DISTINCT co.governmentform\nFROM world.country co \n\nEXCEPT \n\nSELECT s.governmentform\nFROM s  ;\n\n\n\n\n\n\n\n\nSolution\n\n\n\nAlternative utilisant EXCEPT :\n(SELECT governmentform\n   FROM world.country)\nEXCEPT\n(SELECT governmentform\n   FROM world.country NATURAL JOIN world.countrylanguage\n  WHERE isofficial);\n\n\n\n\n\n\n\n\nSolution\n\n\n\nAlternative avec partition, agrégation\nSELECT co.governmentform\nFROM world.country  co LEFT join \n     world.countrylanguage cl ON (co.countrycode=cl.countrycode)\nGROUP BY co.governmentform\nHAVING SUM(CAST(cl.isofficial AS INTEGER))=0 OR \n       SUM(CAST(cl.isofficial AS INTEGER)) IS NULL;\nSi on oublie la condition SUM(CAST(cl.isofficial AS INTEGER)) IS NULL, on ne retrouve pas Co-administrated qui concerne des territoires qui ne sont pas mentionnés dans la table countrylanguage.\n\n\n\nDonner pour chaque région, le minimum du PIB par habitant (c’est-à-dire le résultat de la division 1000000 * gnp / population_country, puisque le PIB est donné en millions) dans la région, un des pays (son countrycode) de la région où ce minimum est réalisé, le maximum du PIB par habitant et un des pays (son countrycode) où ce maximum est réalisé.\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH r AS (\n    SELECT co.region, co.countrycode, co.name_country,\n        1000000*co.gnp/co.population_country AS gnp_per_cap,\n        row_number() OVER w_max AS rang_max,\n        row_number() OVER w_min AS rang_min\n    FROM world.country co\n    WHERE co.population_country IS NOT NULL AND co.population_country &gt;0 AND co.gnp IS NOT NULL\n    WINDOW \n        w_max AS (PARTITION BY co.region ORDER BY co.gnp/co.population_country DESC),\n        w_min AS (PARTITION BY co.region ORDER BY co.gnp/co.population_country) \n), r1 AS (\n    SELECT r.*\n    FROM r\n    WHERE r.rang_max=1\n), r2 AS (\n    SELECT r.*\n    FROM r\n    WHERE r.rang_min=1\n)\n\nSELECT r1.region, r1.countrycode, r1.gnp_per_cap,\n       r2.countrycode, r2.gnp_per_cap\nFROM r1 JOIN r2 ON (r1.region=r2.region)  ;\n\n\n\n\n\n\n\n\nSolution\n\n\n\nAlternative sans fonction fenêtre :\nWITH cc_gpc AS (\n  SELECT countrycode, 1000000 * gnp/population_country AS gnp_per_cap\n    FROM world.country\n   WHERE population_country &gt; 0),\nregion_mingpc_maxgpc AS (\n  SELECT region, MIN(gnp_per_cap) AS mingpc, MAX(gnp_per_cap) AS maxgpc\n    FROM world.country NATURAL JOIN cc_gpc\n   GROUP BY region),\nregion_cc_mingpc AS (\n  SELECT region, MIN(c1.countrycode) AS countrycode, c1.gnp_per_cap\n    FROM world.country c NATURAL JOIN region_mingpc_maxgpc r\n         JOIN cc_gpc c1 ON c.countrycode = c1.countrycode\n                           AND r.mingpc = c1.gnp_per_cap\n   GROUP BY region, c1.gnp_per_cap),\nregion_cc_maxgpc AS (\n  SELECT region, MIN(c1.countrycode) AS countrycode, c1.gnp_per_cap\n    FROM world.country c NATURAL JOIN region_mingpc_maxgpc r\n         JOIN cc_gpc c1 ON c.countrycode = c1.countrycode\n                           AND r.maxgpc = c1.gnp_per_cap\n   GROUP BY region, c1.gnp_per_cap)\n\nSELECT *\n  FROM region_cc_mingpc JOIN region_cc_maxgpc\n       USING (region);\n\n\n\n\n\n\n\n\nErreur commune\n\n\n\nAvec une table foo de schéma (col1, col2, col3, col4), la requête suivante n’est pas correcte :\nSELECT col1, col2, SUM(col4) as bar\nFROM foo\nGROUP BY col1, col3 ;\nLes colonnes qui figurent dans la clause de projection SELECT ... doivent\n\nfigurer dans la clause de partitionnement GROUP BY ..., ici col1 et col3\nreprésenter des agrégations, comme ici SUM(col4)\n\nLa colonne col2 ne peut pas figurer dans la clause de projection !\n\n\n\n\n\n\n\n\nErreur commune\n\n\n\nDans une clause WHERE ou une condition de jointure, lorsqu’on compare deux colonnes, les types des deux colonnes doivent être compatibles (en général identiques).\nDes conditions comme language=isofficial ou governmentform=countrycode n’ont pas de sens."
  },
  {
    "objectID": "exams/cc3-2022-10-14.html",
    "href": "exams/cc3-2022-10-14.html",
    "title": "MA15Y030 - Automne 2024",
    "section": "",
    "text": "Sur le serveur, dans votre schéma personnel, créer les fonctions SQL et vues correspondant aux cinq questions suivantes."
  },
  {
    "objectID": "exams/cc3-2022-10-14.html#les-pays-où-lon-cause-le-.",
    "href": "exams/cc3-2022-10-14.html#les-pays-où-lon-cause-le-.",
    "title": "MA15Y030 - Automne 2024",
    "section": "Les pays où l’on cause le ….",
    "text": "Les pays où l’on cause le ….\nÉcrire une fonction SQL nommée cc_fonc_1 qui prend en argument une chaine de caractères censée désigner une langue et renvoie une table (name_country TEXT, pop_speakers int4) qui contient les 5 pays comportant le plus de locuteurs de la langue en question et pour chaque pays le nombre estimé de locuteurs de la langue en question\n\n\n\n\n\n\nRéponse attendue pour %French% :\n\n\n\nname_country\npop_speakers\n\n\n\n\nFrance\n55435254\n\n\nCanada\n7288398\n\n\nBelgium\n3337914\n\n\nTunisia\n2521118\n\n\nUnited States\n1948499\n\n\n\n\n\n\n\n\n\n\n\n\nsolution\n\n\n\nTODO"
  },
  {
    "objectID": "exams/cc3-2022-10-14.html#pays-peu-concentrés-sur-les-grandes-villes",
    "href": "exams/cc3-2022-10-14.html#pays-peu-concentrés-sur-les-grandes-villes",
    "title": "MA15Y030 - Automne 2024",
    "section": "Pays peu concentrés sur les grandes villes",
    "text": "Pays peu concentrés sur les grandes villes\nCréer une vue cc_vue_2 des pays dont la population n’est pas nulle et où les cinq plus grandes villes ne rassemblent pas plus du dixième de la population. La vue aura pour schéma (countrycode, name_country, portion)\n\n\n\n\n\n\nRéponse attendue pour\nSELECT * \nFROM username.cc_vue_2 cv \nWHERE cv.countrycode  IN (\n SELECT c.countrycode \n FROM world.country c \n WHERE region='Eastern Africa'\n) ;\n\n\n\ncountrycode\nname_country\nportion\n\n\n\n\nMDG\nMadagascar\n0.07045295\n\n\nMWI\nMalawi\n0.08367222\n\n\nBDI\nBurundi\n0.04480956\n\n\nCOM\nComoros\n0.062283736\n\n\nTZA\nTanzania\n0.071704924\n\n\nMYT\nMayotte\n0.08053691\n\n\nUGA\nUganda\n0.040903665\n\n\nRWA\nRwanda\n0.036984354\n\n\nETH\nEthiopia\n0.047906272\n\n\n\n\n\n\n\n\n\n\n\n\nsolution\n\n\n\nTODO"
  },
  {
    "objectID": "exams/cc3-2022-10-14.html#la-cinquième-ville-la-plus-peuplée-dans-chaque-pays",
    "href": "exams/cc3-2022-10-14.html#la-cinquième-ville-la-plus-peuplée-dans-chaque-pays",
    "title": "MA15Y030 - Automne 2024",
    "section": "La cinquième ville la plus peuplée dans chaque pays",
    "text": "La cinquième ville la plus peuplée dans chaque pays\nÉcrire une fonction de cc_fonc_3 langage SQL qui prend en argument une chaine de caractères censée désigner un pays par son nom et renvoie le nom de la cinquième ville la plus peuplée du pays (type de name_city), et la part de la population du pays qui réside dans cette ville (type float4).\n\n\n\n\n\n\nRéponse attendue pour\nSELECT name_city, prop \nFROM username.cc_fonc_3('Italy') ;\n\n\n\nname_city\nprop\n\n\n\n\nPalermo\n0.011854959\n\n\n\n\n\n\n\n\n\n\n\n\nsolution\n\n\n\nTODO"
  },
  {
    "objectID": "exams/cc3-2022-10-14.html#la-population-des-deux-villes-les-plus-peuplées-de-chaque-pays",
    "href": "exams/cc3-2022-10-14.html#la-population-des-deux-villes-les-plus-peuplées-de-chaque-pays",
    "title": "MA15Y030 - Automne 2024",
    "section": "La population des deux villes les plus peuplées de chaque pays",
    "text": "La population des deux villes les plus peuplées de chaque pays\nCréer une vue cc_vue_4 qui liste par pays, le nombre d’habitants des deux villes les plus peuplées. La vue aura pour schéma (name_contry text, pop_two_cities int4).\n\n\n\n\n\n\nRéponse attendue pour\nSELECT * \nFROM username.cc_vue_4 \nWHERE name_country = 'France' ;\n\n\n\nname_country\npop_two_cities\n\n\n\n\nFrance\n2923676\n\n\n\n\n\n\n\n\n\n\n\n\nsolution\n\n\n\nTODO"
  },
  {
    "objectID": "exams/cc3-2022-10-14.html#pays-où-deux-langues-sont-parlées-par-au-moins-un-dixième-de-la-population",
    "href": "exams/cc3-2022-10-14.html#pays-où-deux-langues-sont-parlées-par-au-moins-un-dixième-de-la-population",
    "title": "MA15Y030 - Automne 2024",
    "section": "Pays où deux langues sont parlées par au moins un dixième de la population",
    "text": "Pays où deux langues sont parlées par au moins un dixième de la population\nCréer une vue cc_vue_5 des pays où au moins deux langues sont (chacunes) parlées par au moins un dixieme de la population. La vue aura même schema que world.country.\n\n\n\n\n\n\nSELECT \n  countrycode, name_country  \nFROM \n  username.cc_vue_5 \nWHERE \n  region='Eastern Europe' ;\n\n\n\ncountrycode\nname_country\n\n\n\n\nCZE\nCzech Republic\n\n\nBLR\nBelarus\n\n\nMDA\nMoldova\n\n\nUKR\nUkraine\n\n\nSVK\nSlovakia\n\n\n\n\n\n\n\n\n\n\n\n\nsolution\n\n\n\nSELECT \n  countrycode \nFROM \n  countrylanguage\nWHERE \n  percentage &gt;= 10 \nGROUP BY countrycode\nHAVING COUNT(language) &gt;= 2;"
  },
  {
    "objectID": "exams/ct-2024-06-19.html",
    "href": "exams/ct-2024-06-19.html",
    "title": "MA15Y030 - Automne 2024",
    "section": "",
    "text": "L3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2023-2024\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\n\n\n\n\n\n\nLes requêtes portent sur le schéma nycflights légèrement nettoyé.\n\n\n\n\n\n\nNYCFlights en relationel à pattes de corbeau\n\n\n\n\n\nDéfinition du schéma en SQL\n\n\n\n\n\n\nCREATE TABLE airlines (\n    carrier text NOT NULL,\n    \"name\" text NULL,\n    CONSTRAINT airlines_pk \n        PRIMARY KEY (carrier),\n    CONSTRAINT airlines_un \n        UNIQUE (name)\n);\nCREATE TABLE airports (\n    faa text NOT NULL,\n    \"name\" text NULL,\n    lat float8 NULL,\n    lon float8 NULL,\n    alt float8 NULL,\n    tz float8 NULL,\n    dst text NULL,\n    tzone text NULL,\n    CONSTRAINT airports_pk \n        PRIMARY KEY (faa),\n    CONSTRAINT airports_un \n        UNIQUE (name),\n    CONSTRAINT airports_un_ll \n        UNIQUE (lat, lon)\n);\n\n\nCREATE TABLE weather (\n    origin text NOT NULL,\n    \"year\" int4 NULL,\n    \"month\" int4 NULL,\n    \"day\" int4 NULL,\n    \"hour\" int4 NULL,\n    \"temp\" float8 NULL,\n    dewp float8 NULL,\n    humid float8 NULL,\n    wind_dir float8 NULL,\n    wind_speed float8 NULL,\n    wind_gust float8 NULL,\n    precip float8 NULL,\n    pressure float8 NULL,\n    visib float8 NULL,\n    time_hour timestamptz NOT NULL,\n    CONSTRAINT weather_pk \n        PRIMARY KEY (origin, time_hour)\n);\nALTER TABLE weather ADD \n    CONSTRAINT weather_fk \n    FOREIGN KEY (origin) \n    REFERENCES airports(faa) \n    ON DELETE CASCADE \n    ON UPDATE CASCADE;\n\n\n\nCREATE TABLE planes (\n    tailnum text NOT NULL,\n    \"year\" int4 NULL,\n    \"type\" text NULL,\n    manufacturer text NULL,\n    model text NULL,\n    engines int4 NULL,\n    seats int4 NULL,\n    speed int4 NULL,\n    engine text NULL,\n    CONSTRAINT planes_pk   PRIMARY KEY (tailnum)\n);\n\n\n\n\n\n\nCREATE TABLE flights (\n    \"year\" int4 NULL,\n    \"month\" int4 NULL,\n    \"day\" int4 NULL,\n    dep_time int4 NULL,\n    sched_dep_time int4 NULL,\n    dep_delay float8 NULL,\n    arr_time int4 NULL,\n    sched_arr_time int4 NULL,\n    arr_delay float8 NULL,\n    carrier text NULL,\n    flight int4 NULL,\n    tailnum text NOT NULL,\n    origin text NOT NULL,\n    dest text NULL,\n    air_time float8 NULL,\n    distance float8 NULL,\n    \"hour\" float8 NULL,\n    \"minute\" float8 NULL,\n    time_hour timestamptz NOT NULL,\n    CONSTRAINT flights_pk \n        PRIMARY KEY (\n            tailnum, origin, time_hour)\n);\n\n\nALTER TABLE flights ADD \n    CONSTRAINT flights_fk \n    FOREIGN KEY (carrier) \n    REFERENCES airlines(carrier) \n    ON DELETE SET NULL \n    ON UPDATE CASCADE;\nALTER TABLE flights ADD \n    CONSTRAINT flights_fk_dest \n    FOREIGN KEY (dest) \n    REFERENCES airports(faa) \n    ON DELETE SET NULL \n    ON UPDATE CASCADE;\nALTER TABLE flights ADD \n    CONSTRAINT flights_fk_origin \n    FOREIGN KEY (origin) \n    REFERENCES airports(faa) \n    ON DELETE SET NULL \n    ON UPDATE CASCADE;\nALTER TABLE flights ADD \n    CONSTRAINT flights_fk_planes \n    FOREIGN KEY (tailnum) \n    REFERENCES planes(tailnum) \n    ON DELETE SET NULL \n    ON UPDATE CASCADE;\n\n\n\nDans le schéma nycflights, on a aussi les dépendances fonctionnelles suivantes:\nTable airports\n\nfaa, name, et (lon, lat) sont des clés.\n\nTable airlines\n\ncarrier et name sont des clés\n\nTable weather\n\norigin, time_hour est une clé\ntime_hour → year, month, day, hour\nyear, month, day, hour  → time_hour\n\nTable planes\n\ntailnum est une clé\nmodel → manufacturer, engines, engine, type\n\nTable flights\n\ntailnum, time_hour → carrier\ntime_hour → sched_dep_time\nsched_dep_time, dep_time → dep_delay\nsched_arr_time, arr_time → arr_delay\norigin, dest, dep_time, arr_time → airtime\ntime_hour → year, month, day, hour, minute\nyear, month, day, hour, minute → time_hour\norigin, dest → distance\n(tailnum, origin, time_hour) est une clé\n(flight, dest, origin, year, month, day) est une clé\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\n\n\n\n\nExercice : Requêtes (schéma nycflights)\n\n\n\n\n\n\n\n\n\n\n\n\nRequête 1\n\n\n\n\n\nPour chaque couple origine/destination, lister les caractéristiques de l’avion le plus rapide sur la liaison.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R As (\n  SELECT f.origin, f.dest, f.tailnum, RANK() OVER w AS rnk\n  FROM flights AS f\n  WHERE f.airtime IS NOT NULL\n  WINDOW w AS (PARTITION BY f.origin, f.dest ORDER by f.airtime DESC)\n) \n\nSELECT R.origin, R.dest, p.* \nFROM (SELECT * FROM R WHERE R.rnk=1) AS S \n  JOIN planes as p \n  ON (R.tailnum=p.tailnum) ;\nWITH R As (\n  SELECT f.origin, f.dest, min(f.airtime) as min_time\n  FROM flights AS f\n  WHERE f.airtime IS NOT NULL\n  GROUP BY f.origin, f.dest \n), S AS (\n  SELECT f.origin, f.dest, f.tailnum\n  FROM flights AS f NATURAL JOIN R \n  WHERE f.airtime = R.min_time\n)\n\nSELECT S.origin, S.dest, p.* \nFROM S  \n  JOIN planes as p \n  ON (S.tailnum=p.tailnum) ;\n\n\n\n\n\n\n\n\nRequête 2\n\n\n\n\n\n\nPour chaque aéroport d’origine, déterminer pour chaque heure de la jourńee, les températures maximales et minimales\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH o AS (\n  SELECT DISTINCT f.origin\n  FROM flights as f \n)\nSELECT w.origin, w.hour, MAX(w.temp), MIN(w.temp)\nFROM o NATURAL JOIN weather w \nGROUP BY w.hour ;\n\n\n\n\n\n\n\n\nRequête 3\n\n\n\n\nPour chaque aéroport d’origine, pour chaque température enregistrée en début d’heure, arrondie à l’entier le plus proche, indiquer la proportion de vols avec un retard supérieur à 30 mn au décollage.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS (\n  SELECT f.origin, f.year. f.month, f.day, f.hour, f.flight, f.dep_delay, ROUND(w.temp, 0) as t\n  FROM flights f JOIN weater w ON\n    (f.origin=w.origin AND \n     f.year=w.year AND \n     f.month=w.month AND\n     f.day=w.day AND \n     f.hour=w.hour)\n)\n\nSELECT f.origin, f.t, SUM(f.dep_delay &gt; 30)/COUNT(*) AS p\nFROM R AS f \nGROUP BY f.origin, f.t ;\n\n\n\n\n\n\n\n\nRequête 4\n\n\n\n\n\nPour chaque aéroport de destination, lister les modèles d’avion qui ont atterri au moins une fois dans cet aéroport.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT DISTINCT(f.dest, p.models)\nFROM flights f JOIN planes p ON (f.tailnum=p.tailnum) ;\n\n\n\n\n\n\n\n\nRequête 5\n\n\n\n\n\nPour chaque modèle d’avion, lister pour chaque semaine, le nombre de vols efectivement réalisés.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT p.model, DATE_PART('week', f.time_hour) AS semaine, COUNT(*) AS n\nFROM flights f JOIN planes p ON (f.tailnum=p.tailnum)\nWHERE f.dep_time IS NOT NULL \nGROUP BY p.model, DATE_PART('week', f.time_hour) AS semaine ; \n\n\n\n\n\n\n\n\nRequête 6\n\n\n\n\n\nQuelles sont les destinations qui ne sont pas desservies le jeudi ?\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS (\n  SELECT DISTINCT f.dest\n  FROM flights f\n  WHERE DATE_PART('week', f.time_hour) = 'Thursday'\n), S AS (\n  SELECT DISTINCT f.dest\n  FROM flights f\n)\n\nSELECT * FROM S\n\nEXCEPT\n\nSELECT * FROM R; \n\n\n\n\n\n\n\n\nRequête 7\n\n\n\n\nQuelles sont les villes desservies par une seule compagnie le dimanche ?\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT f.dest\nFROM flights f\nWHERE DATE_PART('week', f.time_hour) = 'Sunday'\nGROUP BY f.dest\nHAVING COUNT(DISTINCT f.carrier) = 1 ;\n L’utilisation d’une clause WITH (Common Table Expression) plutôt que d’une requête imbriquée rend le code plus lisible.\n Dans la réponse, nous donnons plus que ce qui était demandé. On aurait pu se contenter de ;\n...\n\n\n\n\n\n\n\n\n\nRequête 8\n\n\n\n\n\nQuelles sont les compagnies pour lesquelles le retard médian au décollage est supérieur à 15 minutes ?\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT f.carrier\nFROM flights f\nWHERE f.dep_delay IS NOT NULL\nGROUP BY f.carrier\nHAVING MEDIAN(f.dep_delay) &gt; 15 ;\n\n\n\n\n\n\n\n\nRequête 9\n\n\n\n\n\nQuelles sont les destinations qui sont desservies quotidiennement par une compagnie ?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\n\n\n\n\nRequête 10\n\n\n\n\n\nQuelles sont les compagnies qui exploitent des avions de tous les constructeurs ?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\n\n\n\n\nQuelques conseils\n\n\n\n\nPréférez les clauses WITH et les jointures aux requêtes imbriquées sauf si la requête imbriquée est très simple. C’est une question de lisibilité et donc souvent de correction.\nNe mélangez pas les fonctions fenêtres et les clauses GROUP BY ...\n\nSELECT ..., FOO() OVER w\nFROM R\nWINDOW w AS (PARTITION BY ... ORDER BY ...)\nGROUP BY ... ;  \nest tout simplement incorrect.\n\nLorsque vous effectuez un partitionnement par GROUP BY ..., la clause SELECT ... est sévèrement contrainte, vous n’y trouverez que\n\nles colonnes qui ont servi dans la clause GROUP BY ..., normalement elles devraient toutes y figurer\ndes fonctions d’aggrégation, comme COUNT(...), SUM(...), VAR(...)"
  },
  {
    "objectID": "exams/cc3-2022-10-21.html#popularité",
    "href": "exams/cc3-2022-10-21.html#popularité",
    "title": "MA15Y030 - Automne 2024",
    "section": "Popularité",
    "text": "Popularité\n\n\n\n\n\n\nQuestion\n\n\n\nÉcrire une fonction SQL nommée top_k_names_by_year qui prend en argument une année yyyy et un entier n et renvoie une table (name TEXT, sex integer, rank integer) qui contient, selon la table babynames.bebes, les k prénoms les plus populaires (attribués) de l’année yyyy pour chaque sexe.\n\n\n\n\n\n\n\n\nRéponse attendue pour SELECT * FROM top_k_names_by_year(1950, 5); :\n+----+---------+----+\n|F   |MARIE    |   1|\n|F   |MARTINE  |   2|\n|F   |FRANÇOISE|   3|\n|F   |MONIQUE  |   4|\n|F   |NICOLE   |   5|\n|H   |JEAN     |   1|\n|H   |MICHEL   |   2|\n|H   |ALAIN    |   3|\n|H   |GÉRARD   |   4|\n|H   |BERNARD  |   5|\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\nPremière question posée au chatbot :\nFor every year and sex, find the 5 most popular names.\nRéponse :\nTo find the 5 most popular names for each year and sex \nin the babynames.bebes table, you can use `ROW_NUMBER()`. \nHere's a query that retrieves the top 5 names \nfor each combination of year and sex:\nWITH RankedNames AS (\n    SELECT\n        name, year, sex, count,\n        ROW_NUMBER() OVER (PARTITION BY year, sex ORDER BY count DESC) AS rank\n    FROM\n        babynames.bebes\n)\n\nSELECT\n    name, year, sex, count\nFROM\n    RankedNames\nWHERE\n    rank &lt;= 5\nORDER BY\n    year, sex, rank;\nExplanation:\n\n- The `ROW_NUMBER()` function ranks names \nwithin each `year` and `sex` partition,   \nordered by the `count` of babies in descending order.\n- The `PARTITION BY year, sex` groups the data by each year and sex.\n- The `ORDER BY count DESC` ensures that the most popular names \n(with the highest counts) are ranked first.\n- In the `WHERE` clause, we filter for the top 5 names (`rank &lt;= 5`) \nfor each year and sex.\n\nThis query will return the most popular 5 names \nfor both males and females for each year in the dataset.\n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\nPour définir la fonction, on peut demander de l’aide au chatbot:\nDesign a sql function that takes as input a year y and an integer k, \nand returns a table wih columns name, sex and rank \ncontaining the k most popular names in year y for each sex\nLa réponse est\nCREATE OR REPLACE FUNCTION top_k_names_by_year(y INT, k INT)\nRETURNS TABLE(name VARCHAR(500), sex INT, rank INT) AS $$\nBEGIN\n    RETURN QUERY\n    WITH RankedNames AS (\n        SELECT\n            name, sex, count,\n            ROW_NUMBER() OVER (PARTITION BY sex ORDER BY count DESC) AS rank\n        FROM\n            babynames.bebes\n        WHERE\n            year = y\n    )\n    SELECT\n        name, sex, rank\n    FROM\n        RankedNames\n    WHERE\n        rank &lt;= k\n    ORDER BY\n        sex, rank;\nEND;\n$$ LANGUAGE plpgsql;\n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\nEn insistant pour obtenir une fonction SQL on obtient:\nSure! If you'd prefer a **pure SQL function** (without using PL/pgSQL), \nhere's how you can implement it. In PostgreSQL, you can create \na function using SQL that performs the required query:\nCREATE OR REPLACE FUNCTION top_k_names_by_year(y INT, k INT)\nRETURNS TABLE(name VARCHAR(500), sex INT, rank INT) AS $$\n    WITH RankedNames AS (\n        SELECT\n            name, sex, count,\n            ROW_NUMBER() OVER (PARTITION BY sex ORDER BY count DESC) AS rank\n        FROM\n            babynames.bebes\n        WHERE\n            year = y\n    )\n    SELECT\n        name, sex, rank\n    FROM\n        RankedNames\n    WHERE\n        rank &lt;= k\n    ORDER BY\n        sex, rank;\n$$ LANGUAGE sql;\n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\n\nExplanation:\n- **Function Definition:**\n  - The function `top_k_names_by_year` accepts  \n  two parameters: `y` (year) and `k` (number of top names).\n  - It returns a table with three columns:  \n  `name` (name of the baby),  \n  `sex` (gender: 1 for male, 2 for female), and  \n  `rank` (the rank of the name by popularity).\n\n- **WITH Clause:**\n  - The `WITH RankedNames AS` clause ranks names \n  by the count of babies for each sex \n  in the specified year (`y`) using the `ROW_NUMBER()` window function. \n  It partitions by `sex` and orders by `count DESC` to assign ranks \n  starting from the most popular.\n\n- **WHERE Clause:**\n  - The main query filters for names with a rank less \n  than or equal to `k` to get only the top `k` names for each sex.\n\n- **Language:**\n  - The function is written in **pure SQL** (as specified by `LANGUAGE sql`).\n\nThis SQL function will return the top `k` names for each sex in the specified year (`y`)."
  },
  {
    "objectID": "exams/cc3-2022-10-21.html#nombre-de-naissancessex-ratio",
    "href": "exams/cc3-2022-10-21.html#nombre-de-naissancessex-ratio",
    "title": "MA15Y030 - Automne 2024",
    "section": "Nombre de naissances/sex ratio",
    "text": "Nombre de naissances/sex ratio\nDonnées dans le schéma babynames.\n\n\n\n\n\n\nQuestion\n\n\n\nÉcrire une fonction SQL nommée sex_ratio qui prend en argument une année yyyy et renvoie le rapport entre le nombre total de naissances féminines et le nombre total de naissances masculines cette année là selon la table babynames.bebes.\n\n\n\n\n\n\n\n\nRéponse attendue pour SELECT * FRON sex_ratio(1922);\n+-----------+\n| sex_ratio |\n+-----------+\n|   1.05    |\nNB: précision demandée : 0.1\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS (\n   SELECT year, sex, SUM(\"count\") AS n \n   FROM bebes\n   GROUP BY year, sex\n)\n \nSELECT r1.\"year\", \n       (r1.n::float/r2.n::float)::decimal(3,2) AS sex_ratio\nFROM R r1 JOIN R r2 ON (\n     r1.\"year\"=r2.\"year\" AND\n     r1.sex &lt; r2.sex\n) ;\nPour calculer une ligne du résultat final, il faut combiner deux lignes concernant la même année mais deux sexes différents de la table intermédiaire R. La jointure réalise en passant une opération de pivot.\n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\ncreate or replace function sex_ratio(p_y INT)\n  returns DECIMAL(3,2) as \n$$\nwith R as (\n  select\n    b.sex,\n    SUM(b.\"count\") as n\n  from\n    babynames.bebes as b\n  where\n    b.\"year\" = p_y\n  group by\n    b.sex\n)\n\nselect\n  (r1.n::float / r2.n::float)::decimal(3,1) as sex_ratio\nfrom\n  R r1\njoin R r2 on\n  (r1.sex &lt; r2.sex) ;\n$$ language sql;\n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\nQuestion posée au chatbot :\nCan you design a pure SQL function that takes as input a year y \nand returns the sex ratio for that year ?\nRéponse:\n\nYes, I can design a pure SQL function to calculate the sex ratio \nfor a given year in the babynames.bebes table. \nThe sex ratio is typically defined as the number of males (sex = 1) \nper 100 females (sex = 2).\n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\nCREATE OR REPLACE FUNCTION get_sex_ratio(y INT)\nRETURNS DECIMAL(3,2) AS $$\n    SELECT \n        CASE \n            WHEN SUM(CASE WHEN sex = 2 THEN count ELSE 0 END) = 0 THEN NULL\n            ELSE \n                ((SUM(CASE WHEN sex = 1 THEN count ELSE 0 END))::float /\n                SUM(CASE WHEN sex = 2 THEN count ELSE 0 END)::float)::decimal(3,2)\n        END AS sex_ratio\n    FROM \n        babynames.bebes\n    WHERE \n        year = y;\n$$ LANGUAGE sql;\nCette solution évite un GROUP BY et une JOINTURE. L’utilisation de CASE WHEN ... THEN ... ELSE ... permet de calculer les deux agrégations et de les combiner en une seule passe sur la table filtrée."
  },
  {
    "objectID": "exams/cc3-2022-10-21.html#popularité-relative-et-rang-de-popularité",
    "href": "exams/cc3-2022-10-21.html#popularité-relative-et-rang-de-popularité",
    "title": "MA15Y030 - Automne 2024",
    "section": "Popularité relative et rang de popularité",
    "text": "Popularité relative et rang de popularité\nDonnées dans le schéma babynames\n\n\n\n\n\n\nQuestion\n\n\n\nÉcrire une vue nommée popularity de schema\n(sex text, name text, year integer, rank integer, popularity numeric)\nqui donne pour chaque prénom, année, sexe, la popularité relative (nombre sur nombre total de naissance de ce sexe cette année là) et le rang par popularité décroissante.\n\n\n\n\n\n\n\n\nRéponse attendue pour\nSELECT *\nFROM popularity\nWHERE name='THÉO' AND\n      sex = 1 AND\n      \"year\" &gt;1999 AND\n      \"year\" &lt; 2005;\n+----+------+-----+----+----------+\n|sex |name  | year|rank|popularity|\n+----+------+-----+----+----------+\n|1   |THÉO  | 2000|   6|     0.019|\n|1   |THÉO  | 2001|   6|     0.022|\n|1   |THÉO  | 2002|   5|     0.022|\n|1   |THÉO  | 2003|   5|     0.020|\n|1   |THÉO  | 2004|   7|     0.016|\nNB: précision demandée pour la popularité 0.01\n\n\n\n\n\n\n\n\n\nsolution\n\n\n\nQuestion posée au chatbot :\nCan you define a view with schema \n(sex text, name text, year integer, rank integer, popularity numeric) \nwhere popularity is the proportion of babies with given sex \nwho were named by name during year and rank is the rank of the name \nwhen ordering by decreasing popularity. \nRéponse du chatbot :\nCREATE OR REPLACE VIEW name_popularity_view AS\nWITH TotalBySexYear AS (\n    -- Calculate the total number of babies by sex and year\n    SELECT\n        sex,\n        year,\n        SUM(count) AS total_babies\n    FROM\n        babynames.bebes\n    GROUP BY\n        sex, year\n),\nRankedNames AS (\n    -- Calculate the popularity and rank the names by decreasing popularity\n    SELECT\n        CASE \n            WHEN b.sex = 1 THEN 'Male'\n            WHEN b.sex = 2 THEN 'Female'\n        END AS sex,\n        b.name,\n        b.year,\n        (b.count::numeric / t.total_babies) AS popularity,\n        ROW_NUMBER() OVER (PARTITION BY b.sex, b.year \n                           ORDER BY b.count DESC) AS rank\n    FROM\n        babynames.bebes b\n    JOIN\n        TotalBySexYear t ON b.sex = t.sex AND b.year = t.year\n)\n-- Final selection for the view\nSELECT\n    sex,\n    name,\n    year,\n    rank,\n    popularity\nFROM\n    RankedNames;"
  },
  {
    "objectID": "exams/cc3-2022-10-21.html#les-riches-et-les-pauvres-dans-world",
    "href": "exams/cc3-2022-10-21.html#les-riches-et-les-pauvres-dans-world",
    "title": "MA15Y030 - Automne 2024",
    "section": "Les riches et les pauvres dans world",
    "text": "Les riches et les pauvres dans world\nDonnées dans le schéma world\n\n\n\n\n\n\nQuestion\n\n\n\nÉcrire une vue nommée ricchi_e_poveri de schéma:\n(region TEXT,\n min_gnp_cap NUMERIC, poorest_country_name TEXT,\n max_gnp_per_cap NUMERIC, richest_country_name TEXT)\noù chaque ligne indique pour une région donnée, le minimum du PIB (gnp) par habitant, un des pays de la région où ce minimum est réalisé, le maximum du PIB par habitant et un des pays où ce maximum est réalisé.\n\n\n\n\n\n\n\n\nSELECT region, richest_country, poorest_country\nFROM ricchi_e_poveri\nWHERE region='Eastern Asia' ;\n+------------+---------------+---------------+\n|region      |richest_country|poorest_country|\n+------------+---------------+---------------+\n|Eastern Asia|Japan          |North Korea    |\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\nQuestion posée au chatbot:\nIn the world schema, can you build a view ricchi_e_poveri \nwith schema (region TEXT,\nmin_gnp_cap NUMERIC, poorest_country_name TEXT,\nmax_gnp_per_cap NUMERIC, richest_country_name TEXT) \nwhich,  for each region, contains the minimum gnp per capita, \nthe name of the country in the region \nwith the minimum gnp per capita (poorest country), \nthe maximum gnp per capita in the region, \nthe name of the country with maximum gnp per capita \nin the region (richest country). \n\nCountries with zero or no population should not be considered.  \n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\nCREATE OR REPLACE VIEW world.ricchi_e_poveri AS\nWITH GnpPerCapita AS (\n    -- Calculate GNP per capita for countries with valid population and GNP\n    SELECT\n        region,\n        name_country,\n        gnp / population_country AS gnp_per_capita\n    FROM\n        world.country\n    WHERE\n        population_country &gt; 0 -- Exclude countries with zero or no population\n        AND gnp IS NOT NULL -- Exclude countries with no GNP data\n)\nSELECT\n    region,\n    MIN(gnp_per_capita) AS min_gnp_cap, -- Minimum GNP per capita for the region\n    (SELECT name_country FROM GnpPerCapita g2 \n     WHERE g2.region = g1.region \n     ORDER BY gnp_per_capita ASC LIMIT 1) AS poorest_country_name, -- Country with minimum GNP per capita\n    MAX(gnp_per_capita) AS max_gnp_per_cap, -- Maximum GNP per capita for the region\n    (SELECT name_country FROM GnpPerCapita g2 \n    WHERE g2.region = g1.region \n    ORDER BY gnp_per_capita DESC LIMIT 1) AS richest_country_name -- Country with maximum GNP per capita\nFROM\n    GnpPerCapita g1\nGROUP BY\n    region;"
  },
  {
    "objectID": "exams/cc3-2022-10-21.html#fenêtre-glissante-sur-les-bébés",
    "href": "exams/cc3-2022-10-21.html#fenêtre-glissante-sur-les-bébés",
    "title": "MA15Y030 - Automne 2024",
    "section": "Fenêtre glissante sur les bébés",
    "text": "Fenêtre glissante sur les bébés\nDonnées dans le schéma babynames\n\n\n\n\n\n\nQuestion\n\n\n\nCréer une vue sliding_avg_count de schéma (name    TEXT, sex TEXT, year INTEGER, avg_count NUMERIC) qui, pour chaque prénom (name), sexe (sex) et année (year), donne le nombre moyen (average count, avg_count) d’attributions du prénom aux enfants du sexe en question durant l’intervalle formé par les deux années qui précèdent et les deux années qui suivent l’année courante (incluses).\n\n\navg_count est un exemple de moyenne mobile ou glissante.\n\n\n\n\n\n\nSELECT *\nFROM sliding_avg_count\nWHERE \"name\"  ='PATRICK' AND\n      \"year\" BETWEEN 1955 AND 1960 ;\n+-------+----+-----+---------+\n|name   |sex | year|avg_count|     \n+-------+----+-----+---------+\n|PATRICK|F   | 1959|     3.00|\n|PATRICK|H   | 1955| 20381.00|\n|PATRICK|H   | 1956| 20673.80|\n|PATRICK|H   | 1957| 20532.20|\n|PATRICK|H   | 1958| 20173.80|\n|PATRICK|H   | 1959| 19443.20|\n|PATRICK|H   | 1960| 18479.60|\n\n\n\nLa manière la plus simple de répondre à cette question 10 est d’utiliser une fenêtre glissante. Les fenêtres glissantes étendent les fenêtres définies par PARTITION BY ... ORDER BY ....\nLa syntaxe de l’invocation des fonctions fenêtres est décrite dans la documentation PostgreSQL.\nL’invocation d’une fonction opérant sur une fenêtre suit la forme :\nfunction_name ([expression [, expression ... ]])\n      [ FILTER ( WHERE filter_clause ) ]\n      OVER ( window_definition )\n\n-- OU\n\nfunction_name ( * )\n      [ FILTER ( WHERE filter_clause ) ]\n      OVER ( window_definition )\nNous n’avons pas eu besoin d’utiliser la clause FILTER (WHERE filter_clause)\nLa définition de la fenêtre window definition est de la forme\n[ PARTITION BY expression [, ...] ]\n[ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]\n[ frame_clause ]\nRappel : une expression entre [] est optionnelle.\nLa dernière clause optionnelle frame_clause permet de calculer des fenêtres glissantes et d’autres types de fenêtres. Elle peut se décliner en\n{ RANGE | ROWS | GROUPS } frame_start [ frame_exclusion ]\n{ RANGE | ROWS | GROUPS } BETWEEN frame_start AND frame_end [ frame_exclusion ]\noù frame_start (début du cadre/de la fenêtre) peut prendre les formes suivantes :\nUNBOUNDED PRECEDING  -- ou\noffset PRECEDING  -- ou\nCURRENT ROW   --ou\noffset FOLLOWING  -- ou\nUNBOUNDED FOLLOWING  -- ou\nframe_end se définit de la même manière.\nSi on veut calculer le nombre cumulé d’attributions d’un prénom depuis l’origine des temps on pourra procéder ainsi:\nWITH R AS (\nSELECT \"name\", sex, \"year\", SUM(\"count\")\n      OVER (PARTITION BY \"name\"  , sex\n            ORDER BY \"year\"\n            RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)\n      as cumule\nFROM babynames.bebes\n)\n\nSELECT * FROM R\nWHERE \"name\"   IN ('PATRICK', 'MICHEL') ;  -- pour limiter la taille du résultat\n\n\n\n\n\n\nSolution\n\n\n\nQuestion posée au chatbot\nIn schema babynames, design a view with schema \n(name    TEXT, sex TEXT, year INTEGER, avg_count NUMERIC)  \nwhere `avg_count` represents the moving average of `count` for the given `name` and `sex` where average should be computed from the 2 years preceding and following the current `year`, including the current `year`.\n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\nRéponse du chatbot :\nTo design the view with schema \n`(name TEXT, sex TEXT, year INTEGER, avg_count NUMERIC)`\nthat computes a moving average of `count` for the given `name` and `sex`, including the 2 years preceding and following the current `year` (5-year window), the SQL query would look like this:\n\nSteps:\nDefine the window: The average should be computed over the 2 years before, the current year, and 2 years after (a total of 5 years).\nPartition by name and sex: This ensures that the moving average is calculated independently for each combination of name and sex.\nApply a windowing function: Use AVG() with a window frame of 2 rows preceding and 2 rows following.\n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\nCREATE OR REPLACE VIEW name_avg_count AS\nSELECT\n    name,\n    sex,\n    year,\n    AVG(count) OVER (\n        PARTITION BY name, sex \n        ORDER BY year \n        ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING\n    ) AS avg_count\nFROM\n    babynames;"
  },
  {
    "objectID": "exams/cc3-2022-11-13.html",
    "href": "exams/cc3-2022-11-13.html",
    "title": "MA15Y030 - Automne 2024",
    "section": "",
    "text": "L3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2023-2024\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\nÉcrire une fonction SQL nommée cc_fonc_16 qui prend en argument une année p_year, un mois p_month un jour p_day et un aéroport de départ p_origin et renvoie une table de schéma\n(avg_temp float8, avg_visib float8,  avg_wind_speed float8, avg_month_temp float8)\nqui contient pour la journée définie par p_year, p_month et p_day, l’aéroport défini par p_origin, la température moyenne de la journée avg_temp, la visibilité moyenne de la journée avg_visib, la vitesse moyenne du vent avg_wind_speed de la journée, et la température moyenne du mois avg_month_temp.\nRéponse attendue pour :\nSELECT round(avg_temp::numeric, 2) AS avg_temp, \n       round(avg_visib::numeric, 2) AS avg_visib,\n       round(avg_wind_speed::numeric, 2) AS avg_wind_speed,\n       round(avg_month_temp::NUMERIC, 2) AS avg_month_temp\nFROM cc_fonc_16(2013, 2, 16, 'EWR');\n+--------+---------+--------------+--------------+\n|avg_temp|avg_visib|avg_wind_speed|avg_month_temp|\n+--------+---------+--------------+--------------+\n|   36.07|     9.71|         12.37|         34.26|\nCREATE OR REPLACE FUNCTION correction_cc3.cc_fonc_16(\n    p_year int4,  p_month int4, p_day int4, p_origin text)\n    RETURNS TABLE(avg_temp float8, avg_visib float8,  avg_wind_speed float8, avg_month_temp float8)\n    LANGUAGE sql\nAS $function$\nWITH v AS (\n    SELECT AVG(w.temp) AS avg_month_temp\n    FROM nycflights13.weather w \n    WHERE w.\"year\"=p_year AND w.\"month\"=p_month AND w.origin=p_origin\n),\nx AS (\n    SELECT AVG(w.temp) AS avg_temp,\n           AVG(w.visib) AS avg_visib,\n           AVG(w.wind_speed) AS avg_wind_speed\n    FROM nycflights13.weather w \n    WHERE w.\"year\"=p_year AND w.\"month\"=p_month AND w.\"day\"=p_day AND w.origin=p_origin\n) \nSELECT x.avg_temp, x.avg_visib, x.avg_wind_speed, v.avg_month_temp\nFROM x, v \n$function$ ;\n\nDonnées dans le schéma nycflights13.\nÉcrire une fonction SQL nommée cc_fonc_17 qui prend en argument un constructeur d’avion et qui renvoie une table de schéma\n(n_planes int8, n_carriers int8)\nchaque ligne donne pour chaque modèle vendu par le constructeur,\n\nle nombre d’avions de ce modèle qui ont circulé sur des vols domestiques partis de New York d’après la table flights\nle nombre de compagnies qui exploitent ce modèle (d’après la base nycflights13)\nle nombre de vols effectués par les exemplaires du modèle à partir de New York d’après la table flights\n\nRéponse attendue pour :\nSELECT * \nFROM cc_fonc_17('AIRBUS') \nWHERE model='A330-243' ;\n+--------+--------+----------+---------+\n|model   |n_planes|n_carriers|n_flights|\n+--------+--------+----------+---------+\n|A330-243|      14|         1|      342|\n\n\n\n\n\n\nsolution\n\n\n\nTODO\n\n\n\nDonnées dans le schéma nycflights13\nÉcrire une vue nommée cc_vue_18 de schéma\n(origin  text, time_hour timestamptz, flight int4, dep_delay float8, next_flight int4, next_dep_delay float8)\nPour chaque vol effectué f, la vue contient l’aéroport de départ (origin), la date et l’heure de départ programmée arrondie (time_hour), le numéro du vol flight, le retard au départ dep_delay, et aussi le numéro next_flight et le retard au départ du vol next_dep_delay, qui a décollé juste après le vol f du même aéroport de départ.\nRéponse attendue pour\nSELECT r.origin, r.time_hour::timestamp, r.flight, r.dep_time, r.dep_delay, r.next_flight, r.next_dep_delay\nFROM cc_vue_18 AS r \nWHERE  r.origin ='EWR' AND r.time_hour = to_timestamp('2013-01-01 06:00:00', 'YYYY-MM-DD HH:MI:SS') \nLIMIT 5 ;\n+------+-----------------------+------+--------+---------+-----------+--------------+\n|origin|time_hour              |flight|dep_time|dep_delay|next_flight|next_dep_delay|\n+------+-----------------------+------+--------+---------+-----------+--------------+\n|EWR   |2013-01-01 06:00:00.000|   507|     555|     -5.0|       1124|          -2.0|\n|EWR   |2013-01-01 06:00:00.000|  1124|     558|     -2.0|       1187|          -1.0|\n|EWR   |2013-01-01 06:00:00.000|  1187|     559|     -1.0|        343|           1.0|\n|EWR   |2013-01-01 06:00:00.000|   343|     601|      1.0|       1895|          -4.0|\n|EWR   |2013-01-01 06:00:00.000|  1895|     606|     -4.0|       1077|           0.0|\n\nNB: précision demandée pour la popularité 0.01\n\n\n\n\n\n\nsolution\n\n\n\nTODO\n\n\n\nDonnées dans le schéma nycflights13\nÉcrire une vue nommée cc_vue_19 de schéma:\n`(origin text, dest text, year int4, month int4, carrier text)\nPour chaque liaison (origin, dest), chaque mois (year, month), carrier contient le code de la compagnie du mois, celles dont le retard moyen à l’arrivée sur cette liaison, pendant ce mois est minimal.\nSELECT * \nFROM cc_vue_19 t\nWHERE t.origin='JFK' AND t.dest='ATL' \nORDER BY t.\"year\", t\"month\" \nLIMIT 5\n;\n+--------+------+------+-------+---------+\n| origin | dest | year | month | carrier |\n|--------+------+------+-------+---------|\n| JFK    | ATL  | 2013 | 1     | 9E      |\n| JFK    | ATL  | 2013 | 2     | DL      |\n| JFK    | ATL  | 2013 | 3     | DL      |\n| JFK    | ATL  | 2013 | 4     | DL      |\n| JFK    | ATL  | 2013 | 5     | DL      |\n\n\n\n\n\n\nsolution\n\n\n\nTODO\n\n\n\nDonnées dans le schéma babynames\nCréer une vue cc_vue_20 de schéma\n(origin TEXT, dest TEXT, flight int4, time_hour  TIMESTAMP, arr_delay , carrier TEXT, model TEXT, speedy_model TEXT, speedy_carrier TEXT)\nqui liste pour chaque vol de la table flights, l’aéroport de départ, l’aéroport de destination, la date et l’heure de départ prévues trinquée à l’heure (time_hour), le modèle (model) de l’avion, sa compagnie (carrier), son retard à l’arrivée, ainsi que pour un des vols les plus rapides sur cette liaison pendant le mois défini par time_hour, le modèle speedy_model et la compagnie speedy_carrier.\n\n\n\n\n\n\nsolution\n\n\n\nTODO"
  },
  {
    "objectID": "exams/cc3-2022-11-03.html",
    "href": "exams/cc3-2022-11-03.html",
    "title": "MA15Y030 - Automne 2024",
    "section": "",
    "text": "L3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2023-2024\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\nCréer les fonctions SQL et vues correspondant aux questions suivantes.\nLes questions portent sur le schéma nycflights13 issu de https://github.com/tidyverse/nycflights13.\nVoir Documentation package R nycflights13\nDiagramme synthétique en pattes de corbeaux :\n\n\n\nDiagramme en pattes de corbeaux\n\n\nDiagramme sur bd_2023 :\n\n\n\nDiagramme sur bd_2023\n\n\n\nExercice\n\nNombre vols retardés d’un délai minimal à l’arrivée à un aéroport donné\nDonnés sur schéma nycflights13\n\nÉcrire une fonction SQL nommée cc_fonc_11 qui prend en argument un code d’aéroport p_faa de type text, une année p_year (int4), un mois p_month (int4), un délai plancher p_delay (int4) et renvoie le nombre de vols retardés de strictement plus de p_delay minutes à l’arrivée à l’aéroport faa, pendant le mois month de l’année year.\nLa fonction retourne un entier (bigint)\n\n\n\n\n\n\nRéponse attendue pour\nSELECT * \nFROM cc_fonc_11('LAX', 2013, 3, 40) ;` \n73\n\n\n\n\n\n\n\n\n\nsolution\n\n\n\nCREATE OR REPLACE FUNCTION correction_cc3.cc_fonc_11(p_faa TEXT, \n            p_year int4, \n            p_month int4, \n            p_delay int4)\n    RETURNS bigint\n    LANGUAGE sql\nAS $function$\nSELECT COUNT(*) as n\nFROM nycflights13.flights f\nWHERE f.arr_delay &gt; p_delay AND \n      f.dest = p_faa AND \n      f.\"year\" = p_year AND \n      f.\"month\" = p_month;\n$function$\n\n\n\n\n\nExercice\nDonnés sur schéma nycflights.\nÉcrire une fonction SQL nommée cc_fonc_12 qui prend en argument une année p_year, un mois p_month, une compagnie aérienne p_carrier (text) et renvoie le nombre de couples aéroport d’origine origin/aéroports de destination dest distincts desservis par cette compagnie p_carrier pendant le mois p_month de l’année p_year.\nLa fonction retourne un entier (bigint)\nRéponse attendue pour SELECT * FROM cc_fonc_12('UA', 2013, 2);\n39\n\n\n\n\n\n\nsolution\n\n\n\nCREATE OR REPLACE FUNCTION correction_cc3.cc_fonc_12(p_carrier TEXT, p_year int4, p_month int4)\n    RETURNS bigint\n    LANGUAGE sql\nAS $function$\nSELECT COUNT(DISTINCT (origin, dest)) AS n\nFROM nycflights13.flights f\nWHERE f.carrier =p_carrier AND \n      f.year=p_year AND \n      f.month=p_month ;\n$function$\n\n\n\n\n\nExercice\nDonnées dans le schéma nycflights13\nÉcrire une vue nommée cc_vue_13 de schema (origin, dest, year, month, carrier, model, maxspeed) qui indique pour chaque couple (origin, dest), pour chaque couple (year,month), la vitesse maximale maxspeed (numeric) d’un vol reliant origin à dest pendant le mois month de l’année year, le modèle de l’avion qui a réalisé le vol le plus rapide, et la compagnie aérienne qui a assuré ce vol.\nmaxspeed sera exprimée en km/h. distance est exprimée en milles nautiques (1 mille = 1.852 km).\nÉcrire une vue nommée cc_vue_13 de schéma:\n(year INT4, month INT4, origin TEXT, dest TEXT, name TEXT, model TEXT, maxspeed numeric)\nRéponse attendue pour\nSELECT *\nFROM cc_vue_13\nWHERE dest='LAX' AND month=4 ;\n+----+-----+------+----+---------------------+--------+-----------------+\n|year|month|origin|dest|name                 |model   |maxspeed         |\n+----+-----+------+----+---------------------+--------+-----------------+\n|2013|    4|EWR   |LAX |United Air Lines Inc.|A320-232|921.6133333333335|\n|2013|    4|JFK   |LAX |United Air Lines Inc.|757-222 |951.9362068965518|\nPrécision pour maxspeed : (1 km/h)\n\n\n\n\n\n\nsolution\n\n\n\nCREATE MATERIALIZED VIEW correction_cc3.cc_vue_13 AS (\nWITH r AS (\n    SELECT f.year, f.month, f.origin, f.dest, max(1.852 *60*f.distance/f.air_time) as maxspeed\n    FROM nycflights13.flights f \n    where f.distance &gt; 0 and f.air_time &gt; 0 \n    GROUP BY f.year, f.month, f.origin, f.dest\n), s AS (\n    SELECT r.year, r.month, r.origin, r.dest, r.maxspeed, ff.tailnum, ff.carrier\n    FROM nycflights13.flights ff  JOIN r ON (r.\"month\"=ff.\"month\" AND r.\"year\"=ff.\"year\" AND r.origin=ff.origin AND r.dest=ff.dest)\n    WHERE ff.distance &gt; 0 and ff.air_time &gt; 0  AND (1.852 * 60* ff.distance/ff.air_time) &gt;=  r.maxspeed\n)\nSELECT s.year, s.month, s.origin, s.dest, a.name, p.model ,s.maxspeed \nFROM s  \n     JOIN nycflights13.planes p ON (s.tailnum=p.tailnum) \n     JOIN nycflights13.airlines a ON (s.carrier=a.carrier))\nWITH DATA ;\n\n\n\n\n\nExercice\nDonnés sur schéma nycflights13.\nCréer dans votre schéma, une vue nommée cc_vue_14 de schéma:\n(origin , year int4, month int4, day int4, hour int4, avg_depdelay bigint, n_cancelled bigint, n_scheduled_flights bigint)\nqui donne pour chaque aéroport d’origine origin, chaque heure yyyy:mm:dd hh:00:00, le retard moyen au départ avg_depdelay des vols qui ont (effectivement) décollé de origin pendant l’heure qui a précédé yyyy:mm:dd hh:00:00, et n_canceled le nombre de vols annulés sur cet aéroport pendant cette heure, et enfin n_scheduled_flights le nombre de vols prévus pendant cette heure.\nRéponse attendue pour :\nSELECT date_time,\n       round(avg_delay::numeric, 1) as avg_delay,\n       n_cancelled,\n       n_scheduled_flights\nFROM cc_vue_14\nWHERE origin='JFK' AND\n      n_cancelled &gt; .25 * n_scheduled_flights\nORDER BY date_time\nLIMIT 10 ;\n+-----------------------+---------+-----------+-------------------+\n|date_time              |avg_delay|n_cancelled|n_scheduled_flights|\n+-----------------------+---------+-----------+-------------------+\n|2013-01-30 20:00:00.000|     30.7|          7|                 23|\n|2013-02-08 12:00:00.000|      5.8|          5|                 11|\n|2013-02-08 15:00:00.000|     25.9|          7|                 17|\n|2013-02-08 16:00:00.000|     10.6|         17|                 24|\n|2013-02-08 17:00:00.000|      6.7|         19|                 25|\n|2013-02-08 18:00:00.000|         |         24|                 24|\n|2013-02-08 19:00:00.000|         |         24|                 24|\n|2013-02-08 20:00:00.000|         |         23|                 23|\n|2013-02-08 21:00:00.000|         |         17|                 17|\n|2013-02-08 22:00:00.000|         |          6|                  6|\n\n\n\n\n\n\nsolution\n\n\n\nCREATE MATERIALIZED VIEW correction_cc3.cc_vue_14 AS (\nSELECT f.origin, \n    f.\"year\", \n    f.\"month\", \n    f.\"day\", \n    f.\"hour\"+ 1 AS \"hour\", \n    AVG(dep_delay) AS avg_delay,  \n    SUM(CASE WHEN f.arr_time IS NULL THEN 1 ELSE 0 END) AS n_cancelled, \n    COUNT(*) as n_scheduled_flights\nFROM nycflights13.flights f \nGROUP  BY f.origin, f.year, f.month, f.\"day\", f.\"hour\")\nWITH DATA ;\n\n\n\n\n\nExercice\nDonnés sur schéma nycflights13.\nCréer une vue cc_vue_15 de schéma:\n(tailnum text, year int4, woy int4, cumdist numeric, model text)\nqui recense pour chaque semaine (commencant le dimanche) les avions (identifiés par tailnum) qui ont parcouru la plus grande distance durant cette semaine, la distance parcourue pendant la semaine (en milles nautiques), on indiquera aussi le modèle (model) de l’avion\nRéponse attendue pour :\nSELECT  *\nFROM cc_vue_15\nWHERE  woy&gt;=26 AND woy &lt;= 30\n+-------+----+---+-------+-------+\n|tailnum|year|woy|cumdist|model  |\n+-------+----+---+-------+-------+\n|N320AA |2013| 30|22497.0|767-223|\n|N324AA |2013| 28|22497.0|767-223|\n|N327AA |2013| 26|23697.0|767-223|\n|N327AA |2013| 27|22386.0|767-223|\n|N332AA |2013| 29|23475.0|767-223|\n\nIndications\nManipulation du temps\n\nDoc PostgreSQL : types\nDoc PostgreSQL : fonctions\n\nSELECT extract(week from now()), now(), now() + '1 week'::interval ;\n+---------+-----------------------------+-----------------------------+\n|date_part|now                          |?column?                     |\n+---------+-----------------------------+-----------------------------+\n|     46.0|2022-11-20 11:46:59.322 +0100|2022-11-27 11:46:59.322 +0100|\nVoir aussi datetime pour Python ou lubridate pour R.\n\n\n\n\n\n\nsolution\n\n\n\nCREATE MATERIALIZED VIEW correction_cc3.cc_vue_15 AS (\nWITH r AS (\n    SELECT f.tailnum, \n    f.year, \n    extract(week from f.time_hour)::int4 as woy, \n    sum(distance) as cumdist\n    FROM nycflights13.flights f\n    WHERE tailnum is not null\n    GROUP BY  f.year, extract(week from f.time_hour), f.tailnum\n),\ns AS (\n    SELECT DISTINCT r.tailnum, \n    r.year, \n    r.woy, \n    r.cumdist, \n    rank() OVER v AS rnk\n    FROM r \n    WINDOW v AS (PARTITION BY (r.year, r.woy) \n               ORDER BY cumdist DESC  NULLS LAST)),\nt AS (\n    SELECT s.tailnum, s.year, s.woy, s.cumdist\n    FROM s \n    WHERE rnk = 1)\n\nSELECT t.*, p.model\nFROM t JOIN nycflights13.planes p ON (t.tailnum=p.tailnum)\n)\n\nWITH DATA  ;"
  },
  {
    "objectID": "exams/cc2-2022-11-25.html",
    "href": "exams/cc2-2022-11-25.html",
    "title": "MA15Y030 - Automne 2024",
    "section": "",
    "text": "L3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2022-2023\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\nSur le serveur bd_2023 hébergé par etu-pgsql, dans votre schéma personnel, créer les vues correspondant aux cinq questions suivantes.\n\nQuestion 1\nSchéma nycflights13\nCréer dans votre schéma personnel une vue nommée cc2_vue_1 de schéma (n integer) qui répond à la question : combien de vols sont arrivés avec un retard d’au moins une heure en partant à l’heure de l’aéroport JFK ?\n\n\n\n\n\n\nsolution\n\n\n\nCREATE OR REPLACE MATERIALZED VIEW foobar42.v_1 AS (\nWITH A as (\n    SELECT * FROM nycflights13.flights AS f\n    WHERE f.origin = 'JFK'\n    AND f.arr_delay &gt;= 60\n    AND f.dep_delay &lt;= 0\n) SELECT COUNT(*)::integer AS n\nFROM A \n);\n\n\n\nQuestion 2\nSchéma nycflights13\nCréer dans votre schéma personnel une vue nommée cc2_vue_2 de schéma (n integer) qui répond à la question : Combien de modèles différents ont été faits par la compagnie BOEING ?\n\n\n\n\n\n\nsolution\n\n\n\nCREATE OR REPLACE VIEW cc2_vue_2 AS (\nSELECT COUNT(distinct model)::integer  AS N\nFROM nycflights13.planes\nGROUP BY manufacturer\nHAVING manufacturer = 'BOEING'\n);\n\n\n\nQuestion 3\nSchéma babynames\nCréer dans votre schéma personnel une vue nommée cc2_vue_3 de schéma (prenom TEXT) qui répond à la question :\nQuels sont les prénoms donnés durant toutes les décennies pour lesquelles la base de données comporte des informations, sans doublon, par ordre alphabétique.\n844 lignes attendues (dont _PRENOMS_RARES)\n\n\n\n\n\n\nsolution\n\n\n\nWITH decennie AS (\n    SELECT COUNT(DISTINCT annee/10) AS nb F\n    ROM bebes)\nSELECT DISTINCT prenom \nFROM bebes \nGROUP BY prenom \nHAVING COUNT(DISTINCT annee/10)=(SELECT nb FROM decennie) \nORDER BY prenom ;\n\n\n\nQuestion 4\nSchéma ou babynames\nCréer dans votre schéma personnel une vue nommée cc2_vue_4 de schéma (prenom, n_feminin, n_masculin) qui contient les prénoms mixtes, c’est-à-dire les prénoms attribués plus de 5000 fois à des filles et à des garcons (MARIE a été attribué 26897 fois à des petits garcons). n_feminin représente le nombre total d’attributions du prénom à des filles et n_masculin représente le nombre total d’attributions du prénom à des garcons.\nVotre vue contiendra (entre autres) la ligne :\n+---------+---------+----------+\n|prenom   |n_feminin|n_masculin|\n+---------+---------+----------+\n| ...     | ...     | ...      |\n|MARIE    |  2232238|     26897|\n| ...     | ...     | ...      |\n| ...     | ...     | ...      |\n\nQuestion 5\nSchéma nycflights13\nCréer dans votre schéma personnel une vue nommée cc2_vue_5 de schéma (name text) qui répond à la question : Quelles sont les noms des destinations accessibles par un vol direct depuis toutes les origines ?\n\n\n\n\n\n\nsolution\n\n\n\nWITH r AS (\n    SELECT f.dest\n    FROM nycflights13.flights f   \n    GROUP BY f.dest \n    HAVING COUNT(DISTINCT f.origin) &gt;= ALL \n      (SELECT COUNT(DISTINCT f2.origin) \n       FROM nycflights13.flights f2 )\n)\nSELECT a.\"name\"::text \nFROM nycflights13.airports a JOIN r ON (a.faa = r.dest) ;\n\n\n42 lignes attendues"
  },
  {
    "objectID": "exams/ct-2024-01-08.html",
    "href": "exams/ct-2024-01-08.html",
    "title": "MA15Y030 - Automne 2024",
    "section": "",
    "text": "L3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2023-2024\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\n\n\n\n\n\n\nLes trois exercices (modélisation, normalisation, requêtes) portent sur le schéma nycflights légèrement nettoyé.\n\n\n\n\n\n\nNYCFlights en relationel à pattes de corbeau\n\n\n\n\n\nDéfinition du schéma en SQL\n\n\n\n\n\n\nCREATE TABLE airlines (\n    carrier text NOT NULL,\n    \"name\" text NULL,\n    CONSTRAINT airlines_pk \n        PRIMARY KEY (carrier),\n    CONSTRAINT airlines_un \n        UNIQUE (name)\n);\nCREATE TABLE airports (\n    faa text NOT NULL,\n    \"name\" text NULL,\n    lat float8 NULL,\n    lon float8 NULL,\n    alt float8 NULL,\n    tz float8 NULL,\n    dst text NULL,\n    tzone text NULL,\n    CONSTRAINT airports_pk \n        PRIMARY KEY (faa),\n    CONSTRAINT airports_un \n        UNIQUE (name),\n    CONSTRAINT airports_un_ll \n        UNIQUE (lat, lon)\n);\n\n\nCREATE TABLE weather (\n    origin text NOT NULL,\n    \"year\" int4 NULL,\n    \"month\" int4 NULL,\n    \"day\" int4 NULL,\n    \"hour\" int4 NULL,\n    \"temp\" float8 NULL,\n    dewp float8 NULL,\n    humid float8 NULL,\n    wind_dir float8 NULL,\n    wind_speed float8 NULL,\n    wind_gust float8 NULL,\n    precip float8 NULL,\n    pressure float8 NULL,\n    visib float8 NULL,\n    time_hour timestamptz NOT NULL,\n    CONSTRAINT weather_pk \n        PRIMARY KEY (origin, time_hour)\n);\nALTER TABLE weather ADD \n    CONSTRAINT weather_fk \n    FOREIGN KEY (origin) \n    REFERENCES airports(faa) \n    ON DELETE CASCADE \n    ON UPDATE CASCADE;\n\n\n\nCREATE TABLE planes (\n    tailnum text NOT NULL,\n    \"year\" int4 NULL,\n    \"type\" text NULL,\n    manufacturer text NULL,\n    model text NULL,\n    engines int4 NULL,\n    seats int4 NULL,\n    speed int4 NULL,\n    engine text NULL,\n    CONSTRAINT planes_pk   PRIMARY KEY (tailnum)\n);\n\n\n\n\n\n\nCREATE TABLE flights (\n    \"year\" int4 NULL,\n    \"month\" int4 NULL,\n    \"day\" int4 NULL,\n    dep_time int4 NULL,\n    sched_dep_time int4 NULL,\n    dep_delay float8 NULL,\n    arr_time int4 NULL,\n    sched_arr_time int4 NULL,\n    arr_delay float8 NULL,\n    carrier text NULL,\n    flight int4 NULL,\n    tailnum text NOT NULL,\n    origin text NOT NULL,\n    dest text NULL,\n    air_time float8 NULL,\n    distance float8 NULL,\n    \"hour\" float8 NULL,\n    \"minute\" float8 NULL,\n    time_hour timestamptz NOT NULL,\n    CONSTRAINT flights_pk \n        PRIMARY KEY (\n            tailnum, origin, time_hour)\n);\n\n\nALTER TABLE flights ADD \n    CONSTRAINT flights_fk \n    FOREIGN KEY (carrier) \n    REFERENCES airlines(carrier) \n    ON DELETE SET NULL \n    ON UPDATE CASCADE;\nALTER TABLE flights ADD \n    CONSTRAINT flights_fk_dest \n    FOREIGN KEY (dest) \n    REFERENCES airports(faa) \n    ON DELETE SET NULL \n    ON UPDATE CASCADE;\nALTER TABLE flights ADD \n    CONSTRAINT flights_fk_origin \n    FOREIGN KEY (origin) \n    REFERENCES airports(faa) \n    ON DELETE SET NULL \n    ON UPDATE CASCADE;\nALTER TABLE flights ADD \n    CONSTRAINT flights_fk_planes \n    FOREIGN KEY (tailnum) \n    REFERENCES planes(tailnum) \n    ON DELETE SET NULL \n    ON UPDATE CASCADE;\n\n\n\nDans le schéma nycflights, on a aussi les dépendances fonctionnelles suivantes:\nTable airports\n\nfaa, name, et (lon, lat) sont des clés.\n\nTable airlines\n\ncarrier et name sont des clés\n\nTable weather\n\norigin, time_hour est une clé\ntime_hour → year, month, day, hour\nyear, month, day, hour  → time_hour\n\nTable planes\n\ntailnum est une clé\nmodel → manufacturer, engines, engine, type\n\nTable flights\n\ntailnum, time_hour → carrier\ntime_hour → sched_dep_time\nsched_dep_time, dep_time → dep_delay\nsched_arr_time, arr_time → arr_delay\norigin, dest, dep_time, arr_time → airtime\ntime_hour → year, month, day, hour, minute\nyear, month, day, hour, minute → time_hour\norigin, dest → distance\n(tailnum, origin, time_hour) est une clé\n(flight, dest, origin, year, month, day) est une clé\n\n\n\n\n\n\n\n\n\nExercice : Modélisation\n\n\n\n\nLe schéma entité-association est une tentative de rétro-ingénieurie du schéma relationnel nycflights.\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nProposez une variation de la représentation de l’entité plane où on définit une entité model (dont les instances seraient par exemple Airbus A350, Boeing 777, …), et où chaque avion/aéronef serait considéré comme une réalisation d’une instance de model).\nPréciser la nature de l’association entre plane et model et les cardinalités.\nPrécisez la répartition des attributs entre plane et model.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nAssociation est-un (is-a), avec cardinalité 1:1 côté plane et 0:n côté model\nmodel a les attributs model (à renommer), engines, type, manufacturer, engine.\nplane garde les attributs year, seats, tailnum (identifiant)\nSi les instances de plane sont identifiées par tailnum, l’association est-un n’est pas identifiante.\n\n\n\n\n\n\n\n\n\n\nExercice : Normalisation\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 1\n\n\n\nPour chaque table, préciser si elle est en FNBC ou non.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n airlines : en FNBC car deux colonnes\n airports : en FNBC\n planes : viole la condition FNBC par toutes les DF model → ...\n weather : deux clés (origin, time_hour) et (origin, year, month, day, hour), mais les membres gauches des DF time_hour → year, month, day, hour et year, month, day, hour  → time_hour violent la condition FNBC.\n flights viole la condition FNBC de plusieurs façons notamment via la DF origin, dest →  distance.\n\n\n\n\n\n\n\n\n\nQuestion 2\n\n\n\nSi certaines tables ne sont pas en FNBC, proposer une décomposition en FNBC sans perte d’information.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\nPour planes, la décomposition (model, manufacturer, engines, engine, type), (tailnum, year, model, seats, speed) est en FNBC.\nPour weather, supprimer les colonnes year, month, day, hour qui peuvent être calculées à partir de time_hour.\nPour flights, décomposition\n\n(origin, dest, distance)\n(flight, time_hour)\n(flight, dest, origin, time_hour, dep_time, sched_arr_time, arr_time, tailnum)\n(tailnum, time_hour, carrier)\n\n\n\n\n\n\n\n\n\n\n\nExercice : Requêtes (schéma nycflights)\n\n\n\n\n\n\n\n\n\n\n\n\nRequête 1\n\n\n\n\n\nFor each airport of departure (denoted by origin), for each day of the year, list the codes (carrier) of the airlines that have one or more planes taking off from that airport on that day.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT DISTINCT f.origin, f.year, f.month, f.day, f.carrier\nFROM nycflights.flights f \nORDER BY f.origin, f.year, f.month, f.day;\n Il n’est pas nécessaire, ni même utile de procéder à une aggrégation (GROUP BY), il suffit de projeter sur les attributs qui identifient le jour de l’année f.year, f.month, f.day, l’aéroport de décollage (origin), et l’identifiant des compagnies aériennes carrier, et, bien sûr d’éliminer les doublons avec DISTINCT.\n Si on veut récupérer les noms complets des compagnies aériennes, plutôt que les codes, on peut effectuer une jointure naturelle avec airlines.\n Si on veut (finalement) une ligne par aéroport de départ et jour de l’année, on doit alors effectuer une aggrégation et utiliser une fonction d’aggrégation de chaine de caractères comme concat()\nWITH R AS (\n  SELECT DISTINCT f.origin, f.year, f.month, f.day, f.carrier\n  FROM nycflights.flights f \n)\n\nSELECT R.origin, R.year, R.month, R.day, concat(R.carrier) AS carriers\nFROM R \nGROUP BY R.origin, R.year, R.month, R.day\nORDER BY R.origin, R.year, R.month, R.day ;\n\n\n\n\n\n\n\n\nRequête 2\n\n\n\n\n\n\nLister pour chaque aéroport d’origine, chaque jour de l’année, pour chaque compagnie aérienne, le nombre d’avions exploités par la compagnie aérienne qui décollent de cet aéroport, ce jour là.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT f.origin, f.year, f.month, f.day, f.carrier, COUNT(DISTINCT tailnum)\nFROM nycflights.flights f \nGROUP BY f.origin, f.year, f.month, f.day, f.carrier\nORDER BY f.origin, f.year, f.month, f.day, f.carrier;\n Il faut bien garder en tête que la clause GROUP BY (la clause de partitionnement) est définie par une liste de colonnes (ou plus généralement d’expressions) séparées par des virgules, ici f.origin, f.year, f.month, f.day, f.carrier. Ces colonnes sont évoquées dans pour chaque aéroport d’origine, chaque jour de l’année, pour chaque compagnie aérienne. Ces colonnes doivent aussi apparaître dans la clause SELECT (la clause de projection finale).\n Dans la clause de projection SELECT ... ne peuvent figurer que - les expressions qui apparaissent dans la clause GROUP BY ... - les expressions d’aggrégation comme COUNT(...).\n\n\n\n\n\n\n\n\nRequête 3\n\n\n\n\nLister pour chaque vol exploité par la compagnie (carrier nommé dans airlines) Delta Air Lines Inc. : les conditions météorologiques (weather) à l’heure prévue du décollage (sched_dep_time).\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH delta AS (\n    SELECT al.carrier\n    FROM nycflights.airlines al\n    WHERE al.\"name\" = 'Delta Air Lines Inc.'\n),\ndelta_f AS (\n    SELECT f.origin, f.flight, f.year, f.month, f.day, f.hour \n    FROM nycflights.flights f\n    WHERE f.carrier IN (SELECT * FROM delta)\n)\n\nSELECT f.flight, w.*\nFROM  nycflights.weather w NATURAL JOIN delta_f f;\n\n\n\n\n\n\n\n\nRequête 4\n\n\n\n\n\nNombre de vols au décollage par aéoroport d’origine et par compagnie aérienne (carrier).\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT f.origin, f.carrier, COUNT(*) AS n\nFROM nycflights.flights f\nGROUP BY f.origin, f.carrier \nORDER BY f.carrier, n DESC;\n\n\n\n\n\n\n\n\nRequête 5\n\n\n\n\n\nLister les caractéristiques des avions (planes) exploités par au moins deux compagnies aériennes (carrier) différentes dans la base de données.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH for_hire AS (\n    SELECT f.tailnum, COUNT(DISTINCT f.carrier) AS n_carrier\n    FROM nycflights.flights f\n    GROUP BY f.tailnum \n    HAVING COUNT(DISTINCT f.carrier) &gt;=2 \n)\n\nSELECT p.*\nFROM nycflights.planes p NATURAL JOIN for_hire ;\n\n\n\n\n\n\n\n\nRequête 6\n\n\n\n\n\nLister pour chaque jour et chaque aéoroport d’origine les dix avions les plus en retard au décollage (dep_delay). Ne pas prendre en compte les vols annulés (dep_time IS NULL).\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH f_delayed AS (\n  SELECT f.*, RANK() OVER w AS rnk\n  FROM nycflights.flights f\n  WHERE f.dep_time IS NOT NULL\n  WINDOW w AS (PARTITION BY f.origin, f.year, f.month, f.day ORDER BY f.dep_delay DESC)  \n)\n\nSELECT fd.origin, fd.year, fd.month, fd.day, fd.tailnum\nFROM f_delayed fd\nWHERE fd.rnk &lt;= 10;\n\n\n\n\n\n\n\n\nRequête 7\n\n\n\n\n\nLister pour chaque modèle d’avion (model) le nombre de jours où un avion de ce modèle a subi le plus grand retard au décollage (dep_delay) parmi les avions qui ont décollé ce jour là du même aéroport (origin).\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH delayed_flight AS (\n  SELECT f.origin, f.year, f.month, f.day, f.tailnum, \n         RANK() OVER w AS rnk\n  FROM nycflights.flights f\n  WINDOW w AS (PARTITION BY f.origin, f.year, f.month, f.day \n               ORDER BY f.dep_delay DESC)\n), plane_of_day  AS (\n  SELECT df.origin, df.year, df.month, df.day, df.tailnum\n  FROM delayed_flight df\n  WHERE df.rnk = 1\n)\n\nSELECT p.model, COUNT(DISTINCT(df.year, df.month, df.day)) AS nb_bad_days\nFROM plane_of_day df  JOIN nycflights.planes p ON \n  (df.tailnum=p.tailnum)\nGROUP BY p.model \nORDER BY nb_bad_days DESC;\n L’utilisation d’une clause WITH (Common Table Expression) plutôt que d’une requête imbriquée rend le code plus lisible.\n Dans la réponse, nous donnons plus que ce qui était demandé. On aurait pu se contenter de ;\n...\n\nSELECT p.model\nFROM plane_of_day df  NATURAL JOIN nycflights.planes p \nGROUP BY p.model ;\n\n\n\n\n\n\n\n\nRequête 8\n\n\n\n\n\nLister les aéroports de destination (dest) qui sont desservis au moins une fois à partir de chaque aéroport de départ (origin).\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH origins AS (\n  SELECT DISTINCT f.origin  -- les origines\n  FROM nycflights.flights f\n), dests AS (\n  SELECT DISTINCT f.dest  -- les destinations\n  FROM nycflights.flights f\n),\norigin_dest AS (\n  SELECT DISTINCT f.dest, f.origin \n  FROM nycflights.flights f   -- les couples realises\n  ),\norigin_cross_dest AS (\n  SELECT d.dest, o.origin  -- les couples possibles\n  FROM dests d, origins o\n), \nwhitness_orphans AS (\n  SELECT *\n  FROM origin_cross_dest\n\n  EXCEPT\n\n  SELECT *\n  FROM origin_dest  -- couples pas realises\n)\n\nSELECT dest\nFROM dests\n\nEXCEPT\n\nSELECT w.dest\nFROM whitness_orphans w ;\n Dans cette réponse, nous n’avons pas utilisé l’agrégation (GROUP BY ...). On aurait pu écrire cette requête en algèbre relationnelle. Avec l’agrégation c’est plus simple.\nWITH R AS (\n  SELECT COUNT(DISTINCT f.origin) as nb_origins\n  FROM nycflights.flights f\n)\n\nSELECT f.dest\nFROM nycflights.flights f\nGROUP BY f.dest \nHAVING COUNT(DISTINCT f.origin) &gt;= ALL (SELECT * FROM R) ;\n\n\n\n\n\n\n\n\nRequête 9\n\n\n\n\n\nLister les compagnies aériennes (carrier) pour lesquelles, chaque jour, au moins un avion figure parmi les 10 avions les plus en retard au décollage (dep_delay) de son aéroport de départ (origin).\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH delayed_flight AS (\n  SELECT f.origin, f.year, f.month, f.day, f.tailnum, f.carrier,\n         RANK() OVER w AS rnk\n  FROM nycflights.flights f\n  WINDOW w AS (PARTITION BY f.origin, f.year, f.month, f.day \n               ORDER BY f.dep_delay DESC)\n), carriers_of_day  AS (\n  SELECT DISTINCT df.origin, df.year, df.month, df.day, df.carrier\n  FROM delayed_flight df\n  WHERE df.rnk &lt;= 10\n), nb_bad_days_per_carrier AS (\n  SELECT df.origin, \n         df.carrier, \n         COUNT(DISTINCT (df.year, df.month, df.day)) as nb \n  FROM carriers_of_day df  GROUP BY df.origin, df.carrier\n), nb_days AS (\n  SELECT COUNT(DISTINCT (df.year, df.month, df.day)) AS nb\n  FROM carriers_of_day df \n) \n\nSELECT a.origin, a.carrier\nFROM nb_bad_days_per_carrier a \nWHERE a.nb &gt;= ALL (SELECT nb FROM nb_days) ;\n La complexité de la réponse tient à la complexité de la question : s’il fallait écrire une formule du calcul relationnel des tuples, il faudrait introduire des quantifications alternées. Les requêtes de la clause WITH correspondent à ses alternances de quantification \\(\\forall, \\exists\\) . carriers_of_day liste pour chaque journée répertoriée dans la base, les transporteurs dont un avion figure parmi les retardataires du jour pour un aéroport donné. On détermine ensuite le nombre total de journées de la honte pour chaque transporteur, et le nombre total de journées, on sélectionne enfin les transporteurs dont le nombre de journées de la honte coïncide avec le nombre total de journées.\n\n\n\n\n\n\n\n\nRequête 10\n\n\n\n\n\nPour chaque couple (origin, dest), lister les dix vols les plus rapides (airtime donne le temps de vol, distance la distance entre dest et origin).\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS (\n  SELECT f.origin, f.dest, f.tailnum, f.flight, RANK() OVER w AS rnk\n  FROM nycflights.flights f\n  WHERE f.airtime IS NOT NULL\n  WINDOW w AS (PARTITION BY f.origin, f.dest ORDER BY f.distance/f.airtime DESC)\n)\n\nSELECT R.*\nFROM R \nWHERE R.rnk &lt;= 10 ;\n\n\n\n\n\n\n\n\nQuelques conseils\n\n\n\n\nPréférez les clauses WITH et les jointures aux requêtes imbriquées sauf si la requête imbriquée est très simple. C’est une question de lisibilité et donc souvent de correction.\nNe mélangez pas les fonctions fenêtres et les clauses GROUP BY ...\n\nSELECT ..., FOO() OVER w\nFROM R\nWINDOW w AS (PARTITION BY ... ORDER BY ...)\nGROUP BY ... ;  \nest tout simplement incorrect.\n\nLorsque vous effectuez un partitionnement par GROUP BY ..., la clause SELECT ... est sévèrement contrainte, vous n’y trouverez que\n\nles colonnes qui ont servi dans la clause GROUP BY ..., normalement elles devraient toutes y figurer\ndes fonctions d’aggrégation, comme COUNT(...), SUM(...), VAR(...)"
  },
  {
    "objectID": "exams/cc2-2024-11-25.html",
    "href": "exams/cc2-2024-11-25.html",
    "title": "MA15Y030 - Automne 2024",
    "section": "",
    "text": "(schéma pagila)\nSchéma pagila.\nSchéma pagila"
  },
  {
    "objectID": "exams/cc2-2024-11-25.html#schéma-world",
    "href": "exams/cc2-2024-11-25.html#schéma-world",
    "title": "MA15Y030 - Automne 2024",
    "section": "Schéma world ",
    "text": "Schéma world \n\nLister pour chaque pays, la proportion de la population qui utilise l’une des deux langues les plus populaires du pays,\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH ranking AS (\n   SELECT \n     countrycode, name_country, language, percentage,\n     RANK() OVER win AS rnk\n   FROM \n     world.country co\n   JOIN \n     world.countrylanguage cl USING(countrycode)\n   WINDOW \n     win AS (PARTITION by countrycode ORDER BY percentage DESC)\n) \n\nSELECT\n  countrycode, name_country, \n  SUM(percentage) AS prop\nFROM \n  ranking\nWHERE \n  rnk &lt;= 2\nGROUP BY countrycode, name_country \nORDER BY prop DESC;\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\nLister pour chaque région (attribut region de country) les 10 villes les plus peuplées.\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS (\n   SELECT \n     co.countrycode, co.name_country,\n     ci.name,\n     RANK() OVER win AS rnk\n   FROM \n     world.country co\n   JOIN \n     world.city ci USING(countrycode)\n   WINDOW win AS (PARTITION BY co.countrycode ORDER BY ci.population DESC)\n )\n \nSELECT\n  name_country, \n  string_agg(name, ', ')\nFROM \n  R\nWHERE rnk &lt;= 2\nGROUP BY countrycode, name_country\n ;\n\n\n\n\nLister pour chaque langue, les deux pays où on trouve le plus grand nombre d’utilisateurs.\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS (\n   SELECT \n     language, \n     name_country, \n     percentage*population_country/100.0 AS pop_loc,\n     RANK() OVER win AS rnk \n   FROM \n     world.countrylanguage cl \n   NATURAL JOIN \n     world.country\n   WHERE \n     population_country IS NOT NULL\n   WINDOW win AS (PARTITION BY language ORDER BY percentage*population_country DESC)\n)\n\nSELECT \n  language, \n  string_agg(name_country, ', ') AS pays, SUM(pop_loc) AS loc \nFROM \n  R \nWHERE rnk &lt;=  2\nGROUP BY language ;\n\n\n\nLister les pays en donnant leur rang par gnp (pnb) par habitant décroissant et leur rang par espérance de vie à la naissance (lifeexpectancy) décroissante.\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT \n  name_country, \n  lifeexpectancy , \n  RANK() OVER win_gnp AS rnk_gnppercap,\n  RANK() OVER win_life AS rnk_lifeexp\nFROM \n  world.country\nWHERE \n  gnp IS NOT NULL AND \n  population_country IS NOT NULL AND \n  lifeexpectancy IS NOT NULL\nWINDOW \n  win_gnp AS (ORDER BY gnp/population_country DESC),\n  win_life AS (ORDER BY lifeexpectancy DESC)\nORDER BY lifeexpectancy DESC ;"
  },
  {
    "objectID": "exams/cc2-2024-11-25.html#schéma-pagila",
    "href": "exams/cc2-2024-11-25.html#schéma-pagila",
    "title": "MA15Y030 - Automne 2024",
    "section": "Schéma pagila ",
    "text": "Schéma pagila \n\nLister la somme des paiments encaissés par année et par magasin.\n\n\n\n\n\n\n\nEn PostgreSQL, on obtient le (numéro du) mois à partir d’une valeur de type timestamp avec la fonction EXTRACT(). On peut extraire les autres éléments de l’estampille de façon semblable, par exemple :\nSELECT \n  EXTRACT(YEAR FROM rental_date) AS annee\nFROM \n  pagila.rental;\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT \n  st.store_id,\n  EXTRACT(YEAR FROM pay.payment_date) AS annee,\n  SUM(amount) AS payments\nFROM \n  pagila.payment pay \nJOIN \n  pagila.staff st USING(staff_id)\nGROUP BY \n  st.store_id, \n  EXTRACT(YEAR FROM pay.payment_date)\n;\n\n\n\nLister l’identifiant, le nom, le prénom, de chaque employé ainsi que le total des paiements perçus par cet employé, et sa part dans le revenu de son magasin.\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT \n  st.store_id,\n  st.staff_id,\n  SUM(pay.amount) AS encaisse\nFROM  \n  pagila.staff st\nJOIN \n  pagila.payment pay USING(staff_id)\nGROUP BY ROLLUP(st.store_id, st.staff_id) ;   \n\n\n\n\nLister par catégorie de film, les cinq titres qui ont engendré le plus gros chiffre d’affaire/revenu (somme des paiements perçus)\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH film_payment AS (\n   SELECT\n     film_id, \n     fi.title,\n     SUM(amount) AS caffaires\n   FROM\n     pagila.payment pay \n   JOIN \n     pagila.rental re USING(rental_id)\n   JOIN \n     pagila.inventory inv USING(inventory_id)\n   JOIN \n     pagila.film fi USING(film_id)\n   GROUP BY \n     film_id, fi.title\n), rank_per_cat AS (\n  SELECT \n    category_id,\n    ca.name, \n    film_id,\n    title, \n    caffaires,\n    RANK() OVER win AS rnk\n  FROM \n    film_payment fp \n  JOIN  \n    pagila.film_category fc USING(film_id)\n  JOIN\n    pagila.category ca USING(category_id)\n  WINDOW win AS (PARTITION BY category_id ORDER BY caffaires DESC)\n)\n\nSELECT \n  name, \n  title, \n  caffaires, \n  rnk\nFROM rank_per_cat\nWHERE rnk &lt;= 5\nORDER BY name, rnk\n;"
  },
  {
    "objectID": "exams/cc2-2024-11-15.html#schéma-pagila",
    "href": "exams/cc2-2024-11-15.html#schéma-pagila",
    "title": "MA15Y030 - Automne 2024",
    "section": "Schéma pagila ",
    "text": "Schéma pagila \n\nLister la somme des paiments encaissés par année et par magasin.\n\n\n\n\n\n\n\nEn PostgreSQL, on obtient le (numéro du) mois à partir d’une valeur de type timestamp avec la fonction EXTRACT(). On peut extraire les autres éléments de l’estampille de façon semblable, par exemple :\nSELECT \n  EXTRACT(YEAR FROM rental_date) AS annee\nFROM \n  pagila.rental;\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT \n  st.store_id,\n  EXTRACT(YEAR FROM pay.payment_date) AS annee,\n  SUM(amount) AS payments\nFROM \n  pagila.payment pay \nJOIN \n  pagila.staff st USING(staff_id)\nGROUP BY \n  st.store_id, \n  EXTRACT(YEAR FROM pay.payment_date)\n;\n\n\n\nLister l’identifiant, le nom, le prénom, de chaque employé ainsi que le total des paiements perçus par cet employé, et sa part dans le revenu de son magasin.\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT \n  st.store_id,\n  st.staff_id,\n  SUM(pay.amount) AS encaisse\nFROM  \n  pagila.staff st\nJOIN \n  pagila.payment pay USING(staff_id)\nGROUP BY ROLLUP(st.store_id, st.staff_id) ;   \n\n\n\n\nLister par catégorie de film, les cinq titres qui ont engendré le plus gros chiffre d’affaire/revenu (somme des paiements perçus)\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH film_payment AS (\n   SELECT\n     film_id, \n     fi.title,\n     SUM(amount) AS caffaires\n   FROM\n     pagila.payment pay \n   JOIN \n     pagila.rental re USING(rental_id)\n   JOIN \n     pagila.inventory inv USING(inventory_id)\n   JOIN \n     pagila.film fi USING(film_id)\n   GROUP BY \n     film_id, fi.title\n), rank_per_cat AS (\n  SELECT \n    category_id,\n    ca.name, \n    film_id,\n    title, \n    caffaires,\n    RANK() OVER win AS rnk\n  FROM \n    film_payment fp \n  JOIN  \n    pagila.film_category fc USING(film_id)\n  JOIN\n    pagila.category ca USING(category_id)\n  WINDOW win AS (PARTITION BY category_id ORDER BY caffaires DESC)\n)\n\nSELECT \n  name, \n  title, \n  caffaires, \n  rnk\nFROM rank_per_cat\nWHERE rnk &lt;= 5\nORDER BY name, rnk\n;"
  },
  {
    "objectID": "exams/cc2-2024-11-15.html#schéma-world",
    "href": "exams/cc2-2024-11-15.html#schéma-world",
    "title": "MA15Y030 - Automne 2024",
    "section": "Schéma world ",
    "text": "Schéma world \n\nLister pour chaque pays, la proportion de la population qui utilise l’une des deux langues les plus populaires du pays,\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH ranking AS (\n   SELECT \n     countrycode, name_country, language, percentage,\n     RANK() OVER win AS rnk\n   FROM \n     world.country co\n   JOIN \n     world.countrylanguage cl USING(countrycode)\n   WINDOW \n     win AS (PARTITION by countrycode ORDER BY percentage DESC)\n) \n\nSELECT\n  countrycode, name_country, \n  SUM(percentage) AS prop\nFROM \n  ranking\nWHERE \n  rnk &lt;= 2\nGROUP BY countrycode, name_country \nORDER BY prop DESC;\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\nLister pour chaque région (attribut region de country) les 10 villes les plus peuplées.\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS (\n   SELECT \n     co.countrycode, co.name_country,\n     ci.name,\n     RANK() OVER win AS rnk\n   FROM \n     world.country co\n   JOIN \n     world.city ci USING(countrycode)\n   WINDOW win AS (PARTITION BY co.countrycode ORDER BY ci.population DESC)\n )\n \nSELECT\n  name_country, \n  string_agg(name, ', ')\nFROM \n  R\nWHERE rnk &lt;= 2\nGROUP BY countrycode, name_country\n ;\n\n\n\n\nLister pour chaque langue, les deux pays où on trouve le plus grand nombre d’utilisateurs.\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS (\n   SELECT \n     language, \n     name_country, \n     percentage*population_country/100.0 AS pop_loc,\n     RANK() OVER win AS rnk \n   FROM \n     world.countrylanguage cl \n   NATURAL JOIN \n     world.country\n   WHERE \n     population_country IS NOT NULL\n   WINDOW win AS (PARTITION BY language ORDER BY percentage*population_country DESC)\n)\n\nSELECT \n  language, \n  string_agg(name_country, ', ') AS pays, SUM(pop_loc) AS loc \nFROM \n  R \nWHERE rnk &lt;=  2\nGROUP BY language ;\n\n\n\nLister les pays en donnant leur rang par gnp (pnb) par habitant décroissant et leur rang par espérance de vie à la naissance (lifeexpectancy) décroissante.\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT \n  name_country, \n  lifeexpectancy , \n  RANK() OVER win_gnp AS rnk_gnppercap,\n  RANK() OVER win_life AS rnk_lifeexp\nFROM \n  world.country\nWHERE \n  gnp IS NOT NULL AND \n  population_country IS NOT NULL AND \n  lifeexpectancy IS NOT NULL\nWINDOW \n  win_gnp AS (ORDER BY gnp/population_country DESC),\n  win_life AS (ORDER BY lifeexpectancy DESC)\nORDER BY lifeexpectancy DESC ;"
  },
  {
    "objectID": "slides/DF_norm_1.html#terminaison-de-lalgorithme",
    "href": "slides/DF_norm_1.html#terminaison-de-lalgorithme",
    "title": "Normalisation I",
    "section": "Terminaison de l’algorithme",
    "text": "Terminaison de l’algorithme\n Xc grandit à chaque itération\nComme \\(\\mathcal{A}\\) est fini, l’algorithme se termine en au plus \\(|\\mathcal{A}|\\) itérations"
  },
  {
    "objectID": "slides/DF_norm_1.html#section-4",
    "href": "slides/DF_norm_1.html#section-4",
    "title": "Normalisation I",
    "section": "",
    "text": "Preuve ()."
  },
  {
    "objectID": "slides/DF_norm_1.html#vérification-de-la-transitivité",
    "href": "slides/DF_norm_1.html#vérification-de-la-transitivité",
    "title": "Normalisation I",
    "section": "Vérification de la transitivité",
    "text": "Vérification de la transitivité\nOn se rammène à vérifier une règle du calcul propositionnel :\nsi p ⇒ q et q ⇒ r alors p ⇒ r\nSoit une instance \\(\\mathcal{R}\\) telle que :\n\\[\\forall s,t \\in \\mathcal{R} \\qquad\n  \\begin{cases}  \\text{si } s.X =t.X & \\text{alors } s.Y= t.Y \\\\\n   \\text{si } s.Y =t.Y &  \\text{alors } s.Z= t.Z\n\\end{cases}\n\\] On a alors aussi \\(\\forall s,t \\in \\mathcal{R}\\), si \\(s.X =t.X\\) alors \\(s.Z= t.Z\\)"
  },
  {
    "objectID": "slides/DF_norm_1.html#tables-de-vérité",
    "href": "slides/DF_norm_1.html#tables-de-vérité",
    "title": "Normalisation I",
    "section": "Tables de vérité",
    "text": "Tables de vérité\n\n\n\np\nq\nr\np ⇒ q\nq ⇒ r\np ⇒ r\n\n\n\n\nTRUE\nTRUE\nTRUE\nTRUE\nTRUE\nTRUE\n\n\nFALSE\nTRUE\nTRUE\nTRUE\nTRUE\nTRUE\n\n\nTRUE\nFALSE\nTRUE\nFALSE\nTRUE\nTRUE\n\n\nFALSE\nFALSE\nTRUE\nTRUE\nTRUE\nTRUE\n\n\nTRUE\nTRUE\nFALSE\nTRUE\nFALSE\nFALSE\n\n\nFALSE\nTRUE\nFALSE\nTRUE\nFALSE\nTRUE\n\n\nTRUE\nFALSE\nFALSE\nFALSE\nTRUE\nFALSE\n\n\nFALSE\nFALSE\nFALSE\nTRUE\nTRUE\nTRUE"
  },
  {
    "objectID": "weeks/week-10.html#exercices-td-8",
    "href": "weeks/week-10.html#exercices-td-8",
    "title": "Semaine 10",
    "section": "Exercices : TD 8",
    "text": "Exercices : TD 8\nhtml pdf\n L’exercide 1 a été corrigé en Cours Magistral durant la semaine 9",
    "crumbs": [
      "Journal",
      "Semaine 10"
    ]
  },
  {
    "objectID": "weeks/week-10.html#solutions-du-td-8",
    "href": "weeks/week-10.html#solutions-du-td-8",
    "title": "Semaine 10",
    "section": "Solutions du TD 8",
    "text": "Solutions du TD 8\nhtml pdf\n\n\nretour à Agenda ⏎",
    "crumbs": [
      "Journal",
      "Semaine 10"
    ]
  },
  {
    "objectID": "slides/DF_norm_3.html#algorithme-de-construction-de-couverture-irredondante",
    "href": "slides/DF_norm_3.html#algorithme-de-construction-de-couverture-irredondante",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Algorithme de construction de couverture irredondante",
    "text": "Algorithme de construction de couverture irredondante\n\n\n\\begin{algorithm} \\caption{Couverture irredondante} \\begin{algorithmic} \\Procedure{MinCover}{$Σ$} \\State Σ' ← ∅ \\State \\Comment{Normaliser les éléments de Σ} \\For{$(X → Y) ∈ Σ$} \\For{$y ∈ Y$} \\State Σ' ← Σ' ∪ {X → y} \\EndFor \\EndFor \\State \\Comment{Éliminer les dépendances redondantes dans Σ'} \\State \\Comment{Miniser les dépendances dans Σ'} \\Return Σ' \\EndProcedure \\end{algorithmic} \\end{algorithm}"
  },
  {
    "objectID": "slides/DF_norm_3.html#détails",
    "href": "slides/DF_norm_3.html#détails",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Détails",
    "text": "Détails\n\n\n\n\n\\begin{algorithm} \\caption{Éliminer les dépendances redondantes dans Σ' (détail)} \\begin{algorithmic} \\Repeat \\State s ← \\True \\For{$(X → y) ∈ Σ'$} \\If{$Σ' \\ {X → y} ⊧ X → y$} \\State $Σ' ← Σ' \\ {X → y}$ \\State s ← \\False \\EndIf \\EndFor \\Until{s} \\end{algorithmic} \\end{algorithm}\n\n\n\n\n\n\\begin{algorithm} \\caption{Miniser les dépendances dans Σ' (détail)} \\begin{algorithmic} \\Repeat \\State s ← \\True \\For{$(X → y) ∈ Σ'$} \\For{$x ∈ X$} \\If{$Σ' \\ {X → y} ⊧ X \\ {x} → y$} \\State $Σ' ← (Σ' \\ {X → y}) ∪ X \\ {x} → y$ \\State s ← \\False \\Break \\EndIf \\EndFor \\EndFor \\Until{s} \\end{algorithmic} \\end{algorithm}"
  },
  {
    "objectID": "slides/DF_norm_3.html#preuves",
    "href": "slides/DF_norm_3.html#preuves",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Preuves",
    "text": "Preuves\nTerminaison \nFN3 \nSPI \nSPDF"
  },
  {
    "objectID": "slides/DF_norm_1.html#algorithme-1",
    "href": "slides/DF_norm_1.html#algorithme-1",
    "title": "Normalisation I",
    "section": "Algorithme",
    "text": "Algorithme\n\n\n\\begin{algorithm} \\caption{Décomposition FNBC} \\begin{algorithmic} \\Procedure{DecompositionFNBC}{$\\mathcal{A}, Σ$} \\State \\Comment{Initialisation de la décomposition} \\State $D ← \\{\\mathcal{A}\\}$ \\State \\While{Exists some $\\mathcal{B} \\in D$ which is not in BCNF w.r.t. $\\Sigma \\models X → X^+ \\cap \\mathcal{B}$, $X \\subsetneq \\mathcal{B}$} \\State $Y \\leftarrow X^+ \\cap \\mathcal{B} \\setminus X$ \\State $D \\leftarrow D \\setminus \\{\\mathcal{B}\\} \\cup \\{ X \\cup Y, \\mathcal{B} \\setminus Y \\}$ \\EndWhile \\State \\Return $D$ \\EndProcedure \\end{algorithmic} \\end{algorithm}"
  },
  {
    "objectID": "slides/DF_norm_1.html#remarques",
    "href": "slides/DF_norm_1.html#remarques",
    "title": "Normalisation I",
    "section": "Remarques",
    "text": "Remarques\n\n\n\n\n\n\n\nProposition\n\n\n\nL’algorithme termine\nLes éléments de la décomposition finale sont en FNBC\nLa décomposition est Sans Perte d’Information (SPI)"
  },
  {
    "objectID": "slides/DF_norm_1.html#preuves",
    "href": "slides/DF_norm_1.html#preuves",
    "title": "Normalisation I",
    "section": "Preuves ",
    "text": "Preuves \n\nLa terminaison est triviale : à chaque itération le nombre de parties de \\(\\mathcal{A}\\) dans \\(D\\) augmente de \\(1\\) et ce nombre ne peut dépasser \\(\\# \\mathcal{A}\\)\nLa seconde propriété est triviale aussi\nLa propriété SPI se vérifie avec l’algorithme de poursuite (et son analyse): chaque itération de la boucle While est SPI."
  },
  {
    "objectID": "slides/DF_norm_3.html#résultat-important-de-la-séance-précédente",
    "href": "slides/DF_norm_3.html#résultat-important-de-la-séance-précédente",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Résultat important de la séance précédente",
    "text": "Résultat important de la séance précédente\nOn peut décomposer une relation \\(\\mathcal{A}\\) relativement à un ensemble de DF \\(\\Sigma\\) de façon à obtenir :\n\nune décomposition dont tous les membres sont en FNBC relativement à \\(\\Sigma\\)\nune dećomposition SPI\n\n\nCe résultat ne fournit pas toujours une solution complètement satisfaisante"
  },
  {
    "objectID": "slides/DF_norm_3.html#résultat-de-la-séance-précédente",
    "href": "slides/DF_norm_3.html#résultat-de-la-séance-précédente",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Résultat de la séance précédente",
    "text": "Résultat de la séance précédente\n\n\n\n\n\n\nImportant\n\n\nOn peut décomposer une relation \\(\\mathcal{A}\\) relativement à un ensemble de DF \\(\\Sigma\\) de façon à obtenir une décomposition :\n\ndont tous les membres sont en FNBC relativement à \\(\\Sigma\\)\nSPI\n\n\n\n\n\n Ce résultat ne fournit pas toujours une solution complètement satisfaisante"
  },
  {
    "objectID": "slides/DF_norm_3.html#rappels-séance-précédente-bis",
    "href": "slides/DF_norm_3.html#rappels-séance-précédente-bis",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Rappels séance précédente (bis)",
    "text": "Rappels séance précédente (bis)\n\n\n\n\n\n\nDéfinition\n\n\nUn schéma \\(\\mathcal{A}\\) est en FNBC par rapport à un ensemble de dépendances fonctionnelles \\(\\Sigma\\) sur \\(\\mathcal{A}\\)\nsi\npour toute DF \\(X\\rightarrow Y\\) impliquée par \\(\\Sigma\\) avec \\(Y\\not\\subset X\\), \\(X\\) est une super-clef"
  },
  {
    "objectID": "slides/DF_norm_3.html#algorithme-1",
    "href": "slides/DF_norm_3.html#algorithme-1",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Algorithme",
    "text": "Algorithme\n\n\n\\begin{algorithm} \\caption{Decomposition FN3} \\begin{algorithmic} \\Procedure{DecompositionFN3}{$\\mathcal{A}, Σ$} \\State \\Comment{Initialisation de la décomposition} \\State $D ← ∅$ \\State \\Comment{Mise en forme des courverture minimale de Σ} \\State Σ' ← \\Call{MinCover}{$Σ$} \\State \\For{Each distinct determinant $X$ amongst FDs in Σ'} \\State $Y ← \\{y : X → y ∈ Σ'\\}$ \\State $D ← D \\cup \\{X \\cup Y\\}$ \\Comment{ Ajouter $X \\cup Y$ à $D$} \\EndFor \\State \\State $\\mathcal{B} ← $ Attributes in $\\mathcal{A}$ that do not occur in $D$ \\State $D ← D \\cup \\{\\mathcal{B}\\}$ \\State \\If{No component of $D$ includes a key for $\\mathcal{A}, Σ$} \\State $D ← D \\cup $ some key for $\\mathcal{A}, Σ$ \\EndIf \\State \\Return $D$ \\EndProcedure \\end{algorithmic} \\end{algorithm}"
  },
  {
    "objectID": "slides/DF_norm_3.html#un-nouvel-objectif",
    "href": "slides/DF_norm_3.html#un-nouvel-objectif",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Un nouvel objectif",
    "text": "Un nouvel objectif\n\n\n\n\n\n\n\nConstruire\n\n\nUne décomposition :\n\nSPI\nSans perte de Dépendances Fonctionnelles\ndont les éléments sont en FN3 par rapports aux dépendances projetées"
  },
  {
    "objectID": "slides/DF_norm_3.html#pour-réaliser-cet-objectif",
    "href": "slides/DF_norm_3.html#pour-réaliser-cet-objectif",
    "title": "Normalisation II : Décomposition FN3",
    "section": "Pour réaliser cet objectif",
    "text": "Pour réaliser cet objectif\nUne étape cruciale : réécrire l’ensemble de DFs"
  }
]