[
  {
    "objectID": "workshops/td10.html",
    "href": "workshops/td10.html",
    "title": "MA15Y030 - Automne 2024",
    "section": "",
    "text": "L3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2024-2025\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\n\nExercice\nSoit \\(\\mathcal{A}=\\left\\{A,B,C,D,E\\right\\}\\) un schéma et soit \\(\\mathcal{A}_1=\\left\\{A,B,C\\right\\}\\). Pour chaque ensemble \\(\\Sigma\\) de dépendances fonctionnelles ci-dessous, déterminer un ensemble de DF équivalent à \\(\\pi_{\\mathcal{A}_1}(\\Sigma)\\).\n\n\\(\\Sigma=\\left\\{AB\\to DE, C\\to E, D\\to C, E\\to A\\right\\}\\)\n\\(\\Sigma=\\left\\{A\\to D, BD\\to E, AC\\to E, DE\\to B\\right\\}\\)\n\\(\\Sigma=\\left\\{AB\\to D, AC\\to E, BC\\to D, D\\to A, E\\to B\\right\\}\\)\n\\(\\Sigma=\\left\\{A\\to B, B\\to C, C\\to D, D\\to E, E\\to A\\right\\}\\)\n\n\n\n\n\n\n\nSolution\n\n\n\nRappelons que \\(\\pi_{\\mathcal{A}_1}(\\Sigma)\\) est l’ensemble des DF de la forme \\(X\\to Y\\), avec \\(X\\subset\\mathcal{A}_1\\) et \\(Y\\subset\\mathcal{A}_1\\), qui sont impliquées par \\(\\Sigma\\). Un ensemble de DF équivalent à \\(\\pi_{\\mathcal{A}_1}(\\Sigma)\\) est l’ensemble des DF \\(X\\to (X^+\\cap\\mathcal{A}_1)\\setminus X\\) où \\(X\\subset\\mathcal{A}_1\\), \\(X\\not=\\emptyset\\) et \\(X\\not=\\mathcal{A}_1\\).\n\n\\(A^+=A\\), \\(B^+=B\\), \\(C^+=CEA\\) donc on ajoute \\(\\boxed{C\\to A}\\)\\ \\(AB^+=ABDEC\\) donc on ajoute \\(\\boxed{AB\\to C}\\)\\ \\(AC^+=ACE\\), \\(BC^+=BCEAD\\) donc on ajoute \\(\\boxed{BC\\to A}\\)\\ Donc \\(\\pi_{\\mathcal{A}_1}(\\Sigma)\\) est équivalent à \\(\\left\\{C\\to A, AB\\to C, BC\\to A\\right\\}\\) lui-même équivalent à \\(\\left\\{AB\\to C, C\\to A\\right\\}\\).\n\\(A^+=AD\\), \\(B^+=B\\), \\(C^+=C\\) rien à ajouter\\ \\(AB^+=ABDE\\), \\(AC^+=ACDEB\\) donc on ajoute \\(\\boxed{AC \\to B}\\)\\ \\(BC^+=BC\\)\\ Donc \\(\\pi_{\\mathcal{A}_1}(\\Sigma)\\) est équivalent à \\(\\left\\{aC \\to B\\right\\}\\).\n\\(A^+=A\\), \\(B^+=B\\), \\(C^+=C\\) rien à ajouter\\ \\(AB^+=ABD\\), \\(AC^+=ACEBD\\) donc on ajoute \\(\\boxed{AC \\to B}\\)\\ \\(BC^+=BCDAE\\) donc on ajoute \\(\\boxed{BC \\to A}\\) \\ Donc \\(\\pi_{\\mathcal{A}_1}(\\Sigma)\\) est équivalent à \\(\\left\\{aC \\to B, BC\\to A\\right\\}\\).\nTout attribut est une clef, donc c’est aussi le cas pour \\(\\mathcal{A}_1\\). \\(\\pi_{\\mathcal{A}_1}(\\Sigma)\\) est donc équivalent à \\(\\left\\{a\\to B, B\\to C, C\\to A\\right\\}\\).\n\n\n\n\n\nExercice\nSoit \\(\\mathcal{A}=\\left\\{A,B,C,D,E\\right\\}\\) un schéma et soit la décomposition \\(\\left\\{\\mathcal{A}_1,\\mathcal{A}_2,\\mathcal{A}_3\\right\\}\\) où \\[\\mathcal{A}_1=\\left\\{A,B,C\\right\\}\\quad \\mathcal{A}_2=\\left\\{B,C,D\\right\\}\\quad \\mathcal{A}_3=\\left\\{A,C,E\\right\\}\\] Pour chaque ensemble \\(\\Sigma\\) de dépendances fonctionnelles ci-dessous, déterminer quelles dépendances sont préservées par cette décomposition, c’est-à-dire quelles DF de \\(\\Sigma\\) sont impliquées par \\(\\bigcup_{i=1}^3 \\pi_{\\mathcal{A}_i}(\\Sigma)\\).\n\n\\(\\Sigma=\\left\\{b\\rightarrow E, CE\\rightarrow A\\right\\}\\)\n\\(\\Sigma=\\left\\{aC\\rightarrow E, BC\\to D\\right\\}\\)\n\\(\\Sigma=\\left\\{a\\rightarrow D, D\\to E, B\\to D\\right\\}\\)\n\\(\\Sigma=\\left\\{a\\rightarrow D, CD\\to E, E\\to D\\right\\}\\)\n\n\n\n\n\n\n\nSolution\n\n\n\nLa DF \\(X\\to Y\\) est préservée si et seulement la fermeture de \\(X\\) par rapport aux DF locales \\(\\bigcup_{i=1}^3 \\pi_{\\mathcal{A}_i}(\\Sigma)\\) contient \\(Y\\). Pour calculer la fermeture de \\(X\\) par rapport aux DF locales \\(\\bigcup_{i=1}^3 \\pi_{\\mathcal{A}_i}(\\Sigma)\\) on peut utiliser l’algorithme suivant~:\n\nInitialisation \\(Z \\leftarrow X\\)\nTant que \\(Z\\) grandit : pour \\(i=1,2,3\\), \\(Z \\leftarrow Z \\cup\\bigl( (Z\\cap \\mathcal{A}_i)^+_\\Sigma\\cap \\mathcal{A}_i\\bigr)\\)\n\nL’ensemble \\(Z\\) obtenu est la fermeture recherchée\nL’intérêt de cet algorithme est qu’on ne calcule pas toutes les DF locales. Si au cours du calcul on obtient que \\(Y\\subset Z\\), on peut conclure immédiatement que \\(X\\to Y\\) est préservée.\n\n\\(\\Sigma=\\left\\{B\\rightarrow E, CE\\rightarrow A\\right\\}\\)\n\n\\(CE\\to A\\) est préservée puisqu’elle est locale à \\(\\mathcal{A}_3\\).\n\\(B\\to E\\) n’est pas préservée puisque\n\\((B\\cap\\mathcal{A}_1)^+\\cap\\mathcal{A}_1=B^+\\cap\\mathcal{A}_1=BE\\cap\\mathcal{A}_1=B\\)\n\\((B\\cap\\mathcal{A}_2)^+\\cap\\mathcal{A}_2=B^+\\cap\\mathcal{A}_2=BE\\cap\\mathcal{A}_2=B\\)\n\\((B\\cap\\mathcal{A}_3)^+\\cap\\mathcal{A}_3=\\emptyset\\)\n\n\\(\\Sigma=\\left\\{AC\\rightarrow E, BC\\to D\\right\\}\\) est préservé puisqu’il ne contient que des DF locales.\n\\(\\Sigma=\\left\\{A\\rightarrow D, D\\to E, B\\to D\\right\\}\\)\n\\(B\\to D\\) est préservée\n\\(\\Sigma=\\left\\{A\\rightarrow D, CD\\to E, E\\to D\\right\\}\\)\nAucune DF n’est préservée\n\n\n\n\n\nExercice\nOn considère le schéma de relation suivant concernant la gestion de rendez-vous d’un service d’intervention hospitaliers. \\[\n\\mathcal{A}=\\left\\{\\texttt{IdM,NomM,PrenomM,DateRV,HeureRV,IdP,NomP,PrenomP,IdInterV}\\right\\}\n\\]\nChaque rendez-vous implique un médecin et un patient. Chaque médecin est identifié par un numéro, IdM, un nom NomM et un prénom PrenomM. Le rendez-vous est à une date, DateRV, et à une heure, HeureRV données. Chaque patient est identifié par un numéro, IdP, un nom NomP et un prénom PrenomP. Chaque rv est programmé pour un type d’intervention médical, IdInterV. On suppose que chaque jour, un médecin ne peut pratiquer qu’un seul type d’intervention médicale (consultation, type de chirurgie donnée).\nOn a les dépendances fonctionnelles \\(\\Sigma\\) suivantes:\nIdM, DateRV,HeureRV, IdInterV → IdP\nIdM, DateRV →  IdInterV\nIdM → NomM, PrenomM\nIdP → NomP, PrenomP\nIdP,DateRV,HeureRV → IdInterV\nIdP,DateRV,HeureRV →  IdM,NomM\n\nQuels sont les inconvénients d’une telle modélisation par une seule table en terme d’anomalies d’insertion ou de suppression ?\n\n\n\n\n\n\n\nSolution\n\n\n\nA chaque nouveau rv inséré dans \\(R\\), il faut rappeler les noms, prénoms des médecins et patients. Ce qui peut se traduire par des incohérences si cela n’est pas respecté. En cas de suppression d’un groupe de rv, on peut faire disparaitre l’ensemble des informations concernant un patient ou un médecin.\n\n\n\nCalculer \\([\\texttt{IdM}]^+_{\\Sigma}\\)\n\n\n\n\n\n\n\nSolution\n\n\n\n\\([IdM]^+_{\\Sigma}= \\{  \\texttt{IdM, NomM, PrenomM}\\}\\)\n\n\n\nProposez un ensemble d’attributs formant une clé de la relation.\n\n\n\n\n\n\n\nSolution\n\n\n\nIl y a plusieurs clés possibles. Par exemple, {IdM, DateRV, HeureRV} mais aussi {IdP, DateRV, HeureRV}.\n\n\n\nDonner un ensemble de dépendances fonctionnelles \\(\\Sigma'\\) équivalent à \\(\\Sigma\\) qui soit minimal (i.e. sans règles redondantes, notamment). Justifiez\n\n\n\n\n\n\n\nSolution\n\n\n\nIdM, DateRV, HeureRV → IdP\nIdP, DateRV, HeureRV → IdM\nIdM, DateRV → IdInterV\nIdM → NomM\nIdM → PrenomM\nIdP → NomP\nIdP → PrenomP\n\n\n\n\nOn se donne la décomposition de \\(\\mathcal{A}\\) suivante~: \\[\n\\begin{array}{l}\n    \\mathcal{A}_1=\\left\\{\\texttt{IdM,HeureRV,DateRV,IdP,NomP,PrenomP}\\right\\},\\\\\n     \\mathcal{A}_2=\\left\\{\\texttt{IdM,DateRV,IdInterV}\\right\\},\\\\\n     \\mathcal{A}_3=\\left\\{\\texttt{IdM,NomM,PrenomM}\\right\\}\n\\end{array}\n\\]\n\nToutes les dépendances fonctionnelles sont-elles préservées par cette décomposition ?\nEst-elle sans perte d’information ?\nPour \\(i=1,2,3\\), déterminer si \\(\\mathcal{A}_i\\) est en forme normale de Boyce-Codd.\n\n\n\n\n\n\n\nSolution\n\n\n\nPréservation des DF\nLes dépendances de Σ’ sont locales aux \\(\\mathcal{A}_i\\), elles sont donc préservées.\n\nDécomposition SPI ?\nOui, en utilisant seulement (b) et (c) dans l’algorithme de poursuite\\\n\\(\\mathcal{A}_i\\) est en FNBC~?\\\nRappelons que, par définition, \\(\\mathcal{A}_i\\) est en FNBC si et seulement pour toute DF \\(X\\to Y\\) dans un ensemble équivalent à \\(\\pi_{\\mathcal{A}_i}(\\Sigma)\\), soit \\(Y\\subset X\\) (DF triviale) soit \\(Y\\) est une super-clef pour \\(\\mathcal{A}_i\\) relativement à \\(\\pi_{\\mathcal{A}_i}(\\Sigma)\\).\nDonc \\(\\mathcal{A}_i\\) est en FNBC si et seulement si pour tout \\(X\\subset \\mathcal{A}_i\\), pour la DF locale \\(X\\to (X\\cap\\mathcal{A}_i)^+\\cap \\mathcal{A}_i\\) on a \\((X\\cap\\mathcal{A}_i)^+\\cap \\mathcal{A}_i = X\\) (DF triviale) ou \\((X\\cap\\mathcal{A}_i)^+\\cap \\mathcal{A}_i=\\mathcal{A}_i\\) (càd \\(X\\) est une super-clef pour \\(\\mathcal{A}_i\\)).\nDe plus, on n’a pas besoin d’examiner les cas \\(X=\\emptyset\\) ou \\(X=\\mathcal{A}_i\\) ou \\(cardinal(X)=cardinal(\\mathcal{A}_i)-1\\) (dans le dernier cas \\((X\\cap\\mathcal{A}_i)^+\\cap \\mathcal{A}_i=X\\) ou \\((X\\cap\\mathcal{A}_i)^+\\cap \\mathcal{A}_i=\\mathcal{A}_i\\))\n\\(\\mathcal{A}_1\\) n’est pas en FNBC car IdP → NomP, PrenomP est locale à \\(\\mathcal{A}_1\\) et IdP n’est pas une super-clef de \\(\\mathcal{A}_1\\).\n\\(\\mathcal{A}_2\\) est en FNBC car:\n\nIdM^+ ∩ \\mathcal{A}_2 = {idM, NomM, PrenomM} ∩ \\mathcal{A}_2 =IdM\n\\(DateRV^+\\cap\\mathcal{A}_2=\\left\\{dateRV\\right\\}\\cap\\mathcal{A}_2=DateRV\\)\n\\(IdInterV^+\\cap\\mathcal{A}_2=\\left\\{idInterV\\right\\}\\cap\\mathcal{A}_2=IdInterV\\)\\\n\n\\(\\mathcal{A}_3\\) est en FNBC car :\n\n\\(IdM^+\\cap\\mathcal{A}_3=\\left\\{idM,NomM,PrenomM\\right\\}\\cap\\mathcal{A}_3=\\mathcal{A}_3\\)\\\n\\(NomM^+\\cap\\mathcal{A}_3=\\left\\{nomM\\right\\}\\cap\\mathcal{A}_3=NomM\\)\\\n\\(PrenomM^+\\cap\\mathcal{A}_3=\\left\\{prenomM\\right\\}\\cap\\mathcal{A}_3=PrenomM\\)\n\n\n\n\nMêmes questions pour la décomposition :\n\n\\[\n\\begin{array}{rl}\n\\mathcal{A}_1 &=\\left\\{\\texttt{IdM,HeureRV,DateRV,IdP}\\right\\}\\\\\n\\mathcal{A}_2 &=\\left\\{\\texttt{IdP,NomP,PrenomP}\\right\\}, \\\\\n\\mathcal{A}_3 &=\\left\\{\\texttt{IdM,DateRV,IdInterV}\\right\\},\\\\\n\\mathcal{A}_4 &=\\left\\{\\texttt{IdM,NomM,PrenomM}\\right\\}\n\\end{array}\n\\]\n\n\n\n\n\n\nSolution\n\n\n\nLa décomposition est SPI. \\[\n\\begin{array}{|c|c|c|c|c|c|c|c|c|c|}\n\\hline  & IdM & NomM & PrenomM & DateRV & HeureRV & IdP & NomP & PrenomP & IdInterV \\\\\\hline\n\\hline \\mathcal{A}_1  & a & b_1 &  c_1& d & e & f & g_1 & h_1 & i_1 \\\\\n\\hline  \\mathcal{A}_2 & a_2 & b_2 & c_2 & d_2 & e_2 & f & g & h & i_2 \\\\\n\\hline \\mathcal{A}_3 & a & b_3 & c_3 & d & e_3 & f_3 & g_3 & h_3 & i \\\\\n\\hline \\mathcal{A}_4 & a & b & c & d_4 & e_4 & f_4 & g_4 & h_4 & i_4\\\\\n\\hline\n\\end{array}\n\\] (c) donne \\(b_1=b\\) et \\(c_1=c\\). (d) donne \\(g_1=g\\) et \\(h_1=h\\). (b) donne \\(i_1=i\\). La première ligne est \\((a,b,\\dots,i)\\).\\ \\ (b), (c), (d) sont préservées puisque locales.\\ Est-ce que (e) est préservée~? Initialisation \\(Z:=\\left\\{idP,DateRV,HeureRV\\right\\}\\)\\ \\((Z\\cap\\mathcal{A}_1)^+\\cap\\mathcal{A}_1=\\left\\{idP,DateRV,HeureRV\\right\\}^+\\cap\\mathcal{A}_1=\\mathcal{A}\\cap\\mathcal{A}_1=\\mathcal{A}_1\\), donc \\(Z:=\\mathcal{A}_1\\).\\ \\((Z\\cap\\mathcal{A}_3)^+\\cap\\mathcal{A}_3=\\left\\{idM,DateRV\\right\\}^+\\cap\\mathcal{A}_3=\\mathcal{A}_3\\) qui contient \\(IdInterV\\). On conclut que (e) est préservée.\\ (f) est préservée car (f) est impliquée par \\(IdP,DateRV,HeureRV\\to IdM\\) (locale à \\(\\mathcal{A}_1\\)) et (c). Est-ce que (a) est préservée~? Initialisation \\(Z:=\\left\\{idM,DateRV,HeureRV,IdInterV\\right\\}\\)\\ \\((Z\\cap\\mathcal{A}_1)^+\\cap\\mathcal{A}_1=\\left\\{idM,DateRV,HeureRV\\right\\}^+\\cap\\mathcal{A}_1=ALL\\cap\\mathcal{A}_1=\\mathcal{A}_1\\) qui contient \\(IdP\\). Donc (a) est préservée.\\ \\ car\\ \\(IdM^+\\cap\\mathcal{A}_1=IdM\\), \\(HeureRV^+\\cap\\mathcal{A}_1=HeureRV\\), \\(DateRV^+\\cap\\mathcal{A}_1=DateRV\\), \\(IdP^+\\cap\\mathcal{A}_1=IdP\\)\\ \\(\\left\\{idM,HeureRV\\right\\}^+\\cap\\mathcal{A}_1=\\left\\{idM,HeureRV\\right\\}\\), \\(\\left\\{idM,DateRV\\right\\}^+\\cap\\mathcal{A}_1=\\left\\{idM,DateRV\\right\\}\\), \\(\\left\\{idM,IdP\\right\\}^+\\cap\\mathcal{A}_1=\\left\\{idM,IdP\\right\\}\\), \\(\\left\\{heureRV,DateRV\\right\\}^+\\cap\\mathcal{A}_1=\\left\\{heureRV,DateRV\\right\\}\\), \\(\\left\\{heureRV,IdP\\right\\}^+\\cap\\mathcal{A}_1=\\left\\{heureRV,IdP\\right\\}\\), \\(\\left\\{dateRV, IdP\\right\\}^+\\cap\\mathcal{A}_1=\\left\\{dateRV, IdP\\right\\}\\)\\ car\\ \\(IdP^+\\cap\\mathcal{A}_2=\\mathcal{A}_2\\), \\(NomP^+\\cap\\mathcal{A}_2=NomP\\), \\(PrenomP^+\\cap\\mathcal{A}_2=PrenomP\\)\\ car\\ \\(IdM^+\\cap\\mathcal{A}_3=IdM\\), \\(DateRV^+\\cap\\mathcal{A}_3=DateRV\\), \\(IdInterV^+\\cap\\mathcal{A}_3=IdInterV\\)\\ car\\ \\(IdM^+\\cap\\mathcal{A}_4=\\mathcal{A}_4\\), \\(NomM^+\\cap\\mathcal{A}_4=NomM\\), \\(PrenomM^+\\cap\\mathcal{A}_4=PrenomM\\)\n\n\n\n\nExercice\nSoit une relation concernant des personnes résidant en France avec les attributs suivants:\nNom, Numéro de sécurité sociale, Commune, Département, Code postal, Numéro de téléphone\navec l’ensemble \\(\\Sigma\\) de DF suivantes~:\nNuméro de sécurité sociale → Nom, Commune, Département, Code postal, Numéro de téléphone \nCommune → Département \nCode postal → Commune, Département\n\nCe schéma est-il en forme normale de Boyce-Codd ?\n\nSoit la décomposition \\[\\mathcal{A}_1=\\left\\{\\texttt{Code postal}, \\texttt{Commune}, \\texttt{Département}\\right\\}\\] et \\[\\mathcal{A}_2=\\left\\{\\texttt{Numéro de sécurité sociale}, \\texttt{Nom}, \\texttt{Code postal},\\texttt{Numéro de téléphone}\\right\\}\\]\n\nChaque \\(\\mathcal{A}_i\\) est-elle en forme normale de Boyce-Codd ?\nCette décomposition préserve-t-elle les dépendances fonctionnelles ?\nCette décomposition est-elle sans perte d’information ?\nMêmes questions pour la décomposition \\[\\mathcal{A}_1=\\left\\{\\texttt{Commune}, \\texttt{Département}\\right\\}\\]\n\n\\[\\mathcal{A}_2=\\left\\{\\texttt{Numéro de sécurité sociale}, \\texttt{Nom}, \\texttt{Commune}, \\texttt{Code postal},\\texttt{Numéro de téléphone}\\right\\}\\]\n\n\n\n\n\n\nSolution\n\n\n\n\nNon, car on a \\(\\texttt{Commune} \\to \\texttt{Département}\\) et \\(\\texttt{Commune}\\) n’est pas une clef.\n\\(\\mathcal{A}_1\\) n’est pas en FNBC car \\(\\texttt{Commune} \\to \\texttt{Département}\\) est locale à \\(\\mathcal{A}_1\\) et \\(\\texttt{Commune}\\) n’est pas une clef de \\(\\mathcal{A}_1\\).\\ \\(\\mathcal{A}_2\\) est en FNBC puisque \\(\\pi_{\\mathcal{A}_2}(\\Sigma)\\) est équivalent à\\ \\(\\left\\{\\texttt{Numéro de sécurité sociale}\\to \\texttt{Nom, Code postal, Numéro de téléphone }\\right\\}\\)\\ Les DF sont préservées car \\(\\Sigma\\) est équivalent à\\ \\[\\{\\texttt{Numéro de sécurité sociale}\\to \\texttt{Nom, Code postal, Numéro de téléphone }\\};\\] \\[\\texttt{Commune}\\to\\texttt{Département} ;\\texttt{Code postal}\\to\\{\\texttt{Commune, Département}\\}\\] qui ne contient que des DF locales.\\ La décomposition est SPI.\n\\(\\mathcal{A}_1\\) est en FNBC car \\(\\mathcal{A}_2\\) est de cardinal 2.\\ \\(\\mathcal{A}_2\\) n’est pas en FNBC car \\(\\texttt{CodePostal} \\to \\texttt{Département}, \\texttt{Commune}\\) est locale et \\(\\texttt{CodePostal}\\) n’est pas une clé de \\(\\mathcal{A}_2\\)\\ La décomposition est SPI et préserve les DF.\n\n\n\n\n\nExercice\nSoit un schéma d’attributs \\(A_1, A_2,\\dots A_n\\) et un ensemble de dépendances fonctionnelles. Calculer le nombre de super-clefs (en fonction de \\(n\\)) dans les cas suivants~:\n\nLa seule clef est \\(\\left\\{A_1\\right\\}\\).\nLes seules clefs sont \\(\\left\\{A_1\\right\\}\\) et \\(\\left\\{A_2\\right\\}\\).\nLes seules clefs sont \\(\\left\\{A_1,A_2\\right\\}\\) et \\(\\left\\{A_3,A_4\\right\\}\\).\nLes seules clefs sont \\(\\left\\{A_1,A_2\\right\\}\\) et \\(\\left\\{A_1,A_3\\right\\}\\).\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\\(2^{n-1}\\)\n\\(2^{n-2} + 2^{n-2} + 2^{n-2}\\)\n\\(2^{n-4}Titremes 3Titremes 2 + 2^{n-4}\\)\n\\(3Titremes 2^{n-3}\\)\n\n\n\n\n\nExercice\nSoit le schéma \\(\\mathcal{A}=\\{A,B,C,D\\}\\) et l’ensemble de dépendances fonctionnelles \\[\\Sigma = \\{ A \\to B, B \\to C\\} \\]\n\nQuelle est la fermeture \\(\\{A\\}^+\\) de \\(\\{A\\}\\) ?\n\n\n\n\n\n\n\nSolution\n\n\n\nInitialisation : \\(X  =\\{A\\}\\)\nEtape 1 : Il existe une DF dont la partie gauche est incluse dans $ X$ : \\(A \\to B\\). On rajoute les attributs en partie droite.\nD’où \\(X  = \\{A, B\\}\\)\nEtape 2: Il existe une DF dont la partie gauche est incluse dans $ X$ : \\(B \\to C\\). On rajoute les attributs en partie droite.\nD’où \\(X  = \\{A,B,C\\}\\).\nC’est fini, plus de DF à utiliser. Conclusion \\(\\left\\{A\\right\\}^+=\\left\\{A,B,C\\right\\}\\)\n\n\n\nQuelles sont les super-clés ? Les clés ?\n\n\n\n\n\n\n\nSolution\n\n\n\nUne clef doit contenir \\(\\left\\{A,D\\right\\}\\) puis ces deux attributs ne sont à droite d’aucune DF de \\(\\Sigma\\). De plus \\(\\left\\{A,D\\right\\}^+=\\left\\{A,B,C,D\\right\\}\\). La seule clef est donc \\(\\{A,D\\}\\).\n\n\n\n\nExercice\nSoit le schéma \\(\\mathcal{A}=\\{A,B,C,D,E,F\\}\\) et l’ensemble de dépendances fonctionnelles \\[\\Sigma = \\Bigl\\{ \\left\\{A,B\\right\\}\\to C, \\left\\{B,C\\right\\}\\to \\left\\{A,D\\right\\}, D\\to E, \\left\\{C,F\\right\\}\\to B \\Bigr\\}\\]\n\nCalculer la fermeture \\(\\left\\{A,B\\right\\}^+\\) de \\(\\left\\{A,B\\right\\}\\).\nEst-ce que \\(\\Sigma\\) implique la dépendance fonctionnelle \\(\\left\\{A,B\\right\\}\\to D\\)~?\nEst-ce que \\(\\Sigma\\) implique la dépendance fonctionnelle \\(D\\to A\\)~?\n\n\n\n\n\n\n\nSolution\n\n\n\n\nOn obtient \\(\\left\\{A,B\\right\\}^+=\\left\\{A,B,C,D,E\\right\\}\\).\nOui car \\(D\\in\\left\\{A,B\\right\\}^+\\)\nNon car \\(\\left\\{D\\right\\}^+=\\left\\{D,E\\right\\}\\) ne contient pas \\(A\\).\n\n\n\n\n\n\nExercice\nOn considère une schéma \\(\\mathcal{A}\\) avec les attributs\nPropriétaire, Occupant, Adresse, Noapt, Nbpièces, Nbpersonnes\nUn nuplet/tuple (p, o, a, n, nb1, nb2) ayant la signification suivante : La personne o habite avec nb2 personnes l’appartement de numéro n ayant nb1 pièces dont le propriétaire est p.\nUne analyse de cette relation nous fournit un ensemble initial \\(\\Sigma\\) de dépendances fonctionnelles\nOccupant → Adresse\nOccupant → Noapt\nOccupant → Nbpersonnes\nAdresse, Noapt → Proprietaire\nAdresse, Noapt → Occupant\nAdresse, Noapt → Nbpieces\n\nDéterminer les clés du schémas\nLes schéma est-il en FN3 ?\nSi la réponse est Non, décomposer sans perte d’information et sans perte de dépendances fonctionnelles.\n\n\n\nExercice\n\nSoit le schéma \\[\\mathcal{A}=\\{\\texttt{IdLivre, Titre, Langue, Pays, IdTraducteur, Nom, Date}\\}\\] et l’ensemble de DF\nIdLivre → Titre \nLangue → Pays \nIdTraducteur → Nom \nIdLivre, IdTraducteur, Langue → Date\nIdLivre, IdTraducteur → Langue\nAppliquer l’algorithme de décomposition vu en cours pour obtenir une décomposition de \\(\\mathcal{A}\\) qui respecte la FNBC et est sans perte d’information. Déterminer quelles DF sont préservées.\n\n\n\n\n\n\nSolution\n\n\n\n\\(\\texttt{IdLivre}^+=\\texttt{IdLivre, Titre}\\) \\[ \\mathcal{A}_1=\\texttt{IdLivre,Titre} \\quad \\mathcal{A}_2=\\texttt{IdLivre, Langue, Pays, IdTraducteur, Nom, Date}\\] \\(\\texttt{Langue}^+= \\texttt{Langue, Pays}\\) \\[ \\mathcal{A}_{2,1}=\\texttt{Langue, Pays} \\quad \\mathcal{A}_{2,2}=\\texttt{IdLivre, Langue, IdTraducteur, Nom, Date} \\] \\(\\texttt{IdTraducteur}^+=\\texttt{IdTraducteur, Nom}\\) \\[ \\mathcal{A}_{221}=\\texttt{IdTraducteur, Nom} \\quad \\mathcal{A}_{222}=\\texttt{IdLivre,Langue, IdTraducteur, Date}\\] La décomposition FNBC obtenue est \\[ \\{\\texttt{IdLivre,Titre} \\}\\quad \\{\\texttt{Langue, Pays}\\} \\quad \\{\\texttt{IdTraducteur, Nom}\\} \\quad \\{\\texttt{IdLivre,Langue, IdTraducteur, Date}\\}\\] qui préserve toutes les DF.\n\n\n\n\nExercice\nSoit le schéma \\[\\mathcal{A}=\\left\\{\\texttt{A,B,C,D,E,F,G,H}\\right\\}\\] et l’ensemble de DF\nBE → AC  \nB → H  \nF → CD  \nD → G\n\nAppliquer l’algorithme de décomposition vu en cours pour obtenir une décomposition de \\(\\mathcal{A}\\) qui respecte la FNBC et est sans perte d’information. Déterminer quelles DF sont préservées.\nPeut-on, en ajoutant un sous-schéma à la décomposition, obtenir une décomposition FNBC sans perte d’information et sans perte de DF ?\n\n\n\n\n\n\n\nSolution\n\n\n\nRappelons l’algorithme pour décomposer un schéma \\(\\mathcal{A}\\)~:\n\nOn considère la décomposition initiale \\(\\rho=\\{\\mathcal{A}\\}\\).\nTant qu’il existe un sous-schéma \\(\\mathcal{B}\\in\\rho\\) et \\(X\\subset \\mathcal{B}\\) tels que \\(X^+\\cap\\mathcal{B}\\not=X\\) et \\(X^+\\cap\\mathcal{B}\\not=\\mathcal{B}\\) (ce qui signifie que la DF locale \\(X\\to X^+\\cap\\mathcal{B}\\) est une violation de FNBC pour \\(\\mathcal{B}\\)), on remplace \\(\\mathcal{B}\\) par les deux sous-schémas \\[\\mathcal{B}_1=X^+\\cap\\mathcal{B} \\text{ et } \\mathcal{B}_2=(\\mathcal{B}\\setminus X^+)\\cup X\\] De plus il n’y a pas besoin de considérer les parties \\(X\\subset\\mathcal{B}\\) telles que \\(card(X)=card(\\mathcal{B})-1\\) puisque dans ce cas on \\(X^+\\cap \\mathcal{B}=X\\) ou \\(X^+\\cap\\mathcal{B}=\\mathcal{B}\\).\n\nIl est garanti que la décomposition finale est en FNBC et SPI. Par contre toutes les DF ne sont pas préservées en général. De plus on obtient, en général, des décompositions différentes si on change les DF (violant FNBC) utilisées. } - \\(BE^+=BEACH\\) donc on remplace \\(\\mathcal{A}\\) par \\[ \\mathcal{A}_1=BEACH \\quad \\mathcal{A}_2=BDEFG\\] \\(B^+=BH\\) donc on remplace \\(\\mathcal{A}_1\\) par \\[\\mathcal{A}_{11}=BH \\quad \\mathcal{A}_{12}=BEAC\\] \\(\\mathcal{A}_{11}\\) est en FNBC car de cardinal 2. \\(\\mathcal{A}_{12}\\) est en FNBC car \\[B^+\\cap\\mathcal{A}_{12}=B, E^+\\cap\\mathcal{A}_{12}=E, A^+\\cap\\mathcal{A}_{12}=A, C^+\\cap\\mathcal{A}_{12}=C \\] \\[BE^+\\cap\\mathcal{A}_{12}=BEAC, BA^+\\cap\\mathcal{A}_{12}=BA, BC^+\\cap\\mathcal{A}_{12}=BC, EA^+\\cap\\mathcal{A}_{12}=EA, EC^+\\cap\\mathcal{A}_{12}=EC\\] \\[ AC^+\\cap\\mathcal{A}_{12}=AC\\] \\(D^+=DG\\) donc on remplace \\(\\mathcal{A}_2\\) par \\[\\mathcal{A}_{21}=DG \\quad \\mathcal{A}_{22}=BDEF\\] \\(\\mathcal{A}_{21}\\) est en FNBC car de cardinal 2. \\(F^+=CD\\) donc on remplace \\(\\mathcal{A}_{22}\\) par \\[\\mathcal{A}_{221}=FD \\quad \\mathcal{A}_{222}=BEF\\] qui sont tous deux en FNBC\nDécomposition obtenue~:\nBH  BEAC  DG  FD  BEF\nLa seule DF qui n’est pas préservée est \\(F\\to C\\). Toutes les variantes (en changeant les DF utilisées) que j’ai testées, donne une décomposition qui ne préserve pas toutes les DF. Bien sûr ce n’est pas une preuve que l’algorithme ne peut pas donner une décomposition sans perte de DF. - En ajoutant \\(FC\\) à la décomposition précédente, on obtient\nBH   BEAC   DG   FD   BEF   FC\nqui est en FNBC et préserve les DF. De plus elle est SPI puisque la décomposition initiale est SPI. (\\(R \\bowtie \\pi_{FC}(R)=R\\) pour toute relation \\(R\\))\n\n\n\n\nExercice\nReprendre les questions de l’exercice précédent pour le schéma \\[\\mathcal{A}=\\left\\{\\texttt{A,B,C,D,E,F,G,H}\\right\\}\\] et l’ensemble de DF\nBE → AC  \nB → H\nF → CD\nD → G\nA→ E\n\n\n\n\n\n\nSolution\n\n\n\n\nDe manière similaire à l’exercice précédent on arrive à\n\nBH   BEAC   DG   FD   BEF\nmais, ici, BEAC n’est pas en FNBC (les autres le sont). A^+=AE donc on remplace BEAC par AE et ABC. Une décomposition FNBC est donc BH   AE   ABC   DG   FD   BEF Les DF BE → AC et F → C ne sont pas préservées. Les autres sont préservées.\n\nIl n’existe de décomposition FNBC qui préserve BE → A. En effet, si BE → A est préservée, il existe une DF locale à un sous-schéma \\(\\mathcal{B}\\) de la forme X → A. Cela implique que BE ⊂ X et donc BEA ⊂ B. Par suite \\(\\mathcal{B}\\) n’est pas en FNBC à cause de \\(A^+=AE\\)."
  },
  {
    "objectID": "workshops/td-admin.html#administration-sous-postgres",
    "href": "workshops/td-admin.html#administration-sous-postgres",
    "title": "MA15Y030 - Automne 2024",
    "section": "Administration sous Postgres",
    "text": "Administration sous Postgres\nDes outils d’administration importants d’une base de données postgres se trouvent dans deux schémas appelés :\n\ninformation_schema\npg_catalog\n\nCes deux schémas et les tables qu’ils contiennent permettent de retrouver toutes les informations concernant les schémas, tables, utilisateurs, fonctions, etc présentes dans la base de données.\nPour faciliter l’administration de la base et obtenir un certain nombre d’informations basiques, des commandes sont définies dans postgres. On peut en avoir la liste par l’instruction \\? (vous connaissez déjà \\d). Ces commandes sont, en fait, des raccourcis (des macros) en lieu et place de requêtes SQL plus ou moins complexes portant sur les objets des schémas information_schema et pg_catalog.\nLes questions ci-dessous permettent de faire connaissance avec les schémas d’administration à travers quelques requêtes à générer.\n\nDans information_schema la table tables contient le nom (et bien plus) des tables de la base. Examinez la structure de la table tables par l’instruction \\d information_schema.tables (il faut au préalable fixer le search_path pour y inclure information_schema).\n\nLister juste les noms de toutes les tables.\nselect table_name \nfrom information_schema.tables\n\nEn utilisant seulement la table tables de information_schema, lister les noms des tables du schema world puis du schéma information_schema\n\nselect table_name \nfrom information_schema.tables\nwhere table_schema='world';\n\nselect table_name \nfrom information_schema.tables\nwhere table_schema='information_schema'\n\nD’après la requête précédente, une des tables du schéma information_schema s’appelle schemata.\n\nExaminer cette table et en déduire une liste de tous les schémas de la base\nselect schema_name \nfrom information_schema.schemata\n\nUne des tables du schéma information_schema s’appelle columns. Essayez de comprendre la nature des informations présentes dans cette table. Écrire une requête qui renvoie les mêmes informations que l’instruction \\d world.country. Améliorer votre requête pour qu’elle affiche exactement la même chose que \\d world.country.\n\n\nselect column_name as Column, data_type as Type, is_nullable as Modifiers\nfrom information_schema.columns\nwhere table_name='country' and table_schema='world'\nAlternativement\nselect column_name as Column, data_type as Type, (CASE\n WHEN is_nullable='NO'\n THEN 'not null'\n ELSE NULL\n END) as Modifiers\n    from information_schema.columns\n    where table_name='country' and table_schema='world'\n\nListez les noms de tables qui apparaissent dans au moins deux schémas. On donnera aussi les (deux) schémas concernés dans le résultat.\n\nselect t.table_name, q.table_schema, t.table_schema\nfrom information_schema.tables t, information_schema.tables q\nwhere t.table_schema&lt;&gt;q.table_schema and t.table_name=q.table_name;\n\nListez les noms de colonnes (attributs) qui apparaissent dans au moins deux tables du même schéma. On donnera aussi le nom des tables et du schéma dans le résultat (on pourra exclure information_schema et pg_catalog).\n\nselect t1.column_name as Column, t1.table_name as table1,\nt2.table_name as table2, t1.table_schema as schema\nfrom information_schema.columns t1, information_schema.columns t2\nwhere\nt1.table_name&lt;&gt;t2.table_name and t1.table_schema=t2.table_schema and\nt1.column_name=t2.column_name and t1.table_schema&lt;&gt;'pg_catalog' and\nt1.table_schema&lt;&gt;'information_schema';\n\nListez les définitions de toutes les vues que vous avez écrites. Listez celles qui commencent pas ‘q’.\n\n```{.sql}\nselect schemaname, definition from pg_views where schemaname=current_USER;\nselect schemaname, definition from pg_views where schemaname=current_USER and viewname like ‘q%’; ```\n\nLa vue pg_roles contient les identifiants des différents rôles. Trouvez celui du rôle isifar2022.\n\nselect rolname,oid  from pg_roles where rolname='isifar2022'\n\nÀ l’aide de la réponse à la question précédente, listez les noms des schémas des utilisateurs (rôles) qui ont aussi le rôle isifar2022\n\nAttention, nécessite de changer les droits de consultation de ces tables pour les utilisateurs standards.\nselect schema_name from information_schema.schemata, pg_roles\nwhere schemata.schema_name=pg_roles.rolname and\npg_roles.oid in (select member from pg_auth_members where roleid=78094)"
  },
  {
    "objectID": "workshops/td-admin.html#droits",
    "href": "workshops/td-admin.html#droits",
    "title": "MA15Y030 - Automne 2024",
    "section": "Droits",
    "text": "Droits\n\nCréer dans votre schéma une table matable_etudiant par copie de la table datatpadmin du schema durand. Sélectionner les tuples de la table crée : il contiennent des informations (aléatoire) pour chacun des utilisateurs du groupe.\n\nDonner les droits de sélection sur cette table à l’utilisateur de votre choix ou au groupe entier). Vérifier que cela marche.\nEnlever les droits de sélection à cet utilisateur\n\nOn suppose maintenant que vous souhaitez accorder des droits de sélection à chacun des étudiants du groupe mais uniquement pour les données qui le concerne. Par exemple, s’il existe des tuples dont la valeur pour identifiant est johnsmith, l’utilisateur johnsmith doit pouvoir sélectionner ces tuples mais aucun autre. Proposez une manière de réaliser cette politique de sécurité ?\n\nIndication: on pourra s’appuyer sur la création d’une vue. Regardez aussi la documentation de la variable CURRENT_USER.\nOn peut prendre temporairement l’identité d’un utilisateur x par : set role x.\n% la table datatpadmin contient deux colonnes : identifiant et écart. Identifiant prend ses valeurs dans la liste des schémas d’étudiants ISIFAR2022. La table a été obtenue à partir de celle des résultats du contrôle continu.\ncreate view student_view as select * from durand.datatpadmin\nwhere identifiant=current_user;\ngrant usage on schema durand  to isifar2022;\ngrant select on durand.student_view to isifar2022;\n\nDans la continuité de la question précédente, accordez à chaque utilisateur le droit de modifier les tuples qui le concerne dans votre table."
  },
  {
    "objectID": "workshops/td1.html#schémas",
    "href": "workshops/td1.html#schémas",
    "title": "Récapitulatif",
    "section": "Schémas",
    "text": "Schémas\nLes schémas sont une abstraction spécifique à PostgreSQL. Les schémas permettent de faire cohabiter sur une même base de données (ou catalogue dans le jargon PostgreSQL) plusieurs ensembles d’informations de nature différentes. On peut indiquer à pgcli, psql ou un autre client (dbeaver ou autre) quels schémas on veut utiliser par défaut.\nDans ce TP, nous allons nous concentrer sur le schéma world qui contient des informations concernant des villes et des pays/territoires du monde entier. Au cours de ce semestre, nous serons amenés à utiliser d’autres schémas : pagila qui contient des informations concernant des films, …\nPour lister et modifier les schémas de votre environnement de travail:\nbd_2023-24&gt; SHOW search_path ;                  -- lister\nbd_2023-24&gt; SET search_path TO world, public ;  -- modifier\nbd_2023-24&gt; SHOW search_path ;       -- visualiser \nLister les schémas du catalogue bd_2023-24.\n\\dn\nPour lister les tables des schemas inscrits sur votre search_path.\nbd_2023-24&gt; \\d\n+----------+---------------------+--------+----------+\n| Schema   | Name                | Type   | Owner    |\n|----------+---------------------+--------+----------|\n| world    | city                | table  | postgres |\n| world    | country             | table  | postgres |\n| world    | countrylanguage     | table  | postgres |\n+----------+---------------------+--------+----------+\nVue d’ensemble du schéma world"
  },
  {
    "objectID": "workshops/td1.html#suggestion",
    "href": "workshops/td1.html#suggestion",
    "title": "Récapitulatif",
    "section": "Suggestion",
    "text": "Suggestion\nSi vous travaillez avec pgcli/psql, utilisez en local votre éditeur préféré (emacs, vi, sublime text, visual studio code, …), transférez votre script sql grâce à scp, et chargez le script dans votre session psql/pgcli à l’aide de \\\\i."
  },
  {
    "objectID": "workshops/td1.html#tables",
    "href": "workshops/td1.html#tables",
    "title": "Récapitulatif",
    "section": "Tables",
    "text": "Tables\nPour voir la définition (c’est-à-dire les différentes colonnes) d’une table:\nbd_2023-24&gt; \\d world.country\n\n+--------------------+---------------+-------------+\n| Column             | Type          | Modifiers   |\n|--------------------+---------------+-------------|\n| countrycode        | character(3)  |  not null   |\n| name_country       | text          |  not null   |\n| continent          | text          |  not null   |\n| region             | text          |  not null   |\n| surfacearea        | real          |  not null   |\n| indepyear          | smallint      |             |\n| population_country | integer       |  not null   |\n| lifeexpectancy     | real          |             |\n| gnp                | numeric(10,2) |             |\n| gnpold             | numeric(10,2) |             |\n| localname          | text          |  not null   |\n| governmentform     | text          |  not null   |\n| headofstate        | text          |             |\n| capital            | integer       |             |\n| code2              | character(2)  |  not null   |\n+--------------------+---------------+-------------+"
  },
  {
    "objectID": "workshops/td1.html#explorer-les-possibilités-de-psql-ou-de-pgcli",
    "href": "workshops/td1.html#explorer-les-possibilités-de-psql-ou-de-pgcli",
    "title": "Récapitulatif",
    "section": "Explorer les possibilités de psql ou de pgcli",
    "text": "Explorer les possibilités de psql ou de pgcli\nbd_2023-24&gt; \\?\nDans la deuxième partie du TP, on s’intéresse aux requêtes, c’est-à-dire, les moyens d’extraire une information pertinente d’une base de données."
  },
  {
    "objectID": "workshops/td4bis.html#over-partition-by",
    "href": "workshops/td4bis.html#over-partition-by",
    "title": "Fonctions fenêtres/Window functions",
    "section": "OVER (PARTITION BY …)",
    "text": "OVER (PARTITION BY …)\nCette construction peut être combinée avec n’importe quelle fonction d’aggrégation.\nCette requête indique pour chaque ville, la “population moyenne” des villes de ce pays (cette moyenne n’a aucun sens).\nSELECT id, name_city, population_city, \n       avg(population_city) OVER (PARTITION BY countrycode)  AS avg_pop\nFROM world.city;  \nSans le mécanisme de fenêtrage, on pourrait obtenir le résultat au prix d’une jointure\n WITH tmp AS (\n  SELECT c.countrycode, AVG(c.population_city) AS avg_pop\n  FROM world.city c\n  GROUP BY c.countrycode\n ) \n  SELECT cc.id, cc.name_city, cc.population_city, tmp.avg_pop\n  FROM world.city cc NATURAL JOIN tmp;"
  },
  {
    "objectID": "workshops/td4bis.html#over-partition-by-order-by",
    "href": "workshops/td4bis.html#over-partition-by-order-by",
    "title": "Fonctions fenêtres/Window functions",
    "section": "OVER (PARTITION BY … ORDER BY)",
    "text": "OVER (PARTITION BY … ORDER BY)\nOn peut partitioner et trier.\nCette construction est très pratique pour ranger les tuples d’un sous-groupe.\nDans world, si on veut ranger les langues parlées dans un pays par popularité décroissante, on peut procéder ainsi.\nSELECT countrycode, LANGUAGE, \nRANK() OVER (PARTITION BY countrycode ORDER BY percentage DESC)  AS rnk\nFROM world.countrylanguage ;"
  },
  {
    "objectID": "workshops/td4bis.html#rank-over",
    "href": "workshops/td4bis.html#rank-over",
    "title": "Fonctions fenêtres/Window functions",
    "section": "RANK() OVER ()",
    "text": "RANK() OVER ()\nOn peut ne pas partitionner en utilisant l’expression OVER (). Par exemple, si on veut obtenir le rang des tuples d’une table sur un tri particulier.\nSELECT countrycode, name_country, \n       RANK() OVER (ORDER BY population_country DESC)  AS rnk\nFROM world.country ;"
  },
  {
    "objectID": "workshops/td4bis.html#autres-types-de-fenêtres",
    "href": "workshops/td4bis.html#autres-types-de-fenêtres",
    "title": "Fonctions fenêtres/Window functions",
    "section": "Autres types de fenêtres",
    "text": "Autres types de fenêtres\nLa construction OVER ( ...) n’est pas utilisée exclusivement avec des partitions (peut-être triviales), on peut aussi définir des fenêtres glissantes.\nLes fonctions fenêtre ne sont autorisées que dans la liste SELECT et la clause ORDER BY de la requête. Elles sont interdites ailleurs, par exemple dans les clauses GROUP BY, HAVING et WHERE."
  },
  {
    "objectID": "workshops/td4bis.html#forme-générale",
    "href": "workshops/td4bis.html#forme-générale",
    "title": "Fonctions fenêtres/Window functions",
    "section": "Forme générale",
    "text": "Forme générale\nCREATE OR REPLACE FUNCTION  schema_name.func_name(p_arg1 p_arg1_datatype, ..., [OUT o_arg1 o_arg1_datatype, ...])\nRETURNS some type | RECORD | SETOF some type | TABLE (..) \nLANGUAGE SQL AS\n$$\nSQL statement ;\nSQL statement ;\n...\nSQL statement ;\n$$ ;"
  },
  {
    "objectID": "workshops/td4bis.html#fonctions-qui-retournent-un-type-simple",
    "href": "workshops/td4bis.html#fonctions-qui-retournent-un-type-simple",
    "title": "Fonctions fenêtres/Window functions",
    "section": "Fonctions qui retournent un type simple",
    "text": "Fonctions qui retournent un type simple\nDans le schéma world, on veut écrire une fonction qui prend en argument une région et renvoie la population maximale parmi les capitales de la région (voir td2 requête 1).\nCREATE OR REPLACE FUNCTION username.taille_max_capitale_region(p_region text)\nRETURNS INTEGER LANGUAGE SQL AS\n$$\nSELECT MAX(population_city) AS max_pop\nFROM world.country c JOIN world.city cc ON (c.capital=cc.id)\nWHERE c.region=p_region AND cc.population_city IS NOT NULL;\n$$ ;"
  },
  {
    "objectID": "workshops/td4bis.html#fonctions-qui-retournent-un-type-composé",
    "href": "workshops/td4bis.html#fonctions-qui-retournent-un-type-composé",
    "title": "Fonctions fenêtres/Window functions",
    "section": "Fonctions qui retournent un type composé",
    "text": "Fonctions qui retournent un type composé\nDans le schéma world, on veut écrire une fonction qui prend en argument une région et renvoie le nom et la population de la capitale la plus peuplée de cette région (voir td2 requête 1).\nOn peut utiliser le qualifiant OUT pour désigner des paramètres de sortie.\nCREATE OR REPLACE FUNCTION username.capitale(p_region text, OUT o_name_capital TEXT, OUT o_population_capital INTEGER)\nRETURNS RECORD  LANGUAGE SQL AS\n$$\nWITH r AS(\n  SELECT cc.*, RANK() OVER (PARTITION BY c.region \n                            ORDER BY cc.population_city DESC) AS rnk\n  FROM world.country c JOIN world.city cc ON (c.capital=cc.id)\n  WHERE c.region=p_region)\nSELECT r.name_city,  r.population_city\nFROM r \nWHERE r.rnk = 1 ;\n$$ ;"
  },
  {
    "objectID": "workshops/td4bis.html#fonctions-qui-retournent-un-type-composé-défini-par-les-lignes-dune-table",
    "href": "workshops/td4bis.html#fonctions-qui-retournent-un-type-composé-défini-par-les-lignes-dune-table",
    "title": "Fonctions fenêtres/Window functions",
    "section": "Fonctions qui retournent un type composé défini par les lignes d’une table",
    "text": "Fonctions qui retournent un type composé défini par les lignes d’une table\nDans le schéma world, on veut écrire une fonction qui prend en argument une région et renvoie la description de la capitale la plus peuplée de cette région (voir td2 requête 1).\nCREATE OR REPLACE FUNCTION username.capitale(p_region text)\nRETURNS world.city  LANGUAGE SQL AS\n$$\nWITH r AS(\n  SELECT cc.*, RANK() OVER (PARTITION BY c.region \n                            ORDER BY cc.population_city DESC) AS rnk\n  FROM world.country c JOIN world.city cc ON (c.capital=cc.id)\n  WHERE c.region=p_region\n)\nSELECT r.id, r.name_city, r.countrycode, r.district, r.population_city\nFROM r \nWHERE r.rnk = 1 ;\n$$ ;"
  },
  {
    "objectID": "workshops/td4bis.html#fonctions-qui-retournent-une-table",
    "href": "workshops/td4bis.html#fonctions-qui-retournent-une-table",
    "title": "Fonctions fenêtres/Window functions",
    "section": "Fonctions qui retournent une table",
    "text": "Fonctions qui retournent une table\nDans le schéma world, on veut écrire une fonction qui prend en argument une région et renvoie la table des capitales de la région (voir td2 requête 1).\n\nTable de schéma explicite\nOn se contente d’abord de renvoyer le nom de la capitale. On explicite le schéma de la table résultat\nCREATE OR REPLACE FUNCTION username.capitales_region(p_region text)\nRETURNS TABLE (name_capital text) LANGUAGE SQL AS\n$$\nSELECT cc.name_city \nFROM world.country c JOIN world.city cc ON (c.capital=cc.id)\nWHERE c.region=p_region ;\n$$ ;\n\n\nTable de même schéma qu’une autre table\nDocumentation\nOn veut maintenant récupérer une table de même schéma que city.\n\n\n\n\n\n\nLa solution est très simple. On profite de ce qu’à chaque table correspond un type de même nom et on utilise le mot-clé SETOF.\n\n\n\nCREATE OR REPLACE FUNCTION username.capitales_region_large(p_region text)\nRETURNS SETOF world.city  LANGUAGE SQL AS\n$$\nSELECT cc.* \nFROM world.country c JOIN world.city cc ON (c.capital=cc.id)\nWHERE c.region=p_region ;\n$$ ;"
  },
  {
    "objectID": "workshops/td11.html",
    "href": "workshops/td11.html",
    "title": "MA15Y030 - Automne 2024",
    "section": "",
    "text": "L3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2024-2025\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\n\nExercice\nSoit le schéma \\[\\mathcal{A}=\\left\\{\\texttt{A,B,C,D,E,F,G,H}\\right\\}\\] et l’ensemble de DF\nBE → AC  \nB → H  \nF → CD  \nD → G\n\nAppliquer l’algorithme de décomposition vu en cours pour obtenir une décomposition de \\(\\mathcal{A}\\) qui respecte la FNBC et est sans perte d’information. Déterminer quelles DF sont préservées.\nPeut-on, en ajoutant un sous-schéma à la décomposition, obtenir une décomposition FNBC sans perte d’information et sans perte de DF ?\n\n\n\n\n\n\n\nSolution\n\n\n\nRappelons l’algorithme pour décomposer un schéma \\(\\mathcal{A}\\)~:\n\nOn considère la décomposition initiale \\(\\rho=\\{\\mathcal{A}\\}\\).\nTant qu’il existe un sous-schéma \\(\\mathcal{B}\\in\\rho\\) et \\(X\\subset \\mathcal{B}\\) tels que \\(X^+\\cap\\mathcal{B}\\not=X\\) et \\(X^+\\cap\\mathcal{B}\\not=\\mathcal{B}\\) (ce qui signifie que la DF locale \\(X\\to X^+\\cap\\mathcal{B}\\) est une violation de FNBC pour \\(\\mathcal{B}\\)), on remplace \\(\\mathcal{B}\\) par les deux sous-schémas \\[\\mathcal{B}_1=X^+\\cap\\mathcal{B} \\text{ et } \\mathcal{B}_2=(\\mathcal{B}\\setminus X^+)\\cup X\\] De plus il n’y a pas besoin de considérer les parties \\(X\\subset\\mathcal{B}\\) telles que \\(card(X)=card(\\mathcal{B})-1\\) puisque dans ce cas on \\(X^+\\cap \\mathcal{B}=X\\) ou \\(X^+\\cap\\mathcal{B}=\\mathcal{B}\\).\n\nIl est garanti que la décomposition finale est en FNBC et SPI. Par contre toutes les DF ne sont pas préservées en général. De plus on obtient, en général, des décompositions différentes si on change les DF (violant FNBC) utilisées. } - \\(BE^+=BEACH\\) donc on remplace \\(\\mathcal{A}\\) par \\[ \\mathcal{A}_1=BEACH \\quad \\mathcal{A}_2=BDEFG\\] \\(B^+=BH\\) donc on remplace \\(\\mathcal{A}_1\\) par \\[\\mathcal{A}_{11}=BH \\quad \\mathcal{A}_{12}=BEAC\\] \\(\\mathcal{A}_{11}\\) est en FNBC car de cardinal 2. \\(\\mathcal{A}_{12}\\) est en FNBC car \\[B^+\\cap\\mathcal{A}_{12}=B, E^+\\cap\\mathcal{A}_{12}=E, A^+\\cap\\mathcal{A}_{12}=A, C^+\\cap\\mathcal{A}_{12}=C \\] \\[BE^+\\cap\\mathcal{A}_{12}=BEAC, BA^+\\cap\\mathcal{A}_{12}=BA, BC^+\\cap\\mathcal{A}_{12}=BC, EA^+\\cap\\mathcal{A}_{12}=EA, EC^+\\cap\\mathcal{A}_{12}=EC\\] \\[ AC^+\\cap\\mathcal{A}_{12}=AC\\] \\(D^+=DG\\) donc on remplace \\(\\mathcal{A}_2\\) par \\[\\mathcal{A}_{21}=DG \\quad \\mathcal{A}_{22}=BDEF\\] \\(\\mathcal{A}_{21}\\) est en FNBC car de cardinal 2. \\(F^+=CD\\) donc on remplace \\(\\mathcal{A}_{22}\\) par \\[\\mathcal{A}_{221}=FD \\quad \\mathcal{A}_{222}=BEF\\] qui sont tous deux en FNBC\nDécomposition obtenue~:\nBH  BEAC  DG  FD  BEF\nLa seule DF qui n’est pas préservée est \\(F\\to C\\). Toutes les variantes (en changeant les DF utilisées) que j’ai testées, donne une décomposition qui ne préserve pas toutes les DF. Bien sûr ce n’est pas une preuve que l’algorithme ne peut pas donner une décomposition sans perte de DF. - En ajoutant \\(FC\\) à la décomposition précédente, on obtient\nBH   BEAC   DG   FD   BEF   FC\nqui est en FNBC et préserve les DF. De plus elle est SPI puisque la décomposition initiale est SPI. (\\(R \\bowtie \\pi_{FC}(R)=R\\) pour toute relation \\(R\\))\n\n\n\n\nExercice\nReprendre les questions de l’exercice précédent pour le schéma \\[\\mathcal{A}=\\left\\{\\texttt{A,B,C,D,E,F,G,H}\\right\\}\\] et l’ensemble de DF\nBE → AC  \nB → H\nF → CD\nD → G\nA→ E\n\n\n\n\n\n\nSolution\n\n\n\n\nDe manière similaire à l’exercice précédent on arrive à\n\nBH   BEAC   DG   FD   BEF\nmais, ici, BEAC n’est pas en FNBC (les autres le sont). A^+=AE donc on remplace BEAC par AE et ABC. Une décomposition FNBC est donc BH   AE   ABC   DG   FD   BEF Les DF BE → AC et F → C ne sont pas préservées. Les autres sont préservées.\n\nIl n’existe de décomposition FNBC qui préserve BE → A. En effet, si BE → A est préservée, il existe une DF locale à un sous-schéma \\(\\mathcal{B}\\) de la forme X → A. Cela implique que BE ⊂ X et donc BEA ⊂ B. Par suite \\(\\mathcal{B}\\) n’est pas en FNBC à cause de \\(A^+=AE\\)."
  },
  {
    "objectID": "workshops/td2.html#schéma-world-rappel",
    "href": "workshops/td2.html#schéma-world-rappel",
    "title": "MA15Y030 - Automne 2024",
    "section": "Schéma world (rappel)",
    "text": "Schéma world (rappel)\nUtiliser les commandes suivantes pour retrouver les schémas de tables country, countrylanguage et city.\nbd_2023&gt; \\d world.\"nom de table\"\nVue d’ensemble du schéma world"
  },
  {
    "objectID": "workshops/td2.html#écriture-de-requêtes",
    "href": "workshops/td2.html#écriture-de-requêtes",
    "title": "MA15Y030 - Automne 2024",
    "section": "Écriture de requêtes",
    "text": "Écriture de requêtes\nPour extraire des informations d’une base de données, on utilise l’algèbre relationnelle (pour la théorie) et le langage SQL (pour la pratique).\n\n\n\n\n\n\n\n\nOpération\nAlgèbre rel.\nSQL\n\n\n\n\nProjection\n\\(\\Pi_{\\text{liste d'attributs}}(R)\\)\nSELECT attributs FROM  R\n\n\nSélection\n\\({\\Large \\sigma}_{\\text{condition}}{R}\\)\nSELECT * FROM R WHERE condition\n\n\nRenommage\n\\(\\rho_{\\text{nom1} \\rightarrow \\text{nom2}}(R)\\)\nSELECT nom1 AS nom2 FROM table1 AS table2\n\n\nUnion\n\\(R \\cup S\\)\n(SELECT * FROM R) UNION (SELECT * FROM S)\n\n\nDifférence\n\\(R - S\\)\n(SELECT * FROM R) EXCEPT (SELECT * FROM S)\n\n\nProduit\n\\(R \\times S\\)\nSELECT * FROM R,S\n\n\nIntersection\n\\(R \\cap S\\)\n(SELECT * FROM R) INTERSECT (SELECT * FROM S)"
  },
  {
    "objectID": "workshops/td2.html#opérations-avancées",
    "href": "workshops/td2.html#opérations-avancées",
    "title": "MA15Y030 - Automne 2024",
    "section": "Opérations avancées",
    "text": "Opérations avancées\n\nJointures\nLa jointure est une opération qui permet de recoller deux relations ensemble. On la note avec le signe \\(\\bowtie_C\\) où \\(C\\) est une condition. Formellement, ce n’est qu’une sélection selon la condition \\(C\\) d’un produit cartésien, c’est-à-dire, par définition : \\[R {\\Large \\bowtie}_C S = {\\Large \\sigma}_{C}{(R \\times S)}.\\]\nCette opération est très courante dans les requêtes. Cela vient du fait que les bases de données sont conçues pour ne pas avoir d’information redondante.\nPrenons l’exemple du schéma world et des tables world.country et world.city. La table world.country possède une colonne capital qui contient le numéro d’identification d’une ville de la table world.city. Par exemple, pour la France, la colonne capital vaut 2974 et la ville numéro 2974 est Paris:\nbd_2023-24&gt; SELECT capital \nFROM world.country \nWHERE countrycode='FRA';\nbd_2023-24&gt; SELECT name \nFROM world.city \nWHERE id = 2974;\nPour lister les noms des capitales mondiales, on va avoir besoin de recoller les deux tables en prenant soin de respecter la condition d’égalité entre la capitale et le numéro d’identification de la ville. Cela peut s’écrire en SQL comme suit:\nSELECT name\nFROM world.city AS V JOIN \n     world.country AS P ON \n     V.id = P.capital;\nParfois, on veut recoller deux tables avec la condition que les colonnes qui ont le même nom doivent être égales. Cela arrive souvent si la base de données a bien été conçue. On appelle cette jointure une jointure naturelle, qu’on peut écrire avec NATURAL JOIN. La requête\nSELECT name \nFROM world.city NATURAL JOIN world.country\nWHERE continent = 'Oceania';\nrenvoie la liste des villes d’Océanie. La jointure est faite implicitement sur la condition\nworld.city.countrycode = world.country.countrycode\nla table résultante n’aura qu’une seule colonne countrycode. Si l’on souhaite ne faire la jointure naturelle que sur un sous-ensemble a1,...,ak des attributs communs, on peut utiliser JOIN ... USING (a1,...,ak).\n\n\nRequêtes nommées : utilisation de WITH\nLorsque les requêtes se compliquent, il est parfois commode de la découper en plusieurs requêtes qu’on manipulera par la suite. Par exemple, trouver le nom des capitales européennes ayant plus d’un million d’habitants peut se découper ainsi: on résout la requête CAP qui contient le nom, le continent et la population des capitales. Puis on résout la requête finale en filtrant CAP. Cela peut s’écrire avec l’opérateur WITH:\nWITH CAP AS (\nSELECT name, continent, population\nFROM world.city AS V JOIN \n     world.country AS P ON  V.id=P.capital\n)\n\nSELECT name\nFROM CAP\nWHERE continent = 'Europe' AND population &gt; 1000000;"
  },
  {
    "objectID": "workshops/td2.html#requêtes",
    "href": "workshops/td2.html#requêtes",
    "title": "MA15Y030 - Automne 2024",
    "section": "Requêtes",
    "text": "Requêtes\n\nQuels sont les noms des capitales Sud-Américaines ? (14 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT name\n  FROM world.city JOIN world.country ON capital=id\n WHERE continent = 'South America';\n\n\n\nQuels sont les noms des pays où le français est langue officielle ? (18 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT name_country\nFROM world.country NATURAL JOIN world.countrylanguage\nWHERE isofficial AND language='French';\n\n\n\nQuels sont les pays dont le gouvernement est monarchique (constitutionnelle ou pas) ? (43 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT name_country \nFROM world.country \nWHERE governmentform LIKE '%Monarchy%';\n\n\n\nQuelles sont les monarchies d’Europe dont la capitale compte moins d’un million d’habitants ? (8 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH T1 AS (\n  SELECT *\n  FROM world.country\n  WHERE governmentform LIKE '%Monarchy%' AND continent='Europe' )\n\nSELECT name_country\nFROM T1 JOIN world.city ON capital=id\nWHERE population &lt; 1000000;\n\n\n\nQuelles sont les régions où on ne trouve pas de monarchie ? (9 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH monarchy AS (\n  SELECT region\n  FROM world.country\n  WHERE governmentform LIKE '%Monarchy%')\n\n(SELECT region \n FROM world.country) \nEXCEPT \n(SELECT * \n FROM monarchy);\n\n\n\nQuelles sont les langues qui ne sont langues officielles dans aucun pays ? (355 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS (\n  SELECT language \n  FROM world.countrylanguage \n  WHERE isofficial)\n\n(SELECT DISTINCT language \nFROM world.countrylanguage) \nEXCEPT \n(SELECT * \nFROM R);\n\n\n\nQuels sont les pays qui n’ont pas de langue officielle ? (49 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS (\n  SELECT countrycode \n  FROM world.countrylanguage\n  WHERE isofficial),\nS AS (\n  SELECT countrycode \n  FROM world.country\n  EXCEPT \n  SELECT * FROM R)\n\nSELECT name_country \nFROM world.country NATURAL JOIN S;\n\n\n\nQuels sont les pays dont la seule langue officielle est le français ? (9 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS(\n  SELECT DISTINCT T1.countrycode \n  FROM world.countrylanguage as T1 JOIN\n      world.countrylanguage as T2 ON \n      T1.countrycode = T2.countrycode\n  WHERE T1.language &lt;&gt; T2.language AND\n      T1.isofficial AND\n      T2.isofficial),\nS AS (\n  SELECT countrycode \n  FROM world.countrylanguage\n  WHERE language='French' AND isofficial\n  EXCEPT \n  (SELECT * FROM R))\n\nSELECT name_country \nFROM world.country NATURAL JOIN S;\nEn utilisant EXCEPT :\nWITH OnlyFrench AS (\n  (SELECT countrycode\n  FROM countrylanguage\n  WHERE isofficial AND language = 'French')\n  EXCEPT\n  (SELECT countrycode\n  FROM countrylanguage\n  WHERE isofficial AND language &lt;&gt; 'French')\n)\n\nSELECT name_country \nFROM world.country NATURAL JOIN OnlyFrench;\n\n\n\nLes noms des pays où le français n’est pas la seule langue officielle. (9 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS (\nSELECT DISTINCT T1.countrycode FROM world.countrylanguage as T1\n                     JOIN world.countrylanguage as T2\n                     ON T1.countrycode = T2.countrycode\nWHERE T1.language &lt;&gt; T2.language AND\n     T1.language = 'French' AND\n     T1.isofficial AND\n     T2.isofficial)\n\nSELECT name_country FROM R NATURAL JOIN world.country;\nEn utilisant INTERSECT :\nWITH AlsoFrench AS (\n  (SELECT countrycode\n  FROM world.countrylanguage\n  WHERE isofficial AND language = 'French')\n  INTERSECT\n  (SELECT countrycode\n  FROM world.countrylanguage\n  WHERE isofficial AND language &lt;&gt; 'French')\n)\n\nSELECT name_country \nFROM world.country NATURAL JOIN \n     AlsoFrench;\n\n\n\nQuelles sont les régions qui ne comportent qu’une seule forme de gouvernement ? (3 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS (\n  SELECT T1.region \n  FROM world.country AS T1 JOIN \n       world.country AS T2 ON \n       T1.region = T2.region\n  WHERE T1.governmentform &lt;&gt; T2.governmentform)\n\nSELECT region \nFROM world.country \nEXCEPT \nSELECT * \nFROM R;\n\n\n\nQuelles sont les langues officielles des pays dont la capitale compte plus de 5 000 000 d’habitants ? (12 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT DISTINCT language\nFROM world.countrylanguage NATURAL JOIN \n     world.city JOIN world.country ON capital=id\nWHERE population &gt; 5000000 and isofficial;\n\n\n\nQuels sont les pays où au moins trois langues sont parlées chacune par strictement plus de \\(10\\%\\) de la population ? (35 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS (\n  SELECT T1.countrycode \n  FROM  world.countrylanguage AS T1 JOIN \n        world.countrylanguage AS T2 ON T1.countrycode = T2.countrycode JOIN \n        world.countrylanguage AS T3 ON T1.countrycode = T3.countrycode\n  WHERE T1.language &lt;&gt; T2.language AND\n        T2.language &lt;&gt; T3.language AND\n        T1.language &lt;&gt; T3.language AND\n        T1.percentage &gt; 10 AND\n        T2.percentage &gt; 10 AND\n        T3.percentage &gt; 10\n)\n\nSELECT DISTINCT name_country \nFROM world.country NATURAL JOIN R;\nou\nWITH tpc AS (\n  SELECT *\n  FROM world.countrylanguage\n  WHERE percentage &gt; 10), \nthree AS (\n    SELECT DISTINCT t1.countrycode\n    FROM tpc AS t1 JOIN \n         tpc AS t2 ON (t1.countrycode=t2.countrycode AND t1.language &lt; t2.language) JOIN\n         tpc AS t3 ON (t1.countrycode=t3.countrycode AND t3.language &gt; t2.language)\n)\n\nSELECT co.*\nFROM world.country co NATURAL JOIN three ;\n\n\n\nQuelles sont les régions où il existe deux pays dont les espérances de vie diffèrent par au moins \\(10\\) ans ? (16 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT DISTINCT T1.region\nFROM world.country AS T1 JOIN \n     world.country AS T2 ON T1.region = T2.region\nWHERE T1.countrycode &lt;&gt; T2.countrycode AND \n      (T1.lifeexpectancy - T2.lifeexpectancy &gt;= 10 OR \n       T2.lifeexpectancy - T1.lifeexpectancy &gt;= 10);\n\n\n\nQuels sont les pays où l’anglais et le français sont des langues officielles ? (3 lignes)\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS (\n  SELECT T1.countrycode\n  FROM world.countrylanguage AS T1 JOIN \n       world.countrylanguage AS T2 USING (countrycode)\n  WHERE T1.language='French' AND \n        T2.language='English' AND \n        T1.isofficial AND \n        T2.isofficial)\n      \nSELECT name_country \nFROM R NATURAL JOIN \n     world.country;\n\n\n\nMontrer comment calculer l’intersection de deux tables avec une jointure (sous certaines conditions).\n\n\n\n\n\n\n\nSolution\n\n\n\nSi R et S sont deux tables de même schéma, une jointure naturelle des deux tables devrait (en première approximation) calculer l’intersection des deux tables.\nPourtant\n(SELECT * FROM R)\nINTERSECT\n(SELECT * FROM S)   ;\nne donne pas toujours le même résultat que\nSELECT *\nFROM    R NATURAL JOIN S ;\nEssayez par exemple pour l’intersection de la table country avec elle-même :\n(SELECT * FROM country) \nINTERSECT \n(SELECT * FROM country);\nretourne la table country, soit 239 lignes.\nLa jointure naturelle\nSELECT * \nFROM country AS c1 NATURAL JOIN \n     country AS c2;\nne donne que 167 lignes. On peut réconcilier les deux résultats en ne conservant que les lignes pour lesquelles aucune colonne ne prend la valeur NULL.\nEn vérifiant quels attributs peuvent prendre la valeur NULL dans le schéma, on peut tester cela par la requête\nSELECT * \nFROM world.country\nWHERE indepyear IS NOT NULL AND \n      lifeexpectancy IS NOT NUL AND \n      gnp IS NOT NULL AND \n      gnpold IS NOT NULL AND \n      headofstate IS NOT NULL AND \n      capital IS NOT NULL;\nqui retourne bien 167 lignes."
  },
  {
    "objectID": "workshops/td4.html",
    "href": "workshops/td4.html",
    "title": "Fonctions d’agrégation",
    "section": "",
    "text": "Documentation Postgres\nDocumentation Postgres en Français"
  },
  {
    "objectID": "workshops/td4.html#count",
    "href": "workshops/td4.html#count",
    "title": "Fonctions d’agrégation",
    "section": "Count",
    "text": "Count\nPour compter les pays en Europe, on écrira :\nSELECT COUNT(countrycode)\nFROM world.country\nWHERE continent='Europe';\nCette requête renvoie une table ayant une ligne et une colonne contenant le nombre de lignes dans le résultat de la requête."
  },
  {
    "objectID": "workshops/td4.html#sum-max-min-avg",
    "href": "workshops/td4.html#sum-max-min-avg",
    "title": "Fonctions d’agrégation",
    "section": "Sum, Max, Min, Avg",
    "text": "Sum, Max, Min, Avg\nUne autre fonction importante est la fonction SUM(col) qui effectue la somme des valeurs (numériques) d’une colonne :\nSELECT SUM(population_country)\nFROM world.country;\nrenvoie la population mondiale.\nOn peut de même utiliser GROUP BY pour faire des paquets :\nSELECT continent, SUM(population_country)\nFROM world.country\nGROUP BY continent;\nrenvoie la population de chaque continent.\nOn peut même faire des opérations sur la colonne à l’intérieur de SUM. Par exemple: SUM(percentage/100).\n\nÉcrire une requête qui renvoie le nombre de langues officielles par pays\n\n\n\n\n\n\n\nSolution\n\n\n\n\nWITH s AS(\n    SELECT L.countrycode, sum(CAST (isofficial AS INTEGER)) AS n_official\n    FROM  world.countrylanguage as L\n    GROUP BY L.countrycode)\nSELECT s.*, c.name_country\nFROM world.country c NATURAL JOIN s\nORDER BY s.n_official DESC, s.countrycode;"
  },
  {
    "objectID": "workshops/td9.html",
    "href": "workshops/td9.html",
    "title": "MA15Y030 - Automne 2024",
    "section": "",
    "text": "L3 MIASHS/Ingémath\nUniversité Paris Cité\nAnnée 2024-2025\nCourse Homepage\n\nMoodle\n\n\n\n\n\n\n\n\nDéfinitions\nUne dépendance fonctionnelle est une expression de la forme \\[A_1,A_2,\\ldots,A_k \\rightarrow A_{k+1},\\ldots,A_n\\] où \\(A_1,A_2,\\ldots,A_k, A_{k+1},\\ldots,A_n\\) sont des attributs (colonnes) d’une base de données.\nElle signifie que deux tuples ayant la même valeur sur \\(A_1,\\ldots,A_k\\) doivent avoir la même valeur sur chaque colonnes \\(A_{k+1},\\ldots, A_n\\) (en français : \\(A_1,\\ldots,A_k\\) déterminent \\(A_{k+1},\\ldots,A_n\\). On dit que les attributs \\(A_{k+1},\\ldots, A_n\\) dépendent fonctionnellement de \\(A_1,A_2,\\ldots,A_k\\).\nLa notion de dépendance est transitive : si \\(A \\rightarrow B\\) et \\(B \\rightarrow C\\) alors \\(A \\rightarrow C\\).\nUn ensemble de dépendances fonctionnelles \\(\\mathcal{F}\\) est 1 si aucune dépendance ne peut être déduite des autres en utilisant les règles suivantes :\n\ntrivialité : si \\(Y\\subseteq X\\) alors \\(X\\rightarrow Y\\)\naugmentation : si \\(X\\rightarrow Y\\) alors \\(X,Z\\rightarrow Y,Z\\) pour toute suite d’attributs \\(Z\\).\ntransitivité : si \\(X\\rightarrow Y\\) et \\(Y\\rightarrow Z\\) alors \\(X\\rightarrow Z\\)\nunion : si \\(X\\rightarrow Y\\) et \\(X\\rightarrow Z\\) alors \\(X\\rightarrow Y,Z\\)\ndécomposition/séparation si \\(X\\rightarrow Y\\) et \\(Z\\subseteq Y\\) alors \\(X\\rightarrow Z\\)\n\nLa clôture transitive des attributs \\(A_1,\\ldots, A_k\\) pour un ensemble de dépendances fonctionnelles \\(\\mathcal F\\) est l’ensemble des attributs \\(B_1,\\ldots, B_{\\ell}\\) qui dépendent fonctionnellement de \\(A_1,\\ldots, A_k\\).\nOn la note \\[[A_1,\\ldots, A_k]^+_{\\mathcal{F}}\\] en oubliant \\(\\mathcal{F}\\) si le contexte est clair.\nUn ensemble d’attributs \\(A_1,\\ldots, A_k\\) est une super-clé pour une relation \\(R(B_1,\\ldots, B_{\\ell})\\) si ce sont des attributs de \\(R\\) et si sa clôture transitive contient \\(B_1,\\ldots, B_{\\ell}\\). C’est une clé si elle est minimale, c’est-à-dire, aucun sous-ensemble strict de cette super-clé n’est une clé.\nUn schéma est en :\n\n\\(\\text{FN}_1\\) si tout attribut est atomique.\n\\(\\text{FN}_2\\) si un attribut ne fait pas partie d’une clef, il ne peut pas dépendre d’une partie stricte d’une clef.\n\\(\\text{FN}_3\\) Pour toute dépendance fonctionnelle non triviale, le membre de gauche contient une clef ou tout attribut du membre de droit appartient à une clef.\n\nUn schéma et un ensemble de dépendances fonctionnelles peut se décomposer en une collection de schémas, dans le sens où chaque relation \\(R\\) peut se décomposer en \\(R_1,\\ldots, R_k\\) tels que \\(R_i = \\pi_i(R)\\) pour une certaine projection \\(\\pi_i\\).\nOn dit cette décomposition si toute relation \\(R\\) du schéma d’origine peut être retrouvée à partir des relations \\(R_1,\\ldots, R_k\\) : \\(R = \\pi_1(R) \\bowtie \\ldots \\bowtie \\pi_k(R)\\).\nOn dit que cette décomposition respecte les dépendances fonctionnelles si celles-ci sont toujours satisfaites par la nouvelle décomposition.\n\n\nExercice\nSoit une relation concernant des personnes en France avec les attributs suivants~:\\ Nom, Numéro de sécurité sociale, Commune, Département, Code postal, Numéro de téléphone\nQuelles sont les dépendances fonctionnelles censées être satisfaites~?\n\n\n\n\n\n\nSolution\n\n\n\n\nNuméro de sécurité sociale \\(\\to\\) Nom, Commune, Département, Code postal, Numéro de téléphone\nCommune, Département \\(\\longrightarrow\\) Code postal\nCode postal \\(\\to\\) Département\n\n\n\n\n\nExercice\nSoit un schéma d’attributs \\(A_1, A_2,\\dots A_n\\) et un ensemble de dépendances fonctionnelles. Calculer le nombre de super-clefs (en fonction de \\(n\\)) dans les cas suivants~:\n\nLa seule clef est \\(\\{A_1\\}\\).\nLes seules clefs sont \\(\\{A_1\\}\\) et \\(\\{A_2\\}\\).\nLes seules clefs sont \\(\\{A_1,A_2\\}\\) et \\(\\{A_3,A_4\\}\\).\nLes seules clefs sont \\(\\{A_1,A_2\\}\\) et \\(\\{A_1,A_3\\}\\).\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\\(2^{n-1}\\)\n\\(2^{n-2} + 2^{n-2} + 2^{n-2}\\)\n\\(2^{n-4}\\times 3\\times 2 + 2^{n-4}\\)\n\\(3\\times 2^{n-3}\\)\n\n\n\n\n\nExercice\nSoit le schéma \\(\\mathcal{A}=\\{A,B,C,D\\}\\) et l’ensemble de dépendances fonctionnelles \\[\\Sigma = \\{ A \\longrightarrow B, B \\longrightarrow C\\} \\]\n\nQuelle est la fermeture \\(\\{A\\}^+\\) de \\(\\{A\\}\\) ?\n\n\n\n\n\n\n\nSolution\n\n\n\nInitialisation : \\(X  =\\{A\\}\\)\nEtape 1 : Il existe une DF dont la partie gauche est incluse dans $ X$ : \\(A \\longrightarrow B\\). On rajoute les attributs en partie droite. D’où \\(X  = \\{A, B\\}\\)\nEtape 2: Il existe une DF dont la partie gauche est incluse dans $ X$ : \\(B \\longrightarrow C\\). On rajoute les attributs en partie droite. D’où \\(X  = \\{A,B,C\\}\\).\nC’est fini, plus de DF à utiliser. Conclusion \\(\\{A\\}^+=\\{A,B,C\\}\\)\n\n\n\nQuelles sont les super-clés ? Les clés ?\n\n\n\n\n\n\n\nSolution\n\n\n\nUne clef doit contenir \\(\\{A,D\\}\\) puisque ces deux attributs ne sont à droite d’aucune DF de \\(\\Sigma\\). De plus \\(\\{A,D\\}^+=\\{A,B,C,D\\}\\). La seule clef est donc \\(\\{A,D\\}\\).\n\n\n\n\nExercice\nSoit le schéma \\(\\mathcal{A}=\\{A,B,C,D,E,F\\}\\) et l’ensemble de dépendances fonctionnelles \\[\\Sigma = \\Bigl\\{ \\{A,B\\}\\to C, \\{B,C\\}\\to \\{A,D\\}, D\\to E, \\{C,F\\}\\to B \\Bigr\\}\\]\n\nCalculer la fermeture \\(\\{A,B\\}^+\\) de \\(\\{A,B\\}\\).\nEst-ce que \\(\\Sigma\\) implique la dépendance fonctionnelle \\(\\{A,B\\}\\to D\\)~?\nEst-ce que \\(\\Sigma\\) implique la dépendance fonctionnelle \\(D\\to A\\)~?\n\n\n\n\n\n\n\nSolution\n\n\n\n\nOn obtient \\(\\{A,B\\}^+=\\{A,B,C,D,E\\}\\).\nOui car \\(D\\in\\{A,B\\}^+\\)\nNon car \\(\\{D\\}^+=\\{D,E\\}\\) ne contient pas \\(A\\).\n\n\n\n\n\nExercice\nMontrer que les assertions suivantes sont fausses~:\n\n\\(A\\to B\\) implique \\(B\\to A\\).\nSi \\(\\{A,B\\}\\to C\\) et \\(A\\to C\\) alors \\(B\\to C\\).\nSi \\(\\{A,B\\}\\to C\\) alors \\(A\\to C\\) ou \\(B\\to C\\).\n\n\n\n\n\n\n\nSolution\n\n\n\n\nLa relation \\[\n\\begin{array}{|c|c|}\n\\hline A & B \\\\\\hline\n\\hline 1 & 2  \\\\\n\\hline 4 & 2  \\\\\n\\hline\n\\end{array}\n\\] satisfait \\(A\\to B\\) mais pas \\(B\\to A\\).\nLa relation \\[\n\\begin{array}{|c|c|c|}\n\\hline A & B & C\\\\\\hline\n\\hline 1 & 2 & 3 \\\\\n\\hline 4 & 2 & 4  \\\\\n\\hline\n\\end{array}\n\\] satisfait \\(\\{A,B\\}\\to C\\) et \\(A\\to C\\) mais pas \\(B\\to C\\).\nLa relation \\[\n\\begin{array}{|c|c|c|}\n\\hline A & B & C\\\\\\hline\n\\hline 1 & 2 & 3 \\\\\n\\hline 4 & 2 & 4  \\\\\n\\hline 1 & 3 & 1 \\\\\n\\hline\n\\end{array}\n\\] satisfait \\(\\{A,B\\}\\to C\\) mais ni \\(A\\to C\\) ni \\(B\\to C\\).\n\n\n\n\n\nExercice\n\nSoit le schéma \\(\\mathcal{A}=\\{A, B,C, D, E, F, G, H\\}\\) et soit \\[\\Sigma = \\{AB \\longrightarrow C; \\ B \\longrightarrow D;  \\ CD \\longrightarrow E;  \\ CE \\longrightarrow GH; \\  G \\longrightarrow A\\} \\] Est-ce que les dépendances\n\\(A,B \\longrightarrow E\\)\n\\(B,G \\longrightarrow C\\)\n\\(A,B \\longrightarrow G\\)\n\nsont déductibles de \\(\\Sigma\\)~?\n\n\n\n\n\n\nSolution\n\n\n\noui… Méthode à suivre : pour la première et la troisième, on calcule la fermeture de \\(\\{A,B\\}\\). On a \\(\\{A,B\\}^+=\\{A,B,C,D,E,G,H\\}\\).\nPour la seconde, on a \\(\\{B,G\\}^+=\\{A,B,C,D,E,G,H\\}\\).\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\nPour que \\(\\mathcal{F}\\) soit minimale, il y a 3 conditions à remplir :\n\nF est sous forme canonique, un seul attribut à droite.\nAucune DF redondante , i.e. ne pouvant être déduite des autres.\nAucune DF redondante à gauche.\n\nn’est pas minimale: $C,E H $ est redondante à gauche.\nOn la remplace par $C H $.\nDe même \\(A \\longrightarrow H\\) est redondante.\nUne version minimale est :\n\\[\\mathcal{F} = \\{A \\longrightarrow B ; C \\longrightarrow H ; C \\longrightarrow E ; A \\longrightarrow C\\}\\]\n\n\n\nSoit \\[\\Sigma_1 = \\{A \\longrightarrow B ; C,E \\longrightarrow H ; C \\longrightarrow E ; A \\longrightarrow C,H\\}\\] et \\[\\Sigma_2 = \\{A \\longrightarrow B,C ;  C \\longrightarrow E,H\\}\\] Les deux ensembles de dépendances fonctionnelles \\(\\Sigma_1\\) et \\(\\Sigma_2\\) sont-ils équivalents ?\n\n\n\n\n\n\n\nSolution\n\n\n\nMontrons que \\(\\Sigma_1\\) implique \\(\\Sigma_2\\). \\(A\\to B\\) et \\(C\\to E\\) sont dans \\(\\Sigma_1\\). \\(A\\to C\\) est impliqué par \\(A\\to CH \\in \\Sigma_1\\). Donc \\(A\\to BC\\) se déduit de \\(\\Sigma_1\\). De plus \\(\\Sigma_1\\) implique \\(C\\to H\\) (puisque \\(\\Sigma_1\\) contient \\(C\\to E\\) et \\(CE\\to H\\)). Donc \\(\\Sigma_1\\) implique \\(C\\to EH\\). On a montré que toutes les DF de \\(\\Sigma_2\\) sont impliquées par \\(\\Sigma_1\\).\\ Montrons que \\(\\Sigma_2\\) implique \\(\\Sigma_1\\).\\ \\(\\Sigma_2\\) contient \\(A\\to B\\).\\ \\(\\Sigma_2\\) contient \\(C\\to EH\\) qui implique \\(C\\to H\\) qui implique \\(CE\\to H\\).\\ \\(\\Sigma_2\\) contient \\(C\\to EH\\) qui implique \\(C\\to E\\).\\ \\(\\Sigma_2\\) implique \\(A\\to CH\\)…\n\n\n\n\nExercice : Décomposition et perte d’information\n\nOn considère le schéma de relation \\(\\mathcal{A}=\\{A,B,C\\}\\) et la dépendance fonctionnelle suivante:\n\n\\[\\Sigma=\\{  A,B \\longrightarrow C   \\}.\\]\nDéterminer si la décomposition suivante est sans perte d’information\n\\[\\mathcal{A}_1=\\{A,B\\} , \\quad \\mathcal{A}_2=\\{B,C\\}\\]\nen étudiant le cas de la table suivante :\n\n\n\n\n\nA\nB\nC\n\n\n\n\n1\n2\n3\n\n\n4\n2\n5\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\nCette relation satisfait \\(AB\\to C\\). De plus, la jointure naturelle des deux projections contient les deux nouveaux tuples (1,2,5) et (4,2,3). Donc il y a perte d’information.\n\n\n\nOn considère le schéma de relation \\(\\mathcal{A}=\\{A,B,C,D,E\\}\\) et les dépendances fonctionnelles suivantes:\n\n\\[\\Sigma=\\{  A \\longrightarrow C ; B \\longrightarrow C ; C \\longrightarrow D ; D,E \\longrightarrow C ; C,E \\longrightarrow A    \\}.\\]\nAppliquer l’algorithme de poursuite pour déterminer si la décomposition suivante est sans perte d’information :\n\\[ \\mathcal{A}_1=\\{A,D\\} , \\mathcal{A}_2=\\{A,B\\}    , \\mathcal{A}_3=\\{B,E\\} , \\mathcal{A}_4=\\{C,D,E\\}, \\mathcal{A}_5=\\{A,E\\} \\]\nMême question pour la décomposition: \\[ \\mathcal{A}_1=\\{A,D\\}, \\mathcal{A}_2=\\{A,B\\}, \\mathcal{A}_3=\\{B,E\\}, \\mathcal{A}_4=\\{C,D\\}, \\mathcal{A}_5=\\{D,E\\}, \\mathcal{A}_6=\\{A,E\\} \\]\n\n\n\n\n\n\nSolution\n\n\n\nLa première décomposition est SPI. On doit montrer que :\n\\(R=\\pi_{A,D}(R)\\bowtie \\pi_{A,B}(R)\\bowtie \\pi_{B,E}(R)\\bowtie \\pi_{C,D,E}(R) \\bowtie \\pi_{A,E}(R)\\).\nOn voit facilement que : \\(R \\subseteq\\pi_{A,D}(R)\\bowtie \\pi_{A,B}(R)\\bowtie \\pi_{B,E}(R)\\bowtie \\pi_{C,D,E}(R) \\bowtie \\pi_{A,E}(R)\\) et il faut montrer l’autre inclusion.\\ On considère un tuple \\(t=(a,b,c,d,e)\\) de la jointure naturelle. Pour \\(1\\le i\\le 5\\), comme \\(\\pi_{\\mathcal{A}_i}(t) \\in \\pi_{\\mathcal{A}_i}(R)\\) il existe un tuple \\(t_i\\in R\\) tel que \\(\\pi_{\\mathcal{A}_i}(t)=\\pi_{\\mathcal{A}_i}(t_i)\\), ce que l’on représente par le tableau \\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline A & B & C & D & E \\\\\\hline\n\\hline a & b_1 &  c_1& d & e_1 \\\\\n\\hline a & b & c_2 & d_2 & e_2 \\\\\n\\hline  a_3& b & c_3 & d_3 & e \\\\\n\\hline  a_4 & b_4 & c & d & e \\\\\n\\hline  a & b_5 & c_5 & d_5 & e \\\\\n\\hline\n\\end{array}\n\\]\nPar la dépendance \\(A \\longrightarrow C\\), on sait que deux tuples ayant la même valeur sur \\(A\\), ont la même sur \\(C\\). On remplace dans la table les valeurs indicées par la valeur \\(c\\) quand c’est possible, ou on unifie simplement les valeurs indicées sinon (ici on prendra \\(c_1\\)).\n\\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline A & B & C & D & E \\\\\\hline\n\\hline a & b_1 &  c_1& d & e_1 \\\\\n\\hline a & b & c_1 & d_2 & e_2 \\\\\n\\hline  a_3& b & c_3 & d_3 & e \\\\\n\\hline  a_4 & b_4 & c & d & e \\\\\n\\hline  a & b_5 & c_1 & d_5 & e \\\\\n\\hline\n\\end{array}\n\\]\n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\nOn traite maintenant \\(B \\longrightarrow C\\).\n\\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline A & B & C & D & E \\\\\\hline\n\\hline a & b_1 &  c_1& d & e_1 \\\\\n\\hline a & b & c_1 & d_2 & e_2 \\\\\n\\hline  a_3& b & c_1 & d_3 & e \\\\\n\\hline  a_4 & b_4 & c & d & e \\\\\n\\hline  a & b_5 & c_1 & d_5 & e \\\\\n\\hline\n\\end{array}\n\\]\nPour la dépendance \\(C \\longrightarrow D\\), on obtient :\n\\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline A & B & C & D & E \\\\\\hline\n\\hline a & b_1 &  c_1& d & e_1 \\\\\n\\hline a & b & c_1 & d & e_2 \\\\\n\\hline  a_3& b & c_1 & d & e \\\\\n\\hline  a_4 & b_4 & c & d & e \\\\\n\\hline  a & b_5 & c_1 & d & e \\\\\n\\hline\n\\end{array}\n\\]\n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\nPour \\(D,E \\longrightarrow C\\), on a cette fois (notez qu’on remplace tous les \\(c_1\\) du coup comme l’un d’entre eux devait l’être) :\n\\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline A & B & C & D & E \\\\\\hline\n\\hline a & b_1 &  c& d & e_1 \\\\\n\\hline a & b & c & d & e_2 \\\\\n\\hline  a_3& b & c & d & e \\\\\n\\hline  a_4 & b_4 & c & d & e \\\\\n\\hline  a & b_5 & c & d & e \\\\\n\\hline\n\\end{array}\n\\]\nEnfin, on termine avec \\(C,E \\longrightarrow A\\) :\n\\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline A & B & C & D & E \\\\\\hline\n\\hline a & b_1 &  c& d & e_1 \\\\\n\\hline a & b & c & d & e_2 \\\\\n\\hline  a& b & c & d & e \\\\\n\\hline  a & b_4 & c & d & e \\\\\n\\hline  a & b_5 & c & d & e \\\\\n\\hline\n\\end{array}\n\\]\nOn voit que le tuple \\((a,b,c,d,e)\\) apparait.  En d’autres termes : \\(R \\supset\\pi_{A,D}(R)\\bowtie \\pi_{A,B}(R)\\bowtie \\pi_{B,E}(R)\\bowtie \\pi_{C,D,E}(R) \\bowtie \\pi_{A,E}(R)\\). La décomposition est donc SPI.\n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\nLa seconde décomposition n’est pas SPI~: l’algorithme de poursuite échoue. Le tableau de départ s’écrit~: \\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline A & B & C & D & E \\\\\\hline\n\\hline a & b_1 &  c_1& d & e_1 \\\\\n\\hline a & b & c_2 & d_2 & e_2 \\\\\n\\hline  a_3& b & c_3 & d_3 & e \\\\\n\\hline  a_4 & b_4 & c & d & e_4 \\\\\n\\hline  a_5 & b_5 & c_5 & d & e \\\\\n\\hline  a & b_6 & c_6 & d_6 & e \\\\\n\\hline\n\\end{array}\n\\]\n\n\\(A\\to C\\) donc \\(c_1=c_2=c_6\\) \\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline A & B & C & D & E \\\\\\hline\n\\hline a & b_1 &  c_1& d & e_1 \\\\\n\\hline a & b & c_1 & d_2 & e_2 \\\\\n\\hline  a_3& b & c_3 & d_3 & e \\\\\n\\hline  a_4 & b_4 & c & d & e_4 \\\\\n\\hline  a_5 & b_5 & c_5 & d & e \\\\\n\\hline  a & b_6 & c_1 & d_6 & e \\\\\n\\hline\n\\end{array}\n\\]\n\n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\n\n\\(B\\to C\\) donc \\(c_3=c_1\\) \\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline A & B & C & D & E \\\\\\hline\n\\hline a & b_1 &  c_1& d & e_1 \\\\\n\\hline a & b & c_1 & d_2 & e_2 \\\\\n\\hline  a_3& b & c_1 & d_3 & e \\\\\n\\hline  a_4 & b_4 & c & d & e_4 \\\\\n\\hline  a_5 & b_5 & c_5 & d & e \\\\\n\\hline  a & b_6 & c_1 & d_6 & e \\\\\n\\hline\n\\end{array}\n\\]\n\\(C\\to D\\) donc \\(d_1=d_3=d_6=d\\) \\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline A & B & C & D & E \\\\\\hline\n\\hline a & b_1 &  c_1& d & e_1 \\\\\n\\hline a & b & c_1 & d & e_2 \\\\\n\\hline  a_3& b & c_1 & d & e \\\\\n\\hline  a_4 & b_4 & c & d & e_4 \\\\\n\\hline  a_5 & b_5 & c_5 & d & e \\\\\n\\hline  a & b_6 & c_1 & d & e \\\\\n\\hline\n\\end{array}\n\\]\n\n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\n\n\\(DE\\to C\\) donc \\(c_5=c1\\) \\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline A & B & C & D & E \\\\\\hline\n\\hline a & b_1 &  c_1& d & e_1 \\\\\n\\hline a & b & c_1 & d & e_2 \\\\\n\\hline  a_3& b & c_1 & d & e \\\\\n\\hline  a_4 & b_4 & c & d & e_4 \\\\\n\\hline  a_5 & b_5 & c_1 & d & e \\\\\n\\hline  a & b_6 & c_1 & d & e \\\\\n\\hline\n\\end{array}\n\\]\n\\(CE\\to A\\) donc \\(a_3=a_5=a\\) \\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline A & B & C & D & E \\\\\\hline\n\\hline a & b_1 &  c_1& d & e_1 \\\\\n\\hline a & b & c_1 & d & e_2 \\\\\n\\hline  a& b & c_1 & d & e \\\\\n\\hline  a_4 & b_4 & c & d & e_4 \\\\\n\\hline  a & b_5 & c_1 & d & e \\\\\n\\hline  a & b_6 & c_1 & d & e \\\\\n\\hline\n\\end{array}\n\\] Toutes les DF de \\(\\Sigma\\) sont satisfaites et aucune ligne n’est égale à \\((a,b,c,d,e)\\). Donc la décomposition n’est pas SPI.\\ Si on suppose que pour tout \\(1\\le i\\le 6\\), \\(a_i\\not=a\\), \\(b_i\\not=b\\), \\(c_i\\not=c\\), \\(d_i\\not=d\\), \\(e_i\\not=e\\), ce dernier tableau fournit un exemple de relation strictement plus petite que la jointure naturelle des projections. En effet \\(\\Sigma\\) est satisfait et \\((a,b,c,d,e)\\) est clairement dans la jointure naturelles des projections. Or \\((a,b,c,d,e)\\) n’est pas dans la relation.\n\n\n\n\n\nExercice\nSoit \\(\\mathcal{A}=\\{A,B,C,D,E\\}\\) un schéma et soit la décomposition \\(\\{\\mathcal{A}_1,\\mathcal{A}_2,\\mathcal{A}_3\\}\\) où \\[\\mathcal{A}_1=\\{A,B,C\\}\\quad \\mathcal{A}_2=\\{B,C,D\\}\\quad \\mathcal{A}_3=\\{A,C,E\\}\\] Pour chaque ensemble \\(\\Sigma\\) de dépendances fonctionnelles ci-dessous, appliquer l’algorithme de poursuite pour déterminer si la décomposition est sans perte d’information. Dans le cas où il y a perte d’information, donner une relation \\(R\\) de schéma \\(\\mathcal{A}\\) satisfaisant \\(\\Sigma\\) et telle que \\[ \\pi_{\\mathcal{A}_1}(R)\\bowtie\\pi_{\\mathcal{A}_2}(R)\\bowtie\\pi_{\\mathcal{A}_3}(R)\\not\\subset R\\]\n\n\\(\\Sigma=\\{B\\rightarrow E, CE\\rightarrow A\\}\\)\n\\(\\Sigma=\\{AC\\rightarrow E, BC\\to D\\}\\)\n\\(\\Sigma=\\{A\\rightarrow D, D\\to E, B\\to D\\}\\)\n\\(\\Sigma=\\{A\\rightarrow D, CD\\to E, E\\to D\\}\\)\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\\[\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline  & A & B & C & D & E \\\\\\hline\n\\hline \\{A,B,C\\}  & a & b &  c& d_1 & e_1 \\\\\n\\hline  \\{B,C,D\\} & a_2 & b & c & d & e_2 \\\\\n\\hline  \\{A,C,E\\} & a & b_3 & c & d_3 & e \\\\\n\\hline\n\\end{array}\n\\] \\(B\\to E\\) donc \\(e_1=e_2\\). Ensuite \\(CE\\to A\\) donc \\(a_2=a\\). On obtient \\[\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline  & A & B & C & D & E \\\\\\hline\n\\hline \\{A,B,C\\}  & a & b &  c& d_1 & e_1 \\\\\n\\hline  \\{B,C,D\\} & a & b & c & d & e_1 \\\\\n\\hline  \\{A,C,E\\} & a & b_3 & c & d_3 & e \\\\\n\\hline\n\\end{array}\n\\] Toutes les DF de \\(\\Sigma\\) sont satisfaites. Donc il y a perte d’information. Ce dernier tableau est une relation \\(R\\) qui satisfait \\(\\Sigma\\) et telle que \\[\\pi_{\\mathcal{A}_1}(R)\\bowtie\\pi_{\\mathcal{A}_2}(R)\\bowtie\\pi_{\\mathcal{A}_3}(R)\\not\\subset R\\] puisque \\((a,b,c,d,e)\\notin R\\).\n\n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\n\n\\[\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline  & A & B & C & D & E \\\\\\hline\n\\hline \\{A,B,C\\}  & a & b &  c& d_1 & e_1 \\\\\n\\hline  \\{B,C,D\\} & a_2 & b & c & d & e_2 \\\\\n\\hline  \\{A,C,E\\} & a & b_3 & c & d_3 & e \\\\\n\\hline\n\\end{array}\n\\] \\(AC\\to E\\) donc \\(e_1=e\\). Ensuite \\(BC\\to D\\) donc \\(d_1=d\\). On obtient \\[\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline  & A & B & C & D & E \\\\\\hline\n\\hline \\{A,B,C\\}  & a & b &  c& d & e \\\\\n\\hline  \\{B,C,D\\} & a_2 & b & c & d & e_2 \\\\\n\\hline  \\{A,C,E\\} & a & b_3 & c & d_3 & e \\\\\n\\hline\n\\end{array}\n\\] Le premier tuple est \\((a,b,c,d,e)\\). Donc la décomposition est SPI.\n\n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\n\n\\[\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline  & A & B & C & D & E \\\\\\hline\n\\hline \\{A,B,C\\}  & a & b &  c& d_1 & e_1 \\\\\n\\hline  \\{B,C,D\\} & a_2 & b & c & d & e_2 \\\\\n\\hline  \\{A,C,E\\} & a & b_3 & c & d_3 & e \\\\\n\\hline\n\\end{array}\n\\] \\(A\\to D\\) donc \\(d_3=d_1\\). \\[\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline  & A & B & C & D & E \\\\\\hline\n\\hline \\{A,B,C\\}  & a & b &  c& d_1 & e_1 \\\\\n\\hline  \\{B,C,D\\} & a_2 & b & c & d & e_2 \\\\\n\\hline  \\{A,C,E\\} & a & b_3 & c & d_1 & e \\\\\n\\hline\n\\end{array}\n\\] \\(D\\to E\\) donc \\(e_1=e\\) \\[\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline  & A & B & C & D & E \\\\\\hline\n\\hline \\{A,B,C\\}  & a & b &  c& d_1 & e \\\\\n\\hline  \\{B,C,D\\} & a_2 & b & c & d & e_2 \\\\\n\\hline  \\{A,C,E\\} & a & b_3 & c & d_1 & e \\\\\n\\hline\n\\end{array}\n\\] \\(B\\to D\\) donc \\(d_1=d\\) \\[\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline  & A & B & C & D & E \\\\\\hline\n\\hline \\{A,B,C\\}  & a & b &  c& d & e \\\\\n\\hline  \\{B,C,D\\} & a_2 & b & c & d & e_2 \\\\\n\\hline  \\{A,C,E\\} & a & b_3 & c & d_1 & e \\\\\n\\hline\n\\end{array}\n\\] La décomposition est donc SPI.\n\n\n\n\n\n\n\n\n\nSolution (suite)\n\n\n\n\n\\[\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline  & A & B & C & D & E \\\\\\hline\n\\hline \\{A,B,C\\}  & a & b &  c& d_1 & e_1 \\\\\n\\hline  \\{B,C,D\\} & a_2 & b & c & d & e_2 \\\\\n\\hline  \\{A,C,E\\} & a & b_3 & c & d_3 & e \\\\\n\\hline\n\\end{array}\n\\] \\(A\\to D\\) donc \\(d_3=d_1\\). \\[\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline  & A & B & C & D & E \\\\\\hline\n\\hline \\{A,B,C\\}  & a & b &  c& d_1 & e_1 \\\\\n\\hline  \\{B,C,D\\} & a_2 & b & c & d & e_2 \\\\\n\\hline  \\{A,C,E\\} & a & b_3 & c & d_1 & e \\\\\n\\hline\n\\end{array}\n\\] \\(CD\\to E\\) donc \\(e_1=e\\). \\[\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline  & A & B & C & D & E \\\\\\hline\n\\hline \\{A,B,C\\}  & a & b &  c& d_1 & e \\\\\n\\hline  \\{B,C,D\\} & a_2 & b & c & d & e_2 \\\\\n\\hline  \\{A,C,E\\} & a & b_3 & c & d_1 & e \\\\\n\\hline\n\\end{array}\n\\] \\(E\\to D\\) est satisfaite ainsi que les deux premières DF. Donc la décomposition n’est pas SPI.\n\n\n\n\n\nExercice : Normalisation\nOn considère le schéma de relation R(C,T,H,S,E,N) :\nR(Cours, Enseignant, Horaire, Salle, Étudiant, Note)\net les dépendances fonctionnelles suivantes:\n\\[\\mathcal{F}=\\{  \\texttt{C} \\to \\texttt{T}; \\quad \\texttt{H,S} \\to \\texttt{C}; \\quad \\texttt{H,T} \\to \\texttt{S}; \\quad \\texttt{C,E} \\to \\texttt{N}; \\quad \\texttt{H,E} \\to S \\}. \\]\n\nCalculer une clé.\n\n\n\n\n\n\n\nSolution\n\n\n\nH,E n’étant jamais à droite, ils font obligatoirement partis d’une clé. Or HE+ = ALL\n\n\n\nMettre en Boyce-Codd Normal Form (BCNF), donner plusieurs résultats possibles.\n\n\n\n\n\n\n\nSolution\n\n\n\n1er version:\nC -&gt; T donne T1(CT) et T2(CHSEN).\nCE -&gt; N donne T1(CT),T2(C,E,N) T3(CHSE)\nHE -&gt; S donne (HES ; HEC)\n2eme version:\nCE -&gt; N donne T1(CENT), T2(CEHS) ..."
  },
  {
    "objectID": "workshops/nycflights-schema.html",
    "href": "workshops/nycflights-schema.html",
    "title": "MA15Y030 - Automne 2024",
    "section": "",
    "text": "&lt;!–"
  },
  {
    "objectID": "workshops/td-recap-sql.html#schéma-world",
    "href": "workshops/td-recap-sql.html#schéma-world",
    "title": "Recapitulatif SQL",
    "section": "Schéma world",
    "text": "Schéma world\n\n\n\n\n\n\nQuestion\n\n\n\nQuel est le pays qui a le plus de villes recensées dans la table world.city? Combien de villes ? (363 villes)\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH country_city AS\n    (SELECT name_country , COUNT(name_city) nbrcity\n    FROM world.country NATURAL JOIN world.city\n    GROUP BY name_country)\n\nSELECT name_country, nbrcity\nFROM country_city\nWHERE nbrcity = (SELECT MAX(nbrcity) \n                 FROM country_city) ;\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuels sont les pays qui ont \\(3\\) ou plus langues officielles ? (8 lignes)\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT name_country\nFROM world.country NATURAL JOIN world.countrylanguage\nWHERE isofficial\nGROUP BY name_country HAVING COUNT(*) &gt; 2 ;\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuels sont les pays dont plus de \\(1.000.000\\) d’habitants parlent une langue non officielle ? (72 lignes)\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT DISTINCT name_country\nFROM world.country NATURAL JOIN world.countrylanguage\nWHERE (NOT isofficial) AND \n      (percentage / 100) * population_country &gt;= 1000000 ;\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuelles sont les langues qui sont officielles dans tous les continents où au moins une langue est parlée ? (1 ligne)\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH R AS\n    (SELECT count(DISTINCT continent)\n    FROM world.country NATURAL JOIN world.countrylanguage)\nSELECT language, count(DISTINCT continent) as nbcon\nFROM world.country NATURAL JOIN world.countrylanguage WHERE isofficial\nGROUP BY language\n    HAVING count(DISTINCT continent) in (SELECT * FROM R)\nORDER BY nbcon DESC ;\n\n\nou\n\n\n\n\n\n\nSolution\n\n\n\nWITH continent_language AS\n    (SELECT DISTINCT language , continent\n    FROM country NATURAL JOIN countrylanguage\n    WHERE isofficial),\nall_continent_language AS\n    (SELECT DISTINCT l.language , c.continent\n    FROM countrylanguage l , continent_language c),\nnot_continent_language AS\n    ((SELECT * FROM all_continent_language)\n    EXCEPT\n    (SELECT * FROM continent_language))\nSELECT DISTINCT language\nFROM countrylanguage\nWHERE language NOT IN (SELECT language FROM not_continent_language) ;\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuels sont les pays pour lesquels une langue non officielle est parlée par strictement plus de monde (dans le pays) qu’il n’y a d’habitants dans la capitale ? (118 lignes)\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT DISTINCT name_country\nFROM (country c JOIN city ON id = capital)\n    JOIN countrylanguage l ON c.countrycode = l.countrycode\nWHERE NOT isofficial\nAND percentage / 100 * population_country &gt; population_city ;\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuels est le nombre de villes par region ?\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT region , COUNT(id) AS nbr_city\nFROM country NATURAL JOIN city\nGROUP BY region ;"
  },
  {
    "objectID": "workshops/td-recap-sql.html#schéma-pagila",
    "href": "workshops/td-recap-sql.html#schéma-pagila",
    "title": "Recapitulatif SQL",
    "section": "Schéma pagila",
    "text": "Schéma pagila\n\n\n\n\n\n\nQuestion\n\n\n\nQuel est l’acteur (actor_id) présent sur le plus de DVD (inventory_id) ?\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH actor_dvd AS\n    (SELECT actor_id , count(inventory_id) nbrdvd\n    FROM actor NATURAL JOIN film_actor NATURAL JOIN inventory\n    GROUP BY actor_id)\nSELECT first_name , last_name\nFROM actor NATURAL JOIN actor_dvd\nWHERE nbrdvd = (SELECT MAX(nbrdvd) FROM actor_dvd) ;\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuel est le prix moyen d’une location de DVD ?\n\n\n\n\n\n\n\n\nSolution\n\n\n\nSELECT AVG(amount) \nFROM payment ;\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuel est le DVD qui a rapporté le plus d’argent ? Le film (film_id)?\n\n\n\n\n\n\n\n\nSolution\n\n\n\nPour le DVD:\nWITH inventory_amount AS\n    (SELECT inventory_id , SUM(amount) AS dollar\n    FROM inventory NATURAL JOIN rental NATURAL JOIN payment\n    GROUP BY inventory_id)\nSELECT inventory_id , dollar\nFROM  inventory_amount\nWHERE dollar &gt;= ALL (SELECT dollar FROM inventory_amount) ;\n\n\n\n\n\n\n\n\nSolution\n\n\n\nEt pour le film:\nWITH film_amount AS\n    (SELECT film_id , SUM(amount) AS dollar\n    FROM inventory NATURAL JOIN rental NATURAL JOIN payment\n    GROUP BY film_id)\nSELECT film_id , dollar\nFROM  inventory_amount\nWHERE dollar &gt;= ALL (SELECT dollar FROM film_amount) ;\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nQuels sont les employés (staff_id) qui travaillent dans une autre ville que celle dans laquelle ils vivent ? (4 lignes)\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWITH staff_maison AS\n    (SELECT staff_id , city_id\n    FROM (staff NATURAL JOIN address)),\nstaff_travail AS\n    (SELECT staff_id , city_id\n    FROM (staff p JOIN store s ON p.store_id = s.store_id) , address a\n    WHERE a.address_id = s.address_id)\nSELECT staff_id FROM staff_travail NATURAL JOIN staff_maison ;"
  }
]