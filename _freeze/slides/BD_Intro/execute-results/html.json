{
  "hash": "93a8463b47dfcbbf84c084c3bf61c7df",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"BD I: Introduction aux SGBD\"\nsubtitle: \"Bases de Données Licences MIASHS et Mathématiques\"\nauthor: \"Équipe BD\"\ninstitute: \"Université Paris Cité\"\ndate: \"2024-06-23\"\n\nexecute: \n  echo: true\n  eval: false\n---\n\n\n\n\n  \n\n# Données ? {background-color=\"#1c191c\"}\n\n\n\n## Les données en Sciences Sociales \n\nPourquoi ?\n\n\nDe quoi sont faites les données ?\n\n\n\nComment les accumuler ?\n\n\n\nComment les interroger ?\n\n\n\nComment les conserver ? les éditer ?\n\n\n\n## Sources\n\n*Data humanities with R.* Arnold and Tilton \n\n*Quantitative tour at social sciences* Gelman and ?\n\nHumanités numériques \n \n\n- Constitution\n\n- Acquisition\n\n- Usage(s)\n\n- Maintenance \n\n\n## Les données de l'entreprise/des administrations\n\n:::::: {.columns}\n::: {.column}\n\n- La comptabilité\n\n- Les stocks (ERP)\n\n- La clientèle (CRM)\n\n- ...\n\n:::\n\n::: {.column}\n\nTODO\n\n:::\n::::::\n\n\n\n\n\n\n## La vie des données \n\n- Saisie\n\n- Traitement(s)\n\n- Usage(s)\n\n- Archivage \n\n- Maintenance\n\n\n\n## Les enjeux \n\n\n\n\n## Avant-hier\n\n:::::: {.columns}\n::: {.column}\n\n\n  \nLes entreprises et les administrations ont toujours cultivé une mémoire\nsous forme de *fichiers* plus ou moins mécanisés et formattés.\n\nCes collections de fichiers mécanisées répondaient à des exigences de\n*fiabilité*, de *convenance* (facilité de la recherche, de\nla maintenance)\n\n\n:::\n::: {.column}\n\n\n\n![](/images//pexels-mike-1181772.jpg)\n\n\n\n\n\n:::\n::::::\n\n\n\n\n\n## Aujourd'hui\n\n\nExplosion des volumes \n\nBesoins **mixtes**\n\n  \n\n# Systèmes d'information  {background-color=\"#1c191c\"}\n\n\n\n\n\n## Systèmes d'information (SI) et Bases de Données (BD, SGBD, SGBDR)\n\n\nAu coeur des systèmes d'information (modernes) on trouve les **bases de données**\n\n\n\n\n\n\n\n## Des propriétés désirables (ACID)\n\nQuelle que soit la forme, on souhaite avoir :\n\n\n- **A**tomicité : chaque ajout/modification d'information doit\n  former un tout cohérent.\nSi tout se passe correctement, les actions de la transaction sont toutes validées, sinon\non retourne à l'état initial.\nL'unité de travail est indivisible. Une transaction ne peut être partiellement effectuée.\n\n-   **C**ohérence : le contenu de la base de données doit rester\n  conforme à des *contraintes* qui ont été définies lors de la\n  *conception* de la base\n\n-   **I**solation : la bases de données doit pouvoir être utilisée\n  concurremment par plusieurs usagers\n\n-   **D**urabilité : la vie d'une base de données s'étale sur\n  plusieurs dizaines d'années\n\n\n\n  \n\n# Bases de données et (autres) logiciels {background-color=\"#1c191c\"}\n\n\n\n\n## Bases de **données**  \n\n<!-- {{< fa database >}} -->\n\n<!-- {{< fa question >}}  -->\n\nQu'est-ce que c'est ?\n\nCe sont des logiciels intermédiaires (*middleware*) entre :\n\n- Systèmes de gestion de fichiers/Systèmes d'exploitation\n\n- Applications (CRM, ERP, CMS, ...)\n\n\n\nLes bases de données ne sont pas (simplement) un *langage* (comme `JAVA`, \n<!-- {{< fa r-project >}}, {{< fa python >}})  -->\nou un\nenvironnement de calcul \n<!-- (comme {{< fa r-project >}}, {{< fa python >}}) -->\n\n\n\n  \n\n# Bases de données (relationnelles)  {background-color=\"#1c191c\"}\n\n\n\nToutes les bases de données ne sont pas relationnelles\n\nLes **Bases de données relationnelles** forment un sous-ensemble important (et même prépondérant) des systèmes de\ngestion des bases de données en entreprise\n\n\n\n\n\n\n## Collection de tables/`data frame`s\n\nCaricaturalement :\n\n\n> Une base de données relationnelle est une collection de *tables*\n\n\nLes tables s'incarnent de plusieurs façons en informatique\n\n\n`R`, `Pandas`, les tableurs (`Excel` ...), offrent un environnement interactif de manipulation de données et un environnement de définition de données\n\n\n\n\n## Data frame \n\n<!-- ({{< fa r-project >}}) -->\n\n- Un `dataframe` est une *liste* de *vecteurs* (colonnes)\n\n- Les vecteurs (colonnes) d'un `dataframe` sont tous de même longueur\n\n- Les éléments d'un vecteur sont d'un même type de base\n\n- Chaque vecteur a un nom et son propre type\n\n\n\n## Autres environments (`Excel`, `JAVA`, `Python`)\n\n<!-- {{< fa python >}} -->\n\n- Les `spreadsheet` des tableurs\n\n- Les `Dataframes`  de `Pandas` \n<!-- ({{< fa python >}}) -->\n\n- Les tableaux d'objets en `JAVA`\n\npermettent de représenter ce que les `dataframes` représentent en `R`\n<!-- {{< fa r-project >}} -->\n\n\n\n\n## Les SGBD vont au delà : \n\nIls offrent:\n\n- **Persistance**\n\n> Entre deux *sessions* les données sont confiées au système de fichiers de l'ordinateur\n\n\n\n- **Intégrité**\n\n> Les données confiées au système de fichiers ne peuvent pas être altérées par d'autre logiciel\n\n\n\n- **Concurrence**\n\nLes données peuvent être manipulées/consultées/mises à jour de manière *concurrente* par plusieurs\nou du moins par une grande quantité d' utilisateurs.\n\n\n\n\n\n\n## Usages\n\n- Sites web dynamiques\n\n\n-  Logiciels personnels\n\nDerrière certaines applications (gestion de photos, de carnet\nd'adresses, ...), on trouve des bases de données légères\n(`SQLITE`)\n\n- Partout\n\n    - smartphones, tablettes, ...\n\n    - web, réseaux sociaux\n\n    - administrations (APOGEE, ...)\n\n    - entreprises (Stocks Supply Chain, Customer Relationship Management, ...)\n\n    - NSA\n\n\n\n\n\n  \n\n# L'idée relationnelle  {background-color=\"#1c191c\"}\n\n\n\n\n## L'idée clé (Codd, 1970)\n\nOrganiser les informations en **tables** ou **relations**\n\n\n\nDévelopper et formaliser un langage de manipulation de\ntables : l'algèbre relationnelle} (langage SQL, Structured Query Language)\n\n-  L'usager peut définir l'organisation des données\n\n-  Il peut interroger celles-ci (par des requêtes)\n\n-  Le langage est *déclaratif* :\n\n    -  On décrit ce que l'on veut obtenir (quoi mais pas comment)\n    -  Le système fait le reste...\n\n-  L'évaluation de toutes les requêtes s'arrête (au moins en théorie : si on y met les moyens...)\n\n-  L'algèbre relationnelle/SQL n'est pas un langage complet (différence avec  `JAVA`, `C`, `Python`, etc)\n\n\n\n\n{{< embed _codds-principles.qmd >}}\n\n\n\n\n\n\n## Quelques acteurs\n\n\n\n\n:::::: {.columns}\n::: {.column}\n\n\n**Serveurs**\n\n- [ORACLE (commercial)]()\n\n- [DB2 (IBM commercial)]()\n\n- [SQLSERVER (Microsoft commercial)]()\n\n- [MySQL (open source)]()\n\n- [**PostGres** (open source)](https://www.postgresql.org)\n\n- [Hana (commercial)]()\n\n\n:::\n\n::: {.column}\n\n**Clients**\n\n- [`psql`]()\n\n- [`pgcli`]()\n\n- [`dbeaver`]()\n\n- [`PgAdmin4`]()\n\n- ...\n\n\n:::\n::::::\n\n\n## PostGres (PostgreSQL)\n\n\n- Un **serveur** : `etu-pgsql`\n\n- Un **catalogue** : `bd_2023-24`\n\n- Des **schémas**: `world, pagila, nycflights13, ...`\n\n\n\n\n## Un exemple de schéma `world`\n\nUn schema\n\nDes schémas de table\n\n- `continent` : association nom de continent (texte)-code de continent (entier)\n\n- `country` : chaque tuple porte sur un état/territoire\n\n- `city` : chaque tuple porte sur une ville (déisgnée par `id`) qui appartient à un\nétat/territoire désigné par `countrycode`\n\n- `countrylanguage` : chaque tuple indique la\npart de la population d'un état/territoire (désigné par `countrycode`) qui parle/connaît une langue\n(désignée par `language`) et précise si la langue est officielle dans cet état/territoire.\n\n\n\n\n\n\n\n\n\n## Détails du schema `world`\n\n![Image World](/images//world.png)\n\nUn schéma de table : la donnée des noms des colonnes et des types des colonnes\n\n\n\n\n\n\n## Quelques questions et propriétés typiques\n\n-  Extraire de l'information\n\n-  Assurer de la cohérence après modification\n\n\t-  Faire en sorte que chaque état/territoire soit identifié par un numéro unique\n    -  Faire en sorte que chaque ville soit identifiée par un numéro unique\n    -  Ne pas proposer de données sur des villes/territoires/états qui n'existent pas\n\n\n-  Propager l'information\n\n    - Historiciser le schéma\n\n\n\n\n\n## Objectifs du cours\n\n\n- Compétences d'un usager de BD relationnelles\n\n- Exprimer des requêtes en algèbre relationnelle et en SQL\n\n- SQL Définition, manipulation et contrôle des données\n\n- Concevoir un Modèle Conceptuel de Données (Entités/Associations)\n\n- Déterminer les dépendances fonctionnelles et normaliser une relation\n\n\n\n\n\n## Plan du cours\n\n\n- Algèbre et calcul relationnels\n\n- SQL (algèbre relationnelle stricte)\n\n- SQL sous-requêtes\n\n- SQL agrégation\n\n- SQL requêtes paramétrées\n\n- Définition de données/Conception\n\n- Normalisation\n\n\n\n  \n\n# Autour des bases de données  {background-color=\"#1c191c\"}\n\n\n\n\n## Entrepôts de données (Fin des années 1980)\n\n(Datawarehouse)\n\n> Un Data Warehouse est une technologie qui regroupe des données *structurées* provenant d'une ou de plusieurs sources afin qu'elles puissent être comparées et analysées.\n\n<!-- {{< fa hand-point-right >}}  -->\n\n[Entrepôt_de_données sur Wikipedia](https://fr.wikipedia.org/wiki/Entrepôt_de_données)\n\n\n## Lacs de données (2010)\n\n(Datalake)\n\n> Le concept de Data Lake a été évoqué pour la première fois, en 2010, par James Dixon, comme une solution pour le stockage de données sans pré-traitement et sans connaître précisément l'usage futur qui en sera fait. L'image du lac, permettant d'expliquer, que différentes sources peuvent l'alimenter de manière naturelle et brute, et que les utilisateurs peuvent y plonger pour l'explorer et en rapporter des échantillons à examiner\n\n\n\n## Au delà du relationnel: No SQL\n\n\n> Ce sont les grandes entreprises du web amenées à traiter des volumes de données très importants qui ont été les premières confrontées aux limitations intrinsèques des SGBD relationnels traditionnels. Ces systèmes fondés sur une application stricte des propriétés ACID et généralement conçus pour fonctionner sur des ordinateurs uniques ont rapidement posé des problèmes d'extensibilité.\n\n> Afin de répondre à ces limites, ces entreprises ont commencé à développer leurs propres systèmes de gestion de bases de données pouvant fonctionner sur des architectures matérielles distribuées et permettant de traiter des volumes de données importants. Les systèmes propriétaires qui en ont résulté, Google (BigTable), Amazon (Dynamo (en)), LinkedIn (Voldemort), Facebook (Cassandra puis HBase), SourceForge.net (MongoDB), Ubuntu One (CouchDB), Baidu (Hypertable) ont été les précurseurs du modèle NoSQL.\n\n> Les performances restent bonnes avec la montée en charge en multipliant simplement le nombre de serveurs, solution raisonnable avec la baisse des coûts, en particulier si les revenus croissent en même temps que l'activité5. Les systèmes géants sont les premiers concernés : énormes quantités de données6, structuration relationnelle faible (ou de moindre importance que la capacité d'accès très rapide, quitte à multiplier les serveurs).\n\n> Un modèle typique en NoSQL est le système clé-valeur, avec une base de données pouvant se résumer topologiquement à un simple tableau associatif unidimensionnel avec des millions — voire des milliards — d'entrées. Parmi les applications typiques, on retrouve des analyses temps-réel, statistiques, du stockage de logs (journaux), etc.\n\n\n\n\n<!-- {{< fa hand-point-right >}}  -->\n\n[NoSQL](https://fr.wikipedia.org/wiki/NoSQL)\n\n\n\n\n## Lire plus \n\n[Guy Harrison. Next Generation Databases. NoSQL, NewSQL, Big Data](https://scholar.google.com/scholar?hl=fr&as_sdt=0%2C5&q=harrison+next+generation+databases&oq=harrison+next+)\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n<!-- {{< embed http://guyharrison.squarespace.com/blog/tag/nosql >}} -->\n\n\n\n\n# The End  {background-color=\"#1c191c\"}\n\n\n",
    "supporting": [
      "BD_Intro_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}