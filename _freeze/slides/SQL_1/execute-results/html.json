{
  "hash": "b1c28030642a38404cfb306da3e65f76",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"BD II: SQL I\"\nsubtitle: \"Langage Manipulation de Données 1\"\ndate: \"2025-09-19\"\n\nformat: \n  revealjs:\n    header: \"Requêtes SQL simples\"\n\nengine: knitr\n---\n\n\n# Introduction  {background-color=\"#1c191c\"}\n\n\n\n\n##  SQL : Structured Query Language\n\n\nLe SQL est un langage permettant :\n\n- _interrogation_ des données (requêtes)\n\n- _définition_ des données et des contraintes structurelles sur celles-ci\n\n- _manipulation_ des données (insertion, suppression, mise à\n  jour)\n\n- définition des _vues_ et des _index_\n\n- _administration_ des bases de données\n\n\n\n## Plusieurs fois normalisés par l'ISO ...\n\n- SQL-86,  SQL-89, SQL-92, SQL-99,\n- ...\n- SQL-2003, SQL-2008, SQL-2011, SQL-2016,\n- ...\n\nNous utiliserons le dialecte `PostgreSQL` (https://www.postgresql.org)\n\n\nLa norme est révisée environ tous les 5 ans, acutellement ISO/IEC 9075-1:2023 de l'ISO (https://www.iso.org/)\n\n\n\n## Un langage de requête\n\n* Avec SQL, on envoit au serveur des requêtes composées d'instructions,\n\n* Les opérations de l'Algèbre relationnel ne sont pas directement disponibles.\n\n. . .\n\nLa principale instruction  est `SELECT`. Elle permet de _combiner_ :\n\n- restriction/filtrage (sélection) $\\sigma$\n\n- projection $\\pi$\n\n- renommage $\\rho$\n\n- et bien d'autres choses.\n\nD'autres instructions pour définir et manipuler les données, administrer une BDD.\n\n\n\n## Format de l'instruction `SELECT`\n\n\n```{.sql}\nSELECT <liste attribut>\n\nFROM <table>\n\nWHERE <condition> ;\n```\n\\vspace{4cm}\n\ntraduit l'expression\n\n$\\Pi\\left(\\sigma \\left(\\text{<table>}, \\text{<condition>}\\right), \\text{<liste attribut>}\\right)$\n\n<!--Ou `σ(R, Condition) |> Π(<liste attribut>)`-->\n\n\n\n\n## Autres langages, autres choix \n\nOn peut faire autrement : dans les extensions du langage `R`, notamment celles qui relèvent de `tidyverse`, on associe des fonctions à chaque opérateur de l'algèbre\nrelationnelle. Pour les opérateurs qui portent sur une seule table, le premier argument\nde chaque fonction est toujours la table sur laquelle on opère. Les autres arguments\nsont soit les attributs de projection, soit la spécification d'une condition de sélection, soit ...\n\nL'usage d'un opérateur `pipe` (comme dans Unix) permet de composer de facon lisible les opérations.\n\n```\n<table> |>\n  filter(<condition> ) |>\n  select(<liste attribut>) |> \n  ...\n```\n\n\n\n## Syntaxe - requêtes simples\n\n\n```{.sql}\nSELECT [DISTINCT] * | <liste attribut>\n\nFROM <liste de tables>\n\n[WHERE <condition>] ;\n```\n\n- `*` : sélection de tous les attributs (pas de projection)\n\n- `[...]` : clause, expression facultative.\n\n- `DISTINCT` : supprime les doublons.\n\n\n\n## Exemples de requête\n\n::::: {.columns}\n\n::: {.column}\n\nSchémas des tables :\n\n:::\n\n::: {.column}\n\n```{.sql}\nEmploye(Nu, NomE, Annee, Tel, Nudept)\nFournisseur (NomF, Ville, Adresse)\nPiece(NomP, Prix, Couleur)\n```\n:::\n\n:::::\n\nLa requête\n```{.sql}\nSELECT *\n\nFROM Fournisseur ;\n```\n\n. . .\n\nest équivalente à :  $\\quad Fournisseur$\n\n. . .\n\nLa requête\n```{.sql}\nSELECT NomF\n\nFROM Fournisseur\n\nWHERE Ville='Paris' ;\n```\n. . .\n\nest équivalente à : $\\quad \\pi((\\sigma(\\texttt{Fournisseur}, \\texttt{Ville}=\\texttt{'Paris'})), \\texttt{NomF})$\n\n\n\n# Requêtes mono-relation {background-color=\"#1c191c\"}\n\n\n## Structure de base\n\nLa structure de base d'une requête s'appuie sur les trois mots\nclés suivants :\n\n- `SELECT` correspond à l'opérateur de projection sur la liste d'attributs demandée, il peut aussi être suivi de fonctions d'attributs\n\n- `FROM` indique la ou les relations concernées\n\n- `WHERE` précise une condition et correspond à l'opération de restriction/sélection en algèbre relationnelle.\n\n\n\n## Syntaxe de la condition de sélection (`WHERE ...`)\n\n\nUne condition se construit à l'aide des opérations suivantes :\n\n- *Comparaison* avec opérateurs : `=, <>, >,<, >=, <=`\n\n```{.sql}\nSELECT *\n\nFROM Employe\n\nWHERE NomE <>'Durand'  ;  \n```\n\n::: {.callout-caution}\n\nUtiliser `*` en production n'est pas une bonne idée car une modification du schéma de la table `Employe` modifiera le schéma du résultat.\n\n:::\n\n\n## Syntaxe de la condition de sélection (`WHERE ...`) - suite\n\n*Combinaison* de conditions à l'aide des opérateurs logiques:  `AND`, `OR`, `NOT`\n\n```{.sql}\nSELECT DISTINCT NomF\n\nFROM Fournisseur\n\nWHERE (Ville='Londres') OR (Ville='Paris');  \n```\n\n\n{{< fa triangle-exclamation >}} Attention aux priorités dans l'évaluation des expressions logiques\n\n. . . \n\n::: {.callout-warning}\n\n`AND` est prioritaire sur `OR`. Il est utile de parenthéser !\n\n:::\n\n. . .\n\n{{< fa skull >}} Attention aux valeurs `NULL` c.a.d. manquantes/indéterminées. \n \n\n\n## Logique trivalente\n\n`WHERE C` ne sélectionne que les tuples vérifiant `C` = `TRUE`.\n\nUne comparaison sur un attribut `NULL` renvoie `UNKNOWN`, à l'exception de `IS [NOT] NULL`.\n\n. . .\n\nLes opérateurs logiques sont *trivalents* : `TRUE`, `FALSE`, `UNKNOWN`\n\nOn compléte les règles habituelles :\n  \n- `NOT NULL` = `NOT UNKNOWN` = `UNKNOWN`  car résultat incertain\n  \n- `TRUE AND UNKNOWN` = `UNKNOWN`  car résultat incertain\n  \n- `FALSE AND UNKNOWN` = `FALSE`   car résultat certain\n  \n- `TRUE OR UNKNOWN` = `TRUE`  car résultat certain\n  \n- `FALSE OR UNKNOWN` = `UNKNOWN`  car résultat incertain\n\n\n## Test `BETWEEN`\n\nPermet de vérifier si la valeur d'un attribut est comprise entre deux constantes\n\n\n```{.sql}\nSELECT NomE\n\nFROM Employe\n\nWHERE Annee BETWEEN 2022 AND 2025;   \n```\n\n::: {.callout-caution}\n\nÉviter de manipuler les dates et heures comme des chaînes de caractères\n\n:::\n\n\n## Test `IS NULL`\n\nVérifie si une valeur est égale à `NULL` (c-à-d est inconnue).\n\n```{.sql}\nSELECT *\n\nFROM Employe\n\nWHERE Tel IS NULL;    \n```\n\n::: {.callout-caution}\n\n{{< fa skull >}} Attention à la gestion des valeurs manquantes.\n\n:::\n\n\n## Test `IN`\n\n\ntest *appartenance* : permet de vérifier si la valeur d'un attribut appartient à une liste de constantes.\n\n```{.sql}\nSELECT *\n\nFROM Fournisseur\n\nWHERE Ville IN ('Paris', 'Londres');   \n```\n\n\n## Test `LIKE`\n\nPermet de vérifier si un attribut de type chaîne de\ncaractères contient une ou plusieurs sous-chaînes.\n\n$\\_$ : remplace n'importe quel caractère,\n\n$\\%$ : remplace n'importe quelle chaîne de caractères.\n\n\n```{.sql}\nSELECT Ville\n\nFROM Fournisseur\n\nWHERE Ville LIKE 'Saint%';\n```\n\nCette requête sélectionne les noms de ville commençant par 'Saint'.\n\n::: {.callout-warning}\n\n- `LIKE` est sensible à la casse,\n\n- `ILIKE` est insensible à la casse.\n\n:::\n\n\n\n# Requêtes multi-relations  {background-color=\"#1c191c\"}\n\n\n\n## Requêtes multi-relations\n\nQuand l'information est dispersée sur plusieurs tables, on utilise des *jointures*\n\n. . .\n\n\n On peut :\n\n\n- Utiliser plusieurs tables dans la clause `FROM`,\n\n- Faire intervenir des conditions complexes impliquant ces tables dans la clause `WHERE`.\n\n\n\n\n\n\n## Détails du schema `World`\n\nImages et tables créées grâce à DbSchema (https://dbschema.com)\n\n\n\n\n## Diagramme en pattes de corbeau\n\n![img](/images/world.png)\n\n\n\n## Table world.city \n\n| | | |\n|---|---|---|\n| * &#128273;  &#11019; | id| integer  |\n| * | name| text  |\n| * | countrycode| char(3)  |\n| * | district| text  |\n| * | population| integer  |\n\n\n\n\n## Table world.country {.smaller}\n\n::: {.columns}\n\n::: {.column}\n\n| | | |\n|---|---|---|\n| * &#128273;  &#11019; | code| char(3)  |\n| * | name| text  |\n| * | continent| text  |\n| * | region| text  |\n| * | surfacearea| real  |\n|  | indepyear| smallint  |\n| * | population| integer  |\n|  | lifeexpectancy| real  |\n|  | gnp| numeric(10,2)  |\n|  | gnpold| numeric(10,2)  |\n| * | localname| text  |\n| * | governmentform| text  |\n|  | headofstate| text  |\n| &#11016; | capital| integer  |\n| * | code2| char(2)  |\n\n\n:::\n\n::: {.column}\n\n### Foreign Keys\n\n| | | |\n|---|---|---|\n|  | country_capital_fkey | ( capital ) ref [world.city](#city) (id) |\n\n### Constraints\n\n| | |\n|---|---|\n| country_continent_check | ((continent = 'Asia'::text) OR (continent = 'Europe'::text) OR (continent = 'North America'::text) OR (continent = 'Africa'::text) OR (continent = 'Oceania'::text) OR (continent = 'Antarctica'::text) OR (continent = 'South America'::text)) |\n\n:::\n\n::: \n\n\n\n\n\n## Table world.countrylanguage \n\n| | | |\n|---|---|---|\n| * &#128273;  &#11016; | countrycode| char(3)  |\n| * &#128273;  | language| text  |\n| * | isofficial| boolean  |\n| * | percentage| real  |\n\n\n### Foreign Keys\n\n| | | |\n|---|---|---|\n|  | countrylanguage_countrycode_fkey | ( countrycode ) ref [world.country](#country) (code) |\n\n\n\n\n##  Première jointure sur schéma `world`\n\nQuels sont les pays qui portent le même nom que leur capitale ?\n\n. . .\n\n```{.sql}\nSELECT name_country\nFROM country co, city ci   \nWHERE co.capital=ci.id AND co.name_country=ci.name;\n```\n\n. . .\n\nqui correspond à\n\n$\\pi_{\\text{name\\_country}}(\\sigma_{\\text{capital}=\\text{id} \\wedge \\text{name\\_country}=\\text{name}}(\\text{country}\\times \\text{city}))$\n\nautrement dit à\n\n$\\pi_{\\text{name\\_country}}(\\text{country} \\bowtie_{\\text{capital}=\\text{id} \\wedge  \\text{name\\_country}=\\text{name}} \\text{city}))$\n\n\n\n## Syntaxe normalisée pour les jointures : *JOIN* et *ON*\n\nQuels sont les pays qui portent le même nom que leur capitale ?\n\n. . .\n\n```{.sql}\nSELECT name_country\nFROM country co join city ci \nON co.capital=ci.id  \nWHERE co.name_country = ci.name;\n```\n\nqui correspond à\n\n$\\pi_{\\text{name\\_country}}(\\sigma_{\\text{capital}=id \\wedge  \\text{name\\_country}=\\text{name}}(\\text{country} \\times \\text{city}))$\n\n\n\n## Renommage\n\nSi on veut faire une jointure d'une table avec elle-même, on utilise *AS*\npour obtenir deux tables de noms différents\n\n- Quels sont les noms de ville qui apparaissent dans deux pays différents?\n\n. . .\n\n```{.sql}\nSELECT DISTINCT c1.name, c1.countrycode, c2.countrycode\nFROM city AS c1 JOIN city AS c2   \nON c1.countrycode != c2.countrycode AND c1.name=c2.name  \nORDER BY c1.name;\n```\n\n::: {.callout-note}\n\nLe mot `AS` est optionnel.\n\n:::\n\n## Jointure naturelle\n\nQuels sont les noms des pays où le français est parlé ?\n\n. . .\n\n```{.sql}\nSELECT co.name_country, cl.language\nFROM country co, countrylanguage cl\nWHERE co.countrycode=cl.countrycode AND cl.language='French';\n```\nC'est une jointure naturelle.\n\n. . .\n\nSyntaxe normalisée : *NATURAL JOIN*\n\n```{.sql}\nSELECT co.name_country, cl.language\nFROM country co NATURAL JOIN countrylanguage cl\nWHERE cl.language='French';\n```\n\n\n\n## Jointure naturelle (suite)\n\nQuels sont les pays dont une ville a le même nom qu'une langue parlée dans ce pays?\n\n```{.sql}\nSELECT DISTINCT co.name_country, ci.name, language\nFROM country co NATURAL JOIN  \n     city ci NATURAL JOIN     \n     countrylanguage cl     \nWHERE cl.language = ci.name;\n```\n\n::: {.callout-warning}\n\n* la syntaxe `nom_table.nom_attribut` améliore la lisibilité d'une requète multi-table.\n\n* On peut utiliser des alias très systématiquement pour alléger les notations.\n\n:::\n\n \n## Schéma world pour mémoire\n\n![](/images/world.png)\n\n\n\n\n\n## Jointure externe\n\n\n\n- *LEFT OUTER JOIN* : jointure externe gauche. On garde les tuples de la table de gauche qui n'ont pas de correspondant dans l'autre table.\n  \n- *RIGHT OUTER JOIN*  : jointure externe droite. Idem à droite.\n\n- *FULL OUTER JOIN* : on garde les tuples de chacune des tables qui n'ont pas de correspondant.\n\n- On complète les valeurs non renseignées par *NULL*.\n\n\n\n## Exemple de jointure externe\n\n\n- Certains pays n'ont pas de capitale.\n  \n. . .\n\n```{.sql}\nSELECT name_country\nFROM country\nWHERE capital IS NULL;\n```\n\nLe résultat contient 8 lignes.\n\n. . .\n\n- Quels sont les pays qui n'ont pas de capitale ou portent le même nom que leur capitale ?\n\n. . .\n\n```{.sql}\nSELECT co.name_country, ci.name\nFROM country co LEFT OUTER JOIN city ci   \n     ON co.capital=ci.id                  \nWHERE ci.name IS NULL OR co.name_country=ci.name ;  \n```\n\n\n\n\n\n# Fin   {background-color=\"#1c191c\"}\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}