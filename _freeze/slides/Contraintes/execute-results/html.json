{
  "hash": "c199999907ef296110fe9ba72eff8d46",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"BD : Contraintes\"\n---\n\n\n\n\n\n\n\n\n# Introduction  {background-color=\"#1c191c\"}\n\n---\n\n## Problème\n\n- La définition d'un schéma de base ne s'arrête pas à la définition des\ntables, des colonnes et des types des colonnes\n\n. . . \n\n- Les *contraintes* décrivent des propriétés que devront vérifier\ntoutes les mises en oeuvre (instances) du schéma *durant toute sa durée de vie*\n\n---\n\n# Contraintes de type  {background-color=\"#1c191c\"}\n\n---\n\n## Contrainte de type\n\nUne contrainte de type spécifie le type d'une colonne\n\nLes contrainte de type sont les plus simples à mettre en oeuvre. \n\n. . . \n\nAu delà des types de base `varchar, integer, ...`  `PostgreSQL` propose\ndes types sophistiqués pour :\n\n- dates, \n- les estampilles avec ou sans\nfuseau horaire, \n- des types intervalles (`rangetype`), \n- des types énumérés, \n- des types tableaux, \n- etc\n\n---\n\n## Consulter la liste des types\n\n[https://docs.postgresql.fr/docs/current/datatype.html](https://docs.postgresql.fr/docs/current/datatype.html)\n\n\nIl faut essayer d'utiliser ces types pour préciser les contenus des colonnes\n\n{{< fa skull-crossbones >}} Les types disponibles diffèrent d'un SGBD à l'autre (`Mysql`, `Postgres`, `Oracle`, `SQL Server`, ...)\n\n---\n\n\n# Contrainte de vérification  {background-color=\"#1c191c\"}\n\n---\n\n## Contraintes de tuple\n\nUne **contrainte de tuple** peut être vérifiée tuple par tuple (ligne par ligne)\n\n. . . \n\nLors d'une insertion ou d'une modification de tuple, il suffit de\nvérifier que la contrainte est respectée par le nouveau tuple \n\n---\n\n## Exemple\n\nDans un tuple de  `Piece`, on devrait toujours avoir\nune valeur du prix positive. \n\nOn peut imposer cela en\najoutant au schéma de la table  `Piece` une contrainte de\ntype  `CHECK`\n\n---\n\n## Exemple (suite)\n\n```{.sql}\nCREATE TABLE piece(\n    nomp VARCHAR(20),\n    prix MONEY CHECK (prix>= 0::money), #<<\n    couleur VARCHAR(15)\n);\n```\n\n. . . \n\nHave a look at [PostGres Monetary type](https://www.postgresql.org/docs/current/datatype-money.html)\n\n---\n\n## Exemple `world.country`  {smaller}\n\nDans un tuple de `country`, les colonnes numériques ne devraient\npas prendre de valeur négative\n\n. . .\n\n\n```{.sql}\nCREATE TABLE world.country (\n\tcountrycode BPCHAR(3) NOT NULL,\n\tname_country TEXT NOT NULL,\n\tcontinent TEXT NOT NULL,\n\tregion TEXT NOT NULL,\n    surfacearea FLOAT4 CHECK (surfacearea>= 0) NOT NULL, #<<\n\tindepyear INT2 NULL,\n    population_country INT4 NOT NULL,\n    lifeexpectancy FLOAT4 CHECK (lifeexpectancy>= 0) NULL, #<<\n    gnp NUMERIC(10, 2) NULL,    #<<\n    gnpold NUMERIC(10, 2) NULL,  #<<\n\tlocalname TEXT NOT NULL,\n\tgovernmentform TEXT NOT NULL,\n\theadofstate TEXT NULL,\n\tcapital INT4 NULL,\n\tcode2 BPCHAR(2) NOT NULL,\n\tCONSTRAINT country_continent_check CHECK (\n        ((continent = 'Asia'::text) OR (continent = 'Europe'::text) OR \n         (continent = 'North America'::text) OR (continent = 'Africa'::text) OR \n         (continent = 'Oceania'::text) OR (continent = 'Antarctica'::text) OR \n         (continent = 'South America'::text))),\n\tCONSTRAINT country_pkey PRIMARY KEY (countrycode)\n);\n```\n\n\n\n## Contrainte de vérification - Exemple (suite)\n\n\n```{.sql}\nCREATE TABLE piece(\n    nomp VARCHAR(20),\n    prix moNey CHECK (prix>= 0::money),  #<<\n    prix_promo MONEY CHECK (prix_promo >= 0::MONEY), #<<\n    couleur VARCHAR(15),\n    CHECK(prix > prix_promo) #<<\n); \n```\n\n. . . \n\n```{.sql}\nINSERT INTO piece VALUES('x21', 1.51, 1.61,'rouge');\n```\n`ERROR:  new row for relation \"piece\" violates check constraint piece_check` {{< fa face-angry >}}\n\n. . . \n\n```{.sql}\nINSERT INTO piece VALUES('x21', 1.51, null,'rouge');\n```\nest accepté  {{< fa champagne-glasses >}}\n\n\n\n\n---\n\n## {{< fa triangle-exclamation >}}  Valeurs nulles et  contraintes de tuple\n\nLes contraintes  `CHECK` sont satisfaites si l'expression associée vaut  `TRUE` ou  `NULL` \n\n. . . \n\nComme une expression composée vaut parfois `NULL` si l'un\ndes opérandes vaut lui-même  `NULL`, les contraintes  `CHECK` ne\nsuffisent pas à prévenir l'insertion de valeurs nulles\n\n. . . \n\nIl faut  compléter les contraintes de tuple  avec des *contraintes de non-nullité*\n\n---\n\n# Contrainte de non-nullité  (NOT NULL)  {background-color=\"#1c191c\"}\n\n---\n \n\n## Pourquoi imposer qu'une colonne soit toujours renseignée ?\n\nLa présence possible des valeurs nulles rend beaucoup d'opérations complexes \n\nIl faut avoir en tête que en `SQL`, \n\n- les booléens peuvent avoir trois valeurs : `TRUE, FALSE` et  `NULL` et que \n\n- le fait qu'une expression ne vaille pas  `FALSE` ne veut pas dire qu'elle\nvaut  `TRUE` ...\n \n. . . \n\nPour imposer qu'une colonne soit renseignée :\n\n- préciser après le type : `NOT NULL`\n\n\n---\n\n## Contrainte de non-nullité (Exemple)\n\n```{.sql}\nCREATE TABLE piece(\n    nomp VARCHAR(20) NOT NULL,\n    prix MONEY CHECK (prix>= 0::MONEY),  #<<\n    prix_promo MONEY CHECK (prix_promo >= 0::MONEY),  #<<\n    couleur VARCHAR(15),\n    CHECK (prix > prix_promo)   #<<\n); \n```\n\n---\n\n# Contrainte d'unicité  {background-color=\"#1c191c\"}\n\n---\n\n\n## Contrainte d'unicité\n\n- Les contraintes d'unicité garantissent l'unicité des données contenues dans une colonne \nou un groupe de colonnes par rapport à toutes les lignes de la table\n\n- C'est une *contrainte de table* puisqu'elle fait intervenir tous les tuples de la table\n\n\n```{.sql}\nCREATE TABLE piece(\n    nomp VARCHAR(20) NOT NULL UNIQUE, #<< \n    prix money CHECK (prix>= 0::money),\n    prix_promo MONEY CHECK (prix_promo >= 0::MONEY),\n    couleur VARCHAR(15),\n    CHECK (prix > prix_promo)\n);\n \n```\n\n\n\n\n---\n\n## Contrainte d'unicité   \n\n- La contrainte d'unicité peut porter sur un groupe de colonnes\n\n```{.sql}\nCREATE TABLE fournisseur(\n    nomf VARCHAR(20) NOT NULL,\n    villef VARCHAR(20) NOT NULL,\n    UNIQUE(nomf, villef)  #<<\n);\n```\n- Il ne peut pas avoir deux lignes identiques dans la table `fournisseur`\n\n\n---\n\n# Clef primaire  {background-color=\"#1c191c\"}\n\n---\n \n\n## Clef primaire : **PRIMARY KEY**\n\n\n- Une contrainte de type clef primaire indique qu'une colonne, ou un groupe de colonnes, \npeuvent être utilisée comme un identifiant unique de ligne pour cette table.\n\n- Ceci nécessite que les valeurs soient à la fois uniques et `NON NULL`\n\n- Les définitions de table suivantes acceptent de ce fait les mêmes données\n\n::::: {.columns}\n\n::: {.column}\n```{.sql}\nCREATE TABLE fournisseur(\n    nomf VARCHAR(20) NOT NULL,\n    villef VARCHAR(20) NOT NULL,\n    UNIQUE(nomf, villef)  \n);\n```\n:::\n\n::: {.column}\n```{.sql}\nCREATE TABLE fournisseur(\n    nomf VARCHAR(20),\n    villef VARCHAR(20),\n    PRIMARY KEY (nomf, villef)  #<<\n);\n```\n:::\n\n:::::\n\n{{< fa triangle-exclamation >}} Une table a au plus une clef primaire\n\n---\n\n# Clef étrangère  {background-color=\"#1c191c\"}\n\n---\n\n## Clef étrangère\n\n\n- Une contrainte de clef étrangère stipule que les valeurs d'une colonne (ou d'un groupe de colonnes) doivent correspondre aux valeurs qui apparaissent dans les lignes d'une autre table.\n\n- On dit que cela maintient l'*intégrité référentielle* entre les deux tables\n\n- Soit les deux tables suivantes\n\n::::: {.columns}\n\n::: {.column}\n\n```{.sql}\nCREATE TABLE fournisseur(\n    idf INT PRIMARY KEY,\n    nomf VARCHAR(20),\n    villef VARCHAR(20)\n);\n```\n\n:::\n\n::: {.column}\n\n```{.sql}\nCREATE TABLE piece(\n    nomp VARCHAR(20) PRIMARY KEY,\n    prix MONEY CHECK \n        (prix>= 0::MONEY),\n    prix_promo MONEY CHECK \n        (prix_promo >= 0::MONEY),\n    couleur VARCHAR(15),\n    CHECK (prix > prix_promo)\n);\n```\n:::\n\n:::::\n\n---\n\n## Clef étrangère : REFERENCES\n\n- Soit également une table `livraison` qui stocke les livraisons de ces pièces\n\n- Il est intéressant de s'assurer que la table  `livraison` ne contient que des \nréférences de pièces et de fournisseurs qui existent dans la base\n\nPour cela, deux  contraintes de *clef étrangère* sont  émises par la table des livraisons \n\n- Une contrainte référence  `piece` \n- Une contrainte référence  `fournisseur`\n\n```{.sql}\nCREATE TABLE livraison(\n    numliv INT PRIMARY KEY,\n    idf INT REFERENCES fournisseur,  #<< \n    nomp VARCHAR(20) REFERENCES piece,  #<<\n    dateLiv DATE DEFAULT NOW(),\n    quantite INT DEFAULT 1 CHECK (quantite>=0)\n);\n \n```\n\n- Il est désormais impossible de créer des livraisons pour lesquelles les valeurs non `NULL` de `nomp` \nn'apparaissent pas dans la table `piece` et les valeurs non `NULL` de `idf` n'apparaissent pas dans la table `fournisseur`\n\n- On dit que la table des livraisons est la table qui référence et la table des pièces est la table référencée\n\n---\n\n## Définition de world.countrylanguage\n\n\n\n\n```{.default}\n+-------------+--------------+-------------+\n| Column      | Type         | Modifiers   |\n|-------------+--------------+-------------|\n| countrycode | character(3) |  not null   |\n| language    | text         |  not null   |\n| isofficial  | boolean      |  not null   |\n| percentage  | real         |  not null   |\n+-------------+--------------+-------------+\nIndexes:\n    \"countrylanguage_pkey\" PRIMARY KEY, btree (countrycode, language)\n```\n\n\n\n\n\n---\n\n## Définition de world.country  {smaller}\n\n\n\n\n\n\n```{.default}\n+--------------------+---------------+-------------+\n| Column             | Type          | Modifiers   |\n|--------------------+---------------+-------------|\n| countrycode        | character(3)  |  not null   |\n| name_country       | text          |  not null   |\n| continent          | text          |  not null   |\n| region             | text          |  not null   |\n| surfacearea        | real          |  not null   |\n| indepyear          | smallint      |             |\n| population_country | integer       |  not null   |\n| lifeexpectancy     | real          |             |\n| gnp                | numeric(10,2) |             |\n| gnpold             | numeric(10,2) |             |\n| localname          | text          |  not null   |\n| governmentform     | text          |  not null   |\n| headofstate        | text          |             |\n| capital            | integer       |             |\n| code2              | character(2)  |  not null   |\n+--------------------+---------------+-------------+\nIndexes:\n    \"country_pkey\" PRIMARY KEY, btree (countrycode)\nCheck constraints:\n    \"country_continent_check\" CHECK\n    (continent = 'Asia'::text OR continent = 'Europe'::text\n    OR continent = 'North America'::text\n    OR continent = 'Africa'::text OR continent = 'Oceania'::text \n    OR continent = 'Antarctica'::text OR continent = 'South America'::text)\nForeign-key constraints:\n    \"country_capital_fkey\" FOREIGN KEY (capital) REFERENCES world.city(id)  #<<\nReferenced by:\n    TABLE \"world.countrylanguage\"\n    CONSTRAINT \"countrylanguage_countrycode_fkey\" FOREIGN KEY (countrycode)\n    REFERENCES country(countrycode)\n```\n\n\n\n\n\n---\n\n## Foreign keys emitted by `world.country`\n\n\n```{.sql}\nALTER TABLE world.country ADD \n    CONSTRAINT country_capital_fkey \n        FOREIGN KEY (capital)   #<<\n        REFERENCES world.city(id);  #<<\n\nALTER TABLE world.country \n    ADD CONSTRAINT country_fk \n        FOREIGN KEY (continent)   #<<\n        REFERENCES world.code_continent(continent);  #<<\n```\n\n\n---\n\n# Fin {background-color=\"#1c191c\"}\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}