{
  "hash": "982cfb99a0d46e4a4dd4c8e068391574",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Normalisation I\"\nsubtitle: \"Dépendances Fonctionnelles. Décomposition FNBC\"\ndate: \"2024-11-22\"\n\nformat: \n  revealjs:\n    header: \"Dépendances Fonctionnelles. Fermetures. Décomposition FNBC\"\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n# Introduction  {background-color=\"#1c191c\"}\n\n---\n\n\n## Conception du modèle relationnel\n\nUne première approche pour concevoir un modèle relationnel (l'ensemble des schémas de tables d'une bd) consiste à :\n\n- Identifier les attributs d'intérêt\n\n- Répartir les attributs dans plusieurs relations\n\n. . .\n\n- Comment savoir si le modèle relationnel est *bon* ?\n\n. . .\n\n- Si ce n'est pas le cas : y a-t-il des techniques pour le transformer en un *bon* modèle?\n\n\n\n\n---\n\n\n\n## Qualité d'un schéma  {.smaller}\n\nQuelles sont de *bonnes propriétés* d'un schéma ?\n\n\n**Exemple**\n\nAttributs relatifs à des *vendeurs*, *produits* et *livraisons*\n\n| Attribut |  Usage |\n|:--------:|:----------------|\n| **`V#`** | numéro du vendeur   |\n| `Vnom`   | nom du vendeur  |\n| `Vville` |ville du vendeur   |\n| **`P#`** | numéro du produit  |\n|`Pnom`    |nom du produit  |\n|`Pville`  |ville où le produit est stocké  |\n|`Qte`     |quantité de produit livrée au vendeur |\n\n\n\n## Qualité d'un schéma\n\nUn schéma relationnel possible : une seule relation `R` avec tous les attributs\n\n```\nR(V#, Vnom, Vville, P#, Pnom, Pville, Qte)\n```\n\n. . .\n\n\n- {{< fa face-frown >}} C'est une mauvaise modélisation.\n\n- {{< fa brain >}} Pourquoi ?\n\n\n\n---\n\n## Qualité d'un schéma relationnel\n\n::: {.callout-caution}\n\n### Redondance\n\n| V# |  Vnom |  Vville |  P# |  Pnom |  Pville |  Qte |\n|---:|:-----:|:-------:|----:|:-----:|:-------:|----: |\n|3 | MagicV | Paris | ... | ... | ... | ... |\n|3 | MagicV | Paris | ... | ... | ... | ... |\n|2 | IdealB | Lyon | ... | ... | ... | ... |\n|2 | IdealB | Lyon | ... | ... | ... | ... |\n\n\n\n`Vnom` et `Vville` sont déterminés par` V#` :\n\nsi deux livraisons ont le même `V#`, elles ont aussi le même `Vville` et le même `Vnom`\n\n:::\n\n---\n\n## {{< fa face-frown >}}\n\n\n- **Anomalies de mise à jour**\n\n`Vnom` ou `Vville` pourrait être mis à jour dans une livraison et pas dans une autre, ce qui donnerait une incohérence. Les mesures pour éviter cela rendent la mise à jour est coûteuse\n\n. . .\n\n- **Anomalies d'insertion**\n\nOn ne peut pas enregistrer un vendeur s'il ne reçoit pas de livraison\n\n\n. . .\n\n- **Anomalies de suppression**\n\nSi on supprime toutes les livraisons à un vendeur, on perd toute l'information sur ce vendeur\n\n\n---\n\n## Qualité d'un schéma relationnel\n\n- Un *bon* schéma\n\n\n\n\n```{.default}\nVendeur(V#, Vnom, Vville)    Clef : V#\nProduit(P#, Pnom, Pville)    Clef : P#\nLivraison(V#, P#, Qte)       Clef : (V#,P#)\n```\n\n\n\n- Plus d'anomalie ! Comment y arriver?\n\n. . .\n\nLa théorie de la *normalisation* des BD relationnelles fournit\n\n- la notion de **forme normale** : propriétés d'un schéma qui garantissent l'absence de redondance et des anomalies qui en dérivent. Ces propriétés sont définies par rapport à un ensemble de *contraintes*\n\n- des *techniques de normalisation* : passage d'un schéma arbitraire (mauvais) à un schéma en forme normale (obtenu typiquement par décomposition)\n\n\n---\n\n\n# Dépendances fonctionnelles  {background-color=\"#1c191c\"}\n\n\n---\n\n\nUne dépendance fonctionnelle est une forme particulière de *contrainte d'intégrité* portant sur *une* relation/table : il s'agit d'une forme particulière contrainte d'exclusion `EXCLUDE`\n\nC'est la *réalité* modélisée qui impose ces contraintes\n\n. . .\n\n::: {.callout-note}\n\n### Exemple :\n\n`R(V#, Vnom, Vville, P#, Pnom, Pville, Qte)`\n\nUn ensemble de dépendances fonctionnelles qu'on peut raisonnablement supposer :\n\n\n\n\n```{.default}\nV# ⟶ Vnom Vville\nP# ⟶ Pnom Pville\nV# P# ⟶ Qte\n```\n\n\n\n- Cela signifie que l'on ne considère que des relations R qui satisfont :\n- si 2 tuples de `R` ont la même valeur de `V#` alors ils ont la même valeur de `Vnom` et `Vville`\n- si 2 tuples de `R` ont la même valeur de `P#` alors ils ont la même valeur de `Pnom` et `Pville`\n- ...\n\n:::\n\n\n## DF exemple (suite) {.smaller}\n\n\n| V# |  Vnom |  Vville |  P# |  Pnom |  Pville |  Qte  |\n|---:|:-----:|:-------:|----:|:-----:|:-------:|:-----:|\n|3 | MagicV | Paris | 322 | manteau | Lille | 2 |\n|1 | StarV | Rome | 546 | veste | Rome | 1 |\n|3 | MagicV | Paris | 322 | manteau | Lille | 5 |\n|2 | IdealB | Lyon | 145 | jupe | Paris | 7 |\n|2 | IdealB | Lyon | 234 | jupe | Lille | 1 |\n\n. . .\n\n- `R` satisfait `V#` ⟶ `Vnom Vville` et `P#` ⟶ `Pnom Pville`\n\n- `R` viole `V# P#` ⟶ `Qte`\n\n\n---\n\n## Autre Exemple   {.smaller}\n\nSchéma `Films(titre, année, durée, genre, producteur, acteur)`\n\n| titre |  année |  durée |  genre |  producteur |  acteur |\n|:------|:---------:|----------:|:----------|:---------------|:-----------|\n|Star Wars | 1977 | 124 | SciFi | Fox | Carrie Fisher |\n|Star Wars | 1977 | 124 | SciFi | Fox | Mark Hamill |\n| Star Wars | 1977 | 124 | SciFi | Fox | Harrison Ford |\n|Gone With The Wind | 1939 | 231 | drame | MGM | Vivien Leigh|\n|Wayne's World | 1992 | 95 | comédie | Paramount | Dana Carvey|\n|Wayne's World | 1992 | 95 | comédie | Paramount | Mike Meyers|\n| ... | | | | | |\n\n---\n\n- On sait qu'il n'y a pas 2 films de même nom qui sortent la même année. On a donc la dépendance suivante\n\n`titre, année ⟶ durée, genre, producteur`\n\n- La DF `titre, année ⟶ acteur`\n\nest certainement fausse puisqu'un film fait intervenir en général plusieurs acteurs\n\n- A-t-on la DF `titre, acteur ⟶ année, durée, genre, producteur` ?\n\n\n\n## Définition d'une dépendance fonctionnelle\n\n::: {.callout-important}\n\n### Définition : Dépendance fonctionnelle \n\nSoit $\\mathcal{A}$ un schéma de relation ($\\mathcal{A}$ est un ensemble d'attributs)\n\nUne *dépendance fonctionnelle* sur $\\mathcal{A}$ est une expression de la forme\n\n$$X → Y$$\n\noù $X ⊆ \\mathcal{A}$ et $Y ⊆ \\mathcal{A}$\n\nUne relation $R$ de schéma $\\mathcal{A}$ satisfait $X → Y$ si pour tous tuples $s,t ∈ R$ on a\n\n$$\\bigl(∀ A∈ X\\ s.A=t.A\\bigr) ⟹ \\bigl(\\forall A∈ Y\\ s.A=t.A\\bigr)$$\n\n(si $s$ et $t$ coïncident sur $X$ alors $s$ et $t$ coïncident sur $Y$)\n\nUne relation $R$, de schéma $\\mathcal{A}$, satisfait un ensemble $\\Sigma$ de DF si $R$ satisfait chaque DF de $\\Sigma$\n\n:::\n\n---\n\n## Exemples\n\nDans la base **Pagila**, relation `Actor` :\n\n- `Actor_id ⟶ last_name`, `first_name`\n\n- car `Actor_id` est une clé...\n\n\n---\n\n::: {.callout-important}\n\n### Définition : dépendance élémentaire\n\n$A_1,...,A_p \\rightarrow Y$ est une dépendance *élémentaire* si\npour tout $j\\leq p$ :  $A_1,...,A_{j-1},A_{j+1},...,A_p\\not\\rightarrow Y$\n\n:::\n\n. . .\n\n- `No_insee ⟶ sexe, mois_naiss, jour_naiss` est  élémentaire.\n\n- `No_insee, jour_naiss ⟶ sexe, mois_naiss, ville_naiss` n'est pas élémentaire ...\n\n\n::: {.aside}\n\n`No_insee` suffit\n\n:::\n\n\n\n---\n\n\n\n## Dépendance fonctionnelle triviale\n\nUne DF triviale est une DF satisfaite par toute relation\n\n\n::: {.callout-important}\n\n### Définition (dépendance triviale)\n\nSoient $X,Y⊂ \\mathcal{A}$\n\n$X\\rightarrow Y$ est une dépendance triviale si $Y ⊂ X$\n\n:::\n\n. . .\n\n::: {.callout-note}\n\n### Exemple\n\n`No_insee ` ⟶ `No_insee` est  triviale\n\n\n:::\n\n\n## Implication pour les  DF\n\n- Soit $\\mathcal{A}$ un schéma de relation ( $\\mathcal{A}$ est un ensemble d'attributs) et $\\Sigma$\nun ensemble de DF sur $\\mathcal{A}$\n\n- Exemple : $\\mathcal{A}=\\{A,B,C\\}$ et $\\Sigma=\\{A\\rightarrow B, B\\rightarrow C\\}$\n\n- Les DF données impliquent d'autres DF additionnelles\n\n. . .\n\n::: {.callout-note}\n\n### Exemple I\n\n$A\\rightarrow B$ et $B\\rightarrow C$ impliquent $A\\rightarrow C$\n\nc'est-à-dire : toute relation de schéma $\\mathcal{A}$ qui satisfait $A\\rightarrow B$ et $B\\rightarrow C$\nsatisfait également $A\\rightarrow C$\n\n:::\n\n. . .\n\n::: {.callout-note}\n\n### Exemple II\n\n$A\\rightarrow C$, $BC\\rightarrow D$, $AD\\rightarrow E$ impliquent $AB\\rightarrow E$\n\n:::\n\n---\n\n\n\n## Implication entre  DF\n\n\n::: {.callout-important}\n\n### Définition\n\nUn ensemble $\\Sigma$ de DF *implique* une autre DF $X\\rightarrow Y$ si\ntoute relation qui satisfait $\\Sigma$ satisfait également $X\\rightarrow Y$.\n\nNotation pour $\\Sigma$ implique $X\\rightarrow Y$ :\n\n$$\\Sigma \\models X \\rightarrow Y$$\n\n:::\n\n. . .\n\n::: {.callout-note}\n\n\n### Exemple\n\n$\\Sigma=\\{A\\rightarrow B, B\\rightarrow C\\}$ implique\n\n$A\\rightarrow B$, $B\\rightarrow C$, $A\\rightarrow C$, $A,B\\rightarrow C$, ...\n\nmais aussi les DF triviales $A\\rightarrow A$, $AB\\rightarrow A$, ...\n\n:::\n\n\n---\n\nTrois règles d'inférence (facile à vérifier) :\n\n::: {.callout-important}\n\n### Règles d'Armstrong\n\n- *Transitivité* : $\\{ X\\rightarrow Y, Y\\rightarrow Z\\} \\models X\\rightarrow Z$\n\n- *Augmentation* : $X\\rightarrow Y \\models \\{X,Z\\} \\rightarrow \\{Y,Z\\}$\n\n- *Réflexivité* : $\\varnothing \\models \\{X,Y\\}\\rightarrow X$  (DF triviale)\n\n:::\n\n\n---\n\n::: {.callout-important}\n\n### Théorème\n\n$\\Sigma \\models X\\rightarrow Y$\n\nsi et seulement si\n\n$X\\rightarrow Y$ peut-être dérivée de $\\Sigma$ par applications successives des trois règles d'Armstrong\n\n:::\n\n\n## Preuve\n\n\n### {{< fa person-chalkboard >}}\n\n\n---\n\nDe ces 3 règles, on déduit d'autres règles :\n\n- *Union* : $\\{X\\rightarrow Y, X\\rightarrow Z\\} \\models X\\rightarrow \\{Y,Z\\}$\n\n- *Séparation* : $X\\rightarrow \\{Y,Z\\} \\models X\\rightarrow Y$\n\n- ...\n\n\n---\n\n\n\n# Clef et super-clef {background-color=\"#1c191c\"}\n\n---\n\nSoit $\\mathcal{A}$ un schéma et $\\Sigma$ une ensemble de DF sur $\\mathcal{A}$\n\n::: {.callout-important}\n\n### Définition\n\nUn ensemble d'attributs $X$ est une **super-clef** si\n\n$\\Sigma \\models X \\rightarrow \\mathcal{A}$\n\nc-à-d si $X$ détermine tous les attributs de $\\mathcal{A}$\n\n:::\n\n--- \n\n::: {.callout-important}\n\n### Définition\n\nUn ensemble d'attributs $X$ est une **clef** si $X$ est une super-clef et si\ntout sous-ensemble $Y\\subset X$ tel que $Y\\not=X$ n'est pas une super-clef\n\n:::\n\n\n. . . \n\n::: {.callout-note}\n\n### Exemple\n\n$R(A,B,C) \\qquad \\Sigma = \\{A\\rightarrow B, B\\rightarrow C\\}$\n\nSuper-clefs : $A$, $AB$, $AC$, $ABC$\n\nClef : $A$ (la seule)\n\n:::\n\n\n\n## Implication d'un ensemble de DF par un autre  {visibility=\"hidden\"}\n\nSoit $\\Sigma$ et $\\Sigma'$ deux ensemble de DF sur un schéma $\\mathcal{A}$\n\nOn dit que $\\Sigma$ *implique* $\\Sigma'$  si $\\Sigma$ implique toutes les DF de $\\Sigma'$\n\nOn le note $\\Sigma \\models \\Sigma'$\n\n---\n\n## Exemples\n\n\n$\\mathcal{A}=\\{A,B,C,D\\}$,\n\n$\\Sigma= \\{AB\\rightarrow C, C\\rightarrow A, BC\\rightarrow D\\}$|\n\n$\\Sigma'=\\{AB\\rightarrow D\\}$\n\n$\\Sigma\\models\\Sigma'$\n\n\n---\n\n::: {.callout-important}\n\n### Définition\n\n\n$\\Sigma$ est *équivalent* à $\\Sigma'$\n\nssi\n\n$\\Sigma\\models\\Sigma'$ et $\\Sigma'\\models\\Sigma$\n\n:::\n\n\n--\n\nExemples\n\n- $X\\rightarrow A_1,...,A_n$ est équivalent à $X\\rightarrow A_1$, ..., $X\\rightarrow A_n$|\n\n- $XY\\rightarrow YZ$ est équivalent à $XY\\rightarrow Z$\n\n\n\n\n\n\n\n\n\n\n\n# Fermeture d'un ensemble d'attributs  {background-color=\"#1c191c\"}\n\n\n\n## Question principale\n\n- Comment vérifier si un ensemble $\\Sigma$ de DF implique une DF $X\\rightarrow Y$~?\n\n. . . \n\n- Par les équivalences présentées précédemment, la question se ramène à :\n\nComment vérifier si un ensemble $\\Sigma$ de DF implique une DF $X\\rightarrow A$\noù $A$ est un attribut~?\n\n\n## Fermeture d'un ensemble d'attributs\n\nSoit $X \\subset\\mathcal{A}$ un sous-ensemble d'attributs et $\\Sigma$ un ensemble de DF sur $\\mathcal{A}$\n\n\n::: {.callout-important}\n\n### Définition\n\nLa fermeture de $X$ par rapport à $\\Sigma$ est\n\n$$X^+=\\{ A\\in\\mathcal{A} \\mid \\Sigma\\models X\\rightarrow A \\}$$\n\n:::\n\n::: {.aside}\n\nAutrement dit $X^+$ est l'ensemble des attributs déterminés par $X$\n\n:::\n\n\n##  Exemple de fermeture\n\n- $R(ABCDE)$\n- $\\Sigma=\\{AB\\rightarrow C, C\\rightarrow D, E\\rightarrow D\\}$\n- $\\{A,B\\}^+=\\{A,B,C,D\\}$\n\n\n---\n\n\n\n# Algorithme pour calculer une fermeture  {background-color=\"#1c191c\"}\n\n---\n\nSoit $\\Sigma$ un ensemble de DF sur un schéma $\\mathcal{A}$ et $X\\subset\\mathcal{A}$\n\n### Algorithme\n\n\n##  {.smaller}\n\n\n```pseudocode\n#| html-indent-size: \"1.2em\"\n#| html-comment-delimiter: \"//\"\n#| html-line-number: true\n#| html-line-number-punc: \":\"\n#| html-no-end: false\n\n\\begin{algorithm}\n\\caption{Fermeture}\n\\begin{algorithmic}\n\\Procedure{Fermeture}{$X, Σ$}\n\n\\State $X^c ←  X$\n\n\\Repeat\n  \\State stop ← \\True\n  \\For{$(Y → Z) ∈ Σ$}\n    \\If{$Y ⊆ Z ∧ Z ⊄ X^c$}\n      \\State $X^c ←  X^c ∪ Z$\n      \\State stop ← \\False\n    \\EndIf\n  \\EndFor\n\\Until{stop}\n\n\\Return $X^c$\n\\EndProcedure\n\n\\end{algorithmic}\n\\end{algorithm}\n```\n\n##\n\n```{.r}\nXc <-  X\n\nwhile (exists Y -> Z in Σ with Y ⊂ Xc and not Z ⊄ Xc) {\n  Xc <- Xc ∪ Z\n}\n\nreturn Xc\n```\n\n. . .\n\n- `Xc` grandit à chaque itération\n\nComme $\\mathcal{A}$ est fini, l'algorithme se termine en au plus $|\\mathcal{A}|$ itérations\n\n\n## Preuve de la correction de l'algorithme de fermeture\n\n\n### {{< fa person-chalkboard >}}\n\n\n\n## Exemple de calcul de fermeture\n\n$\\mathcal{A}=\\{ABCDEF\\}$ $\\Sigma=\\{A\\rightarrow C, BC\\rightarrow D, AD\\rightarrow E\\}$ $X=\\{A,B\\}$\n\n- $X_c=\\{A,B\\}$\n\n- $A\\rightarrow C$ donc on obtient $X_c=\\{A,B,C\\}$\n\n- $BC\\rightarrow D$ donc on obtient $X_c=\\{A,B,C,D\\}$\n\n- $AD\\rightarrow E$ donc on obtient $X_c=\\{A,B,C,D, E\\}$\n\n- On obtient $X^+=\\{A,B,C,D, E\\}$\n\n\n## Correction de l'algorithme de fermeture\n\n- L'algorithme calcule uniquement des attributs dans la fermeture car\non a toujours $X_c\\subset X^+$\n\n- L'algorithme calcule tous les attributs dans la fermeture:  $X_c=X^+$ quand l'algorithme se termine\n\n\n---\n\n::: {.proof}\n\nSupposons que $A\\notin X_c$ quand l'algorithme se termine\n\nLa relation $R=\\{t_1,t_2\\}$ suivante (où $c\\neq d$ )\n\n\n|       | $X_c$   | A |  ...| ... |\n|:------|:-------:|:----:|:------:|\n| $t_1$ | aa... a | c | cc... c |\n| $t_2$ | aa... a | d | dd... d |\n\nsatisfait $\\Sigma$\n\ncar pour toute DF $Y\\rightarrow Z$ telle que $Y\\subset X_c$ on a $Z\\subset X_c$.\n\nMais $R$ ne satisfait pas $X\\rightarrow A$. Donc $A\\notin X^+$.\n\n:::\n\n\n## Calcul de la fermeture transitive : exemple\n\n::::: {.columns}\n\n::: {.column}\n\nSoit $R$ d'ensemble d'attributs\n\n$$\\mathcal{A} =\\{A,B,C,D,E,F,G\\}$$\n\nSoit $X=\\{B,D\\} \\subset \\mathcal{A}$\n\nEt $Σ$ l'ensemble de dépendances fonctionnelles ci-contre\n\n:::\n\n::: {.column}\n\n|   $\\Sigma$   |\n|:---------------------:|\n| $A,B \\rightarrow C$ |\n| $C \\rightarrow A$ |\n| $B,C \\rightarrow D$ |\n| $A,C,D \\rightarrow B$ |\n| $F\\rightarrow A,C$|\n| $D \\rightarrow E,G$ |\n| $B,E \\rightarrow C$ |\n| $C,G \\rightarrow B,D$ |\n| $C,E \\rightarrow A,G$ |\n\n:::\n\n:::::\n\nMontrer que  $X^+=\\{A,B,C,D,E,G\\}$\n\nDonner une clef de $R$\n\n\n\n---\n\n\n# Forme normale de Boyce-Codd  {background-color=\"#1c191c\"}\n\n\n\n## Forme normale de Boyce-Codd (FNBC)\n\n::: {.callout-important}\n\n### Définition\n\nUn schéma $\\mathcal{A}$ est en FNBC par rapport à un ensemble de dépendances fonctionnelles $\\Sigma$ sur $\\mathcal{A}$\n\nsi\n\npour toute DF $X\\rightarrow Y$ impliquée par $\\Sigma$ avec $Y\\not\\subset X$, $X$ est une super-clef\n\n:::\n\n. . .\n\n- {{< fa hand-point-right >}} $(\\mathcal{A},\\Sigma)$ est en FNBC si pour toute DF non triviale impliquée par $\\Sigma$, le membre de gauche est une super-clef\n\n---\n\n::: {.callout-important}\n\n### Proposition\n\nSoit $\\Sigma'$ un ensemble de DF équivalent à $\\Sigma$.\n\n$(\\mathcal{A},\\Sigma)$ est en FNBC si et seulement si pour toute DF non triviale de $\\Sigma'$, le membre de gauche est une super-clef\n\n:::\n\n::: {.aside}\n\nEn effet  toute DF impliquée par $\\Sigma$ peut être obtenue à partir des DF de $\\Sigma'$ en utilisant les règles d'Armstrong\n\n:::\n\n---\n\n\n\n## FNBC : exemple 1\n\n- Schéma $\\mathcal{A}=\\{\\texttt{V\\#, Vnom, Vville, P\\#, Pnom, Pville, Qte}\\}$\n\nEnsemble de dépendances fonctionnelles $\\Sigma$ :\n\n\n\n\n```{.default}\nV# ⟶ Vnom Vville\nP# ⟶ Pnom Pville\nV# P# ⟶ Qte\n```\n\n\n\n. . .\n\n$\\mathcal{A}$ n'est pas en FNBC par rapport $\\Sigma$.\n\nEn effet ni V# ni P# ne sont des super-clefs\n\n\n## FNBC : exemple 2\n\nSchéma `Films(titre, année, durée, genre, producteur, acteur)`\n\n\n- On a la dépendance suivante `titre, année ⟶ durée, genre, producteur`\n\n- `titre, année, acteur` est la seule clef\n\n- La DF  `titre, année` ⟶ `durée, genre, producteur`} viole la condition de FNBC\n\n\n\n\n\n\n## FNBC : exemple 3\n\n\nTrois schémas en FNBC :\n\n| Relation | Clef |\n|:---------|:------:|\n| `Vendeur(V#, Vnom, Vville)` |  `V#`  |\n| `Produit(P#, Pnom, Pville)` |  `P#`  |\n| `Livraison(V#, P#, Qte)`    | `(V#,P#)` |\n\n\n---\n\n\n\n## Schéma avec deux attributs\n\n::: {.callout-important}\n\n### Proposition\n\nSoit $\\mathcal{A}=\\{A,B\\}$ un schéma avec deux attributs et $\\Sigma$ un ensemble de DF non triviales.\n\n$\\mathcal{A}$ est toujours en FNBC par rapport à $\\Sigma$\n\n:::\n\n. . .\n\n::: {.proof}\n\nOn distingue 4 cas\n\n- $\\Sigma=\\emptyset$\n- $\\Sigma=\\{A\\rightarrow B\\}$\n- $\\Sigma=\\{B\\rightarrow A\\}$\n- $\\Sigma=\\{A\\rightarrow B, B\\rightarrow A\\}$\n\n:::\n\n\n\n\n\n# Décomposition d'une relation  {background-color=\"#1c191c\"}\n\n\n## Décomposition d'un schéma de relation\n\n\n::: {.callout-important}\n\n### Définition \n\nSoit $\\mathcal{A}$ un schéma de relation\n\nUn *décomposition* de $\\mathcal{A}$ est un ensemble $\\{\\mathcal{A}_1,..., \\mathcal{A}_k\\}$\nde sous-ensembles de $\\mathcal{A}$ tel que\n\n$$\\mathcal{A}_i\\not=\\emptyset, 1\\le i\\le k, \\quad \\text{ et } \\quad \\mathcal{A} = \\bigcup_{i=1}^k \\mathcal{A}_i$$\n\n:::\n\n\n---\n\n## Exemple de décomposition I\n \n\n\n\n\n```{.default}\nVendeur(V#, Vnom, Vville)\nProduit(P#, Pnom, Pville)\nLivraison(V#, P#, Qte)\n```\n\n\n\nest une décomposition du schéma\n\n\n\n\n```{.default}\nR(V#, Vnom, Vville, P#, Pnom, Pville, Qte)\n```\n\n\n\n\n---\n\n## Exemple de décomposition II\n\n\nSchéma :\n\n`Films(titre, année, durée, genre, producteur, acteur)`\n\n. . .\n\nUne décomposition :\n\n`Films1(titre, année, durée, genre, producteur)`\n\n`Films2(titre, année, acteur)`\n\n- `Films1` est FNBC par rapport à $\\Sigma_1=\\{\\texttt{titre, année ⟶ durée, genre, producteur}\\}$\n- `Films2` est en FNBC par rapport à $\\Sigma_2=\\emptyset$\n\n\n## Propriétés d'une décomposition\n\nOn ne peut pas décomposer arbitrairement,\n\nToutes les décompositions ne sont pas intéressantes\n\n--\n\n#### Conditions pour une décomposition *raisonnable* :\n\n- Décomposition *sans perte d'information*\n\n- Décomposition *sans perte de dépendance fonctionnelle*\n\n\n\n\n\n---\n\n# Décomposition sans perte d'information  {background-color=\"#1c191c\"}\n\n---\n\n\n## Décomposition sans perte d'information\n\n\nIdée : Si on remplace le schéma\n\n\n\n\n```{.default}\n(V#, Vnom, Vville, P#, Pnom, Pville, Qte)\n```\n\n\n\npar les trois schémas\n\n\n\n\n```{.default}\nVendeur(V#, Vnom, Vville)\nProduit(P#, Pnom, Pville)\nLivraison(V#, P#, Qte)\n```\n\n\n\nalors au lieu de stocker une relation `R(V#, Vnom, Vville, P#, Pnom, Pville, Qte)`, on stockera\nses projections:\n\n\n$$\\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R}) \\qquad \\pi_{\\texttt{P\\#,Pnom,Pville}}(\\texttt{R}) \\qquad \\pi_{\\texttt{V\\#,P\\#,Qte}}(\\texttt{R})$$\n\n\n{{< fa brain >}} Peut-on retrouver `R` à partir de ces trois projections ?\n\n\n\n---\n\n\n\n## Décomposition sans perte d'information\n\n- La décomposition doit garantir que pour toute relation `R`, ses projections contiennent\nla même information que `R` au sens que l'on doit pouvoir reconstruire `R` à partir de ses projections\n\n- Comment tenter de reconstruire `R` à partir de ses projections ?\n\nOn considère la *jointure naturelle*\n\n$$\\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{P\\#,Pnom,Pville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{V\\#,P\\#,Qte}}(\\texttt{R})$$\n\n\n\n---\n\n\n\n## Décomposition sans perte d'information\n\nLa propriété souhaitée s'écrit donc\n\n$$R = \\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{P\\#,Pnom,Pville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{V\\#,P\\#,Qte}}(\\texttt{R})$$\n\npour toute relation `R(V#, Vnom, Vville, P#, Pnom, Pville, Qte)` satisfaisant les DF\n\n. . .\n\n- Est ce vrai?\n\n- Intuitivement, oui : à partir d'un tuple de `Livraison(V#,P#,Qte)`\n\n- `V#` permet de récupérer toutes les informations sur le vendeur `(V# ⟶ Vnom Vville)`\n\n- `P#` permet de récupérer toutes les informations sur le produit `(P# ⟶ Pnom Pville)`\n\n- {{< fa hand-point-right >}} La propriété d'être sans perte d'information est liée à l'ensemble de DF considéré\n\n\n\n\n\n## Décomposition sans perte d'information (lossless join)\n\n\n::: {.callout-important}\n\n### Définition\n\nSoit $\\mathcal{A}$ un schéma de relation et $\\Sigma$ un ensemble de DF sur $\\mathcal{A}$.\n\nUne décomposition $\\{\\mathcal{A}_1,..., \\mathcal{A}_k\\}$ est *sans perte d'information par rapport à* $\\Sigma$\nsi pour toute relation $R$  de schéma $\\mathcal{A}$ satisfaisant $\\Sigma$ on a\n\n$$R= \\pi_{\\mathcal{A}_1}(R) \\bowtie \\pi_{\\mathcal{A}_2}(R) \\bowtie...\\bowtie\\pi_{\\mathcal{A}_k}(R)$$\n\n:::\n\n\n## Exemple de décomposition avec perte d'information  {.smaller}\n\n$\\mathcal{A}=\\{A,B,C\\} \\quad  \\Sigma=\\{AB\\rightarrow C\\}$\n\nDécomposition $\\mathcal{A}_1=\\{A,B\\}  \\quad  \\mathcal{A}_2=\\{B,C\\}$\n\n::::: {.columns}\n::: {.column width=\"30%\"}\n\nSoit $R$ la relation\n\n| A   |  B  |  C  |\n|:---:|:---:|:---:|\n|1 | 2 | 3 |\n|4 | 2 | 5 |\n\n:::\n\n::: {.column width=\"30%\"}\n\n$\\pi_{AB}(R)=$\n\n| A |  B |\n|:---:|:---:|\n| 1 | 2  |\n| 4 | 2  |\n\n:::\n\n\n::: {.column width=\"30%\"}\n\n$\\pi_{BC}(R)=$\n\n| B |  C |\n|:---:|:---:|\n| 2 | 3  |\n| 2 | 5  |\n\n:::\n\n:::::\n\n$\\pi_{AB}(R) \\bowtie \\pi_{BC}(R)=$\n\n| A   |  B  |  C  |\n|:---:|:---:|:---:|\n|   1 | 2   | 3   |\n|   4 | 2   | 5   |\n| **1** | **3** | **5** |\n| **4** | **2** | **3** |\n\n\n\n\n\n# Algorithme de poursuite  {background-color=\"#1c191c\"}\n\n\n\n## Algorithme de poursuite\n\n- Comment déterminer si une décomposition est sans perte d'information?\n\n- Si $R$ est une relation de schéma $\\mathcal{A}$ on a toujours que\n\n$$R\\subset \\pi_{\\mathcal{A}_1}(R) \\bowtie \\pi_{\\mathcal{A}_2}(R) \\bowtie...\\bowtie\\pi_{\\mathcal{A}_k}(R)$$\n\npar définition de la jointure naturelle et de la projection\n\n- Le seul problème est que les jointures peuvent générer des tuples supplémentaires\n- Mais comme $R$ est supposée vérifier les DF de $\\Sigma$, l'inclusion inverse est garantie dans *certains cas*\n- Pour le savoir, un algorithme simple existe appelé *algorithme de poursuite*\n\n\n\n\n\n\n\n## Algorithme de poursuite : exemple\n\n\nSi on remplace le schéma `(V#, Vnom, Vville, P#, Pnom, Pville, Qte)`\npar\n\n\n\n\n```{.default}\nVendeur(V#, Vnom, Vville)}\nProduit(P#, Pnom, Pville)}\nLivraison(V#, P#, Qte)\n```\n\n\n\nA-t-on\n\n$$\\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{P\\#,Pnom,Pville}}(\\texttt{R}) \\bowtie \\pi_{\\texttt{V\\#,P\\#,Qte}}(R) \\subset \\texttt{R} \\quad ?$$\n\n---\n\n\nSoit $t$ un tuple dans la jointure\n\n\n| V# |  Vnom |  Vville |  P# |  Pnom |  Pville |  Qte |\n|:--:|:------|:------|:---:|:------|:------|:------|\n| $a$ | $b$ | $c$ | $d$ | $e$ | $f$ | $g$ |\n\n\n\n\n## Algorithme de poursuite : exemple  {.smaller}\n\n\nSoit $t$ un tuple dans la jointure\n\n| V# |  Vnom |  Vville |  P# |  Pnom |  Pville |  Qte |\n|:--:|:------|:------|:---:|:------|:------|:------|\n| $a$ | $b$ | $c$ | $d$ | $e$ | $f$ | $g$ |\n\n\n- $(a, b, c)\\in \\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R})$ donc\nil existe $e_1, f_1, g_1$ tels que  $(a, b, c, d_1, e_1, f_1, g_1) \\in \\texttt{R}$\n\n- $(d,e,f) \\in \\pi_{\\texttt{P\\#,Pnom,Pville}}(\\texttt{R})$ donc il existe $a_2, b_2, c_2, g_2$ tels que\n$(a_2, b_2, c_2, d, e, f, g_2)\\in \\texttt{R}$\n\n- $(a,d,g)\\in \\pi_{\\texttt{V\\#,P\\#,Qte}}(R)$ donc il existe $b_3,c_3,e_3,f_3$ tels que\n$(a,b_3,c_3,d,e_3,f_3,g)\\in \\texttt{R}$\n\n- On peut le représenter comme ceci :\n\n| `V#` |  `Vnom` |  `Vville` |  `P#` |  `Pnom` |  `Pville` |  `Qte` |\n|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|\n|Vendeur | $a$  | $b$  | $c$  | $d_1$ | $e_1$ | $f_1$ | $g_1$ |\n|Produit | $a_2$ | $b_2$ | $c_2$ | $d$  | $e$  | $f$  | $g_2$ |\n|Livraison | .$a$  | $b_3$ | $c_3$ | $d$  | $e_3$ | $f_3$ | $g$  |\n\n\n\n\n\n\n## Algorithme de poursuite : exemple   {.smaller}\n\n\n| `V#` |  `Vnom` |  `Vville` |  `P#` |  `Pnom` |  `Pville` |  `Qte` |\n|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|\n|Vendeur | $a$  | $b$  | $c$  | $d_1$ | $e_1$ | $f_1$ | $g_1$ |\n|Produit | $a_2$ | $b_2$ | $c_2$ | $d$  | $e$  | $f$  | $g_2$ |\n|Livraison | $a$  | $b_3$ | $c_3$ | $d$  | $e_3$ | $f_3$ | $g$  |\n\n\n\n- `V#` ⟶ `Vnom`, `Vville` donc $b_3=b$ et $c_3=c$\n\n| `V#` |  `Vnom` |  `Vville` |  `P#` |  `Pnom` |  `Pville` |  `Qte` |\n|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|\n|Vendeur | $a$  | $b$  | $c$  | $d_1$ | $e_1$ | $f_1$ | $g_1$ |\n|Produit | $a_2$ | $b_2$ | $c_2$ | $d$  | $e$  | $f$  | $g_2$ |\n|Livraison | $a$  | $b$ | $c$ | $d$  | $e_3$ | $f_3$ | $g$  |\n\n\n\n## Algorithme de poursuite : exemple (suite)  {.smaller}\n\n- `P#⟶ Pnom, Pville` donc $e_3=e$ et $f_3=f$\n\n\n| `V#` |  `Vnom` |  `Vville` |  `P#` |  `Pnom` |  `Pville` |  `Qte` |\n|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|\n|Vendeur | $a$  | $b$  | $c$  | $d_1$ | $e_1$ | $f_1$ | $g_1$ |\n|Produit | $a_2$ | $b_2$ | $c_2$ | $d$  | $e$  | $f$  | $g_2$ |\n|Livraison | $a$  | $b$ | $c$ | $d$  | $e$ | $f$ | $g$  |\n\n- On a obtenu une ligne égale au tuple $t=(a,b,c,d,e,f,g)$ donc $t\\in \\texttt{R}$.\n\nOn en déduit que la décomposition est Sans Perte d'Information (SPI)\n\n\n## Algorithme de poursuite : cas général  {.smaller}\n\n- **Entrée** : un schéma $\\mathcal{A}$, une décomposition $\\{\\mathcal{A}_1,...,\\mathcal{A}_k\\}$ et un ensemble $\\Sigma$ de DF\n\n- Pour chaque attribut de $\\mathcal{A}$, choisir un symbole (par exemple $a$, $b$, $c$,...). La correspondance doit être injective.\n\n- Construire un tableau dont les colonnes sont les attributs de $\\mathcal{A}$\n\nLe tableau a une ligne pour chaque $\\mathcal{A}_i$\n\nSur la ligne associée à $\\mathcal{A}_i$, les positions correspondant à $\\mathcal{A}_i$ sont remplies avec les symboles choisis.\n\nLes autres positions sont remplies avec les symboles indicés par $i$\n\n- Répéter tant que possible : s'il existe une DF $X\\rightarrow Y$ dans $\\Sigma$ et deux lignes du tableau\nen accord sur $X$, égaliser ces deux lignes sur $Y$\n\n- **Sortie** : Si on obtient une ligne sans valeur indicée, la décomposition est sans perte d'information, sinon il y a perte d'information\n\n## \n\n::: {.proof}\n\n### {{< fa person-chalkboard >}}\n\n:::\n\n## Algorithme de poursuite : exemple 2 {.smaller}\n\nConsidérons l'exemple : $\\mathcal{A}=\\{A,B,C,D\\}$ avec $\\mathcal{A}_1=\\{A,B\\}$, $\\mathcal{A}_2=\\{B,C\\}$ et $\\mathcal{A}_3=\\{C,D\\}$\n\nSoit $\\Sigma=\\{{C}\\rightarrow{D}; {B}\\rightarrow{A}\\}$.\n\nSoit $t=(a,b,c,d)$. Soit $t_1,t_2,t_3$ les tuples de $R$ suivants:\n\n\n|  | A | B | C | D  |\n|:----|:----:|:----:|:----:|:----:|\n| $t_2$ | $a_2$ | `b` | `c` | $d_2$  |\n| $t_3$ | $a_3$ | $b_3$ | `c` | `d`  |\n\nOn a pris  $c_1,d_1, a_2,d_2, a_3,b_3$ comme valeurs variables et `a,b,c,d` comme constantes\n\n\n\n\n\n## Algorithme de poursuite - exemple 2  {.smaller}\n\n\n|  | A | B | C | D  |\n|:----|:----:|:----:|:----:|:----:|\n| $t_1$ | `a` | `b` |  $c_1$| $d_1$  |\n| $t_2$ | $a_2$ | `b` | `c` | $d_2$  |\n| $t_3$ | $a_3$ | $b_3$ | `c` | `d`  |\n\nPar la dépendance ${B}\\rightarrow{A}$, il vient :\n\n\n|  | A | B | C | D  |\n|:----|:----:|:----:|:----:|:----:|\n| $t_1$ | `a` | `b` |  $c_1$| $d_1$  |\n| $t_2$ | `a`  | `b` | `c` | $d_2$  |\n| $t_3$ | $a_3$ | $b_3$ | `c` | `d`  |\n\n\n\n## Algorithme de poursuite : exemple 2 {.smaller}\n\n\nPar la dépendance ${C}\\rightarrow{D}$, il vient :\n\n|  | A | B | C | D  |\n|:----|:----:|:----:|:----:|:----:|\n| $t_1$ | `a` | `b` |  $c_1$| $d_1$  |\n| $t_2$ |  `a`  | `b` | `c` |  `d`   |\n| $t_3$ | $a_3$ | $b_3$ | `c` | `d`  |\n\nOn a bien fait apparaître $t$ qui appartient donc à  $R$.\n\n\n\n## Algorithme de poursuite - exemple 3 {.smaller}\n\nConsidérons toujours l'exemple : $\\mathcal{A}=\\{A,B,C,D\\}$ avec\n\n$\\mathcal{A}_1=\\{A,B\\}$, $\\mathcal{A}_2=\\{B,C\\}$ et $\\mathcal{A}_3=\\{C,D\\}$\n\nMais avec  $\\Sigma=\\{{B}\\rightarrow{AD}\\}$.\n\n\n\n\n| A | B | C | D  |\n|:---:|:---:|:---:|:---:|\n| `a` | `b` |  $c_1$ | $d_1$  |\n| $a_2$ | `b` | `c` | $d_2$  |\n|  $a_3$ | $b_3$ | `c` | `d`  |\n\n\n\nDans ce cas, en utilisant la seule DF ${B}\\rightarrow{AD}$, on obtient $a_2=a$ et $d_1=d_2$ :\n\n| A | B | C | D  |\n|:---:|:---:|:---:|:---:|\n| `a` | `b` |  $c_1$ | $d_1$  |\n| `a` | `b` | `c` | $d_1$  |\n|  $a_3$ | $b_3$ | `c` | `d`  |\n\n::: {.callout-note}\n\nMais on ne peut aller plus loin : la jointure des projections contient\ndes tuples qui ne sont pas dans la relation originelle\n\n:::\n\n\n\n\n\n# Fin   {background-color=\"#1c191c\"}",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}