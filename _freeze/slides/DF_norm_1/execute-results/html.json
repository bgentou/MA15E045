{
  "hash": "ec3c28f8392e31eb85524d5873601221",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Normalisation I\"\nsubtitle: \"Dépendances Fonctionnelles, Clés, Fermetures, Couvertures irredondantes.\"\ndate: \"2025-12-01\"\n\nformat: \n  revealjs:\n    header: \"Dépendances Fonctionnelles, Clés, Fermetures, Couvertures irredondantes.\"\n\nengine: knitr\n---\n\n\n# Introduction  {background-color=\"#1c191c\"}\n\n\n## Conception du modèle relationnel\n\nUne première approche pour concevoir un modèle relationnel (l'ensemble des schémas de tables d'une bd) consiste à :\n\n- Identifier les attributs d'intérêt\n\n- Répartir les attributs dans plusieurs relations\n\n. . .\n\n- Comment savoir si le modèle relationnel est *bon* ?\n\n. . .\n\n- Si ce n'est pas le cas : y a-t-il des techniques pour le transformer en un *bon* modèle?\n\n\n\n\n\n## Qualité d'un schéma  {.smaller}\n\nQuelles sont de *bonnes propriétés* d'un schéma ?\n\n\n**Exemple**\n\nAttributs relatifs à des *vendeurs*, *produits* et *livraisons*\n\n| Attribut |  Usage |\n|:--------:|:----------------|\n| **`V#`** | numéro du vendeur   |\n| `Vnom`   | nom du vendeur  |\n| `Vville` |ville du vendeur   |\n| **`P#`** | numéro du produit  |\n|`Pnom`    |nom du produit  |\n|`Pville`  |ville où le produit est stocké  |\n|`Qte`     |quantité de produit livrée au vendeur |\n\n\n\n## Qualité d'un schéma\n\nUn schéma relationnel possible : une seule relation `R` avec tous les attributs\n\n```\nR(V#, Vnom, Vville, P#, Pnom, Pville, Qte)\n```\n\n. . .\n\n\n- {{< fa face-frown >}} C'est une mauvaise modélisation.\n\n- {{< fa brain >}} Pourquoi ?\n\n\n\n\n## Qualité d'un schéma relationnel\n\n::: {.callout-caution}\n\n### Redondance\n\n| V# |  Vnom |  Vville |  P# |  Pnom |  Pville |  Qte |\n|---:|:-----:|:-------:|----:|:-----:|:-------:|----: |\n|3 | MagicV | Paris | ... | ... | ... | ... |\n|3 | MagicV | Paris | ... | ... | ... | ... |\n|2 | IdealB | Lyon | ... | ... | ... | ... |\n|2 | IdealB | Lyon | ... | ... | ... | ... |\n\n\n\n`Vnom` et `Vville` sont déterminés par` V#` :\n\nsi deux livraisons ont le même `V#`, elles ont aussi le même `Vville` et le même `Vnom`\n\n:::\n\n\n## {{< fa face-frown >}}\n\n\n- **Anomalies de mise à jour**\n\n`Vnom` ou `Vville` pourrait être mis à jour dans une livraison et pas dans une autre, ce qui donnerait une incohérence. Les mesures pour éviter cela rendent la mise à jour est coûteuse\n\n. . .\n\n- **Anomalies d'insertion**\n\nOn ne peut pas enregistrer un vendeur s'il ne reçoit pas de livraison\n\n\n. . .\n\n- **Anomalies de suppression**\n\nSi on supprime toutes les livraisons à un vendeur, on perd toute l'information sur ce vendeur\n\n\n---\n\n## Qualité d'un schéma relationnel\n\n- Un *bon* schéma\n\n\n```{.default}\nVendeur(V#, Vnom, Vville)    Clef : V#\nProduit(P#, Pnom, Pville)    Clef : P#\nLivraison(V#, P#, Qte)       Clef : (V#,P#)\n```\n\n- Plus d'anomalie ! Comment y arriver?\n\n. . .\n\nLa théorie de la *normalisation* des BD relationnelles fournit\n\n- la notion de **forme normale** : propriétés d'un schéma qui garantissent l'absence de redondance et des anomalies qui en dérivent. Ces propriétés sont définies par rapport à un ensemble de *contraintes*\n\n- des *techniques de normalisation* : passage d'un schéma arbitraire (mauvais) à un schéma en forme normale (obtenu typiquement par décomposition)\n\n\n\n\n\n# Dépendances fonctionnelles  {background-color=\"#1c191c\"}\n\n## Exemple\n\n`R(V#, Vnom, Vville, P#, Pnom, Pville, Qte)`\n\nUn ensemble de dépendances fonctionnelles qu'on peut raisonnablement supposer :\n\n\n```{.default}\nV# ⟶ Vnom Vville\nP# ⟶ Pnom Pville\nV# P# ⟶ Qte\n```\n\n- Cela signifie que l'on ne considère que des relations R qui satisfont :\n- si 2 tuples de `R` ont la même valeur de `V#` alors ils ont la même valeur de `Vnom` et `Vville`\n- si 2 tuples de `R` ont la même valeur de `P#` alors ils ont la même valeur de `Pnom` et `Pville`\n- ...\n\n\n\n## DF exemple (suite) {.smaller}\n\n\n| V# |  Vnom |  Vville |  P# |  Pnom |  Pville |  Qte  |\n|---:|:-----:|:-------:|----:|:-----:|:-------:|:-----:|\n|3 | MagicV | Paris | 322 | manteau | Lille | 2 |\n|1 | StarV | Rome | 546 | veste | Rome | 1 |\n|3 | MagicV | Paris | 322 | manteau | Lille | 5 |\n|2 | IdealB | Lyon | 145 | jupe | Paris | 7 |\n|2 | IdealB | Lyon | 234 | jupe | Lille | 1 |\n\n. . .\n\n- `R` satisfait `V#` ⟶ `Vnom Vville` et `P#` ⟶ `Pnom Pville`\n\n- `R` ne respecte pas `V# P#` ⟶ `Qte`\n\n\n\n## Autre Exemple   {.smaller}\n\nSchéma `Films(titre, année, durée, genre, producteur, acteur)`\n\n| titre |  année |  durée |  genre |  producteur |  acteur |\n|:------|:---------:|----------:|:----------|:---------------|:-----------|\n|Star Wars | 1977 | 124 | SciFi | Fox | Carrie Fisher |\n|Star Wars | 1977 | 124 | SciFi | Fox | Mark Hamill |\n| Star Wars | 1977 | 124 | SciFi | Fox | Harrison Ford |\n|Gone With The Wind | 1939 | 231 | drame | MGM | Vivien Leigh|\n|Wayne's World | 1992 | 95 | comédie | Paramount | Dana Carvey|\n|Wayne's World | 1992 | 95 | comédie | Paramount | Mike Meyers|\n| ... | | | | | |\n\n---\n\n- On sait qu'il n'y a pas 2 films de même nom qui sortent la même année. On a donc la dépendance suivante\n\n`titre, année ⟶ durée, genre, producteur`\n\n- La DF `titre, année ⟶ acteur`\n\nest certainement fausse puisqu'un film fait intervenir en général plusieurs acteurs\n\n- A-t-on la DF `titre, acteur ⟶ année, durée, genre, producteur` ?\n\n\n\n## Définition d'une dépendance fonctionnelle\n\n::: {.callout-important}\n\n### Définition : Dépendance fonctionnelle \n\nSoit $\\mathcal{A}$ un schéma de relation ($\\mathcal{A}$ est un ensemble d'attributs)\n\nUne *dépendance fonctionnelle* sur $\\mathcal{A}$ est une expression de la forme\n\n$$X \\to Y$$\n\noù $X \\subseteq \\mathcal{A}$ et $Y \\subseteq \\mathcal{A}$\n\nUne relation $R$ de schéma $\\mathcal{A}$ satisfait $X \\to Y$ si pour tous tuples $s,t ∈ R$ on a\n\n$$\\bigl(∀ A∈ X\\ s.A=t.A\\bigr) ⟹ \\bigl(\\forall A∈ Y\\ s.A=t.A\\bigr)$$\n\n(si $s$ et $t$ coïncident sur $X$ alors $s$ et $t$ coïncident sur $Y$)\n\nUne relation $R$, de schéma $\\mathcal{A}$, satisfait un ensemble $\\Sigma$ de DF si $R$ satisfait chaque DF de $\\Sigma$\n\n:::\n\n\n\n## Exemples\n\nDans la base **Pagila**, relation `Actor` :\n\n- `Actor_id ⟶ last_name`, `first_name`\n\n- car `Actor_id` est une clé...\n\n\n## Dépendance fonctionnelle élémentaire\n\n::: {.callout-important}\n\n### Définition : dépendance élémentaire\n\n$A_1,...,A_p \\to Y$ est une dépendance *élémentaire* si\npour tout $j\\leqslant p$ :  $A_1,...,A_{j-1}, A_{j+1},..., A_p\\not\\to Y$\n\n:::\n\n. . .\n\n- `No_insee ⟶ sexe, mois_naiss, jour_naiss` est  élémentaire.\n\n- `No_insee, jour_naiss ⟶ sexe, mois_naiss, ville_naiss` n'est pas élémentaire ...\n\n\n::: {.callout-note}\n\n`No_insee` suffit\n\n:::\n\n\n\n\n\n\n## Dépendance fonctionnelle triviale\n\nUne DF triviale est une DF satisfaite par toute relation.\n\n\n::: {.callout-important}\n\n### Définition (dépendance triviale)\n\nSoient $X,Y⊂ \\mathcal{A}$\n\n$X\\to Y$ est une dépendance triviale si $Y \\subset X$\n\n:::\n\n. . .\n\n::: {.callout-note}\n\n### Exemple\n\n`No_insee ` $\\to$ `No_insee` est  triviale\n\n\n:::\n\n\n\n\n## Implication entre  DF\n\n::: {.callout-important}\n\n### Définition\n\nUn ensemble $\\Sigma$ de DF *implique* une autre DF $X\\to Y$ si\ntoute relation qui satisfait $\\Sigma$ satisfait également $X\\to Y$.\n\nNotation pour $\\Sigma$ implique $X\\to Y$ : $\\quad \\quad\\Sigma \\models X \\to Y$\n\n:::\n\n::: {.callout-note}\n\n### Exemple I\n$A\\to B$ et $B\\to C$ impliquent $A\\to C$.\n:::\n\n. . .\n\n::: {.callout-note}\n\n### Exemple II\n$A\\to C$, $BC\\to D$, $AD\\to E$ impliquent $AB\\to E$.\n:::\n\n\n## Règles d'inférence\n\nLes règles d'inférence permettent de calculer toutes les DF impliquées par un ensemble donné de DF.\n\n::: {.callout-important}\n\n### Règles d'Armstrong\n\n- *Transitivité* : $\\{ X\\to Y, Y\\to Z\\} \\models X\\to Z$\n\n- *Augmentation* : $X\\to Y \\models \\{X,Z\\} \\to \\{Y,Z\\}$\n\n- *Réflexivité* : $\\varnothing \\models \\{X,Y\\}\\to X$  (DF triviale)\n\n:::\n\n## Vérification de la transitivité\n\nOn se rammène à vérifier une règle du calcul propositionnel :  \nsi p ⇒ q et q ⇒ r alors p ⇒ r \n\nSoit une instance $\\mathcal{R}$ telle que :  \n$$\\forall s,t \\in \\mathcal{R} \\qquad \n  \\begin{cases}  \\text{si } s.X =t.X & \\text{alors } s.Y= t.Y \\\\\n   \\text{si } s.Y =t.Y &  \\text{alors } s.Z= t.Z\n\\end{cases}\n$$\nOn a alors aussi \n$\\forall s,t \\in \\mathcal{R}$, si $s.X =t.X$ alors $s.Z= t.Z$\n\n\n\n\n## Calcul sur les DF  \n\n::: {.callout-important}\n\n### Théorème\n\n$\\Sigma \\models X\\to Y$\n\nsi et seulement si\n\n$X\\to Y$ peut-être dérivée de $\\Sigma$ par applications successives des trois règles d'Armstrong.\n\n:::\n\n::: {.callout-note}\nDes 3 règles d'Armstrong, on déduit d'autres règles :\n\n- *Union* : $\\{X\\to Y, X\\to Z\\} \\models X\\to \\{Y,Z\\}$\n- *Séparation* : $X\\to \\{Y,Z\\} \\models X\\to Y$\n\n- ...\n:::\n\n\n## Exemple\n\nSoient $\\mathcal{A}$ un schéma de relation ( $\\mathcal{A}$ est un ensemble d'attributs) \n\nOn considère l'ensemble de DF $\\Sigma=\\{A\\to B, B\\to C\\}$\n\n- $\\Sigma$ implique $A\\to B$, $B\\to C$, $A\\to C$, $AB\\to C$, ...\n- mais aussi les DF triviales $A\\to A$, $AB\\to A$, ...\n\n\n\n## Ensembles de DF équivalents\n\n\n::: {.callout-important}\n### Définition\n\nSoit $\\Sigma$ et $\\Sigma'$ deux ensemble de DF sur un schéma $\\mathcal{A}$\n\n\n$\\Sigma$ est *équivalent* à $\\Sigma'$\n\nssi\n\n$\\Sigma\\models\\Sigma'$ et $\\Sigma'\\models\\Sigma$\n\n:::\n\n\n. . .\n\nExemples simples :\n\n- $\\{X\\to A_1,...,A_n\\}$ est équivalent à $\\{X\\to A_1, ..., X\\to A_n\\}$\n\n- $XY\\to YZ$ est équivalent à $XY\\to Z$\n\n\n\n\n\n# Clés et sur-clés {background-color=\"#1c191c\"}\n\n## Définitions\n\nSoit $\\mathcal{A}$ un schéma et $\\Sigma$ une ensemble de DF sur $\\mathcal{A}$\n\n::: {.callout-important}\n\n### Définition : sur-clé\n\nUn ensemble d'attributs $X$ est une **sur-clé** (ou super-clé) si $\\Sigma \\models X \\to \\mathcal{A}$\n\nc-à-d si $X$ détermine tous les attributs de $\\mathcal{A}$.\n\n:::\n\n. . .\n\n::: {.callout-important}\n\n### Définition : clé\n\nUn ensemble d'attributs $X$ est une **clé** si $X$ est une sur-clé et si\ntout sous-ensemble $Y\\subset X$ tel que $Y\\not=X$ n'est pas une sur-clé.\n\nAutrement dit, $X$ est une clé si $X$ est une sur-clé minimale au sens de l’inclusion.\n:::\n\n\n## Exemple\n\n\n$R(A,B,C) \\qquad \\Sigma = \\{A\\to B, B\\to C\\}$\n\nSur-clé : $A$, $AB$, $AC$, $ABC$\n\nClé : $A$ (la seule)\n\n\n\n\n# Fermeture d'un ensemble d'attributs  {background-color=\"#1c191c\"}\n\n\n\n## Question principale\n\n- Comment vérifier si un ensemble $\\Sigma$ de DF implique une DF $X\\to Y$ ?\n\n. . . \n\n- Par les équivalences présentées précédemment, la question se ramène à :\n\nComment vérifier si un ensemble $\\Sigma$ de DF implique une DF $X\\to A$\noù $A$ est un attribut ?\n\n\n## Fermeture d'un ensemble d'attributs\n\nSoit $X \\subset\\mathcal{A}$ un sous-ensemble d'attributs et $\\Sigma$ un ensemble de DF sur $\\mathcal{A}$\n\n\n::: {.callout-important}\n\n### Définition\n\nLa fermeture de $X$ par rapport à $\\Sigma$ est\n\n$$X^+=\\{ A\\in\\mathcal{A} \\mid \\Sigma\\models X\\to A \\}$$\n\n:::\n\n::: {.aside}\n\nAutrement dit $X^+$ est l'ensemble des attributs déterminés par $X$\n\n:::\n\n\n##  Exemple de fermeture\n\n- $R(ABCDE)$\n- $\\Sigma=\\{AB\\to C, C\\to D, E\\to D\\}$\n- $\\{A,B\\}^+=\\{A,B,C,D\\}$\n\n\n## Algorithme de calcul d'une fermeture\n\nL'algorithme retourne $X^+$ relativement à un ensemble de DF $\\Sigma$.\n\n```{=html}\n<pre style=\"background-color: #f0f0ffff;font-family:'Lucida Console','Courier New',monospace; color: #15093aff;font-size:1em;padding:10px;border:1px solid #220f61ff;\">\nfonction fermeture(X, Σ)\n   X⁺ :=  X\n   while (exists Y → Z in Σ with Y ⊂ X⁺ and Z ⊄ X⁺)\n      X⁺ := X⁺ ⋃ Z\n   return X⁺\n</pre>\n```\n\n\n## Exemple de calcul de fermeture\n\n$\\mathcal{A}=\\{ABCDEF\\}$, $\\Sigma=\\{A\\to C, BC\\to D, AD\\to E\\}$, $X=\\{A,B\\}$\n\n- $X_c=\\{A,B\\}$\n\n- $A\\to C$ donc on obtient $X_c=\\{A,B,C\\}$\n\n- $BC\\to D$ donc on obtient $X_c=\\{A,B,C,D\\}$\n\n- $AD\\to E$ donc on obtient $X_c=\\{A,B,C,D, E\\}$\n\n- On obtient $X^+=\\{A,B,C,D, E\\}$\n\n\n\n\n## Terminaison de l'algorithme\n\n{{< fa hand-point-right >}} $X^c$ grandit à chaque itération\n\nComme $\\mathcal{A}$ est fini, l'algorithme se termine en au plus $|\\mathcal{A}|$ itérations\n\n\n## Correction de l'algorithme de fermeture  {{< fa person-chalkboard >}}\n\n- L'algorithme calcule uniquement des attributs dans la fermeture car\non a toujours $X^c \\subset X^+$ (récurrence sur le nombre d'itérations de la boucle `while`).\n\n- L'algorithme calcule tous les attributs dans la fermeture:  $X_c=X^+$ quand l'algorithme se termine.\n\n::: {.aside}\n\nLe dernier point est le plus délicat. Que peut signifier le fait qu'il existe au moins un attribut $Y\\in X^+$ qui n'appartienne pas à la valeur terminale de $X^c$ ?  \n:::\n\n\n## Calcul de la fermeture transitive : exemple\n\n::::: {.columns}\n\n::: {.column width=\"75%\"}\n\nSoit $R$ d'ensemble d'attributs\n\n$\\mathcal{A} =\\{A,B,C,D,E,F,G\\}$\n\nSoit $X=\\{B,D\\} \\subset \\mathcal{A}$\n\nEt $\\Sigma$ l'ensemble de dépendances fonctionnelles ci-contre\n\n:::\n\n\n\n::: {.column width=\"25%\"}\n\n$A,B \\to C$ \n$C \\to A$ \n$B,C \\to D$ \n$A,C,D \\to B$ \n$F\\to A,C$\n$D \\to E,G$ \n$B,E \\to C$ \n$C,G \\to B,D$ \n$C,E \\to A,G$ \n\n:::\n\n:::::\n\n. . . \n\nMontrer que  $X^+=\\{A,B,C,D,E,G\\}$\n\nDonner une clé de $R$ : par exemple $\\{A,B,F\\}$, $\\{E,F\\}$, $\\{F,G\\}$. Il n'y a pas unicité.\n\n\n\n## Fermetures et clés\n\n::: {.callout-important}\n\n### Propriété \n\nSoit $\\mathcal{A}$ un schéma, $X \\subset \\mathcal{A}$ est une clé de $\\mathcal{A}$ si et seulement si \n\n- $X^+ = \\mathcal{A}$, \n- $\\forall \\ Y \\subsetneqq X$, $\\quad Y^+ \\subsetneqq X$\n\noù $\\subsetneqq$ signifie \"strictement inclus\".\n\n:::\n\n## Fermetures et implications de DF\n\n::: {.callout-important}\n\n### Propriété \n\nSoit $\\mathcal{A}$ un schéma, X,Y des parties de $\\mathcal{A}$, $\\Sigma$ un ensemble de DF sur $\\mathcal{A}$.\n\n- $\\Sigma \\models X\\to Y \\quad$  ssi $\\quad Y \\subset X^+$\n\n:::\n\n\n\n## Fermetures et équivalences de DF\n\n::: {.callout-important}\n\n### Propriété \n\nSoit $\\mathcal{A}$ un schéma, $\\Sigma_1$ et $\\Sigma_2$ deux ensembles de DF sur $\\mathcal{A}$.\n\n**$\\Sigma_1$ et $\\Sigma_2$ sont équivalents** si et seulement si $\\quad \\forall\\ X \\subset \\mathcal{A},\\ \\ X^+_{\\Sigma_1} = X^+_{\\Sigma_2}$.\n\noù $X^+_{\\Sigma_1}$ et $X^+_{\\Sigma_2}$ sont les fermetures transitives de $X$ respectivement selon $\\Sigma_1$ et $\\Sigma_2$.\n\n:::\n\n::: {.callout-note}\n\n### justification \n\nCette propriété dit que $\\Sigma_1$ et $\\Sigma_2$ sont équivalents si, pour tout ensemble d'attributs $X$ , les ensembles $X^+$ de tous les attributs déterminés par $X$ sont identiques selon $\\Sigma_1$ et selon $\\Sigma_2$.\n\n:::\n\n\n\n\n# Couverture irredondante d'un ensemble de DF {background-color=\"#1c191c\"}\n\n\n\n## Définition de la couverture irredondante d'un ensemble de DFs\n\n::: {.callout-important}\n### Définition\n\nSoit  $\\Sigma$ un ensemble de DF, une *couverture irredondante* (ou minimale) de  $\\Sigma$ est un ensemble de DF $\\Sigma'$ qui vérifie :\n\n- Chaque DF de $\\Sigma'$ est de la forme $X → a$, où $a$ est un attribut,\n\n- Chaque DF de $\\Sigma'$ est élémentaire, c.a.d. $\\quad ∀ (X → a) ∈ Σ',\\ \\ ∀ Y ⫋ X,\\ \\ Σ' ⊭ Y → a $. \n\n- $\\Sigma'$ et $\\Sigma$ sont équivalents\n\n- Aucun sous-ensemble strict de $\\Sigma'$ n'implique $\\Sigma$.\n:::\n\n::: {.callout-note}\n\nDans une couverture irredondante, toutes des DFs sont nécessaires, chaque DF est élémentaire et une DF avec plusieurs attributs à droite est décomposée en autant de DF avec un seul attribut à droite.\n\n- **pas d'unicité**.\n- minimise la compléxité des algorithmes.\n- utile pour la décomposition FN3.\n:::\n\n \n## Algorithme de construction d'une couverture irredondante  {.scrollable}\n\n```{=html}\n<pre style=\"background-color: #f0f0ffff;font-family:'Lucida Console','Courier New',monospace; color: #15093aff;font-size:0.8em;padding:10px;border:1px solid #220f61ff;\">\nfonction min_cover(Σ)\n   Σ' := ∅ \n   for (X → Y) ∈ Σ    // sélection des DF non redondantes\n      for y ∈ Y\n         if not (Σ' ⊨ X → y)\n            Σ':= Σ' ⋃ {X → y}\n   go = True\n   while go       // élimination d'attributs, obtenir des DF élémentaires \n      go := False\n      for (X → y) ∈ Σ'\n         for x ∈ X\n            if Σ' ⊨ (X\\{x}) → y\n               Σ' := (Σ'\\{X → y}) ⋃ {(X\\{x}) → y}\n               go := True\n               break\n   return Σ'\n</pre>\n```\n\n\n\n\n# Fin   {background-color=\"#1c191c\"}\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}