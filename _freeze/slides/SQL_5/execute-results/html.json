{
  "hash": "bf9d40f0744280524c47215314b8a2dc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'BD : Fonctions et extension PlpgSQL de SQL'\ndate: \"2025-01-31\"\n\nengine: knitr\n\nformat: \n  revealjs:\n    header: \"Fonctions et extension PlpgSQL de SQL\"\n---\n\n\n\n\n\n\n\n\n\n\n# Fonctions plpgSQL: introduction et exemples  {background-color=\"#1c191c\"}\n\n\nPourquoi étendre SQL ?\n\n\n## Trois objectifs\n\n1. Automatisation de taches répétitives (administration)\n  - On veut répéter une même tache sur une collection de schémas\n  - On veut traiter une collection de roles\n  - \n2. Calculs impossibles à  réaliser en SQL : \n  - Calculer la *fermeture transitive* d'une relation comme `film_actors`  \n  - L'algèbre relationnelle est un modèle de calculabilité restreint·\n  \n3. `Triggers`\n  - Certaines contraintes ne peuvent pas être mises en place avec les seules constructions `primary key` , `unique`, `foreign key`, `check` et `exclude` (notamment des contraintes d'exclusion qui mettent en jeu plusieurs tables). \n  - On peut les maintenir à l'aide de traitements spéciaux :  les `triggers`\n  - Les triggers reposent sur des fonctions spéciales\n\n. . .\n\nExtensions procédurales de SQL\n\n`plpgsql` : *Programming Language PostGres SQL*\n\n\n\n\n\n\n## Automatisation des tâches répétitives : deux outils nécessaires\n\nLorsqu'on administre une base, on doit souvent engendrer des *requêtes dynamiques* à l'intérieur\nd'une fonction `PL/pgSQL`, c'est à dire des commandes qui vont\nconcerner des tables ou des types différents à chaque exécution\n\nLes *requêtes préparées* sont alors très utilement combinées avec les\n*structures de contrôle* (itérations, alternatives) pour\nautomatiser les tâches !\n\n. . .\n\n\n{{< fa screwdriver-wrench >}} 2 outils (pour étendre SQL) :\n\n-   requêtes dynamiques `EXECUTE, PREPARE`\n-   structures de contrôles `IF, LOOP, ...` *Transforment SQL en un langage de programmation*\n\n---\n\nOn commence par des exemples !\n\n\n# Un premier cas : fonctions issues du schéma `sakila`  {background-color=\"#1c191c\"}\n\n## Fonction `inventory_in_stock()`\n\nObjectif : calculer si un dvd est en stock ou pas\n\nUn DVD est en stock\n\n- s'il n'a jamais été loué \n\n**OU**\n\n- si toutes les locations de ce DVD sont déjà terminées (`return_date` n'est pas nul)\n\n```{.sql}\n-- AN ITEM IS IN-STOCK IF THERE ARE EITHER NO ROWS IN THE rental TABLE\n-- FOR THE ITEM OR ALL ROWS HAVE return_date POPULATED\n```\n\n\n\n## Fonction `inventory_in_stock`  {.smaller}\n\n\n```{.sql}\nCREATE OR REPLACE FUNCTION sakila.inventory_in_stock(p_inventory_id integer)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\nDECLARE                 \n    v_rentals INTEGER;  #<<\n    v_out     INTEGER;  #<<\nBEGIN\n    SELECT count(*) INTO v_rentals  #<<\n    FROM rental\n    WHERE inventory_id = p_inventory_id;\n\n    IF v_rentals = 0 THEN   #<<\n      RETURN TRUE;          #<< \n    END IF;                 #<<\n\n    SELECT COUNT(rental_id) INTO v_out     #<< \n    FROM inventory LEFT JOIN rental USING(inventory_id)\n    WHERE inventory.inventory_id = p_inventory_id AND rental.return_date IS NULL;\n\n    IF v_out > 0 THEN\n      RETURN FALSE;\n    ELSE\n      RETURN TRUE;\n    END IF;\nEND $function$ ;\n```\n\n---\n\n\n```{.sql}\n-- Permissions\n\nALTER FUNCTION sakila.inventory_in_stock(int4) OWNER TO postgres;\nGRANT ALL ON FUNCTION sakila.inventory_in_stock(int4) TO postgres;\n```\n\n\n\n\n---\n\n## {{< fa hand-point-right >}}\n\n- `SELECT ... INTO ...`\n\nLe résultat de la requête est ici un entier, il est affecté à une\nvariable locale comme `v_rentals`, `v_out`, ...  \n\nEn `plpgsql`, le résultat d'une requête doit être mémorisé ou\nexplicitement négligé en utilisant `PERFORM` plutôt que `SELECT` \n\n\n- `IF ... THEN ...`\n\nAlternative, comme dans un langage de programmation ordinaire\n\n- `RETURN`\n\nRetourne le résultat et termine l'exécution de la fonction\n\n# Un deuxième cas : surveillance et maintenance  {background-color=\"#1c191c\"}\n\n\n## Une tâche de surveillance/maintenance\n\n\n\n\n{{< fa bullseye >}}\n\n\n\n\n\n\nDéterminer pour chaque usager (*schéma*) le nombre de tuples dans\nla table `ville_pays` de cet usager.\n\n\nPour chaque schéma `schema`, on veut évaluer une requête\n\n```{.sql}\nSELECT COUNT(*) \nFROM schema.ville_pays ;\n```\n\nIci `schema` doit être calculé en interrogeant le SGBD\n\n. . .\n\nSituation inédite :\n\n-  comment déterminer les schémas pertinents ?\n\n\n\n\n## La métabase : `information_schema` et `pg_catalog`\n\nOn va s'aider des tables d'administration du SGBD\n\nChaque usager correspond à un `role` et ce rôle correspond dans notre cas à un schema créé à partir du rôle via l'instruction\n\n```{.sql}\nCREATE SCHEMA AUTHORIZATION user_name ;\n```\n\nOn a envie d'écrire une requête comme\n\n```{.sql}\nSELECT COUNT(*) FROM username.tournaments ; \n```\n\noù `username` est collectée à partir de\n\n```{.sql}\nSELECT usename  FROM pg_catalog.pg_user ;\n```\n\n\n\n## Deux schémas pour l'administration : la **métabase**\n\n1. `information_schema`\n\nCe schema contient l'information sur les `schémas` du\ncluster/catalogue :\n\n- les définitions de tables, de vues, de colonnes, les contraintes, ...\n- il est formé de tables et surtout de (très nombreuses) vues\n- les instructions, `CREATE, ALTER,  DROP` modifient le contenu de ce schéma (une seule instruction `ALTER  TABLE` peut engendrer plusieurs mises à jours dans les tables de `information_schema`\n\n\n2. `pg_catalog`\n\nCe schema contient lui aussi beaucoup de tables et de vues utiles au\nfonctionnement du serveur\n\n\n\n## Exemple de vue de `pg_catalog` : `pg_user`\n\n\n::::: {.columns}\n\n::: {.column}\n\nSchéma\n\n\n\n\n\n```{.default}\n+--------------+---------+-------------+\n| Column       | Type    | Modifiers   |\n|--------------+---------+-------------|\n| usename      | name    |             |\n| usesysid     | oid     |             |\n| usecreatedb  | boolean |             |\n| usesuper     | boolean |             |\n| userepl      | boolean |             |\n| usebypassrls | boolean |             |\n| passwd       | text    |             |\n| valuntil     | abstime |             |\n| useconfig    | text[]  |             |\n+--------------+---------+-------------+\n```\n\n\n\n\n:::\n\n\n::: {.column}\n\n`pg_user` nous renseigne sur :\n\n- {{< fa user >}}  les usagers (`usename`)\n- {{< fa user-plus >}}  leur statut (`usesuper` : super-utilisateur ou pas)\n- {{< fa scale-balanced >}} leurs privilèges (`createdb` : peut créer une base ou non)\n\n\n:::\n\n:::::\n\n\n\n## Autre exemple d'usage de la métabase\n\n\n```{.sql}\nSELECT datname, application_name, client_addr, backend_start, state \nFROM pg_catalog.pg_stat_activity psa \nWHERE datname='bd_2023';                                               \n\n+-----------+-------------------------------------------+---------------+-------------------------------+---------+\n| datname   | application_name                          | client_addr   | backend_start                 | state   |\n|-----------+-------------------------------------------+---------------+-------------------------------+---------|\n| bd_2023   | DBeaver 22.2.0 - Main <bd_2023>           | 127.0.0.1     | 2022-10-04 22:48:59.57231+02  | idle    |\n| bd_2023   | DBeaver 22.2.0 - Metadata <bd_2023>       | 127.0.0.1     | 2022-10-04 22:48:59.693656+02 | idle    |\n| bd_2023   | DBeaver 22.2.0 - SQLEditor <Script-4.sql> | 127.0.0.1     | 2022-10-04 22:48:59.958616+02 | idle    |\n| bd_2023   | pgcli                                     | <null>        | 2022-10-04 23:23:19.739258+02 | active  |\n| bd_2023   | pgcli                                     | <null>        | 2022-10-04 23:23:19.770006+02 | idle    |\n+-----------+-------------------------------------------+---------------+-------------------------------+---------+\n```\n\n---\n\nRenseigne sur les utilisateurs ayant une session en cours sur la base `bd_2023`\n\n---\n\n## Tentative\n\nOn engendre *dynamiquement* une série de requêtes par une instruction de la forme :\n\n\n```{.sql}\nSELECT \n    'SELECT ' || quote_literal(usename) || ', COUNT(*)  FROM ' || usename || '.ville_pays ;'\nFROM pg_catalog.pg_user  ;\n```\n\n{{< fa brain >}} A quoi sert `quote_literal()` ?\n\n---\n\n\n## Le résultat est une table de chaines de caractères  {.smaller}\n\n\n```{.sql}\nrqt                                                      |\n---------------------------------------------------------+\nSELECT 'postgres', COUNT(*)  FROM postgres.ville_pays ;  |\nSELECT 'shinken', COUNT(*)  FROM shinken.ville_pays ;    |\nSELECT 'aalahy99', COUNT(*)  FROM aalahy99.ville_pays ;  |\nSELECT 'etemam', COUNT(*)  FROM etemam.ville_pays ;      |\nSELECT 'durand', COUNT(*)  FROM durand.ville_pays ;      |\n...\n```\n\n\n. . .\n\nTel quel, cela ne fonctionnera pas !\n\n- Il faut pouvoir confier ces chaines de caractères à l'évaluateur de\n  requêtes\n\n- Il faut pouvoir le faire pour chacune des chaines de caractères\n  produites par la requête (itérer)\n\n\n\n---\n\n\n\n## Mode opératoire\n\n\n```{.sql}\nCREATE OR REPLACE FUNCTION taille_ville_pays()\nLANGUAGE plpgsql RETURNS  TEXT AS\n$$\nDECLARE\n  stmt CHARACTER VARYING ;\n  usename CHARACTER VARYING ;\n  result CHARACTER VARYING    := '' ;\n  resp CHARACTER VARYING := '' ;\nBEGIN\nFOR usename IN SELECT u.usename  #<<\n  FROM pg_catalog.pg_user AS u JOIN\n  information_schema.tables t ON\n  (u.usename=t.table_schema and t.table_name ='ville_pays')\nLOOP\n  stmt = 'SELECT CAST(COUNT(*) AS VARCHAR) FROM '|| usename||'.ville_pays #<<\n  result:=result || usename || ': ' ||resp| '; ';   #<< \nEND LOOP ;\nRETURN result ; #<< \nEND;$$ ;\n```\n\n---\n\nNous utilisons une des structures itératives de `plpgSQL` :\n\n```{.sql}\nFOR v IN expression \nLOOP\n  instructions\nEND LOOP ;\n```\n\n. . .\n\n- On itère sur les tuples de la requête `SELECT u.usename  ...`\n\nVoir [Documentation officielle](https://www.postgresql.org/docs/current/plpgsql.html)\n\n. . .\n\n- Dans le corps de la boucle `LOOP`, on fabrique une requête :\n\n`stmt := ...` \n\n- Puis on exécute cette requête :\n\n`EXECUTE stmt INTO resp ;`\n\n. . .\n\nLe résultat de la requête engendrée dynamiquement est affecté à la variable locale `stmt`\n\nLe contenu est accumulé dans `result`\n\n. . .\n\nRenvoi du résultat\n\n`plpgSQL` propose une variété de manières de construire et de renvoyer le résultat d'une fonction\n\nVoir [Documentation officielle](https://www.postgresql.org/docs/current/plpgsql-declarations.html)\n\n\n\n\n# Extension de SQL en un langage procédural  {background-color=\"#1c191c\"}\n\n\n## Extension de SQL\n\nA travers ces deux exemples, on a vu quelques particularités des extensions possible de `SQL` en un langage procédural `pgplSQL`. Le principe est le même dans la plupart des SGBD permettant une telle extension (`Oracle`, `SQL Server`, ...). Il repose sur la norme `SQL`.\n\nOn a besoin :\n\n\n- d'instructions conditionnelles (*si ... alors ... sinon*)\n\n- d'instruction itératives (*boucles*)\n\n- de la capacité à définir des variables\n\n- de mécanismes d'articulations entre `SQL` et son extension procédurale :\n\n    - Pouvoir stocker le résultat d'une requête (avec résultat unique) dans une variable\n    - Pouvoir stocker, les uns après les autres, les résultats d'une requêtes complexes pour traitement, définir un curseur (`CURSOR`)\n\n\n## Extension de SQL\n\nOn doit avoir un mécanisme qui permet conserver les programmes écrits pour les utiliser lors de sessions futures \n\nLe langage `plpgsql` permet :\n\n- de définir des fonctions et procédures stockées...\n- qui vont avoir la même *persistence* que les *tables*, *vues*, etc\n\n- L'existence de ces fonctions, leurs codes, etc, seront conservés dans des tables et vue d'administration (`information_schema.routines`). \n\n\n\n\n## Exemple \n\n```{.sql}\nSELECT routine_catalog, routine_schema, routine_name, data_type, security_type\nFROM information_schema.routines    #<< \nWHERE routine_type='FUNCTION' AND specific_schema='sakila'   #<< \n```\n\n. . .\n\n```\nroutine_catalog|routine_schema|routine_name              |data_type   |security_type|\n---------------+--------------+--------------------------+------------+-------------+\nbd_2023        |sakila        |_group_concat             |text        |INVOKER      |\nbd_2023        |sakila        |film_in_stock             |integer     |INVOKER      |\nbd_2023        |sakila        |film_not_in_stock         |integer     |INVOKER      |\nbd_2023        |sakila        |get_customer_balance      |numeric     |INVOKER      |\nbd_2023        |sakila        |inventory_held_by_customer|integer     |INVOKER      |\nbd_2023        |sakila        |inventory_in_stock        |boolean     |INVOKER      |\nbd_2023        |sakila        |last_day                  |date        |INVOKER      |\nbd_2023        |sakila        |last_updated              |trigger     |INVOKER      |\nbd_2023        |sakila        |rewards_report            |USER-DEFINED|DEFINER      |\n```\n\n\n#  Un exemple plus complexe issu de `sakila`  {background-color=\"#1c191c\"}\n\n\n## `rewards_report` signature  {.smaller}\n\n\n```{.sql}\nCREATE OR REPLACE FUNCTION \n    sakila.rewards_report(min_monthly_purchases integer, \n                          min_dollar_amount_purchased numeric)\n RETURNS SETOF sakila.customer\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    last_month_start DATE;\n    last_month_end DATE;\nrr RECORD;\ntmpSQL TEXT;\nBEGIN\n...\nEND $$ ;\n```\n\n\nDétermine la liste des bons clients qui beaucoup consommé durant le dernier mois écoulé\n\n---\n\n```{.sql}\nCREATE OR REPLACE FUNCTION sakila.rewards_report(min_monthly_purchases integer, min_dollar_amount_purchased numeric)\n RETURNS SETOF sakila.customer\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    last_month_start DATE;\n    last_month_end DATE;\nrr RECORD;\ntmpSQL TEXT;\nBEGIN\n\n    /* Some sanity checks... */\n    IF min_monthly_purchases = 0 THEN\n        RAISE EXCEPTION 'Minimum monthly purchases parameter must be > 0';\n    END IF;\n    IF min_dollar_amount_purchased = 0.00 THEN\n        RAISE EXCEPTION 'Minimum monthly dollar amount purchased parameter must be > $0.00';\n    END IF;\n\n    last_month_start := CURRENT_DATE - '3 month'::interval;\n    last_month_start := to_date((extract(YEAR FROM last_month_start) || '-' || extract(MONTH FROM last_month_start) || '-01'),'YYYY-MM-DD');\n    last_month_end := LAST_DAY(last_month_start);\n\n    /*\n    Create a temporary storage area for Customer IDs.\n    */\n    CREATE TEMPORARY TABLE tmpCustomer (customer_id INTEGER NOT NULL PRIMARY KEY);\n\n    /*\n    Find all customers meeting the monthly purchase requirements\n    */\n\n    tmpSQL := 'INSERT INTO tmpCustomer (customer_id)\n        SELECT p.customer_id\n        FROM payment AS p\n        WHERE DATE(p.payment_date) BETWEEN '||quote_literal(last_month_start) ||' AND '|| quote_literal(last_month_end) || '\n        GROUP BY customer_id\n        HAVING SUM(p.amount) > '|| min_dollar_amount_purchased || '\n        AND COUNT(customer_id) > ' ||min_monthly_purchases ;\n\n    EXECUTE tmpSQL;\n\n    /*\n    Output ALL customer information of matching rewardees.\n    Customize output as needed.\n    */\n    FOR rr IN EXECUTE 'SELECT c.* FROM tmpCustomer AS t INNER JOIN customer AS c ON t.customer_id = c.customer_id' LOOP\n        RETURN NEXT rr;\n    END LOOP;\n\n    /* Clean up */\n    tmpSQL := 'DROP TABLE tmpCustomer';\n    EXECUTE tmpSQL;\n\nRETURN;\nEND\n$function$\n;\n\n-- Permissions\n\nALTER FUNCTION sakila.rewards_report(int4, numeric) OWNER TO postgres;\nGRANT ALL ON FUNCTION sakila.rewards_report(int4, numeric) TO postgres;\n\n\n```\n\n---\n\n\n> Whenever you create a new table, PostgreSQL automatically creates a\ncomposite type based on the structure of the table. This allows you to\ntreat table rows as objects in their own right. You'll appreciate this\nautomatic type creation when you write functions that loop through\ntables. pgAdmin doesn't make the automatic type creation obvious\nbecause it does not list them under the types node, but rest assured that\nthey are there\n\n\n---\n\n\n## {{< fa hand-point-right >}}\n\n-   la signature comporte une déclaration de type originale\n-   la déclaration des variables locales mentionne un type fourre-tout\n\n\n#### `SETOF customer`\n\nTable de même schéma que `customer` (mêmes colonnes)\n\nConstruction très très utile : `SETOF nom_de_table`\n\n\n#### `RECORD`\n\nUn type générique (fourre-tout) pour désigner les types *composés*\n(en particulier comme les types définis à partir des tables)\n\n---\n\n## `rewards_report` corps (I)   {.smaller}\n\n\n\n```{.sql}\nBEGIN\n    /* Some sanity checks... */\n    IF min_monthly_purchases = 0 THEN\n        RAISE EXCEPTION 'Minimum monthly purchases parameter must be > 0';\n    END IF;\n    IF min_dollar_amount_purchased = 0.00 THEN\n        RAISE EXCEPTION 'Minimum monthly dollar amount purchased parameter must be > $0.00';  #<< \n    END IF;\n\n    last_month_start := CURRENT_DATE - '3 month'::interval;\n    last_month_start := to_date((extract(YEAR FROM last_month_start) || '-' || extract(MONTH FROM last_month_start) || '-01'),'YYYY-MM-DD');\n    last_month_end := LAST_DAY(last_month_start);\n...\n```\n\n\n. . .\n\n\n\n{{< fa hand-point-right >}} `RAISE EXCEPTION 'msg'`\n\ntermine (en erreur) l'exécution de la fonction envoie un message d'erreur\n\n\n## `rewards_report` corps (II)\n\n\n\n```{.sql}\n/*\n    Create a temporary storage area for Customer IDs.\n    */\n    CREATE TEMPORARY TABLE tmpCustomer (customer_id INTEGER NOT NULL PRIMARY KEY);\n\n    /*\n    Find all customers meeting the monthly purchase requirements\n    */\n\n    tmpSQL := 'INSERT INTO tmpCustomer (customer_id)\n        SELECT p.customer_id\n        FROM payment AS p\n        WHERE DATE(p.payment_date) BETWEEN '|| quote_literal(last_month_start) ||' AND '|| quote_literal(last_month_end) || '\n        GROUP BY customer_id\n        HAVING SUM(p.amount) > ' || min_dollar_amount_purchased || \n        'AND COUNT(customer_id) > ' || \n        min_monthly_purchases ;\n\n    EXECUTE tmpSQL;  #<< \n```\n\n\n\n\n\n\n\n## {{< fa hand-point-right >}} `CREATE TEMPORARY TABLE ...`\n\nCrée une table (très simple ici) qui sera détruite avant la fin de\nl'exécution de la fonction. \n\nSi l'exécution de la fonction devait être interrompue, cette table ne survivrait pas à la *session* qui a invoqué la fonction\n\n\n\n## Pourquoi utiliser une requête créée dynamiquement ?\n\n-   Est ce une nécessité ici ?\n\n-   Si non, quel est l'intérêt ?\n\n\n\n## `rewards_report` corps III\n\n\n```{.sql}\n/*\n    Output ALL customer information of matching rewardees.\n    Customize output as needed.\n    */\n    FOR rr IN EXECUTE 'SELECT c.* FROM tmpCustomer AS t INNER JOIN customer AS c ON t.customer_id = c.customer_id' LOOP\n        RETURN NEXT rr;   #<<\n    END LOOP;\n\n    /* Clean up */\n    tmpSQL := 'DROP TABLE tmpCustomer';\n    EXECUTE tmpSQL;\n\nRETURN;   #<<\nEND\n$function$ ;\n```\n\n---\n\n#### `FOR rr IN EXECUTE ...`\n\n#### `RETURN NEXT rr`\n\n\n---\n\n{{< fa hand-point-right >}} Les requêtes dynamiques sont-elles vraiment nécessaires ?\n\n\n---\n\n\n# Fin {background-color=\"#1c191c\"}\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}