{
  "hash": "de7adf12039cc92921b2619480e9b277",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"BD I: Algèbre Relationnelle\"\nsubtitle: \"Cadre formel pour la manipulation de tables\"\ndate: \"2024-09-13\"\n\nformat: \n  revealjs:\n    header: \"Algèbre Relationnelle\"\n---\n\n\n\n\n\n# Le modèle relationnel {background-color=\"#1c191c\"}\n\n\n---\n\n\n- Formulé par [E. Codd](https://en.wikipedia.org/wiki/Edgar_F._Codd) en 1970\n\n- Fondé sur la théorie des *relations* (partie de la théorie naïve des ensembles)\n\n- Propose une solution pour\n \n  + la modélisation\n  + l'interrogation de données\n\n- Facile à traduire/mettre en œuvre dans des langages *réels* comme `Structured Query Language (SQL)` ou dans des environnements de calcul orientés données comme `R/dplyr`\n\n\n\n\n## Un peu de formalisation\n\nRappel sur la notion de relation (au sens classique)\n\n\n::: {.callout-important}\n\n### Definition : Domaine \n\nUn ensemble d'éléments\n\n:::\n\n. . .\n\n\nExemples :  entiers $\\mathbb{Z}$, flottants, chaines de caractères $\\mathcal{A}^*$, date, ...\n\nLes *types* d'un langage de programmation comme `C`, `Java`, ...\n\n\n\n\n## Remarque   {.incremental}\n\n- Un *domaine* peut se définir :\n\n  - en *extension* (en donnant la\nliste de toutes les valeurs possibles) ou\n\n  -  en *intention* (en donnant une propriété caractéristique).\n\n\n\n## Produit cartésien\n\n::: {.callout-important}\n\n### Définition : Produit cartésien  \n\nLe *Produit cartésien*  d'une liste de domaines $D_1, D_2, \\dots, D_k$, noté \n\n$$D_1 \\times D_2 \\times \\dots \\times D_k$$\n\nest l'ensemble\n\n$$\\Bigl\\{(t_1,t_2,\\dots,t_k);\\ t_i\\in D_i \\text{ pour } i=1,\\dots,k\\Bigr\\}$$\n\n\nUn élément $t=(t_1,t_2,\\dots,t_k)\\in D_1 \\times D_2 \\times \\dots \\times  D_k$ est appelé  $k$ -uplet\n\n:::\n\n\n\n---\n\n\n\n\n::: {.callout-note}\n\n### Relations (classique)\n\nUne *Relation* $R$ est un sous-ensemble de \n\n$$D_1\\times D_2\\times \\cdots \\times D_k$$\n\noù $D_1,...,D_k$ sont des domaines\n\n\n$$R \\subseteq D_1  \\times D_2\\times \\cdots \\times D_k$$\n\n:::\n\n\n\n## Exemple  {.smaller}\n\n\n\n::::: {.columns}\n::: {.column width=\"65%\"}\n\nDeux domaines \n\n$$D_1=\\left\\{1,2,5\\right\\} \\quad\\text{et}\\quad D_2=\\left\\{2,4\\right\\}$$\n\nUn produit cartésien \n\n$$D_1 \\times D_2 = \\left\\{(1,2),(1,4),(2,2),(2,4),(5,2),(5,4)\\right\\}$$\n\nUne relation \n\n$$R =\\left\\{(1,2),(1,4),(5,2),(5,4)\\right\\}$$\n\nUne relation est un (sous-) ensemble (d'un produit cartésien)\n\n:::\n\n::: {.column   width=\"30%\"}\n\nOn peut  représenter $R$  par le tableau :\n\n::: {.center}\n\n| $X_1$  | $X_2$ |\n|:------:|:-----:|\n|  1    |  2 |\n|  1    |  4 |\n|  5    |  2 |\n|  5    |  4 |\n\n:::\n\nChaque ligne de la table correspond à  un élément de la relation $R$ \n\n:::\n\n::::: \n\n\n\n\n\n## Relations (classiques)\n\nDans ce cours, toutes les relations ont  un nombre fini d'éléments !\n\n\n---\n\n::: {.callout-important}\n\n### Définition : *Cardinalité* de la relation $R$: $|R|$\n\nOn appelle *cardinalité* d'une relation $R$, notée $|R|$, le nombre d'éléments  de $R$.\n\n:::\n\n. . .\n\n::: {.callout-important}\n\n### *Arité* de la relation $R$\n\nSoit $R\\subset D_1\\times D_2\\times \\cdots \\times D_k$, l'entier $k$ est appelé *arité* de $R$.\n\n:::\n\n. . .\n\nOn parle parfois aussi de *degré* d'une relation.\n\n. . .\n\nUne *relation binaire* est une relation d'arité $2$\n\n\n\n# Schémas et relations  {background-color=\"#1c191c\"}\n\n\n\n## Relations et schémas\n\n\n- Une *relation* (classique) peut se voir comme une *table* à deux dimensions :\n  - chaque ligne correspond alors à un $k$-uplet (si la relation est d'arité $k$),\n  - chaque élément d'une colonne est à valeur dans  un domaine.\n  - Un *domaine* peut apparaître plusieurs fois dans la définition d'une relation.\n\n---\n\nEn BD relationnelle, on  donne un nom à chaque colonne\n\n- *Attribut*:  nom/rôle de la colonne. L'attribut suggère/précise la sémantique de la colonne \n \n{{< fa  triangle-exclamation >}}  En BD on ne peut pas avoir deux attributs identiques (même nom, même domaine) dans une même table\n\n---\n\n::: {.callout-note}\n\nL'idée de nommer les colonnes plutôt que de les désigner par une position/un numéro se retrouve dans les sytèmes qui manipulent des données tabulaires (`Pandas/Python`, `R`, `Spark`, ...). \n\n:::\n\n\n## Schéma d'une relation \n\n\n::: {.callout-important}\n\n### Définition : schéma \n\nLe *Schéma* d'une relation $R$ est la donnée  des  attributs et domaines de la relation\n\n:::\n\nLe schéma peut se noter\n\n$$R(A_1\\! :\\! D_1,A_2\\! :\\! D_2,\\dots,A_k\\! :\\! D_k)$$\n\noù $A_i$ : attribut et $D_i$ : domaine.\n\n\n\n## Exemple de schéma : table `bebes`  dans `babynames` {.smaller}\n\n::: {.columns}\n\n::: {.column}\n\n```{.sql}\nbd_2023-24> \\dt\n+-----------+-------+-------+-----------+\n| Schema    | Name  | Type  | Owner     |\n|-----------+-------+-------+-----------|\n| babynames | bebes | table | boucheron |\n+-----------+-------+-------+-----------+\n\nbd_2023-24> \\d bebes\n+--------+------------------------+-----------+\n| Column | Type                   | Modifiers |\n|--------+------------------------+-----------|\n| sexe   | integer                |           |\n| prenom | character varying(500) |           |\n| annee  | integer                |           |\n| nombre | integer                |           |\n+--------+------------------------+-----------+\n```\n\n$$\\left((\\textsf{sexe}, \\mathbb{Z}), (\\textsf{prenom}, \\texttt{char}), (\\texttt{annee}, \\mathbb{Z}), (\\texttt{nombre}, \\mathbb{Z})\\right)$$\n:::\n\n::: {.column}\n\nDonnées [INSEE](). Une ligne de la table `bébés` nous informe qu'en France (héxagone?), pendant une `annee`, le nombre de naissances de sexe `sexe`, ayant reçu le prénom `prenom` est donnée par la colonne `nombre`.  \n\n\n```{.sql}\nbd_2023-24> SELECT * \nFROM bebes \nWHERE sexe=1 AND annee=2000 AND prenom='THÉO' ;\n\n+------+--------+-------+--------+\n| sexe | prenom | annee | nombre |\n|------+--------+-------+--------|\n| 1    | THÉO   | 2000  | 7961   |\n+------+--------+-------+--------+\n```\n\nL'arité de `bebes` est $4$, sa cardinalité est $648 614$. \n\n\n:::\n\n::: \n\n\n\n\n# Relations et schémas : formalisation alternative   {background-color=\"#1c191c\"}\n\n\n\n##  Formalisation alternative\n\n\n- En BD, l'ordre des éléments et l'ordre des colonnes n'a pas d'importance (on désigne les membres d'un $k$-uplet par leur nom plutôt que par leur position/rang)\n\n- La définition formelle diffère donc de celle \td'une relation classique\n\n- Soient $\\{A_1,...,A_k\\}$ un ensemble fini et $D_1,...,D_k$ suite de domaines.\n\n::: {.callout-important}\n\n### Notation\n\nUne relation $R$ de schéma $R(A_1\\! :\\! D_1,A_2\\! :\\! D_2,\\dots,A_k\\! :\\! D_k)$ est la donnée d'un ensemble d'éléments, noté $\\mathcal{R}$ et de $k$  fonctions $\\mathcal{A}_1: \\mathcal{R}\\rightarrow D_1$, ..., $\\mathcal{A}_k: \\mathcal{R}\\rightarrow D_k$.\n\nPour tout $t\\in \\mathcal{R}$ et $i\\leq k$, on note $t.A_i=\\mathcal{A}_i(t)$ l'image par $\\mathcal{A}_i$ de $t$.\n\nUn élément $t$ de $\\mathcal{R}$ est appelé *tuple* de la relation $R$\n\n:::\n\n\n---\n\n### Conventions (suite)\n\n- Pour désigner l'ensemble des valeurs $t.A_1,...., t.A_k$ associées à un tuple $t\\in \\mathcal{R}$,\non fixe un ordre arbitraire sur les attibuts et on note $t=(t.A_1,...., t.A_k)$ \n\n- A un tuple $t$ de $\\mathcal{R}$ correspondent les $k$ valeurs $t.A_1, \\dots, t.A_k$\n\n- On notera aussi $R$ le domaine $\\mathcal{R}$ d'une relation $R$.\n\n\n## Relations et schémas : formalisation\n\n\n::: {.columns}\n\n::: {.column}\n\n```{.sql}\nbd_2023-24> SELECT * \nFROM bebes \nWHERE sexe=1 AND \n  annee> 1960 AND \n  prenom LIKE 'THEODULE' ;\n```\n\n```{.sql}\n+------+----------+-------+--------+\n| sexe | prenom   | annee | nombre |\n|------+----------+-------+--------|\n| 1    | THEODULE | 1961  | 4      |\n| 1    | THEODULE | 1962  | 4      |\n| 1    | THEODULE | 1965  | 4      |\n| 1    | THEODULE | 1969  | 4      |\n+------+----------+-------+--------+\n\n```\n:::\n\n::: {.column}\n\nQuatre tuples de `bebes` : $t_1, t_2, t_3, t_4$. \n\n\\begin{align*}\nt_1.\\text{sexe} & =  1 \\\\\nt_1.\\text{prenom} & = \\texttt{THEODULE} \\\\\nt_1.\\text{annee} & = 1961 \\\\\nt_1.\\text{nombre} & = 4\n\\end{align*}\n\n:::\n\n::: \n\n\n\n\n## Résumé informel\n\n- RELATION ↔  TABLE À DEUX DIMENSIONS\n\n- (NOM DE) COLONNE ↔  ATTRIBUT\n\n- EN-TÊTE DU TABLEAU ↔ SCHEMA DE LA RELATION\n\n- LIGNE ↔ TUPLE\n\n- ENSEMBLE DES LIGNES ↔ CONTENU DE LA RELATION\n\n\n\n# LMD : Opérateurs  {background-color=\"#1c191c\"}\n\n\n## Langage de manipulation de données\n\nL'algèbre relationnelle est un système de calcul sur les tables\n\nElle est formée d'une collection d'*opérateurs* qui prennent en argument des tables et retournent des tables\n\n::: {.callout-note}\n\n### Remarque:\n\nLes opérateurs prennent en général des arguments supplémentaires qui ne sont pas des tables. La notion d'algèbre relationnelle\nest inspirée par les structures algébriques comme les groupes, les anneaux, les corps où des opérations internes opèrent sur \nune ensemble (par exemple $(\\mathbb{R}, +, \\times)$), mais elle ne rentre pas exactement dans le cadre.\n\n:::\n\nL'algèbre n'est pas aussi expressive qu'un langage de programmatoin classique (comme `Python`). C'est cela qui rend ce modèle de \ncalcul intéressant : il permet de faire des choses pas triviales, mais il est plus facile à utiliser qu'un langage de programmation.     \n\n\n\n## Opérateurs de base\n\n\n::: {.callout-important}\n\n\n### Liste des opérateurs\n\nL'algèbre relationnelle est d'abord un *Langage de Manipulation de Données& (LMD)}.\n\n\n- Union: $\\Large{\\cup}$  \n\n- Intersection: $\\Large{\\cap}$ \n\n- Différence: $\\Large{\\backslash}$ \n\n- Projection:  $\\Large{\\Pi}$  \n\n- Sélection: $\\Large{\\sigma}$ \n\n- Produit cartésien:  $\\Large{\\times}$ \n\n- Renommage:  $\\Large{\\rho}$ \n\n\ns'appliquent à des relations pour produire d'autres relations (le résultat).\n\n:::\n\n\n## Union $\\cup$ et intersection  $\\cap$\n\n::: {.callout-important}\n\n### Définition\n\n- L'*union* et l'*intersection* sont des  opérations portant sur deux relations $R_1$ et $R_2$ de **même  schéma**\n\n- $T=R_1\\cup R_2$  est  constituée des tuples appartenant à $R_1$ *ou* à\n$R_2$.\n\n- $T=R_1\\cap R_2$  est  constituée des tuples appartenant à $R_1$ *et* à\n$R_2$.\n\n- Les Schémas de  $R_1\\cup R_2$, $R_1\\cap R_2$ sont les mêmes que ceux de $R_1$  et  $R_2$\n\n:::\n\n## Union : exemple  {.smaller}\n\n<!-- \n\n\n```{sql}\n-- | echo: false\n\nSET search_path TO babynames ;\n\nSELECT * \nFROM bebes AS b\nWHERE b.sexe=1 AND\n  b.prenom ILIKE 'THEO%' AND\n  b.annee = 2000 ;\n\n\nSELECT * \nFROM bebes AS b\nWHERE b.sexe=1 AND\n  b.prenom ILIKE 'THEO%' AND\n  b.annee = 1900 ;\n```\n\n -->\n\n::::: {.columns}\n\n::: {.column}\n\n```{.sql}\n-- THEO_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n| 1    | THEOPHANE | 1900  | 3      |\n+------+-----------+-------+--------+\n\n-- THEO_2000\n\n|------+-----------+-------+--------|\n| 1    | THEO      | 2000  | 6      |\n| 1    | THEODOR   | 2000  | 3      |\n| 1    | THEOPHILE | 2000  | 336    |\n| 1    | THEODORE  | 2000  | 149    |\n| 1    | THEOPHANE | 2000  | 47     |\n| 1    | THEOPHYLE | 2000  | 4      |\n| 1    | THEOTIME  | 2000  | 73     |\n| 1    | THEOS     | 2000  | 3      |\n| 1    | THEOTIM   | 2000  | 4      |\n+------+-----------+-------+--------+\n```\n\n:::\n\n::: {.column}\n\n`THEO_1900` ∪ `THEO_2000`\n\n```{.sql}\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEO      | 2000  | 6      |\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEODOR   | 2000  | 3      |\n| 1    | THEOPHANE | 2000  | 47     |\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODORE  | 2000  | 149    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n| 1    | THEOPHANE | 1900  | 3      |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEOTIME  | 2000  | 73     |\n| 1    | THEOPHILE | 2000  | 336    |\n| 1    | THEOPHYLE | 2000  | 4      |\n| 1    | THEOS     | 2000  | 3      |\n| 1    | THEOTIM   | 2000  | 4      |\n+------+-----------+-------+--------+\n\n```\n\n:::\n\n:::::\n\n\n---\n\n## Intersection : exemple    {.smaller}\n\n::: {.columns}\n::: {.column}\n\n```{.sql}\n-- THEO_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n| 1    | THEOPHANE | 1900  | 3      |\n+------+-----------+-------+--------+\n\n-- THEOD_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n+------+-----------+-------+--------+\n\n```\n:::\n::: {.column}\n\n`THEO_1900` ∩ `THEOD_1900`\n```{.sql}\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n+------+-----------+-------+--------+\n```\ncar `THEOD_1900` ⊂ `THEO_1900`\n\n:::\n\n:::\n\n\n## Différence\n\n\n::: {.callout-important}\n\n### Définition\n\n\n- La **différence** de deux relations $R_1$ et $R_2$ (de même schéma) est une relation $T$\n\n- de même schéma que $R_1$ et $R_2$ \n\n- constituée des tuples appartenant à $R_1$ et n'appartenant pas à $R_2$.\n\n\n- On note $T = R_1 - R_2$.\n\n:::\n\n. . .\n\n::: {.callout-caution}\n\n### Opération non *commutative* !\n\n$R_1 - R_2\\neq  R_2 - R_1$ (en général).\n\n\n:::\n\n\n\n## Différence : exemple   {.smaller}\n\n\n::::: {.columns}\n\n\n::: {.column}\n\n```{.sql}\n-- THEO_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n| 1    | THEOPHANE | 1900  | 3      |\n+------+-----------+-------+--------+\n\n-- THEOD_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n+------+-----------+-------+--------+\n```\n\n:::\n\n::: {.column}\n\n`THEO_1900` ∖ `THEOD_1900`\n\n```{.sql}\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEOPHANE | 1900  | 3      |\n+------+-----------+-------+--------+\n\n\n```\n:::\n\n:::::\n\n\n\n\n## Produit Cartésien\n\n\n\n::: {.callout-important}\n\n### Définition\n\n- Soient:\n  -  $R_1$ de schéma $R_1(A_1,A_2,...,A_k)$\n  -  $R_2$ de schéma $R_2(B_1,B_2,...,B_\\ell)$\n  -  avec $A_i\\neq B_j$, pour tout $i=1,...,k$, $j=1,..,\\ell$\n\n-  Dans le contexte \"classique\" : $R_1 \\times R_2= \\{(e_1,e_2): e_1\\in R_1, e_2\\in R_2\\}$\n\n- $R=R_1 \\times R_2$  de schéma $R(A_1,A_2,...,A_k,B_1,B_2,...,B_\\ell)$. Le schéma de $R$ est *l'union* des schémas de $R_1$ et $R_2$\n\n:::\n\n::: {.callout-caution}\n\n### Attention \n\nEn algèbre relationnelle, cette opération est commutative  ( $R_1\\times R_2 = R_2\\times R_1$ ) et associative\n \n:::\n\n## Produit cartésien :\n\n\n::: {.callout-important}\n\n###  Définition formelle\n\n$R=R_1\\times R_2$ est la relation de schéma $R(A_1,A_2,...,A_k,B_1,B_2,...,B_\\ell)$ vérifiant~:\n\n\n- Pour tout $t\\in R$, il existe $t_1\\in R_1$, $t_2\\in R_2$  ($\\forall t \\in R, \\exists t_1 \\in R_1, \\exists t_2 \\in R_2, \\ldots$) tels que :\n\n$$t.A_1=t_1.A_1, \\ldots, t.A_k=t_1.A_k,\\quad t.B_1=t_2.B_1, \\ldots, t.B_\\ell=t_2.B_\\ell$$\n\n- Réciproquement, pour tout $t_1\\in R_1$, $t_2\\in R_2$ , il existe $t\\in R$ tels que :\n\n$$t.A_1=t_1.A_1, \\ldots, t.A_k=t_1.A_k,\\quad \\text{et} \\quad t.B_1=t_2.B_1, \\ldots, t.B_\\ell=t_2.B_\\ell$$\n\n$$\\forall t_1 \\in R_1, \\forall t_2 \\in R_2, \\exists t \\in R, \\qquad  t.A_1=t_1.A_1, \\ldots, t.A_k=t_1.A_k,\\quad \\text{et} \\quad t.B_1=t_2.B_1, \\ldots, t.B_\\ell=t_2.B_\\ell$$\n:::\n\n\n\n## Produit cartésien : exemple\n\n\n\n\n\n\n## Projection  ( $\\Large{\\pi}$ )\n\n\n::: {.callout-important}\n\n### Définition\n\n- La *projection* d'une relation $R$ de schéma $R(A_1,\\dots, A_k)$\n sur les attributs $A_{i_1}, \\dots, A_{i_p}$, $i_1,..., i_p\\in \\{1,...,k\\}$,  est la relation $S$\n  - de schéma $S(A_{i_1}, \\dots,A_{i_p})$\n  - dont les tuples sont obtenus par élimination des attributs\nnon mentionnés dans $A_{i_1}, \\dots, A_{i_p}$ (et par élimination\ndes doublons).\n  - On note $S = \\pi_{A_{i_1}, \\dots, A_{i_p}} (R)$.\n\n- Définition formelle :\n\n$$s\\in S\\quad  \\iff \\quad \\exists t\\in R, \\forall n\\in\\left\\{1,\\dots,p\\right\\}\\qquad s.A_{i_n}=t.A_{i_n}$$\n\n:::\n\n::: {.callout-note}\n\n### Remarque \n\nImplicitement, on a *élimination des doublons* car une projection peut produire plusieurs fois le même tuple.\n\n:::\n\n---\n\n::: {.callout-caution}\n\n### Remarque \n\nÀ la différence des opérations ensemblistes ∩, ∪, ∖, ×, la projection ne fait pas intervenir que des tables. \n\nOn peut considérer la projection comme une fonction à deux arguments, avec un premier argument de type table, et un \nsecond argument constitué par une liste d'attributs. \n\nOn peut aussi considérer la projection comme une fonction avec un nombre *variable*  d'arguments. Un premier argument de type  table, puis de arguments qui désignent des attributs de la table. Si on accepte ce point de vue, on peut adopter la \nnotation \n\nOn note \n$$S = \\pi(R, {A_{i_1}, \\dots, A_{i_p}})$$\nau lieu de $S = \\pi_{A_{i_1}, \\dots, A_{i_p}} (R)$\n\nDans la suite, nous utiliserons cette possibilité. \n \n:::\n\n## Projection : Exemple\n\n\nΠ(`THEO_1900`, `prenom`, `nombre`)\n\n```{.sql}\n+-----------+---------+\n| prenom    |  nombre |\n|-----------+---------+\n| THEODORE  |  227    |\n| THEODOSE  |  3      |\n| THEODULE  |  39     |\n+-----------+---------+\n```\n\nIci, aucune éliminitation de doublons n'a été nécessaire\n\n\n## Sélection  ( $\\Large{\\sigma}$ ) \n\n\n::: {.callout-important}\n\n### Définition\n\n- La *sélection* d'une relation $R$\npar une condition $C$ est une relation $S$\n\n  - de même schéma que $R$ \n\n  - dont les tuples sont ceux de $R$ qui satisfont la condition $C$.\n\n- On note $S = \\sigma_C (R)$.\n\n- La condition $C$  \n\n  - s'exprime à l'aide des noms d'attributs de la relation ou de constantes (pour les opérandes)\n\n  - on peut utiliser des opérateurs arithmétiques de comparaison ( $=, \\neq, \\leq, \\geq, <, >$ ) ainsi que des connecteurs logiques ( $\\lnot, \\land, \\lor$ )..\n\n:::\n\n\n---\n\n\n::: {.callout-caution}\n\n### Remarque \n\nÀ la différence des opérations ensemblistes ∩, ∪, ∖, ×, comme la projection, la sélection ne fait pas intervenir que des tables. \n\nOn peut considérer la sélection comme une fonction à deux arguments, avec un premier argument de type table, et un \nsecond argument constitué par une condition (une expression dont l'évaluation sur chaque ligne de la table retourne `Vrai`, `Faux`, ou `Indéterminé`). \n\nOn peut aussi considérer la sélection comme une fonction avec un nombre *variable*  d'arguments. Un premier argument de type  table, puis de arguments qui représentent des expressions susceptibles d'être évaluées sur chaque ligne de la table.\nUne ligne fera partie de la table résultat, si elle satisfait toutes les expressions.\n\nOn note \n$$S = \\sigma(R, {C_{1}, \\dots, C_{p}})$$\nau lieu de $S = \\sigma_{C_1 \\wedge C_2 \\wedge \\ldots \\wedge C_p } (R)$\n\nDans la suite, nous utiliserons cette possibilité. \n\nNotons que dans un langage comme `Python`, nous ne disposons pas d'emblée d'un type *expression* et que \nla notation proposée ici ne se code pas trivialement en `Python`.\n\nEn langage `R`, on dispose d'un type *expression*, la notation proposée ici est mise en œuvre dans le package `dplyr`.\n\n:::\n\n\n## Sélection : Exemple\n\n\nσ(`THEO_1900`, `prenom` `LIKE` 'THEOD%')\n\n\n```{.sql}\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEOPHANE | 1900  | 3      |\n+------+-----------+-------+--------+\n```\n\n\n## Renommage\n\n::: {.callout-important}\n\n### Définition\n\n- Soit  $R$ de schéma $R(A_1,\\dots, A_k)$, le *renommage* d'un attribut $A_i$, $i\\leq k$, en $B$ est une relation $S$ :\n  - de même contenu  (mêmes lignes)\n  - de schéma $S(A_1,...,A_{i-1},B,A_{i+1},..., A_k)$\n  - On le note $S=\\rho_{A_i\\mapsto B}(R)$\n\n:::\n\n\n---\n\n::: {.callout-caution}\n\n### Remarque \n\nComme la projection et la sélection, le renommage  ne fait pas intervenir que des tables. \n\n\nOn peut  considérer le renommage comme une fonction avec un nombre *variable*  d'arguments. Un premier argument de type  table, puis de arguments qui représentent des expressions indiquant comment doivent être renommées certains attributs.\n\nOn note \n$$S = \\rho(R, A_{i_1}\\mapsto B_1,\\ldots, A_{i_p}\\mapsto B_p)$$\nau lieu de $S=\\rho_{A_{i_1}\\mapsto B_1,\\ldots, A_{i_p}\\mapsto B_p}(R)$\n\nDans la suite, nous utiliserons cette possibilité. \n\nNotons que dans un langage comme `Python`, nous ne disposons pas d'emblée d'un type *expression* et que \nla notation proposée ici ne se code pas trivialement en `Python`.\n\nEn langage `R`, on dispose d'un type *expression*, la notation proposée ici est mise en œuvre dans le package `dplyr`.\n\n:::\n\n\n## Renommage : Exemple   {.smaller}\n\n```{.sql}\n-- THEOD_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n+------+-----------+-------+--------+\n```\n\nρ(`THEOD_1900`, `sexe→sex`, `prenom→name`, `annee→year`, `nombre→count`)\n\t\n```{.sql}\n-- THEOD_1900\n\n+------+-----------+-------+--------+\n| sex  | name      | year  | count  |\n|------+-----------+-------+--------|\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n+------+-----------+-------+--------+\n```\n\n\n\n*Utilité* Va permettre d'étendre certains opérateurs pour des relations de schémas non-disjoints\n\n\n\n# Résumé   {background-color=\"#1c191c\"}\n\n\n## Algèbre relationnelle\n\n- Opérations ensemblistes classiques.\n\n- Projection : élimine des colonnes\n\n- Sélection : élimine des lignes\n\nPour interroger une BD, on *compose* ces opérateurs :\n\n\n## Exemple\n\nπ(σ(`THEO_1900`, `prenom` `LIKE` 'THEOD%'), `prenom`, `nombre`)\n\n. . .\n\nρ(π(σ(`THEO_1900`, `prenom` `LIKE` 'THEOD%'), `prenom`, `nombre`), `prenom→name`, `nombre→count`)\n\n\n## De la composition aux tuyeaux (pipelines)\n\n\nOn peut  rendre la composition de fonctions plus lisible (pour l'humain) en reprenant un mécanisme d'`Unix` : le *pipe* (tuyeau) `|`\n\nPlutôt qu'écrire $g(f(x,y), z, t)$, on convient d'écrire  `f(x,y) | g(z, t)` voire `x | f(y) | g(z,t)`\n\nEt pour rendre l'expression encore plus lisible on peut écrire \n\n```{.sql}\nx | \n  f(y) | \n  g(z,t)\n```\n\n## De la composition aux tuyeaux (suite)\n\nOn peut ainsi réécrire \n\nρ(π(σ(`THEO_1900`, `prenom` `LIKE` 'THEOD%'), `prenom`, `nombre`), `prenom→name`, `nombre→count`)\n\nen \n\n```{.sql}\nTHEO_1900  |\n  σ(`prenom` `LIKE` 'THEOD%') |\n  π(`prenom`, `nombre`) |\n  ρ(`prenom→name`, `nombre→count`)\n```\n\n::: {.aside}\n\nDans le langage `R` (> 4.x), le pipe s'écrit `|>`\n\n:::\n\n\n# Opérations complémentaires : les jointures  {background-color=\"#1c191c\"}\n\n\n## Les jointures\n\nOn va définir des opérations pratiques pour la manipulation de données : les *jointures*\n\n- Jointure\n\n- Jointure *naturelle*\n\n- $\\theta$-jointure et équi-jointure\n\n\n\n## Jointure\n\n\n::: {.callout-important}\n\n### Définition\n\nLa jointure $T=R_1\\bowtie_C R_2$ de deux relations $R_1$ et $R_2$ de schémas disjoints sous la condition $C$ est la relation $T$:\n\n- de schéma la *concaténation* des schémas de $R_1$ et $R_2$\n\n- formée des tuples du produit cartésien $R_1  \\times R_2$ qui satisfont la condition $C$\n\n\nRègles de formation de la *condition de jointure* : comme pour la sélection\n\n\n:::\n\n\n::: {.callout-important}\n\n### Définition formelle\n\n$$R_1 \\bowtie_C R_2 = \\sigma_C(R_1\\times R_2)$$\n\n:::\n\n\n---\n\n::: {.callout-note}\n\n### Remarque \n\nComme la projection, la sélection et le renommage, la jointure  ne fait pas intervenir que des tables. \n\nOn peut  considérer la jointure comme une fonction avec un nombre *variable*  d'arguments. Deux  premiers arguments de type  table, puis une expression dont l'évaluation permet de déterminer quels couples de lignes doivent figurer dans la table résultat\n\nOn note \n$$T = \\bowtie(R, S, C)$$\nau lieu de $T=R  \\bowtie_C C$\n\nDans la suite, nous utiliserons cette possibilité. \n\nNotons que dans un langage comme `Python`, nous ne disposons pas d'emblée d'un type *expression* et que \nla notation proposée ici ne se code pas trivialement en `Python`.\n\nEn langage `R`, on dispose d'un type *expression*, la notation proposée ici est mise en œuvre dans le package `dplyr` avec \nla fonction `inner_join()`,\n\n\n:::\n\n\n\n## Exemple  sur le schéma `world`\n\n![](/images/layout_world.png)\n\nLier les pays (les lignes de `country`) à leur capitale, c'est à dire les couples de lignes de `country`  et de `city`\nqui satisfont  `capital = id` \n\n## Exemple  sur le schéma `world` (suite)\n\n```{.sql}\n`country` |\n  ⋈(`city`, `capital=id`) |\n  π(`name_country`, `name`)\n\n```\n\n```{.sql}\n\n+----------------------+------------------+\n| name_country         | name             |\n|----------------------+------------------|\n| Afghanistan          | Kabul            |\n| Netherlands          | Amsterdam        |\n| Netherlands Antilles | Willemstad       |\n| Albania              | Tirana           |\n| Algeria              | Alger            |\n...\n+----------------------+------------------+\n\n```\n\n::: {.aside}\n\nOn se contente d'afficher les cinq premières lignes du résultat.\n\n:::\n\n## Différentes variétés de jointures\n\nAutour de la jointure `⋈(R, S, C)` on a pris l'habitude de distinguer des types de jointure selon la forme de l'expression de jointure (la condition `C`) \n\nOn distingue \n\n- les équi-jointures \n- les θ-jontures \n- les jointures naturelles\n\n::: {.aside}\n\nCes distinctions portent sur la condition `C`. Elles ne sont pas de même nature que les distinctions qui portent sur la manière dont le résultat final est calculé et qui définissent les jointures *internes*, *externes*, ... \n\n\n:::\n\n\n## Équi-jointure, \n\n\n::: {.callout-important}\n\n### Équi-jointure  \n\nJointure avec égalité entre attributs de types comparables\n\n:::\n\n. . .\n\n\n```{.sql}\n⋈(`country`, `city`, `capital=id`)\n```\n\n\n## θ-jointure\n\n::: {.callout-important}\n\n### $\\theta$-*jointure*\n\nCondition de jointure entre attributs de types comparables et avec un opérateur différent de l'égalité, c'est-à-dire dans $\\left\\{<,>,\\leq,\\geq, \\neq\\right\\}$.\n\n\n:::\n \n\n. . .\n\n\n```{.sql}\n⋈(`country`, `city`, `capital=id`  ∧ `population > .5 * population_country`)\n```\n\n\n\n\n## Jointure naturelle\n\n::: {.callout-important}\n\n### Définition\n\nC'est une équi-jointure concernant les attributs communs (même nom et même type) de deux relations   \n\nOn ne garde dans le résultat qu'une copie des attributs communs {{< fa  triangle-exclamation >}}\n\n:::\n\n\nOn considère\n\n- $R_1$ d'attributs $A_1,..,A_k,B_1,...,B_h$\n\n- $R_2$ d'attributs $A_1,..,A_k,B_{h+1},...,B_\\ell$\n\n- $A_1,..., A_k$ : attributs communs et $\\{B_1,...,B_h\\}\\cap \\{ B_{h+1},...,B_\\ell \\}=\\emptyset$\n\n- Soit $A'_1, ...., A'_k$ tels que $\\{A_1,..., A_k\\}\\cap \\{ A'_1, ...., A'_k \\}=\\emptyset$\n\n\n\n## Jointure naturelle  (formalisation)   {.scrollable}\n\nConsidérons $S$ d'attributs $A_1',..,A_k',B_{h+1},...,B_l$ définie par :\n\n$$S=\\rho_{A_1\\mapsto A_1'}(\\rho_{A_2\\mapsto A_2'}(\\cdots (\\rho_{A_k\\mapsto A_k'}(R_2)\\cdots ))$$\n\n\nLa *jointure naturelle* sur deux relations $R_1$ et $R_2$ est la relation\n\n- d'attributs $A_1,..,A_k,B_1,...,B_h, B_{h+1},...,B_\\ell$\n- définie par :\n$$\\pi_{A_1,..,A_k,B_1,...,B_h, B_{h+1},...,B_\\ell}(R_1\\bowtie_{C} S)$$\noù $C$ est $(A_1=A_1') \\wedge (A_2=A'_2) \\wedge \\ldots \\wedge (A_k=A_k')$\n\n. . .\n\n::: {.aside}\n\n{{< fa  hand-point-right >}} on réalise une équi-jointure sur tous les attributs communs et on ne garde qu'un seul \"exemplaire\" de ces attributs communs par projection. On note cette opération : $R_1 \\bowtie R_2$.\n\n{{< fa  hand-point-right >}} Pour éviter le renommage, on peut décider de préfixer les noms des attributs par ceux de la relation. La condition $C$ devient :\n\n$$(R_1.A_1=R_2.A_1) \\wedge \\ldots \\wedge (R_1.A_k=R_2.A_k)$$\n\n:::\n\n\n\n## Exemple de Jointure naturelle  {.smaller}\n\n::::: {.columns}\n::: {.column}\n\n```{.sql}\nbd_2023-24> \\d countrylanguage\n+-------------+--------------+-----------+\n| Column      | Type         | Modifiers |\n|-------------+--------------+-----------|\n| countrycode | character(3) |  not null |\n| language    | text         |  not null |\n| isofficial  | boolean      |  not null |\n| percentage  | real         |  not null |\n+-------------+--------------+-----------+\n```\n\n\n```{.sql}\n\n+--------------------+---------------+-----------+\n| Column             | Type          | Modifiers |\n|--------------------+---------------+-----------|\n| countrycode        | character(3)  |  not null |\n| name_country       | text          |  not null |\n| continent          | text          |  not null |\n| region             | text          |  not null |\n| surfacearea        | real          |  not null |\n| indepyear          | smallint      |           |\n| population_country | integer       |  not null |\n| lifeexpectancy     | real          |           |\n| gnp                | numeric(10,2) |           |\n| gnpold             | numeric(10,2) |           |\n| localname          | text          |  not null |\n| governmentform     | text          |  not null |\n| headofstate        | text          |           |\n| capital            | integer       |           |\n| code2              | character(2)  |  not null |\n+--------------------+---------------+-----------+\n```\n\n\n:::\n\n::: {.column}\n\n### Jointure naturelle\n\n```{.sql}\ncountry |\n  ⋈(countrylanguage) |\n  σ(country='France') |\n  π(name_country, language)\n\n```\n\n```{.sql}\n+--------------+------------+\n| name_country | language   |\n|--------------+------------|\n| France       | French     |\n| France       | Arabic     |\n| France       | Portuguese |\n| France       | Italian    |\n| France       | Spanish    |\n| France       | Turkish    |\n+--------------+------------+\n```\n\n:::\n\n:::::\n\n---\n\nOn aurait pu décrire de façon plus explicite la jointure en précisant sur quels attributs s'effectue la jointure \n\n\n```{.sql}\ncountry |\n  ⋈(countrylanguage, countrycode) |\n  σ(country='France') |\n  π(name_country, language)\n\n```\n\n## Exemples de requêtes\n\n\n- déterminer les noms des capitales des pays situés en Asie (`Asia`)\n\n```{.sql}\ncountry |\n  σ(continent='Asia') |\n  ⋈(city, capital=id) |\n  π(name)\n```\n\n. . .\n\n- déterminer les langues parlées dans les pays d'Asie\n\n```{.sql}\ncountry |\n  σ(continent='Asia') |\n  ⋈(countrylanguage) |\n  π(language)\n```\n\n\n\n\n\n\n\n# Encore des opérations...  {background-color=\"#1c191c\"}\n\n\n\n\n## Jointure externe\n\n::: {.callout-note}\n\n### Perte d'information dans jointure naturelle\n\nLes tuples ne satisfaisant pas la condition (non appariés) disparaissent\n\n:::\n\n::: {.callout-important}\n\n### Définition\n\n<!-- TODO -->\n\nOn ajoute symboliquement\" une ligne dont les valeurs sont vides (ou avec valeur spéciale `NULL`) pour garder les tuples initiaux \"non satisfaisants\" après la jointure\n\nOn note cette opération entre deux relations $R$ et $S$  :\n\n$$R \\bowtie^+ S$$\n\n:::\n\n\n## Jointure externe (exemple)\n\n\n::::: {.columns}\n::: {.column}\n\n\n:::\n::: {.column}\n\n$$\\text{TrDep} \\bowtie^+ \\text{TrArr}$$\n\n\n\n:::\n:::::\n\n## Division\n\n::: {.callout-important}\n\n### Définition\n\nLa *division* ou *quotient*\n\n- d'une relation $R$ de schéma\n$R(A_1,A_2,\\dots,A_k)$\n\n- par une relation $S$ de schéma\n$S(A_{p+1},\\dots ,A_k)$\n\nest la relation $T$ de schéma $T(A_1, \\dots, A_p)$ formée des tuples qui complétés par chaque tuple\nde $S$ donnent un tuple de $R$.\n\nAutrement dit\n\n$$\\begin{array}{l} t\\in T(A_1,\\dots,A_p)  \\quad \\Longleftrightarrow \\\\\n\\forall s\\in S(A_{p+1},\\dots ,A_k) \\quad \\exists r\\in R \\quad \\begin{cases}\nt.A_1=r.A_1, \\dots, t.A_p=r.A_p\\\\ s.A_{p+1}=r.A_{p+1},\\dots, s.A_{k}=r.A_{k} \\end{cases} \\end{array}$$\n\n\nOn note \n$$T = R \\div S$$\n\n\n\n:::\n\n\n## Division (exemple)\n\n\n::: {.columns}\n::: {.column}\n\n{{< fa hand-point-right >}} Lister les langues parlées sur tous les continents \n\n\nOn aimerait écrire une expression qui renvoie un résultat correct quelque soit les conventions adoptées sur la définition de *continent* (les Amériques forment-elles un ou deux continents, etc)\n\n\n:::\n\n\n::: {.column}\n\n```{.sql}\nCL ← ⋈(country, countrylanguage) |\n  π(continent, language)\n\nC ← π(CL, continent)\nL ← π(CL, language)\n\nLPPTC ← (C × L  ∖  CL ) |\n  π(language)\n\nL  ∖  LPPTC\n```\n\nOn vient de calculer une division !\n\n```{.sql}\nCL ÷ C\n```\n\n\n\n:::\n\n:::\n\n\n\n## Interdéfinissabilité des opérateurs\n\n\n- L'union, la différence, le produit cartésien, la sélection et la projection et le renommage sont *suffisants* pour définir tous les opérateurs que l'on a vu.\n\n- Mais avoir un panier  plus large d'opérateurs simplifie l'écriture des requêtes.\n\n\nQuelques définitions\n\n- Pour la *Jointure* : $R \\bowtie_C S \\equiv \\sigma_C (R \\times S)$\n\n\n- Pour l'*intersection* : $A \\cap B = A \\cup B - ((B - A) \\cup (A - B))$\n\n\n\n## Définition de la division\n\n::: {.callout-important}\n\n### Formalisation\n\nSoient  $R$ de schéma\n$R(A_1,A_2,\\dots,A_k)$, $S$ de schéma\n$S(A_{p+1},\\dots ,A_k)$\n\nest la relation $T= R ÷ S$ de schéma $T(A_1, \\dots, A_p)$.\n\n\n```{.sql}\nT ← Π(R, A) ∖ Π((Π(R, A) × S ∖ R), A)\n```\n\n:::\n\n\n::: {.aside}\n\nDans la définition de `R ÷ S`, on utilise en deux endroits  `Π(R, A)`. \nIl serait utile, lors de l'évaluation de   `R ÷ S` de n'évaluer `Π(R, A)`\nqu'une seule fois.\n\n:::\n\n\n\n# Petite histoire    {background-color=\"#1c191c\"}\n\n\n---\n\nL'algèbre relationnelle est la définition d'un modèle de calculabilité restreint. \n\nComme les modèles de calcul classiques  (les langages de programmation comme `Python`), elle est formée de briques de base (les opérateurs) et de mécanismes d'assemblage (la composition de fonction). \n\nLe modèle de calcul relationnel est bien plus simple qu celui d'un langage de programmation (pas de boucles `while`, `for`). Il est aussi moins expressif. \nOn peut montrer qu'il existe de questions qui sont solubles avec un langage de programmation mais qui ne le sont pas avec l'algèbre relationnelle.\n\nL'histoire de l'algèbre relationnelle éclaire le développement des bases de données.\n\n\n\n##  Depuis  Wikipedia {.smaller}\n\n> In the 1960s and 1970s he [Codd] worked out his theories of data arrangement, issuing his paper \"A Relational Model of Data for Large Shared Data Banks\" in 1970.[ To his disappointment, IBM proved slow to exploit his suggestions until commercial rivals started implementing them.\n\n> Initially, IBM refused to implement the relational model to preserve revenue from IMS/DB. Codd then showed IBM customers the potential of the implementation of its model, and they in turn pressured IBM. Then IBM included in its Future Systems project a System R subproject – but put in charge of it developers who were not thoroughly familiar with Codd's ideas, and isolated the team from Codd. As a result, they did not use Codd's own Alpha language but created a non-relational one, SEQUEL. Even so, SEQUEL was so superior to pre-relational systems that it was copied, in 1979, based on pre-launch papers presented at conferences, by Larry Ellison, of Relational Software Inc, in his Oracle Database, which actually reached market before SQL/DS – because of the then-already proprietary status of the original name, SEQUEL had been renamed SQL.\n\n> Codd continued to develop and extend his relational model, sometimes in collaboration with Christopher J. Date. One of the normalised forms, the Boyce–Codd normal form, is named after him.\n\n> Codd's theorem, a result proven in his seminal work on the relational model, equates the expressive power of relational algebra and relational calculus.\n\n\n\n\n# Fin  {background-color=\"#1c191c\"}\n\n",
    "supporting": [
      "SQL_0_files/figure-revealjs"
    ],
    "filters": [],
    "includes": {}
  }
}