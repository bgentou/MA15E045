{
  "hash": "6e88b04ab39d678c2333ddb601b3db39",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"BD I: Algèbre Relationnelle\"\nsubtitle: \"Cadre formel pour la manipulation de tables\"\ndate: \"2025-09-12\"\n\nformat: \n  revealjs:\n    header: \"Algèbre Relationnelle\"\n  \nengine: knitr\n---\n\n# Le modèle relationnel {background-color=\"#1c191c\"}\n\n\n---\n\n\n- Formulé par [E. Codd](https://en.wikipedia.org/wiki/Edgar_F._Codd) en 1970.\n\n- Fondé sur la théorie des *relations* (partie de la théorie naïve des ensembles).\n\n- Propose une solution pour\n \n  + la modélisation,\n  + l'interrogation de données;\n\n- Facile à traduire/mettre en œuvre dans des langages *réels* comme `Structured Query Language (SQL)` ou dans des environnements de calcul orientés données comme `R/dplyr`.\n\n\n\n## Un peu de formalisation\n\nRappel sur la notion de relation (au sens classique).\n\n\n::: {.callout-important}\n\n### Definition : Domaine \n\nUn ensemble d'éléments.\n\n:::\n\n. . .\n\n\nExemples :  entiers $\\mathbb{Z}$, flottants, chaines de caractères $\\mathcal{A}^*$, date, ...\n\nLes *types* d'un langage de programmation comme `C`, `Java`, ...\n\n\n\n\n## Remarque   {.incremental}\n\nUn *domaine* peut se définir :\n\n  - en *extension* (en donnant la liste de toutes les valeurs possibles) ou\n\n  -  en *intention* (en donnant une propriété caractéristique).\n\n\n\n## Produit cartésien\n\n::: {.callout-important}\n\n### Définition : Produit cartésien d'ensembles/domaines \n\nLe *Produit cartésien*  d'une liste de domaines $D_1, D_2, \\dots, D_k$, noté \n\n$$D_1 \\times D_2 \\times \\dots \\times D_k$$\n\nest l'ensemble\n\n$$\\Bigl\\{(t_1,t_2,\\dots,t_k);\\ t_i\\in D_i \\text{ pour } i=1,\\dots,k\\Bigr\\}$$\n\n\nUn élément $t=(t_1,t_2,\\dots,t_k)\\in D_1 \\times D_2 \\times \\dots \\times  D_k$ est appelé  $k$-uplet.\n\n:::\n\n\n---\n\n\n::: {.callout-note}\n\n### Définition classique d'une relation\n\nUne *Relation* $R$ est un sous-ensemble de \n\n$$D_1\\times D_2\\times \\cdots \\times D_k$$\n\noù $D_1,...,D_k$ sont des domaines.\n\nOn a donc : \n\n$$R \\subseteq D_1  \\times D_2\\times \\cdots \\times D_k$$\n\n:::\n\n\n## Exemple  {.smaller}\n\n\n::::: {.columns}\n\n::: {.column width=\"65%\"}\n\nDeux domaines \n\n$$D_1=\\left\\{1,2,5\\right\\} \\quad\\text{et}\\quad D_2=\\left\\{2,4\\right\\}$$\n\nUn produit cartésien \n\n$$D_1 \\times D_2 = \\left\\{(1,2),(1,4),(2,2),(2,4),(5,2),(5,4)\\right\\}$$\n\nUne relation \n\n$$R =\\left\\{(1,2),(1,4),(5,2),(5,4)\\right\\}$$\n\nUne relation est un (sous-) ensemble (d'un produit cartésien)\n\n:::\n\n::: {.column   width=\"30%\"}\n\nOn peut  représenter $R$  par le tableau :\n\n::: {.center}\n\n| $X_1$  | $X_2$ |\n|:------:|:-----:|\n|  1    |  2 |\n|  1    |  4 |\n|  5    |  2 |\n|  5    |  4 |\n\n:::\n\nChaque ligne de la table correspond à  un élément de la relation $R$ \n\n:::\n\n::::: \n\n\n\n\n\n## Relations (classiques)\n\nDans ce cours, toutes les relations ont  un nombre fini d'éléments !\n\n\n::: {.callout-important}\n\n### Définition : *Cardinalité* de la relation $R$: $|R|$\n\nOn appelle *cardinalité* d'une relation $R$, notée $|R|$, le nombre d'éléments  de $R$.\n\n:::\n\n. . .\n\n::: {.callout-important}\n\n### Définition : *Arité* de la relation $R$\n\nSoit $R\\subset D_1\\times D_2\\times \\cdots \\times D_k$, l'entier $k$ est appelé *arité* de $R$.\n\n:::\n\n. . .\n\nOn parle parfois aussi de *degré* d'une relation.\n\n. . .\n\nUne *relation binaire* est une relation d'arité $2$\n\n\n\n\n# Schémas et relations  {background-color=\"#1c191c\"}\n\n\n\n## Relations et schémas\n\n\n- Une *relation* (classique) peut se voir comme une *table* à deux dimensions :\n  - chaque ligne correspond alors à un $k$-uplet (si la relation est d'arité $k$),\n  - chaque élément d'une colonne est à valeur dans  un domaine.\n  - Un *domaine* peut apparaître plusieurs fois dans la définition d'une relation.\n\n---\n\nEn BD relationnelle, on  donne un nom à chaque colonne \n\n- *Attribut*:  nom de la colonne. \n\nCe nom est choisi de manière à être sémantiquement signifiant.\n \n{{< fa  triangle-exclamation >}}  En BD on ne peut pas avoir deux attributs de même nom dans une même table.\n\n. . .\n\n::: {.callout-note}\n\nL'idée de nommer les colonnes plutôt que de les désigner par une position/un numéro se retrouve dans les sytèmes qui manipulent des données tabulaires (`Pandas/Python`, `R`, `Spark`, ...). \n\n:::\n\n\n## Schéma d'une relation \n\n\n::: {.callout-important}\n\n### Définition : schéma \n\nLe *Schéma* d'une relation $R$ est la donnée  des  attributs et domaines de la relation.\n\n:::\n\nLe schéma peut se noter\n\n$$R(A_1\\! :\\! D_1,A_2\\! :\\! D_2,\\dots,A_k\\! :\\! D_k)$$\n\noù $A_i$ : attribut et $D_i$ : domaine.\n\n\n\n## Exemple de schéma : table `bebes`  dans `babynames` {.smaller}\n\n::::: {.columns}\n\n::: {.column}\n\n<!--```{.sql}\nbd_2023-24> \\dt\n+-----------+-------+-------+-----------+\n| Schema    | Name  | Type  | Owner     |\n|-----------+-------+-------+-----------|\n| babynames | bebes | table | boucheron |\n+-----------+-------+-------+-----------+\n```\n-->\n\n```{.sql}\nbd_2023-24> \\d bebes\n+--------+------------------------+-----------+\n| Column | Type                   | Modifiers |\n|--------+------------------------+-----------|\n| sexe   | integer                |           |\n| prenom | character varying(500) |           |\n| annee  | integer                |           |\n| nombre | integer                |           |\n+--------+------------------------+-----------+\n```\n\nLa relation `bebes` a donc pour schéma :\n$\\left((\\textsf{sexe}, \\mathbb{Z}), (\\textsf{prenom}, \\texttt{string}), (\\texttt{annee}, \\mathbb{Z}), (\\texttt{nombre}, \\mathbb{Z})\\right)$\n\n:::\n\n::: {.column}\n\nDonnées INSEE. Une ligne de la table `bebes` nous informe qu'en France (héxagone?), pendant une `annee`, le nombre de naissances de sexe `sexe`, ayant reçu le prénom `prenom` est donnée par la colonne `nombre`.  \n\n\n```{.sql}\nbd_2023-24> SELECT * \nFROM bebes \nWHERE sexe=1 AND annee=2000 AND prenom='THÉO' ;\n\n+------+--------+-------+--------+\n| sexe | prenom | annee | nombre |\n|------+--------+-------+--------|\n| 1    | THÉO   | 2000  | 7961   |\n+------+--------+-------+--------+\n```\n\nL'arité de `bebes` est $4$, sa cardinalité est $648 614$. \n\n\n:::\n\n::::: \n\n\n\n\n## Particularité de la définition orientée BDD d'une relation    <!--{background-color=\"#1c191c\"}-->\n\n\nEn BD, l'ordre des colonnes n'a pas d'importance car on désigne chaque composante d'un $k$-uplet par son nom d'attribut et non par sa position/rang.\n\n<!--\n- Soient $\\{A_1,...,A_k\\}$ un ensemble fini et $D_1,...,D_k$ une suite de domaines.\n\n\n::: {.callout-important}\n\n### Notation\n\nUne relation $R$ de schéma $R(A_1\\! :\\! D_1,A_2\\! :\\! D_2,\\dots,A_k\\! :\\! D_k)$ est la donnée d'un ensemble d'éléments, noté $\\mathcal{R}$ et de $k$  fonctions $\\mathcal{A}_1: \\mathcal{R}\\rightarrow D_1$, ..., $\\mathcal{A}_k: \\mathcal{R}\\rightarrow D_k$.\n\nPour tout $t\\in \\mathcal{R}$ et $i\\leq k$, on note $t.A_i=\\mathcal{A}_i(t)$ l'image par $\\mathcal{A}_i$ de $t$.\n\nUn élément $t$ de $\\mathcal{R}$ est appelé *tuple* de la relation $R$\n\n:::\n\n\n---\n\n### Conventions (suite)\n\n- Pour désigner l'ensemble des valeurs $t.A_1,...., t.A_k$ associées à un tuple $t\\in \\mathcal{R}$,\non fixe un ordre arbitraire sur les attributs et on note $t=(t.A_1,...., t.A_k)$,\n\n- A un tuple $t$ de $\\mathcal{R}$ correspondent les $k$ valeurs $t.A_1, \\dots, t.A_k$,\n\n- Par simplicité, on note $R$ le domaine et la relation.\n-->\n\n<!--\n## Exemple de relations\n-->\n\n<!--\n::: {.columns}\n\n::: {.column}\n\n```{.sql}\nbd_2023-24> SELECT * \nFROM bebes \nWHERE sexe=1 AND \n  annee> 1960 AND \n  prenom = 'THEODULE' ;\n```\n\n```{.sql}\n+------+----------+-------+--------+\n| sexe | prenom   | annee | nombre |\n|------+----------+-------+--------|\n| 1    | THEODULE | 1961  | 4      |\n| 1    | THEODULE | 1962  | 4      |\n| 1    | THEODULE | 1965  | 4      |\n| 1    | THEODULE | 1969  | 4      |\n+------+----------+-------+--------+\n\n```\n:::\n\n::: {.column}\n\nCes quatre tuples de `bebes` : $t_1, t_2, t_3, t_4$. \n\n\\begin{align*}\nt_1.\\text{sexe} & =  1 \\\\\nt_1.\\text{prenom} & = \\texttt{THEODULE} \\\\\nt_1.\\text{annee} & = 1961 \\\\\nt_1.\\text{nombre} & = 4\n\\end{align*}\n\n:::\n\n::: \n-->\n\n\n\n## Résumé informel\n\n- RELATION ↔  TABLE À DEUX DIMENSIONS\n\n- (NOM DE) COLONNE ↔  ATTRIBUT\n\n- EN-TÊTE DU TABLEAU ↔ SCHEMA DE LA RELATION\n\n- LIGNE ↔ TUPLE\n\n- ENSEMBLE DES LIGNES ↔ CONTENU DE LA RELATION\n\n\n\n# LMD : Opérateurs  {background-color=\"#1c191c\"}\n\n\n## Langage de manipulation de données\n\nL'algèbre relationnelle est un système de calcul sur des tables.\n\nElle est formée d'une collection d'*opérateurs* qui prennent en argument des tables et retournent des tables.\n\n::: {.callout-note}\n\n### Remarque :\n\nLes opérateurs prennent en général des arguments supplémentaires qui ne sont pas des tables. La notion d'algèbre relationnelle est inspirée par les structures algébriques comme les groupes, les anneaux, les corps où des opérations internes opèrent sur un ensemble (par exemple $(\\mathbb{R}, +, \\times)$), mais elle ne rentre pas exactement dans le cadre.\n\n:::\n\n### {.smaller}\n\nL'algèbre n'est pas aussi expressive qu'un langage de programmation classique (comme `Python`). C'est cela qui rend ce modèle de calcul intéressant : il permet de faire des choses pas triviales, mais il est plus facile à utiliser qu'un langage de programmation.  \n\n\n\n\n## Opérateurs de base\n\n\n::: {.callout-important}\n\n\n### Liste des opérateurs\n\nL'algèbre relationnelle est d'abord un *Langage de Manipulation de Données* (LMD).\n\n- Union: $\\Large{\\cup}$  \n\n- Intersection: $\\Large{\\cap}$ \n\n- Différence: $\\Large{\\backslash}$ \n\n- Projection:  $\\Large{\\Pi}$  \n\n- Sélection: $\\Large{\\sigma}$ \n\n- Produit cartésien:  $\\Large{\\times}$ \n\n- Renommage:  $\\Large{\\rho}$ \n\nCes opérateurs s'appliquent à des relations pour produire d'autres relations (le résultat). \n\n:::\n\n\n## Union $\\cup$ et intersection  $\\cap$\n\n::: {.callout-important}\n\n### Définition\n\n- L'*union* et l'*intersection* sont des  opérations portant sur deux relations $R_1$ et $R_2$ de **même  schéma**,\n\n- $T=R_1\\cup R_2$  est  constituée des tuples appartenant à $R_1$ *ou* à\n$R_2$,\n\n- $T=R_1\\cap R_2$  est  constituée des tuples appartenant à $R_1$ *et* à\n$R_2$.\n\n- Les schémas de  $R_1\\cup R_2$, $R_1\\cap R_2$ sont les mêmes que ceux de $R_1$  et  $R_2$.\n\n:::\n\n\n## Union : exemple  {.smaller}\n\n<!-- \n\n\n::: {.cell}\n\n```{.sql .cell-code}\n-- | echo: false\n\nSET search_path TO babynames ;\n\nSELECT * \nFROM bebes AS b\nWHERE b.sexe=1 AND\n  b.prenom ILIKE 'TH_O%' AND\n  b.annee = 2000 ;\n\n\nSELECT * \nFROM bebes AS b\nWHERE b.sexe=1 AND\n  b.prenom ILIKE 'TH_O%' AND\n  b.annee = 1900 ;\n```\n:::\n\n -->\n\n::::: {.columns}\n\n::: {.column}\n\n```{.sql}\n-- THEO_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n| 1    | THEOPHANE | 1900  | 3      |\n+------+-----------+-------+--------+\n\n-- THEO_2000\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEO      | 2000  | 6      |\n| 1    | THAO      | 2000  | 4      |\n| 1    | THÉO      | 2000  | 7961   |\n| 1    | THÉO-PAUL | 2000  | 3      |\n| 1    | THEODOR   | 2000  | 3      |\n| 1    | THEOPHANE | 2000  | 47     |\n| 1    | THEODORE  | 2000  | 149    |\n| 1    | THEOPHILE | 2000  | 336    |\n| 1    | THEOPHYLE | 2000  | 4      |\n| 1    | THEOS     | 2000  | 3      |\n| 1    | THEOTIM   | 2000  | 4       |\n| 1    | THEOTIME  | 2000  | 73     |\n+------+-----------+-------+--------+\n\n```\n\n:::\n\n::: {.column}\n\n`THEO_1900` ∪ `THEO_2000`\n\n```{.sql}\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEODOR   | 2000  | 3      |\n| 1    | THAO      | 2000  | 4      |\n| 1    | THÉO      | 2000  | 7961   |\n| 1    | THÉO-PAUL | 2000  | 3      |\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEO      | 2000  | 6      |\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n| 1    | THEODORE  | 2000  | 149    |\n| 1    | THEOPHANE | 1900  | 3      |\n| 1    | THEOPHANE | 2000  | 47     |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEOTIME  | 2000  | 73     |\n| 1    | THEOPHILE | 2000  | 336    |\n| 1    | THEOPHYLE | 2000  | 4      |\n| 1    | THEOS     | 2000  | 3      |\n| 1    | THEOTIM   | 2000  | 4      |\n+------+-----------+-------+--------+\n```\n\n:::\n\n:::::\n\n\n---\n\n## Intersection : exemple    {.smaller}\n\n::: {.columns}\n\n::: {.column}\n\n```{.sql}\n-- THEO_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n| 1    | THEOPHANE | 1900  | 3      |\n+------+-----------+-------+--------+\n\n-- THEOD_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n+------+-----------+-------+--------+\n\n```\n:::\n\n::: {.column}\n\n`THEO_1900` ∩ `THEOD_1900`\n```{.sql}\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n+------+-----------+-------+--------+\n```\ncar `THEOD_1900` ⊂ `THEO_1900`\n\n:::\n\n:::\n\n\n## Différence\n\n\n::: {.callout-important}\n\n### Définition\n\n- La **différence** de deux relations $R_1$ et $R_2$ (de même schéma) est une relation $T$,\n\n- de même schéma que $R_1$ et $R_2$,\n\n- constituée des tuples appartenant à $R_1$ et n'appartenant pas à $R_2$.\n\n\n- On note $T = R_1 - R_2$ ou $T = R_1 \\setminus R_2$.\n\n:::\n\n. . .\n\n::: {.callout-caution}\n\n### Opération non *commutative* !\n\n$R_1 - R_2\\neq  R_2 - R_1$ (en général).\n\n\n:::\n\n\n\n## Différence : exemple   {.smaller}\n\n\n::::: {.columns}\n\n::: {.column}\n\n```{.sql}\n-- THEO_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n| 1    | THEOPHANE | 1900  | 3      |\n+------+-----------+-------+--------+\n\n-- THEOD_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n+------+-----------+-------+--------+\n```\n\n:::\n\n::: {.column}\n\n`THEO_1900` ∖ `THEOD_1900`\n\n```{.sql}\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEOPHANE | 1900  | 3      |\n+------+-----------+-------+--------+\n```\n:::\n\n:::::\n\n\n\n\n## Produit Cartésien\n\n\n\n::: {.callout-important}\n\n### Définition\n\nSoient $R_1$ et $R_2$ dont les schémas $R_1(A_1,A_2,...,A_k)$ et $R_2(B_1,B_2,...,B_\\ell)$ n'ont pas d'attributs communs.\n\n-  Dans le contexte \"classique\" : $R_1 \\times R_2= \\{(e_1,e_2): e_1\\in R_1, e_2\\in R_2\\}$.\n\n- Dans le contexte BDD, $R_1 \\times R_2$ contient tous les tuples formés par concaténation d'un tuple de $R_1$ et d'un tuple de $R_2$.\n\n- Le schéma de $R=R_1 \\times R_2$  est $R(A_1,A_2,...,A_k,B_1,B_2,...,B_\\ell)$ obtenu par concaténation des schémas de $R_1$ et $R_2$.\n\n### {.smaller}\n\nLa condition sur les schémas est indispensable pour que le schéma du résultat n'ait pas deux attributs identiques. On peut contourner ce problème avec un renommage (voir plus loin).\n\n\n:::\n\n. . . \n\n::: {.callout-caution}\n\n### Attention \n\nEn algèbre relationnelle, on ne tient pas compte de l'ordre des attributs dans le schéma d'une relation puisque que les attributs ont des noms deux à deux distincts.\nDe ce fait, le produit cartésien est commutatif  ( $R_1\\times R_2 = R_2\\times R_1$ ce qui n'est pas vrai classiquement) et associatif.\n \n:::\n\n\n\n## Produit cartésien\n\n::: {.callout-important}\n\n###  Définition formelle\n\n$R=R_1\\times R_2$ est la relation de schéma $R(A_1,A_2,...,A_k,B_1,B_2,...,B_\\ell)$ vérifiant :\n\n\n- Pour tout $t\\in R$, il existe $t_1\\in R_1$, $t_2\\in R_2$  tels que :\n\n$$t.A_1=t_1.A_1, \\ldots, t.A_k=t_1.A_k,\\quad t.B_1=t_2.B_1, \\ldots, t.B_\\ell=t_2.B_\\ell$$\n\n- Réciproquement, pour tout $t_1\\in R_1$, $t_2\\in R_2$ , il existe $t\\in R$ tels que :\n\n$$t.A_1=t_1.A_1, \\ldots, t.A_k=t_1.A_k,\\quad \\text{et}\\quad t.B_1=t_2.B_1, \\ldots, t.B_\\ell=t_2.B_\\ell\\quad \\text{et}$$\n\n$$$\\forall t_1 \\in R_1, \\forall t_2 \\in R_2, \\exists t \\in R, \\qquad  t.A_1=t_1.A_1, \\ldots, t.A_k=t_1.A_k,\\quad \\text{et} \\quad t.B_1=t_2.B_1, \\ldots, t.B_\\ell=t_2.B_\\ell \\qquad\\qquad\\qquad$$\n\n:::\n\n\n\n<!-- ## Produit cartésien : exemple -->\n<!-- A faire-->\n\n\n\n\n\n## Projection  ( $\\Large{\\pi}$ )\n\n\n::: {.callout-important}\n\n### Définition\n\n- La *projection* d'une relation $R$ de schéma $R(A_1,\\dots, A_k)$\n sur les attributs $A_{i_1}, \\dots, A_{i_p}$, avec $i_1,..., i_p\\in \\{1,...,k\\}$,  est la relation $S$\n  - de schéma $S(A_{i_1}, \\dots,A_{i_p})$\n  - dont les tuples sont obtenus par élimination des attributs\nnon mentionnés dans $A_{i_1}, \\dots, A_{i_p}$ (et par élimination\ndes doublons).\n  - On note $S = \\pi_{A_{i_1}, \\dots, A_{i_p}} (R)$.\n\n- Définition formelle : $s\\in S\\quad  \\iff \\quad \\exists t\\in R, \\forall k\\in\\left\\{1,\\dots,p\\right\\}\\qquad s.A_{i_k}=t.A_{i_k}$\n\n:::\n\n. . .\n\n::: {.callout-note}\n\n### Remarque \n\nImplicitement, on a *élimination des doublons* car une projection peut produire plusieurs fois le même tuple. Or une relation est un ensemble de tuples, et un ensemble ne peut pas contenir plusieurs fois le même élément.\n\n:::\n\n---\n\n::: {.callout-caution}\n\n### Remarque\n\nÀ la différence des opérations ensemblistes ∩, ∪, ∖, ×, la projection ne fait pas intervenir que des tables. \n\nOn peut considérer la projection comme une fonction à deux arguments, avec un premier argument de type table, et un \nsecond argument constitué par une liste d'attributs. \n\nOn peut aussi considérer la projection comme une fonction avec un nombre *variable*  d'arguments. Un premier argument de type  table, puis des arguments qui désignent des attributs de la table. Si on accepte ce point de vue, on peut adopter la notation :\n\n$$S = \\pi(R, {A_{i_1}, \\dots, A_{i_p}})\\quad\n \\text{ ou bien } \\quad S = \\textrm{PROJECTION}(R, {A_{i_1}, \\dots, A_{i_p}})$$\nau lieu de $\\quad S = \\pi_{A_{i_1}, \\dots, A_{i_p}} (R)$\n\nDans la suite, nous utiliserons ces notations. \n \n:::\n\n\n## Projection : Exemple\n\n\nPROJECTION(`THEOD_1900`, `prenom`, `nombre`)\n\n```{.sql}\n+-----------+---------+\n| prenom    |  nombre |\n|-----------+---------+\n| THEODORE  |  227    |\n| THEODOSE  |  3      |\n| THEODULE  |  39     |\n+-----------+---------+\n```\n\nIci, aucune éliminitation de doublons n'a été nécessaire\n\n\n## Sélection  ( $\\Large{\\sigma}$ ) \n\n\n::: {.callout-important}\n\n### Définition\n\n- La *sélection* d'une relation $R$ par une condition $C$ est une relation $S$ :\n\n  - de même schéma que $R$, \n\n  - dont les tuples sont ceux de $R$ qui satisfont la condition $C$.\n\n  - On note $S = \\sigma_C (R)$.\n\n\n- La condition $C$ :\n\n  - s'exprime à l'aide des noms d'attributs de la relation et de constantes (pour les opérandes),\n\n  - on peut utiliser des opérateurs arithmétiques de comparaison ( $=, \\neq, \\leq, \\geq, <, >$ ) ainsi que des connecteurs logiques ( $\\lnot, \\land, \\lor$ ).\n\n:::\n\n. . .\n\n::: {.callout-caution}\n\nOn peut utiliser le terme *Restriction* à la place de *Sélection*.\n\n:::\n\n---\n\n\n::: {.callout-caution}\n\n### Remarque \n\nÀ la différence des opérations ensemblistes ∩, ∪, ∖, ×, , la sélection comme la projection ne font pas intervenir que des tables. \n\nOn peut considérer la sélection comme une fonction à deux arguments, avec un premier argument de type table, et un \nsecond argument constitué par une condition (une expression dont l'évaluation sur chaque ligne de la table retourne `Vrai`, `Faux`, ou `Indéterminé`). \n\n<!--On peut aussi considérer la sélection comme une fonction avec un nombre *variable*  d'arguments. Un premier argument de type  table, puis des arguments qui représentent des expressions susceptibles d'être évaluées sur chaque ligne de la table.\nUne ligne fera partie de la table résultat, si elle satisfait toutes les expressions.-->\n\nOn note \n$$S = \\sigma(R, C) \\quad\n \\text{ ou bien } \\quad S= \\textrm{SELECTION}(R, C)$$\nau lieu de $\\quad S = \\sigma_{C} (R)$\n\nDans la suite, nous utiliserons ces notations. \n\n:::\n\n. . .\n\n::: {.callout-note}\n\nNotons que dans un langage comme `Python`, nous ne disposons pas d'emblée d'un type *expression* et que \nla notation proposée ici ne se code pas trivialement en `Python`.\n\nEn langage `R`, on dispose d'un type *expression*, la notation proposée ici est mise en œuvre dans le package `dplyr`.\n\n:::\n\n\n\n## Sélection : Exemple\n\n\nSELECTION(`THEO_1900`, ¬ `prenom` `LIKE` 'THEOD%')\n\n\n```{.sql}\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEOBALD  | 1900  | 6      |\n| 1    | THEOPHILE | 1900  | 309    |\n| 1    | THEOPHANE | 1900  | 3      |\n+------+-----------+-------+--------+\n```\n\n\n## Renommage\n\n::: {.callout-important}\n\n### Définition\n\n- Soit  $R$ de schéma $R(A_1,\\dots, A_k)$, le *renommage* d'un attribut $A_i$, $i\\leq k$, en $B$ est une relation $S$ :\n  - de même contenu  (mêmes lignes)\n  - de schéma $S(A_1,...,A_{i-1},B,A_{i+1},..., A_k)$\n  - On le note $S=\\rho_{A_i\\mapsto B}(R)$\n\n:::\n\n\n---\n\n::: {.callout-caution}\n\n### Remarque \n\nComme la projection et la sélection, le renommage  ne fait pas intervenir que des tables. \n\n\nOn peut  considérer le renommage comme une fonction avec un nombre *variable*  d'arguments. Un premier argument de type  table, puis des arguments qui représentent des expressions indiquant comment doivent être renommées certains attributs.\n\nOn note \n$$S = \\rho(R, A_{i_1}\\mapsto B_1,\\ldots, A_{i_p}\\mapsto B_p)\\quad\n \\text{ ou bien } \\quad S = RENOMMAGE(R, A_{i_1}\\mapsto B_1,\\ldots, A_{i_p}\\mapsto B_p)$$\n\nau lieu de $\\quad S=\\rho_{A_{i_1}\\mapsto B_1,\\ldots, A_{i_p}\\mapsto B_p}(R)$\n\nDans la suite, nous utiliserons ces notations. \n\n:::\n\n. . .\n\n\n\n## Renommage : Exemple   {.smaller}\n\n```{.sql}\n-- THEOD_1900\n\n+------+-----------+-------+--------+\n| sexe | prenom    | annee | nombre |\n|------+-----------+-------+--------|\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n+------+-----------+-------+--------+\n```\n\nρ(`THEOD_1900`, `sexe→sex`, `prenom→name`, `annee→year`, `nombre→count`)\n\t\n```{.sql}\n-- THEOD_1900\n\n+------+-----------+-------+--------+\n| sex  | name      | year  | count  |\n|------+-----------+-------+--------|\n| 1    | THEODORE  | 1900  | 227    |\n| 1    | THEODOSE  | 1900  | 3      |\n| 1    | THEODULE  | 1900  | 39     |\n+------+-----------+-------+--------+\n```\n\n\n\n*Utilité* : le renommage permet d'étendre certains opérateurs à des relations de schémas non-disjoints (c.a.d. ayant des noms d'attributs communs), par exemple le produit cartésien.\n\n\n\n# Résumé   {background-color=\"#1c191c\"}\n\n\n## Algèbre relationnelle \n\nPour interroger une BD, on *compose* les opérateurs :\n\n- Opérations ensemblistes classiques : $\\cup$, $\\cap$, $\\setminus$, $\\times$.\n\n- Projection : élimine des colonnes,\n\n- Sélection : élimine des lignes.\n\n\n\n\n## Exemple\n\nπ(σ(`THEO_1900`, `prenom` `LIKE` 'THEOD%'), `prenom`, `nombre`)\n\n. . .\n\nρ(π(σ(`THEO_1900`, `prenom` `LIKE` 'THEOD%'), `prenom`, `nombre`), `prenom→name`, `nombre→count`)\n\n\n## De la composition aux tuyaux (pipelines)\n\n\nOn peut  rendre la composition de fonctions plus lisible (pour l'humain) en reprenant un mécanisme d'`Unix` : le *pipe* (tuyau) `|>` (notation de {{< fa brands r-project >}})\n\nPlutôt qu'écrire $g(f(x,y), z, t)$, on convient d'écrire  `f(x,y) |> g(z, t)` voire `x |> f(y) |> g(z,t)`\n\nEt pour rendre l'expression encore plus lisible on peut écrire \n\n```{.sql}\nx |> \n  f(y) |> \n  g(z,t)\n```\n\n## De la composition aux tuyaux (suite)\n\nOn peut ainsi réécrire \n\nρ(π(σ(`THEO_1900`, `prenom` `LIKE` 'THEOD%'), `prenom`, `nombre`), `prenom→name`, `nombre→count`)\n\nen \n\n```{.sql}\nTHEO_1900  |>\n  σ(prenom LIKE 'THEOD%') |>\n  π(prenom, nombre) |>\n  ρ(prenom→name, nombre→count)\n```\n\n::: {.aside}\n\nDans le langage {{< fa brands r-project >}} (> 4.x), le pipe s'écrit `|>`\n\n:::\n\n\n# Opérations complémentaires : les jointures  {background-color=\"#1c191c\"}\n\n\n## Les jointures\n\nOn va définir des opérations pratiques pour la manipulation de données : les *jointures*\n\n- Jointure\n\n- Jointure *naturelle*\n\n- $\\theta$-jointure et équi-jointure\n\n\n\n## Jointure\n\n\n::: {.callout-important}\n\n### Définition\n\nConsidérons deux relations $R_1$ et $R_2$ de schémas disjoints.\n\nLa jointure de $R_1$ et $R_2$  sous la condition $C$ est la relation $T$ :\n\n- de schéma la *concaténation* des schémas de $R_1$ et $R_2$,\n\n- formée des tuples du produit cartésien $R_1  \\times R_2$ qui satisfont la condition $C$,\n\n- on note $T=R_1\\bowtie_C R_2$.\n\nRègles de formation de la *condition de jointure* : comme pour la sélection.\n\n\n:::\n\n. . .\n\n::: {.callout-important}\n\n### Définition formelle\n\n$$R_1 \\bowtie_C R_2 = \\sigma_C(R_1\\times R_2)$$\n\n:::\n\n\n---\n\n::: {.callout-note}\n\n### Remarque \n\nComme la projection, la sélection et le renommage, la jointure  ne fait pas intervenir que des tables. \n\nOn peut  considérer la jointure comme une fonction avec un nombre *variable*  d'arguments. Deux  premiers arguments de type  table, puis une expression dont l'évaluation permet de déterminer quels couples de lignes doivent figurer dans la table résultat\n\nOn note \n$$T =\\ \\bowtie(R, S, C)\\quad \\text{ou} \\quad S= \\textrm{JOINTURE}(R, S, C)$$\nau lieu de $\\quad T=R  \\bowtie_C C$\n\n\nDans la suite, nous utiliserons ces notations. \n\n:::\n\n. . .\n\n::: {.callout-note}\n\nComme dit précédemment, dans un langage comme `Python`, nous ne disposons pas d'emblée d'un type *expression* et la notation proposée ici ne se code pas trivialement en `Python`.\n\nEn langage `R`, on dispose d'un type *expression*, la notation proposée ici est mise en œuvre dans le package `dplyr` avec la fonction `inner_join()`.\n\n:::\n\n\n\n\n## Exemple  sur le schéma `world`\n\n::::: {.columns}\n\n::: {.column width=\"35%\"}\n\n![](/images/layout_world.png)\n\n:::\n\n::: {.column width=\"65%\"}\n\nLier les pays (les lignes de `country`) à leur capitale, c'est à dire les couples de lignes de `country`  et de `city`\nqui satisfont  `capital = id` \n\n:::\n\n:::::\n\n## Exemple  sur le schéma `world` (suite)\n\n```{.sql}\nT =  JOINTURE(country, city, country.capital = city.id)\nS =  PROJECTION(T, name_country, name)\n\n```\n\n```{.sql}\n\n+----------------------+------------------+\n| name_country         | name             |\n|----------------------+------------------|\n| Afghanistan          | Kabul            |\n| Netherlands          | Amsterdam        |\n| Netherlands Antilles | Willemstad       |\n| Albania              | Tirana           |\n| Algeria              | Alger            |\n...\n+----------------------+------------------+\n\n```\n\n::: {.aside}\n\nOn a affiché seulement les cinq premières lignes du résultat.\n\n:::\n\n## Différentes variétés de jointures\n\nAutour de la jointure `⋈(R, S, C)` on a pris l'habitude de distinguer des types de jointure selon la forme de l'expression de jointure (la condition `C`) \n\nOn distingue \n\n- les équi-jointures, \n- les θ-jointures,\n- les jointures naturelles.\n\n::: {.callout-note}\n\nCes distinctions portent sur la condition `C`. Elles ne sont pas de même nature que les distinctions qui portent sur la manière dont le résultat final est calculé et qui définissent les jointures *internes*, *externes* (voir plus loin). \n\n:::\n\n\n## Équi-jointure \n\n\n::: {.callout-important}\n\n### Définition  \n\nJointure où la condition est une égalité entre des attributs de types comparables\n\n:::\n\n. . .\n\n```{.sql}\nJOINTURE(country, city, country.capital = city.id)\n```\n\n\n## $\\theta$--jointure\n\n::: {.callout-important}\n\n### Définition\n\nCondition de jointure entre attributs de types comparables et comportant au moins un opérateur différent de l'égalité, c'est-à-dire dans $\\left\\{<,>,\\leq,\\geq, \\neq\\right\\}$.\n\n\n:::\n \n\n. . .\n\n\n```{.sql}\nJOINTURE(country, city, country.capital = city.id  ∧ city.population > .5 * country.population_country)\n```\n\n\n\n\n## Jointure naturelle\n\n::: {.callout-important}\n\n### Définition\n\nC'est une équi-jointure où la condition portent implicitement sur tous les attributs communs (de même nom) aux schémas des deux relations.   \n\nDans le résultat, les attributs communs n'apparaissent qu'une seule fois {{< fa  triangle-exclamation >}} puisque la relation résultat ne peut pas avoir deux attributs de même nom.\n\nOn note cette opération : $R_1 \\bowtie R_2$.\n:::\n\nOn peut écrire la jointure naturelle comme une équi-jointure sur tous les attributs communs suivie d'une projection pour éliminer les attributs doublons.\n\n## Jointure naturelle  (formalisation)   {.smaller}\n\nConsidérons deux relations $R_1(A_1,..,A_k,B_1,...,B_h)$ et $R_2(A_1,..,A_k,B_{h+1},...,B_\\ell)$ de schémas **non** disjoints avec :\n\n- $A_1,..., A_k$ : attributs communs,\n   \n- $\\{B_1,...,B_h\\}\\cap \\{ B_{h+1},...,B_\\ell \\}=\\emptyset$,\n\nSoit $A'_1, ...., A'_k$ des noms tels que $\\{A_1,..., A_k\\}\\cap \\{ A'_1, ...., A'_k \\}=\\emptyset$.\n\nConsidérons la relation $S(A_1',..,A_k',B_{h+1},...,B_l)$ définie par :\n$\\quad S=\\rho_{A_1\\mapsto A_1'}(\\rho_{A_2\\mapsto A_2'}(\\cdots (\\rho_{A_k\\mapsto A_k'}(R_2)\\cdots ))$\n\n\nLa *jointure naturelle* sur les relations $R_1$ et $R_2$ est la relation $R$\n\n- de schéma $R(A_1,..,A_k,B_1,...,B_h, B_{h+1},...,B_\\ell)$\n \n- définie par :\n$\\quad R = \\pi_{A_1,..,A_k,B_1,...,B_h, B_{h+1},...,B_\\ell}(R_1\\bowtie_{C} S)\\quad$\noù $C$ est $(A_1=A_1') \\wedge (A_2=A'_2) \\wedge \\ldots \\wedge (A_k=A_k')$\n\n\n::: {.aside}\n\n{{< fa  hand-point-right >}} En préfixant les noms des attributs par ceux de la relation, la condition $C$ s'écrit alors :\n$$(R_1.A_1=R_2.A_1) \\wedge \\ldots \\wedge (R_1.A_k=R_2.A_k)$$\n\n:::\n\n\n\n## Exemple de Jointure naturelle  {.smaller}\n\nAfficher la liste des langues parlées en France (schéma `world`).\n\n::::: {.columns}\n\n::: {.column}\n\n```{.sql}\nbd_2023-24> \\d countrylanguage\n+-------------+--------------+-----------+\n| Column      | Type         | Modifiers |\n|-------------+--------------+-----------|\n| countrycode | character(3) |  not null |\n| language    | text         |  not null |\n| isofficial  | boolean      |  not null |\n| percentage  | real         |  not null |\n+-------------+--------------+-----------+\n```\n\n```{.sql}\nbd_2023-24> \\d city\n+-------------+--------------+-----------+\n| Column      | Type         | Modifiers |\n|-------------+--------------+-----------|\n| id          | integer      |  not null |\n| name        | text         |  not null |\n| countrycode | character(3) |  not null |\n| district    | text         |  not null |\n| population  | integer      |  not null |\n+-------------+--------------+-----------+\n```\n:::\n\n::: {.column}\n\n```{.sql}\nbd_2023-24> \\d country\n+--------------------+---------------+-----------+\n| Column             | Type          | Modifiers |\n|--------------------+---------------+-----------|\n| countrycode        | character(3)  |  not null |\n| name_country       | text          |  not null |\n| continent          | text          |  not null |\n| region             | text          |  not null |\n| surfacearea        | real          |  not null |\n| indepyear          | smallint      |           |\n| population_country | integer       |  not null |\n| lifeexpectancy     | real          |           |\n| gnp                | numeric(10,2) |           |\n| gnpold             | numeric(10,2) |           |\n| localname          | text          |  not null |\n| governmentform     | text          |  not null |\n| headofstate        | text          |           |\n| capital            | integer       |           |\n| code2              | character(2)  |  not null |\n+--------------------+---------------+-----------+\n```\n\n:::\n\n:::::\n\n\n## Exemple de Jointure naturelle (suite)\n\n::::: {.columns}\n\n::: {.column}\n\n```{.sql}\nT = JOINTURE(country, countrylanguage)\nS = SELECTION(T, name_country='France')\nR = PROJECTION(S, name_country, language)\n\n```\n\n```{.sql}\n+--------------+------------+\n| name_country | language   |\n|--------------+------------|\n| France       | French     |\n| France       | Arabic     |\n| France       | Portuguese |\n| France       | Italian    |\n| France       | Spanish    |\n| France       | Turkish    |\n+--------------+------------+\n```\n:::\n\n::: {.column}\n\n::: {.callout-note}\n\nDu point de la complexité des opérations à faire par le serveur, il vaut mieux faire le plus en amont possible les sélections puis les projections et enfin les jointures qui sont plus coûteuses en temps de calcul.\n\n:::\n\nOn écrira donc plutôt : \n```{.sql}\nS = SELECTION(country, name_country='France')\nT = JOINTURE(S, countrylanguage)\nR = PROJECTION(T, name_country, language)\n```\n\n:::\n\n:::::\n\n<!--\n---\n\nOn aurait pu décrire de façon plus explicite la jointure en précisant sur quels attributs s'effectue la jointure \n\n\n```{.sql}\ncountry |\n  ⋈(countrylanguage, countrycode) |>\n  σ(country='France') |>\n  π(name_country, language)\n\n```\n-->\n\n## Exemples de requêtes\n\n\n- Déterminer les noms des capitales des pays situés en Asie.\n\n. . . \n\n```{.sql}\nS =  SELECTION(country, continent='Asia')\nT =  JOINTURE(S, city, S.capital=city.id)\nR =  PROJECTION(T, name)\n```\n\nLe début de `R` est \n```{.sql}\n+-------------+\n| name        |\n|-------------+\n| Kabul       |\n| Abu Dhabi   |\n| Yerevan     | \n| al-Manama   |\n```\n\n## Exemples de requêtes (suite)\n\n\n- Déterminer les langues parlées dans les pays d'Asie.\n  \n. . .\n\n```{.sql}\nS = SELECTION(country, continent='Asia')\nT = JOINTURE(R1, countrylanguage)\nR = PROJECTION(R2, language)\n```\n\nLe début de `R` est \n\n```{.sql}\n+-------------+\n| name        |\n|-------------+\n| Pashto      |\n| Arabic      |\n| Armenian    | \n| Azerbaijani |\n```\n\n\n\n# Encore des opérations...  {background-color=\"#1c191c\"}\n\n\n## Jointure externe\n\n::: {.callout-note}\n\n### Perte d'information dans les jointures internes\n\nDans les jointures que nous avons vues, les tuples du produit cartésien ne satisfaisant pas la condition C (non appariés) disparaissent.\n\nOn appelle ces jointures des *jointures internes*.\n\nOn définit aussi des *jointures externes* qui n'adoptent pas ce comportement. \n\n:::\n\n. . .\n\n::: {.callout-important}\n\n### Définition\n\nLa *jointure externe* entre $R_1$ et $R_2$ est une jointure qui produit une relation R3 à laquelle on ajoute les tuples de R1 et de R2 exclus par la jointure, en complétant avec des valeurs nulles pour les attributs de l'autre relation.\n\n*Notation* : $R_1 {}^+\\!\\bowtie^+ R_2$.\n\n:::\n\n\n## Jointure externe gauche\n\n::: {.callout-important}\n\n### Définition\n\nLa jointure externe gauche entre R1 et R2 est une jointure externe pour laquelle on ajoute seulement les tuples de R1 (c'est à dire la relation de gauche) ayant été exclus.\n\n*Synonyme* : Jointure gauche\n\n*Notation* : $R_1 {}^+\\!\\bowtie R_2$   \n\n:::\n\n. . .\n\n::: {.callout-note}\n\n{{< fa  hand-point-right >}} Le + est du côté où on ajoute les tupes manquants.\n\n:::\n\n## Jointure externe droite\n\n::: {.callout-important}\n\n### Définition\n\nLa jointure externe droite entre R1 et R2 est une jointure externe pour laquelle on ajoute seulement les tuples de R2 (c'est à dire la relation de droite) ayant été exclus.\n\n*Synonyme* : Jointure droite\n\n*Notation* : $R_1 \\bowtie^+ R_2$\n\n:::\n\n::: {.callout-note}\n\nUne jointure externe droite peut être réécrite par une jointure externe gauche (et réciproquement) en échangeant l'ordre de R1 et R2.\n\n:::\n\n. . . \n\n::: {.callout-note}\n\nOn peut aussi utiliser une notation fonctionnelle et nommer ces jointures par des mots par exemple OUTER JOIN, LEFT JOIN, RIGHT JOIN.\n\n:::\n\n\n\n\n## Jointure externe (exemple)\n\n\nOn veut une table formée par les codes ISO, les noms des pays et (si possible) les noms des capitales. Les territoires sans capitale doivent apparaître en fin de table,  avec une colonne *nom de capitale* nulle. \n\n\n::: {.smaller}\n\nObtenir la première partie de la réponse avec une jointure est facile. Pour trouver les territoires sans capitale, il faudrait faire une sélection dans `country` sur le critère `capital IS NULL` puis une `UNION` des deux relations.\n\n:::\n\n\nAvec une jointure droite, on peut obtenir le résultat en une opération :\n\n. . .\n\n\n```{.default}\nS = RIGHT JOIN(city, country, city.id = country.capital) \nR = PROJECTION(S, countrycode, name_country, name)\n```\n\n\n\n## Division\n\n\n::: {.callout-important}\n\n### Définition\n\nLa *division* ou *quotient*\n\n- d'une relation $R$ de schéma\n$R(A_1,A_2,\\dots,A_k)$\n\n- par une relation $S$ de schéma\n$S(A_{p+1},\\dots ,A_k)$\n\nest la relation $T$ de schéma $T(A_1, \\dots, A_p)$ formée des tuples qui, complétés par chaque tuple\nde $S$, donnent un tuple de $R$.\n\nAutrement dit\n\n$$\\begin{array}{l} t\\in T(A_1,\\dots,A_p)  \\quad \\text{ si et seulement si } \\\\\n\\forall s\\in S(A_{p+1},\\dots ,A_k) \\quad \\exists r\\in R \\quad \\begin{cases}\nt.A_1=r.A_1, \\dots, t.A_p=r.A_p\\\\ s.A_{p+1}=r.A_{p+1},\\dots, s.A_{k}=r.A_{k} \\end{cases} \\end{array}$$\n\nOn note : $\\quad T = R \\div S$\n\n\n:::\n\n\n## Division (exemple)\n\nLa division permet de répondre à des questions du type : \n\n \"Donner tous les X qui ont toutes les valeurs existantes d'une propriété Y\".\n\n *Exemple* : lister les langues parlées sur tous les continents.\n\n. . .\n\n```{.sql}\nJ = JOINTURE(country, countrylanguage)\nCL =  PROJECTION(J, continent, language)\nC = PROJECTION(CL, continent)\n\nCL ÷ C\n```\n\n. . .\n\n\nAutre possibilité sans la division\n\n```{.sql}\nJ = JOINTURE(country, countrylanguage)\nCL =  PROJECTION(J, continent, language)\n\nC = PROJECTION(CL, continent)\nL = PROJECTION(CL, language)\n--- LPPTC Langues Pas Parlées dans Tous les Continents\nLPPTC = PROJECTION((C × L  ∖  CL ), language)\n\nR = L  ∖  LPPTC\n```\n<!--\n```{.sql}\nCL ← ⋈(country, countrylanguage) |>\n  π(continent, language)\n\nC ← π(CL, continent)\nL ← π(CL, language)\n\nLPPTC ← (C × L  ∖  CL ) |>\n  π(language)\n\nL  ∖  LPPTC\n```\n-->\n\n\n\n## Interdéfinissabilité des opérateurs\n\n\n- L'union, la différence, le produit cartésien, la sélection et la projection et le renommage sont *suffisants* pour définir tous les opérateurs que l'on a vus.\n\n- Mais avoir un panier  plus large d'opérateurs simplifie l'écriture des requêtes.\n\n\n## Définitions des autres opérateurs à partir de cet ensemble minimal\n\n\n. . .\n\n- Pour la *jointure* : $R \\bowtie_C S = \\sigma_C (R \\times S)$\n\n. . .\n\n- Pour l'*intersection* : $A \\cap B = A \\cup B - ((B - A) \\cup (A - B))$\n\n. . .\n\n- Pour la *division* : \n\nsoient $R(A_1,A_2,\\dots,A_k)$ et $S(A_{p+1},\\dots ,A_k)$, \n\n$T= R ÷ S\\quad$ a pour schéma $\\quad T(A_1, \\dots, A_p)$ et\n\n$$T = {\\Pi}(R, A) \\setminus {\\Pi}\\left(\\left(\\left({\\Pi}\\left(R, A\\right) × S\\right) \\setminus R\\right), A\\right)$$\n\noù $A = (A_1, \\dots, A_p)$.\n\n\n<!--\nDans la définition de $R ÷ S$, on utilise en deux endroits  $Π(R, A)$. \nIl serait utile, lors de l'évaluation de  $R ÷ S$, de n'évaluer $Π(R, A)$ qu'une seule fois en créant une table temporaire.\n-->\n\n\n\n# Petite histoire    {background-color=\"#1c191c\"}\n\n\n---\n\nL'algèbre relationnelle est la définition d'un modèle de calculabilité restreint. \n\nComme les modèles de calcul classiques  (les langages de programmation comme `Python`), elle est formée de briques de base (les opérateurs) et de mécanismes d'assemblage (la composition de fonction). \n\nLe modèle de calcul relationnel est bien plus simple qu celui d'un langage de programmation (pas de boucles `while`, `for`). Il est aussi moins expressif. \nOn peut montrer qu'il existe de questions qui sont solubles avec un langage de programmation mais qui ne le sont pas avec l'algèbre relationnelle.\n\nL'histoire de l'algèbre relationnelle éclaire le développement des bases de données.\n\n\n\n##  Depuis  Wikipedia {.smaller}\n\n> In the 1960s and 1970s he [Codd] worked out his theories of data arrangement, issuing his paper \"A Relational Model of Data for Large Shared Data Banks\" in 1970.[ To his disappointment, IBM proved slow to exploit his suggestions until commercial rivals started implementing them.\n\n> Initially, IBM refused to implement the relational model to preserve revenue from IMS/DB. Codd then showed IBM customers the potential of the implementation of its model, and they in turn pressured IBM. Then IBM included in its Future Systems project a System R subproject – but put in charge of it developers who were not thoroughly familiar with Codd's ideas, and isolated the team from Codd. As a result, they did not use Codd's own Alpha language but created a non-relational one, SEQUEL. Even so, SEQUEL was so superior to pre-relational systems that it was copied, in 1979, based on pre-launch papers presented at conferences, by Larry Ellison, of Relational Software Inc, in his Oracle Database, which actually reached market before SQL/DS – because of the then-already proprietary status of the original name, SEQUEL had been renamed SQL.\n\n> Codd continued to develop and extend his relational model, sometimes in collaboration with Christopher J. Date. One of the normalised forms, the Boyce–Codd normal form, is named after him.\n\n> Codd's theorem, a result proven in his seminal work on the relational model, equates the expressive power of relational algebra and relational calculus.\n\n\n\n\n# Fin  {background-color=\"#1c191c\"}\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}