{
  "hash": "f6b5dc4edf75210a3abf2beb4ade33ab",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"BD II: SQL LDD\"\n\nexecute: \n  eval: false\n  echo: true\n---\n\n\n\n```{.r, include=FALSE, eval=FALSE, echo=FALSE}\ntryCatch({\n    drv <- dbDriver(\"PostgreSQL\")\n    print(\"Connecting to Database…\")\n    connec <- dbConnect(drv,\n                 dbname = \"bd_2018\",\n                 host = \"localhost\",\n                 port = 5432,\n                 user = \"postgres\",\n                 password = \"postgres\")\n    print(\"Database Connected!\")\n    },\n    error=function(cond) {\n            print(\"Unable to connect to Database.\")\n    })\n\ndbSendQuery(connec, \"SET search_path TO world ;\")\n\nres <- dbSendQuery(connec,\n\"SELECT\n    region, name ,\nsum(gnp) OVER (PARTITION BY region\n                ORDER BY gnp)\nFROM world.country c\nWHERE region LIKE '%Europe'\nLIMIT 6;\"\n)\n\nfoo <- dbFetch(res)\n\n\ndbDisconnect(connec)\n```\n\n\n\n# Introduction  {background-color=\"#1c191c\"}\n\n\n\n## Définition de données\n\n\nSQL est un monde à part entière\n\nOn peut :\n\n- Interroger des données par des requêtes (déjà vu en partie)\n\n- Administrer les bases de données. C'est-à-dire :\n\n    - Créer celles-ci : définition des tables (schémas, etc), contraintes..\n\n    - Créer de nouvelles données, en insérer, supprimer, mettre à jour, etc\n\n    - Créer et gérer les utilisateurs, leurs droits sur les objets de la base,\n\n    - ...\n\nDans ce cours : création des tables (version simplifiée) et des données\n\n\n\n\n# Création de tables  {background-color=\"#1c191c\"}\n\n\n\n\n## Création de tables\n\n\n- Instruction : `CREATE TABLE ...`\n\n\nPermet de définir :\n\n\n- Les noms et les domaines (*type*) des attributs ainsi que des **contraintes d'intégrité** comme :\n\n    - Contraintes de clés primaires\n\n    - Contraintes référentielles (clés étrangères, par exemple)\n\n\n- Des contraintes assez générales (de contrôle des données)\n\n- Des index (pour la recherche et l'exécution efficaces)\n\n\n## Création de tables : noms et domaines d'attributs\n\n\nChaque relation est définie par un nom de relation et une liste d'attributs\n\n\n```{.sql}\nCREATE TABLE <nom_relation> (\n  <element de relation>\n  <,element de relation>*\n  <,contrainte de relation>* );\n```\n\n\nChaque attribut est défini par un nom d'attribut et un type de données\n\n```{.sql}\n<element de relation> ::=\n<nom_attrib><type_donnees>[<contrainte_attrib>*]\n```\n\n\nExemples de types:\n\n```{.sql}\n<type_donnees> ::=\nVARCHAR <longueur>| INT | REAL | DATE\n```\n\n\n\n## Exemple\n\nSchéma:\n\n\n```{verbatim}\nfournisseur(nomf, villef),\npiece(nomp, prix, couleur),\nlivraison(numliv, nomf, nomp, dateliv, quantite)\n```\n\n\n```{.sql}\nCREATE TABLE fournisseur(\n\tnomf VARCHAR(20),\n\tvillef VARCHAR(20)\n);\n\nCREATE TABLE piece(\n\tnomp VARCHAR(20),\n\tprix REAL,\n\tcouleur VARCHAR(15)\n);\n\nCREATE TABLE livraison(\n\tnumLiv INT,\n\tnomf VARCHAR(20),\n\tnomp VARCHAR(20),\n\tdateliv DATE DEFAULT NOW(),\n\tquantite INT DEFAULT 1\n);\n```\n\n\n\n---\n\n## Exemple : schéma `world`  {smaller}\n\n\n```{.sql}\nCREATE TABLE world.city (\n\tid int4 NOT NULL,\n\tname_city text NOT NULL,\n\tcountrycode bpchar(3) NOT NULL,\n\tdistrict text NOT NULL,\n\tpopulation_city int4 NOT NULL,\n\tCONSTRAINT city_pkey\n        PRIMARY KEY (id)\n);\n\n\nCREATE TABLE world.code_continent (\n\tcontinent name NOT NULL,\n\tcodecontinent float4 NULL,\n\tCONSTRAINT code_continent_pk\n        PRIMARY KEY (continent)\n);\n\nCREATE TABLE world.countrylanguage (\n\tcountrycode bpchar(3) NOT NULL,\n\t\"language\" text NOT NULL,\n\tisofficial bool NOT NULL,\n\tpercentage float4 NOT NULL,\n\tCONSTRAINT countrylanguage_pkey\n        PRIMARY KEY (countrycode, language)\n);\n```\n\n\n---\n\n\n![](/images/bd_2023-world.png)\n\n\n\n\n## Exemple: schéma `world` (suite)   {smaller}\n\n\n```{.sql}\nCREATE TABLE world.country (\n\tcountrycode bpchar(3) NOT NULL,\n\tname_country text NOT NULL,\n\tcontinent text NOT NULL,\n\tregion text NOT NULL,\n\tsurfacearea float4 NOT NULL,\n\tindepyear int2 NULL,\n\tpopulation_country int4 NOT NULL,\n\tlifeexpectancy float4 NULL,\n\tgnp numeric(10, 2) NULL,\n\tgnpold numeric(10, 2) NULL,\n\tlocalname text NOT NULL,\n\tgovernmentform text NOT NULL,\n\theadofstate text NULL,\n\tcapital int4 NULL,\n\tcode2 bpchar(2) NOT NULL,\n\tCONSTRAINT country_continent_check CHECK (\n        ((continent = 'Asia'::text) OR (\n            continent = 'Europe'::text) OR\n            (continent = 'North America'::text) OR\n            (continent = 'Africa'::text) OR\n            (continent = 'Oceania'::text) OR\n            (continent = 'Antarctica'::text) OR\n            (continent = 'South America'::text))),\n\tCONSTRAINT country_pkey PRIMARY KEY (countrycode)\n);\n```\n\n---\n\n\n\n![](/images/bd_2023-world.png)\n\n---\n\n\n## Suppression d'une table\n\n```{.sql}\nDROP TABLE fournisseur;\nDROP TABLE piece;\nDROP TABLE livraison;\n```\n\n\n# Insertion, mise à jour, suppression  {background-color=\"#1c191c\"}\n\n\n## Contenu des relations\n\n\nOn peut gérer le contenu des tables directement dans le langage `SQL`.\n\nOn peut donc :\n\n- Ajouter des tuples à une table : `INSERT INTO ...`\n\n- Mettre à jour des tuples d'une relation : `UPDATE ...`\n\n- Supprimer des tuples : `DELETE FROM ...`\n\n\n\n\n## Insertion de tuples\n\n\n```{.sql}\nINSERT INTO <nom_relation>\n\t[(nom_attrib [, nom_attrib]*)]\n\tVALUES (valeur [, valeur]*);\n```\n\n\nExemple\n\n```{.sql}\nINSERT INTO piece VALUES('x21', 1.51, 'rouge');\n\nINSERT INTO piece (nomp,couleur) VALUES('x22', 'vert');\n\n+--------+--------+-----------+\n| nomp   | prix   | couleur   |\n|--------+--------+-----------|\n| x21    | 1.51   | rouge     |\n| x22    | <null> | vert      |\n+--------+--------+-----------+\n```\n\n\n- Les valeurs doivent être fournies dans l'ordre de déclaration des attributs\n\n- Les valeurs non spécifiées sont  affectées à `NULL`.\n\n\n\n\n## Insertion, exemple  {smaller}\n\n\n```{.sql}\nINSERT INTO world.country\n(countrycode, name_country, continent,\n region, surfacearea, indepyear, population_country,\n lifeexpectancy, gnp, gnpold,\n localname, governmentform, headofstate, capital, code2)\nVALUES(\n    'SYL', 'Syldavia', 'Europe',\n    'Eastern Europe', 200000, 1918, 21345717,\n    81.2, 25213, 24878,\n    'Syldavie', 'Constitutional Monarchy', 'Ottokar II', 0, 'SY'\n);\n```\n\n\n---\n\n\n\n\n\n![](./images/bd_2023-world.png)\n\n\n\n\n> The latter portion of the multirow constructor, starting with the VALUES\nkeyword, is often referred to as a values list. \n\n> A values list can stand alone and effectively creates a table on the fly. \n> Using a multirow constructor as a virtual table\n\n```{.sql}\nSELECT *\nFROM (\n    VALUES\n        ('robe', 'logged in', '2011-01-10 10:15 AM EST'::timestamptz),\n        ('lhsu', 'logged out', '2011-01-11 10:20 AM EST'::timestamptz)\n) AS l (user_name, description, log_ts);\n```\n\n> When you use `VALUES` as a stand-in for a virtual table, you need to specify the\nnames for the columns. You also need to explicitly cast the values to the data\ntypes in the table if the parser can't infer the data type from the data. \n\n\n\n## Insertion de tuples\n\n```{.sql}\nINSERT INTO livraison\n    VALUES\n    (1, 'fournisseur1', 'x21', '2019-07-13', 2);\n\n-- Avec des colonnes pas renseignées\n\nINSERT INTO livraison\n   (numliv, dateliv, quantite)\n    VALUES\n   (2, '2018-07-29', 10);\n\n+----------+--------------+--------+------------+------------+\n| numliv   | nomf         | nomp   | dateliv    | quantite   |\n|----------+--------------+--------+------------+------------|\n| 1        | fournisseur1 | x21    | 2019-07-13 | 2          |\n| 2        | <null>       | <null> | 2018-07-29 | 10         |\n+----------+--------------+--------+------------+------------+\n```\n\n\n\n\n- Les valeurs doivent être fournies dans l'ordre de déclaration des attributs\n\n- Les valeurs non spécifiées sont  affectées à `NULL`.\n\n\n\n## Insertion de tuples par requête\n\n- On peut faire une insertion par le biais d'une requête\n\n- La clause `VALUES` est remplacée par une requête\n\n- Les résultats de la requête sont insérés comme valeurs dans la table\n\nExemple : Alimentation d'une nouvelle table à l'aide des données d'une autre\n\n```{.sql}\nINSERT INTO FournisseursParisiens\n\t(SELECT *\n\t FROM Fournisseur\n\t WHERE VilleF='Paris'\n);\n```\n\n\n## Mise à jour\n\n\n- On peut mettre à jour des tuples existants par le biais d'une requête\n\n  - Soit tous les tuples de la table,\n  - Soit l'ensemble des tuples vérifiants une condition donnée\n\n```{.sql}\nUPDATE nom_relation\nSET nom_attribut = <expression de valeur>\n[ , nom_attribut = <expression de valeur> ]*\n[ WHERE <condition de recherche> ];\n```\n\n\n\n## Mise à jour de tuples\n\nLe `WHERE` permet de sélectionner les tuples à mettre à jour\n\n```{.sql}\nUPDATE Fournisseur\n    SET VilleF='St.Petersburg'\n    WHERE VilleF='Leningrad';\n```\n\nOn peut aussi effectuer des opérations sur les tuples à mettre à jour.\n\nLa clause `<expression de valeur>` peut être :\n\n- `NULL`\n\n- Une constante (explicite ou via une requête)\n\n- Une expression arithmétique sur les attributs de la table à modifier\n\n\n\n## Mise à jour de tuples (exemple)\n\nAugmentation du prix d'une pièce\n\n```{.sql}\nUPDATE Piece\nSET Prix = Prix * 1.05\n    WHERE NomP = 'x21';\n```\n\n\n\n## Mise à jour par requête\n\n```{.sql}\nUPDATE Piece\nSET Prix = (\n    SELECT Prix\n    FROM Piece\n    WHERE NomP = 'x21'\n)\nWHERE Prix <= 1000;\n```\n\n\n## Suppression de tuples : syntaxe\n\n\n```{.sql}\nDELETE FROM <nom_relation>\n[WHERE <condition de recherche>];\n```\n\n\n\n### Exemple\n\n```{.sql}\nDELETE FROM Fournisseur\nWHERE NomF = 'FastDelivery';\n```\n\nOn supprime dans `Fournisseur` les tuples correspondant au fournisseur nommé `'FastDelivery'`\n\n\n## Suppression de tuples avec requête imbriquée\n\n\n```{.sql}\nDELETE FROM Livraison\nWHERE NomP IN (\n    SELECT NomP\n    FROM Piece\n    WHERE Couleur='Rouge'\n);\n```\n\n\n\n## `DELETE FROM <table> USING <t> WHERE ... `  {smaller}\n\n> Souvent, lorsque vous supprimez des données d'une table, \nvous souhaitez supprimer ces données en fonction de leur présence\ndans un autre ensemble de données. Spécifiez cet ensemble supplémentaire avec le prédicat `USING`\n\n\n```{.sql}\nCREATE TABLE chaprot.city () INHERITS (world.city) ;\nCREATE TABLE chaprot.country () INHERITS (world.country) ;\n\nINSERT INTO chaprot.country (\n\tSELECT * FROM world.country\n\tWHERE continent = 'Europe' \n);\n\nINSERT INTO chaprot.city (\n\tSELECT ci.*  FROM world.city ci NATURAL JOIN world.country co\n\tWHERE co.continent = 'Europe'\n) ;\n```\n\n\n## `DELETE FROM <table> USING <t> WHERE ... `\n\n> Souvent, lorsque vous supprimez des données d'une table, \nvous souhaitez supprimer ces données en fonction de leur présence\ndans un autre ensemble de données. Spécifiez cet ensemble supplémentaire avec le prédicat `USING`\n\n\n```{.sql}\nDELETE FROM chaprot.city \nUSING chaprot.country AS co\nWHERE city.countrycode = co.countrycode AND \n      co.region= 'Eastern Europe' AND \n      co.indepyear = 1991 ;\n```\n\n---\n\nLa requête suivante pose-t'elle problème ?\n\n```{.sql}\nDELETE FROM Piece\nWHERE NomP IN (\n\tSELECT NomP\n\tFROM Livraison\n\tWHERE Quantite>10\n);\n```\n\n\nPeut-être.\n\nCela dépend des contraintes d'intégrité qui pèsent sur la base\n\n# Intégrité référentielle   {background-color=\"#1c191c\"}\n\n## Maintien de l'intégrité référentielle (un problème)\n\nLa dernière requête renvoie à un problème plus général que l'on illustre à l'aide des tables\n`Livraison` et `Piece`, notées `L` et `P`.\n\nIl y a problème quand :\n\n\n- On cherche à insérer dans `L` un tuple dont la valeur de `NomP` n'existe pas dans `P`\n\n- On cherche à mettre à jour un tuple de `L` avec une valeur de `NomP` qui  n'existe pas dans `P`\n\n- On efface de  `P`, un tuple dont la valeur du champs `NomP` apparait comme valeur  d'un tuple de `L`\n\n- On met à jour le champs `NomP` d'un tuple de `P` alors que l'ancienne valeur de ce champs est présente comme valeur de `NomP` dans `L`\n\n\n## Maintien de l'intégrité référentielle (politiques possibles)\n\nPlusieurs politiques possibles pour régler ces problèmes\n\n- *Par défaut* : le système rejette toute modification ne respectant pas les contraintes d'intégrité\n\n. . . \n\n- *En cascade* : les modifications sur l'attribut référencé sont effectués aussi sur  l'attribut qui référence (la clé étrangère)\n\nExemple : mise à jour de `P.NomP` répercutée sur `L.NomP`. Effacement répercuté aussi..\n\n. . . \n\n- *Set-Null* :  les modifications sur l'attribut référencé sont répercuté sur l'attribut qui référence en mettant sa valeur à `NULL`.\n\n\n\n\n## Maintien de l'intégrité référentielle (exemple)\n\n*Exemple de syntaxe*\n\n```{.sql}\nCREATE TABLE Livraison (\n    NumLiv INT(10) PRIMARY KEY,\n    NomF VARCHAR(30) NOT NULL REFERENCES Fournisseur,\n    DateLiv DATE,\n    Quantite INT(8);\n    NomP VARCHAR(30) REFERENCES Piece\n      ON DELETE SET NULL\n      ON UPDATE CASCADE\n)\n```\n\n\nCette déclaration force :\n\n- à répercuter l'effacement d'un tuple dans `Piece` en mettant tous les champs `L.NomP` à `NULL`  lorsque ceux-ci avait pour valeur celle de `P.NomP` effacée.\n\n- à répercuter la mise à jour d'un tuple dans `Piece` (pour ce qui concerne le champs `NomP`) dans les tuples de `Livraison` concernés.\n\n\n\n# Contraintes  {background-color=\"#1c191c\"}\n\n\n---\n\n{{< fa triangle-exclamation >}} La définition d'un schéma de base ne s'arrête pas à la définition des\ntables, des colonnes et des types des colonnes\n\n\nLes *contraintes* décrivent des propriétés que devront vérifier\ntoutes les mises en oeuvre (instances) du schémas *durant toute leur durée de vie*\n\n\n{{< fa hand-point-right >}}  Pour spécifier une *contrainte*, il suffit de préciser que le\nrésultat d'une certaine requête doit toujours être vide\n\n\n\n## Famille de contraintes\n\n- Contrainte de **type**  (attribut)\n\n- Contrainte de **non-nullité**   (attribut)\n\n- Contrainte de **vérification**  (tuple)\n\n- Contrainte de **clé primaire**  (table)\n\n- Contrainte d'**unicité** (table)\n\n- Contrainte d'**unicité avancée** (table)\n\n- Contraintes d'**exclusion**  (table)\n\n- Contrainte de **clé étrangère** (multi-tables)\n\n\n\n\n## Contraintes élémentaires\n\n\nSpécifier le type d'un attribut, c'est le contraindre\n\n\n{{< fa book >}} Consulter la liste des constructions de type possible\n\n[http://www.postgresql.org/docs/9.4/interactive/datatype.html](http://www.postgresql.org/docs/9.4/interactive/datatype.html)\n\n\nIl faut essayer d'utiliser autant que possible ces types pour préciser\nles contenus des colonnes.\n\n\n\n\n## Les valeurs nulles\n\nImposer qu'une colonne soit toujours renseignée\n\n{{< fa hand-point-right >}} La présence possible des valeurs nulles rend beaucoup d'opérations\ncomplexes\n\nIl faut avoir en tête que en `SQL`, les booléens peuvent avoir\ntrois valeurs : `TRUE, FALSE` et `NULL` et que le fait\nqu'une expression ne vaille pas `FALSE` ne veut pas dire qu'elle\nvaut `TRUE` ...\n\n{{< fa hand-point-right >}} Pour imposer qu'une colonne soit renseignée\n\nPréciser, après le type : `NOT NULL`\n\n\n![](/images/world-country-details.png)\n\n\n## Contraintes élémentaires : clé primaire\n\nQuand on précise que `code` est clé primaire de `country_code`, on impose que la requête suivante renvoie toujours une table vide:\n\n```{.sql}\nSELECT cc1.code, cc2.code\nFROM country_code cc1 JOIN\n     country_code cc2\nWHERE cc1.code = cc2.code AND\n      cc1.country <> cc2.country  ;\n```\n\n\nLa requête est une jointure de la table sur elle-même\n\n\n\n\n## Quelques remarques\n\n\n- Une contrainte d'attribut concerne un seul attribut\n\n- Si valeur NULL impossible : `NOT NULL`\n\n- Si l'attribut est une **clé** : `PRIMARY KEY`\n\n- **Unicité** de l'attribut : `UNIQUE`\n\n- **Contrainte référentielle** :\n\n.f6[`REFERENCES <relation référencée>[(<attribut référencé>)]`]\n\n- Définir  une valeur par **défaut** : `DEFAULT <valeur>`\n\n\n\n::: {.callout-caution}\n\n### Attention \n\nles types disponibles (mais pas seulement) diffèrent grandement suivant les SGBD (`Mysql`, `Postgresql`, `Oracle`, `SQL Server`, ...)\n\n:::\n\n\n## Exemple de contrainte de clé primaire\n\n```{.sql}\nFournisseur (NomF, VilleF, AdresseF)\nPiece(NomP, Prix, Couleur)\nLivraison(NumLiv,NomP,NomF,DateLiv,Quantite)\n```\n\n\n```{.sql}\nCREATE TABLE Piece (\n    NomP\tVARCHAR(30) PRIMARY KEY,\n    Prix\tINT(10),\n    Couleur VARCHAR(15));\n```\n\nou bien :\n\n```{.sql}\nCREATE TABLE Piece (\n    NomP\tVARCHAR(30),\n    Prix\tINT(10),\n    Couleur VARCHAR(15),\n    PRIMARY KEY(NomP));\n```\n\n\n\n\n## Contraintes d'unicité \n\n\n```{.sql}\nCREATE TABLE sakila.\"language\" (\n\tlanguage_id serial4 NOT NULL,\n\t\"name\" bpchar(20) NOT NULL,\n\tlast_update timestamp NOT NULL DEFAULT now(),\n\tCONSTRAINT language_pkey PRIMARY KEY (language_id)\n);\n```\n\nOn voudrait aussi imposer que `\"name\"` satisfît une contrainte d'unicité\n\n. . . \n\n```{.sql}\nCREATE TABLE uname.\"language\" (\n\tlanguage_id int4 NULL,\n\t\"name\" bpchar(20) NULL,\n\tlast_update timestamp NULL,\n\tCONSTRAINT language_un UNIQUE (\"name\"),\n\tCONSTRAINT language_pk PRIMARY KEY (language_id)\n);\n```\n\n\n## Contraintes d'unicité avancées\n\n\n```{.sql}\nINSERT INTO colors(color, hex)\n    VALUES \n        ('blue', '0000FF'), \n        ('red', 'FF0000'), \n        ('green', '00FF00')\n    ON CONFLICT DO NOTHING ;\n```\n\nSomeone could come and put in a different case 'Blue' in our system, and\nwe'd then have two different cased blues. \n\n. . .\n\nTo remedy this, we can put a\nunique index on our table:\n\n```{.sql}\nCREATE UNIQUE INDEX uidx_colors_lcolor \n    ON colors \n    USING btree(lower(color));\n```\n\n. . .\n\nAs before, if we tried to insert a 'Blue', we'd be prevented from doing so\nand the `ON CONFLICT DO NOTHING` would result in nothing happening.\n\nIf we really wanted to spell the colors as given to us, we could use code like\nthat given in Example 7-18.\n\n```{.sql}\nON CONFLICT DO UPDATE\nINSERT INTO colors(color, hex)\n    VALUES\n        ('Blue', '0000FF'), \n        ('Red', 'FF0000'), \n        ('Green', '00FF00')\nON CONFLICT(lower(color))\n\nDO UPDATE SET color = EXCLUDED.color, hex = EXCLUDED.hex;\n```\n\n\n\n## Contraintes référentielles/clé étrangère\n\n\nUne contrainte de **clé étrangère** sur une collection de colonnes stipule que\n\n. . . \n\n> pour tout tuple de la table *émettrice*, la combinaison des\n> valeurs des colonnes impliquées se trouve aussi dans un tuple la table *cible*\n\n\n\n\n---\n\n## Exemple de contrainte référentielle\n\n\n```{.sql}\nFournisseur (NomF, VilleF, AdresseF)\nPiece(NomP, Prix, Couleur)\nLivraison(NumLiv,NomP,NomF,DateLiv,Quantite)\n```\n\n\n```{.sql}\nCREATE TABLE Livraison (\n    NumLiv int(10) PRIMARY KEY,\n    NomF VARCHAR(30) NOT NULL REFERENCES Fournisseur,\n    NomP VARCHAR(30) NOT NULL REFERENCES Piece,\n    DateLiv DATE,\n    Quantite Int(8);\n```\n\n\n\n# Résumé  {background-color=\"#1c191c\"}\n\n\n---\n\n\n- On a vu comment créer  des tables (de façon simplifiée) et gérer le contenu de celles-ci\n\n- On peut spécifier bien plus de contraintes dans la partie création de tables\n\n- L'ajout ou la suppression de données n'est pas libre : les contraintes (de clés notamment) doivent être satisfaites après\nl'exécution des mises à jours\n\n\n\n\n\n# Fin {background-color=\"#1c191c\"}\n\n",
    "supporting": [
      "LDD_0_files/figure-revealjs"
    ],
    "filters": [],
    "includes": {}
  }
}