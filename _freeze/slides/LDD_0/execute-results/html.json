{
  "hash": "b72435d0c2290ff4dd573eee976024c6",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"BD II: SQL LDD\"\nsubtitle: \"Définition de données\"\ndate: \"2025-10-03\"\n\nexecute: \n  eval: false\n  echo: true\n\nformat: \n  revealjs:\n    header: \"SQL : Définition de données, Insertion, ...\"  \n---\n\n\n\n\n\n\n# Introduction  {background-color=\"#1c191c\"}\n\n\n\n## Définition de données\n\n\nSQL est un monde à part entière\n\nOn peut :\n\n- Interroger des données par des requêtes (déjà vu en partie)\n\n- Administrer les bases de données :\n\n    - Créer celles-ci : définition des tables (schémas, etc), contraintes..\n\n    - Créer de nouvelles données, en insérer, supprimer, mettre à jour, etc\n\n    - Créer et gérer les utilisateurs, leurs droits sur les objets de la base,\n\n    - ...\n\n. . .\n\nDans ce cours : création des tables (version simplifiée) et des données\n\n\n# Création de tables  {background-color=\"#1c191c\"}\n\n\n## Création de tables\n\n\n- Instruction : `CREATE TABLE ...`\n\n\nPermet de définir :\n\n\n- Les noms et les domaines (*type*) des attributs ainsi que des **contraintes d'intégrité** comme :\n\n    - Contraintes de *clés primaires* (`PRIMARY KEY`)\n\n    - Contraintes *référentielles* (clés étrangères  `FOREIGN KEY`, par exemple)\n\n\n- Des contraintes assez générales (de contrôle des données)\n\n- Des index (pour la recherche et l'exécution efficaces)\n\n\n## Création de tables : noms et domaines d'attributs\n\n\nChaque relation est définie par un nom de relation et une liste d'attributs\n\n\n```{.sql}\nCREATE TABLE <nom_relation> (\n  <element de relation>\n  <,element de relation>*\n  <,contrainte de relation>* );\n```\n \n. . .\n\nChaque attribut est défini par un nom d'attribut et un type de données\n\n```{.sql}\n<element de relation> ::= <nom_attrib><type_donnees>[<contrainte_attrib>*]\n```\n\n. . .\n\n\n### Exemples de types\n\n```{.sql}\n<type_donnees> ::=  VARCHAR <longueur>| INT | REAL | DATE\n```\n\n\n\n## Exemple  \n\nSchéma:\n\n```{.sql}\nfournisseur(nomf, villef),\npiece(nomp, prix, couleur),\nlivraison(numliv, nomf, nomp, dateliv, quantite)\n```\n\n. . .\n\n```{.sql}\nCREATE TABLE fournisseur(\n\tnomf VARCHAR(20),\n\tvillef VARCHAR(20)\n);\n\nCREATE TABLE piece(\n\tnomp VARCHAR(20),\n\tprix REAL,\n\tcouleur VARCHAR(15)\n);\n```\n\n## Exemple avec valeurs par défaut \n\n```{sql}\nCREATE TABLE livraison(\n\tnumLiv INT,\n\tnomf VARCHAR(20),\n\tnomp VARCHAR(20),\n\tdateliv DATE DEFAULT NOW(),\n\tquantite INT DEFAULT 1\n);\n```\n\n. . .\n\n::: {.callout-note}\n\n### Valeurs par défaut\n\n- Pour `dateliv`, c'est la date courante lors de l'insertion de la ligne dans la table,\n\n- Pour `quantite`, c'est une constante. \n\n:::\n\n\n\n## Exemple : schéma `world`  {.smaller}\n\n\n![](/images/modelisation/MRD_world2.svg)\n\n---\n\n```{sql}\nCREATE TABLE world.city (\n\tid int4 NOT NULL,\n\tname text NOT NULL,\n\tcountrycode bpchar(3) NOT NULL,\n\tdistrict text NOT NULL,\n\tpopulation int4 NOT NULL,\n\tCONSTRAINT city_pkey\n        PRIMARY KEY (id)\n);\n```\n\n```{sql}\nCREATE TABLE world.code_continent (\n\tcontinent name NOT NULL,\n\tcodecontinent int4 NOT NULL,\n\tCONSTRAINT code_continent_pk\n        PRIMARY KEY (codecontinent)\n);\n```\n\n\n## Exemple : schéma `world`  avec clé primaire composée {.smaller}\n\n```{sql}\nCREATE TABLE world.countrylanguage (\n\tcountrycode bpchar(3) NOT NULL,\n\t\"language\" text NOT NULL,\n\tisofficial bool NOT NULL,\n\tpercentage float4 NOT NULL,\n\tCONSTRAINT countrylanguage_pkey\n        PRIMARY KEY (countrycode, language)\n);\n```\n. . .\n\n::: {.callout-note}\n\n### Attention\n\nUne clé peut être composée de plusieurs attributs\n\n:::\n\n\n\n## Exemple: schéma `world` (suite)   {.smaller}\n\n\n```{sql}\nCREATE TABLE world.country (\n\tcountrycode bpchar(3) NOT NULL,\n\tname_country text NOT NULL,\n\tcontinent text NOT NULL,\n\tregion text NOT NULL,\n\tsurfacearea float4 NOT NULL,\n\tindepyear int2 NULL,\n\tpopulation_country int4 NOT NULL,\n\tlifeexpectancy float4 NULL,\n\tgnp numeric(10, 2) NULL,\n\tgnpold numeric(10, 2) NULL,\n\tlocalname text NOT NULL,\n\tgovernmentform text NOT NULL,\n\theadofstate text NULL,\n\tcapital int4 NULL,\n\tcode2 bpchar(2) NOT NULL,\n\tCONSTRAINT country_continent_check CHECK (\n        ((continent = 'Asia'::text) OR (\n            continent = 'Europe'::text) OR\n            (continent = 'North America'::text) OR\n            (continent = 'Africa'::text) OR\n            (continent = 'Oceania'::text) OR\n            (continent = 'Antarctica'::text) OR\n            (continent = 'South America'::text))),\n\tCONSTRAINT country_pkey PRIMARY KEY (countrycode)\n);\n```\n\n\n\n## Suppression d'une table\n\n```{.sql}\nDROP TABLE fournisseur;\nDROP TABLE piece;\nDROP TABLE livraison;\n```\n\n::: {.callout-caution}\n\n### Suppression n'est pas vidange\n\nSupprimer une table, c'est supprimer son contenu (vidange) mais aussi son schéma \n\n:::\n\n\n# Insertion, mise à jour, suppression  {background-color=\"#1c191c\"}\n\n\n## Contenu des relations\n\n\nOn peut gérer le contenu des tables directement dans le langage `SQL` :\n\n\n::: {.incremental}\n\n- Ajouter des tuples à une table : `INSERT INTO ...`\n\n- Mettre à jour des tuples d'une relation : `UPDATE ...`\n\n- Supprimer des tuples : `DELETE FROM ...`\n\n:::\n\n\n\n# Insertion  {background-color=\"#1c191c\"}\n\n\n\n## Insertion de tuples : syntaxe\n\n\n```{sql}\nINSERT INTO <nom_relation>\n\t[(nom_attrib [, nom_attrib]*)]\n\tVALUES (valeur [, valeur]*);\n```\n\n\n. . .\n\n\n```{sql}\nINSERT INTO piece VALUES('x21', 1.51, 'rouge');\n\nINSERT INTO piece (nomp,couleur) VALUES('x22', 'vert');\n\n+--------+--------+-----------+\n| nomp   | prix   | couleur   |\n|--------+--------+-----------|\n| x21    | 1.51   | rouge     |\n| x22    | <null> | vert      |\n+--------+--------+-----------+\n```\n\n\n::: {.callout-caution}\n\n### Attention\n\n- Les valeurs doivent être fournies dans l'ordre de déclaration des attributs,\n- Les valeurs non spécifiées sont  affectées à `NULL`\n\n:::\n\n\n\n\n## Insertion, exemple  (suite) \n\n\n```{.sql}\nINSERT INTO world.Country\n  (countrycode, name_country, continent,\n   region, surfacearea, indepyear, population_country,\n   lifeexpectancy, gnp, gnpold,\n   localname, governmentform, headofstate, capital, code2)\nVALUES(\n    'SYL', 'Syldavia', 'Europe',\n    'Eastern Europe', 200000, 1918, 21345717, 81.2, 25213, 24878,\n    'Syldavie', 'Constitutional Monarchy', 'Ottokar II', 0, 'SY'\n);\n```\n\n\n---\n\n\n![](/images/modelisation/MRD_world2.svg)\n\n\n## Remarques \n\n\n\nLa dernière partie du constructeur multiligne, qui commence avec  `VALUES`\nest souvent appelée la *liste de valeurs*. \n\n. . .\n\nUne liste de valeurs peut être définie sans référence à une table existante et \ndéfinir à la volée une nouvelle table virtuelle/éphémère.\n\n. . .\n\n\n```{sql}\nSELECT *\nFROM (\n  VALUES\n    ('robe', 'logged in', '2011-01-10 10:15 AM EST'::timestamptz),\n    ('lhsu', 'logged out', '2011-01-11 10:20 AM EST'::timestamptz)\n) AS l (user_name, description, log_ts);\n```\n\n::: {.callout-note}\n\nQuand on utilise `VALUES` pour définir une table virtuelle, \nil faut spécifier le nom des colonnes. \n\nPar défaut, les types des colonnes sont inférés. Si l'inférence de type n'est pas possible, il faut effectuer explicitement des conversions de type comme ici avec `::timestamptz`. \n\n\n:::\n\n\n\n## Exemple : Insertion de tuples  (suite)\n\n```{.sql}\nINSERT INTO livraison\n    VALUES\n    (1, 'fournisseur1', 'x21', '2019-07-13', 2);\n```\n\n. . .\n\n\n```{.sql}\n-- Avec des colonnes non renseignées\n\nINSERT INTO livraison\n   (numliv, dateliv, quantite)\n    VALUES\n   (2, '2018-07-29', 10);\n```\n\n. . .\n\n\n```{.sql}\n+----------+--------------+--------+------------+------------+\n| numliv   | nomf         | nomp   | dateliv    | quantite   |\n|----------+--------------+--------+------------+------------|\n| 1        | fournisseur1 | x21    | 2019-07-13 | 2          |\n| 2        | <null>       | <null> | 2018-07-29 | 10         |\n+----------+--------------+--------+------------+------------+\n```\n\n\n\n## Insertion de tuples par requête\n\n- On peut faire une insertion par le biais d'une requête,\n\n- La clause `VALUES` est remplacée par une requête,\n\n- Les résultats de la requête sont insérés comme valeurs dans la table.\n  \n- Pour respecter les contraintes d'unicité, le mot clé `DISTINCT` peut être nécessaire, en particulier lorsqu'il y a une jointure.\n\n. . .\n\n\n### Exemple 1\n\n```{.sql}\nINSERT INTO FournisseursParisiens (\n  SELECT *\n  FROM Fournisseur\n  WHERE VilleF='Paris'\n);\n```\n\n\n\n##  Exemple 2\n\n```{.sql}\nCREATE TABLE monschema.city () \n  INHERITS (world.city) ;\n\nCREATE TABLE monschema.country () \n  INHERITS (world.country) ;\n\nINSERT INTO monschema.country (\n\tSELECT * \n    FROM world.country\n\tWHERE continent = 'Europe' \n);\n\nINSERT INTO monschema.city (\n\tSELECT ci.*  \n    FROM world.city ci NATURAL JOIN \n      world.country co\n\tWHERE co.continent = 'Europe'\n) ;\n```\n\n\n# Mise à jour  {background-color=\"#1c191c\"}\n\n\n## Mise à jour de colonnes, de cellules \n\nOn peut mettre à jour des tuples d'une table par le biais d'une requête `UPDATE`.\n\n```{.sql}\nUPDATE nom_table1\nSET nom_attribut = <expression de valeur> \n    [ , nom_attribut = <expression de valeur> ]\n[FROM nom_table2 [, [JOIN] nom_table3]]\n[WHERE <condition de recherche> ];\n```\n. . .\n\n::: {.callout-note}\n`<expression de valeur>` peut être :\n\n- `NULL`,\n- une constante explicite,\n- une expression arithmétique sur les attributs des tables des clauses `SET` ou `FROM`,\n- le résultat d'une requête scalaire.\n\n:::\n\n. . .\n\n::: {.callout-warning}\n\n**On ne peut pas** utiliser la notation `nom_table.nom_attribut` dans la clause `SET`.\n\n:::\n\n<!-- \n## Mise à jour conditionnelle de tuples\n\nLe `WHERE` permet de sélectionner les tuples à mettre à jour\n\n```{.sql}\nUPDATE Fournisseur\nSET villef='St.Petersburg'\nWHERE villef='Leningrad';\n```\n\nOn peut aussi effectuer des opérations sur les tuples à mettre à jour.-->\n\n\n\n## Exemple de mise à jour de tuples\n\nAugmentation du prix d'une pièce\n\n```{.sql}\nUPDATE Piece\nSET prix = prix * 1.05\nWHERE nomp = 'x21';\n```\n\n\n\n## Calcul de la nouvelle valeur par une sous-requête\n\n```{.sql}\nUPDATE Piece\nSET Prix = (\n    SELECT prix\n    FROM Piece\n    WHERE nomp = 'x21'\n)\nWHERE Prix <= 1000;\n```\n\n\n## Utilisation de la clause `FROM`\n\n- On peut avoir besoin de plusieurs tables pour sélectionner les tuples à mettre à jour.\n\n- La syntaxe à utiliser varie un peu selon le SGBD. \n\n- Avec PostgreSQL, on écrira les tables suplémentaires dans une clause `FROM` (`JOIN` possible si au moins deux tables supplémentaires).\n\n```{.sql}\nUPDATE Piece p\nSET p.prix = p.prix * 1.1\nFROM Livraison l\nWHERE\n    p.nomp = l.nomp\n    AND l.quantite > 2* (SELECT MIN(quantite) FROM Livraison);\n```\n\n::: {.callout-caution}\nSi, pour une même ligne de la table `Piece`, plusieurs lignes de la table `Livraison` vérifient la condition, la mise à jour n'est effectuée qu'une seule fois.\n:::\n\n\n## `UPDATE` avec CTE\n\nIl est parfois pratique d'écrire une CTE pour définir les couples (identifiant, nouvelle valeur).\n\n```{.sql}\nWITH r AS (\n  SELECT p.nomp AS id, p.prix * 1.1 AS newvalue\n  FROM Piece p\n  JOIN Livraison l ON p.nomp = l.nomp\n  WHERE l.quantite > 2* (SELECT MIN(quantite) FROM Livraison)\n)\nUPDATE Piece p\nSET prix = r.newvalue\nFROM r\nWHERE p.nomp = r.id\n```\n\n\n\n# Suppression de tuples {background-color=\"#1c191c\"}\n\n## Suppression de tuples\n\n\n```{.sql}\nDELETE FROM <nom_relation>\n[USING nom_table2 [, [JOIN] nom_table3]]\n[WHERE <condition de recherche>];\n```\n:::{.callout-important}\nL'oubli de la clause `where` supprime toutes les données de la table.\n:::\n\n\n\n## Exemple de suppression de tuples\n\n```{.sql}\nDELETE FROM Fournisseur\nWHERE NomF = 'FastDelivery';\n```\n\nOn supprime dans `Fournisseur` les tuples correspondant au fournisseur nommé `'FastDelivery'`\n\n\n## Suppression de tuples avec requête imbriquée\n\n\n```{.sql}\nDELETE FROM Livraison\nWHERE NomP IN (\n    SELECT NomP\n    FROM Piece\n    WHERE Couleur='Rouge'\n);\n```\n\n\n## Utilisation de la clause `USING`  \n\n- On peut avoir besoin de plusieurs tables pour sélectionner les tuples à supprimer.\n\n- La syntaxe à utiliser varie un peu selon le SGBD. PostgreSQL ne supporte pas l'utilisation de `JOIN` dans la clause `FROM` d'une instruction `DELETE`.\n\n- On écrira les tables suplémentaires dans une clause `USING` (`JOIN` possible si au moins deux tables supplémentaires).\n\n\n\n```{sql}\nDELETE FROM monschema.city AS ci\nUSING monschema.country AS co\nWHERE \n  ci.countrycode = co.countrycode AND \n  co.region= 'Eastern Europe' AND \n  co.indepyear = 1991 ;\n```\n\n\n\n## Suppression de données et contraintes d'intégrité référentielle\n\n::: {.callout-warning}\n\nLa requête précédente pose-t'elle problème ?\n\n:::\n\n. . .\n\nLes identifiants de l'attribut `country.capital` pour les pays vérifiant `country.region = 'Eastern Europe' AND  country.indepyear = 1991` ne seront plus référencés dans la table `city`.\n\n\n\n\n# Résumé  {background-color=\"#1c191c\"}\n\n\n---\n\n\n- On a vu comment créer  des tables (de façon simplifiée) et gérer le contenu de celles-ci,\n\n- On peut spécifier bien plus de contraintes dans la partie création de tables,\n\n- L'ajout ou la suppression de données n'est pas libre : les contraintes (de clés notamment) doivent être satisfaites après l'exécution des mises à jours.\n\n\n\n\n\n# Fin {background-color=\"#1c191c\"}\n\n",
    "supporting": [
      "LDD_0_files"
    ],
    "filters": [],
    "includes": {}
  }
}