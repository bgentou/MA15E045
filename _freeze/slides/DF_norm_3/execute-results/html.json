{
  "hash": "536ea86c7ea68893396f93703ad77b43",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Normalisation II : Décomposition FN3\"\nsubtitle: \"Pertes de Dépendances Fonctionnelles. Décomposition FN3\"\ndate: \"2024-11-29\"\n\nformat: \n  revealjs:\n    header: \"Pertes de Dépendances Fonctionnelles. Décomposition FN3\"\n\nengine: knitr\n---\n\n\n# Décompositions : rappels {background-color=\"#1c191c\"}\n\n\n---\n\n::: {.callout-important}\n\n### Définition \n\nSoit $\\mathcal{A}$ un schéma de relation\n\nUn *décomposition* de $\\mathcal{A}$ est un ensemble $\\{\\mathcal{A}_1,..., \\mathcal{A}_k\\}$\nde sous-ensembles de $\\mathcal{A}$ tel que\n\n$$\\mathcal{A}_i\\not=\\emptyset, 1\\le i\\le k, \\quad \\text{ et } \\quad \\mathcal{A} = \\bigcup_{i=1}^k \\mathcal{A}_i$$\n\n:::\n\n\n---\n\n\n\n::: {.callout-important}\n\n### Définition\n\nSoit $\\mathcal{A}$ un schéma de relation et $\\Sigma$ un ensemble de DF sur $\\mathcal{A}$.\n\nUne décomposition $\\{\\mathcal{A}_1,..., \\mathcal{A}_k\\}$ est *sans perte d'information par rapport à* $\\Sigma$\nsi pour toute relation $R$  de schéma $\\mathcal{A}$ satisfaisant $\\Sigma$ on a\n\n$$R= \\pi_{\\mathcal{A}_1}(R) \\bowtie \\pi_{\\mathcal{A}_2}(R) \\bowtie...\\bowtie\\pi_{\\mathcal{A}_k}(R)$$\n\n:::\n\n## Résultat de la [séance précédente](/slides/DF_norm_1.qmd#/décomposition-fnbc-spi) \n\n::: {.callout-important}\n\nOn peut décomposer une relation $\\mathcal{A}$ relativement à un ensemble de DF $\\Sigma$ de façon à obtenir une décomposition :\n\n- dont tous les membres sont en FNBC relativement à $\\Sigma$\n  \n- SPI\n\n:::\n\n. . .\n\n{{< fa skull-crossbones >}} Ce résultat ne fournit pas toujours une solution complètement satisfaisante\n\n\n# Projection d'un ensemble de dépendances fonctionnelles {background-color=\"#1c191c\"}\n\n\n## Projection d'un ensemble de DF\n\nSoientt $\\mathcal{A}$ un schéma de relation ($\\mathcal{A}$ est un ensemble d'attributs) et $\\Sigma$ un ensemble de DF sur $\\mathcal{A}$\n\nSoit $\\mathcal{A}_1\\subset  \\mathcal{A}$ un sous-ensemble  d'attributs\n\n::: {.callout-important}\n\n### Définition\n\n$$\\pi_{\\mathcal{A}_1}(\\Sigma)=\\left\\{ X\\to Y \\mid \\Sigma\\models X\\to Y \\text{ et } X,Y\\subset \\mathcal{A}_1\\right\\}$$\n\n:::\n\n::: {.aside}\n\n$\\pi_{\\mathcal{A}_1}(\\Sigma)$ est l'ensemble des DF de la forme $X\\to Y$ impliquées par $\\Sigma$ et telles que $X\\subset \\mathcal{A}_1$ et $Y\\subset \\mathcal{A}_1$\n\n:::\n\n\n::: {.callout-important}\n\n### Caractérisation\n\nSi $X\\subset {\\mathcal{A}}_1$ on a l'équivalence\n$$X\\to Y \\in \\pi_{{\\mathcal{A}}_1}(\\Sigma) \\iff Y\\subset\\left\\{X\\right\\}^+∩{\\mathcal{A}}_1$$\n\n\n:::\n\n\n## Exemple\n\n-   ${\\mathcal{A}}=\\left\\{A,B,C\\right\\}$ et\n    $\\Sigma=\\left\\{A\\to B, B\\to C, C\\to A\\right\\}$\n\n-   $\\pi^{}_{\\left\\{A,B\\right\\}}(\\Sigma)$ est équivalent à\n    $\\left\\{A\\to B, B\\to A\\right\\}$\n\n\n\n\n## Calcul de $\\pi_{{\\mathcal{A}}_1}(\\Sigma)$ \n\nOn calcule un ensemble de DF équivalent à $\\pi_{\\mathcal{A}_1}(\\Sigma)$\n\n```pseudocode\n#| html-indent-size: \"1.2em\"\n#| html-comment-delimiter: \"//\"\n#| html-line-number: true\n#| html-line-number-punc: \":\"\n#| html-no-end: false\n\n\\begin{algorithm}\n\\caption{Projection de DF}\n\\begin{algorithmic}\n\\Procedure{Projection}{$\\mathcal{A}_1, Σ$}\n\n\\State P ← ∅\n\n\\For{$X ⊂ \\mathcal{A}_1$, $X ≠ ∅$, $X ≠ \\mathcal{A}_1$}\n  \\State Y ← $X^+ ∩ \\mathcal{A}_1$  \n  \\State P ← P ∪ $\\{ X → Y\\}$\n\\EndFor\n\n\\Return P\n\n\\EndProcedure\n\n\\end{algorithmic}\n\\end{algorithm}\n```\n\n\n::: {.aside}\n\nL'ensemble de DF obtenu est équivalent à $\\pi_{{\\mathcal{A}}_1}(\\Sigma)$\\\n[Très coûteux !]{.alert} Le nombre de sous-ensembles $X$ considérés est\n$2^{\\#{\\mathcal{A}}_1}-2$\n:::\n\n\n## Exemple  {.smaller}\n\n-   ${\\mathcal{A}}=\\left\\{A,B,C,D,E\\right\\}$ et\n    [$\\Sigma=\\left\\{A\\to C, BC\\to D, AD\\to E\\right\\}$]{.alert}\n\n. . .\n\n-   $\\pi_{AC}(\\Sigma)$ est équivalent à $\\left\\{A\\to C\\right\\}$ car\\\n    $\\left\\{A\\right\\}^+=\\left\\{A,C\\right\\}$ et\n    $\\left\\{C\\right\\}^+=\\left\\{C\\right\\}$\n\n. . .\n\n-   $\\pi_{ABD}(\\Sigma)$ est équivalent à $\\left\\{AB\\to D\\right\\}$ car\\\n    $\\left\\{A\\right\\}^+=\\left\\{A,C\\right\\}$,\n    $\\left\\{B\\right\\}^+=\\left\\{D\\right\\}$,\n    $\\left\\{D\\right\\}^+=\\left\\{D\\right\\}$,\\\n    $\\left\\{A,B\\right\\}^+=\\left\\{A,B,C,D,E\\right\\}$,\n    $\\left\\{A,D\\right\\}^+=\\left\\{A,D,C,E\\right\\}$,\n    $\\left\\{B,D\\right\\}^+=\\left\\{B,D\\right\\}$\n\n. . .\n\n-   $\\pi_{ABCE}(\\Sigma)$ est équivalent à\n    $\\left\\{A\\to C, AB \\to CE, AE\\to C, ABC\\to E, ABE\\to C\\right\\}$\\\n    $A^+=AC \\quad B^+=B \\quad C^+=C \\quad E^+=E$\\\n    $AB^+=ABCDE \\quad AC^+=AC \\quad AE^+=AEC$\\\n    $BC^+=BCD \\quad BE^+=BE \\quad CE^+=CE$\\\n    $ABC^+=ABCDE \\quad ABE^+=ABECD$\\\n    $BCE^+=BCED \\quad ACE^+=ACE$\n\n. . .\n\n-   Simplification : $\\pi_{ABCE}(\\Sigma)$ équivaut à\n    $\\left\\{A\\to C, AB\\to E\\right\\}$\n\n\n\n# Perte de dépendances fonctionnelles   {background-color=\"#1c191c\"}\n\n\n## Préservation de dépendances fonctionnelles\n\n::: {.callout-important}\n\n###  Définition\n\nSoit $\\mathcal{A}$ un schéma de relation et $\\Sigma$ un ensemble de DF sur $\\mathcal{A}$.\n\nSoit $\\left\\{ \\mathcal{A}_1,\\dots, \\mathcal{A}_k\\right\\}$ une décomposition du schéma $\\mathcal{A}$\n($\\mathcal{A}_i\\neq \\emptyset, 1\\leq i\\leq k$ et $\\mathcal{A}= \\bigcup_{i=1}^k \\mathcal{A}_i$)\n\nLa décomposition $\\left\\{\\mathcal{A}_1,\\dots, \\mathcal{A}_k\\right\\}$ *préserve* $\\Sigma$\nsi l'ensemble des *dépendances fonctionnelles locales*\n$\\bigcup_{i=1}^k \\pi_{\\mathcal{A}_i}(\\Sigma)$ est équivalent à $\\Sigma$\n\n:::\n\n\n::: {.aside}\n\nPuisque $\\Sigma ⊧ \\bigcup_{i=1}^k \\pi_{\\mathcal{A}_i}(\\Sigma)$, la décomposition\npréserve $\\Sigma$ si et seulement si toutes les DF de $\\Sigma$ sont impliquées par les DF locales\n\n:::\n\n\n\n\n\n\n\n# Détection de perte de DF {background-color=\"#1c191c\"}\n\n\n## Algorithme pour tester si  $\\bigcup_{i=1}^k \\pi_{\\mathcal{A}_i}(\\Sigma) \\models X \\rightarrow Y$  {.smaller}\n\n\n```pseudocode\n#| html-indent-size: \"1.2em\"\n#| html-comment-delimiter: \"//\"\n#| html-line-number: true\n#| html-line-number-punc: \":\"\n#| html-no-end: false\n\n\\begin{algorithm}\n\\caption{X → Y est-elle impliquée par les dépendances projetées?}\n\\begin{algorithmic}\n\\Procedure{Implique}{$\\left\\{ \\mathcal{A}_1,\\dots, \\mathcal{A}_k\\right\\}, Σ, X, Y$}\n\n\\State Z ← X\n\\State continuer ← \\True\n\n\\While{continuer}\n  \\State $W ← Z$\n  \\For{i ∈ 1, ..., k}\n    \\State $W ← W ∪ \\bigl((W ∩ \\mathcal{A}_i)^+ ∩ \\mathcal{A}_i\\bigr)$\n  \\EndFor\n  \\If{W ≠ Z}\n        \\State Z ← W\n  \\Else\n        \\State continuer ← \\False\n  \\EndIf\n\\EndWhile\n\n\\If{Y ⊆ Z}\n  \\Return \\True\n\\Else\n  \\Return \\False\n\\EndIf \n\n\\EndProcedure\n\n\\end{algorithmic}\n\\end{algorithm}\n```\n\n\n\n## Exemple I  {.smaller}\n\n\n- $\\mathcal{A}=\\left\\{A,B,C,D\\right\\}$, \n- $\\mathcal{A}_1=\\left\\{A,B\\right\\}$, $\\mathcal{A}_2=\\left\\{B,C\\right\\}$, $\\mathcal{A}_3=\\left\\{C,D\\right\\}$\n\n- $\\Sigma=\\left\\{A\\to B, B\\to C, C\\to D, D\\to A\\right\\}$\n\n- Est-ce que la décomposition $\\left\\{\\mathcal{A}_1,\\mathcal{A}_2,\\mathcal{A}_3\\right\\}$ préserve $\\Sigma$ ?\n\n. . .\n\n- Les DF locales impliquent $A\\to B$, $B\\to C$, $C\\to D$ (ce sont DF locales)\n\n. . .\n\n- Est-ce que les DF locales impliquent $D\\to A$ ?\n\n. . . \n\nCommencer avec $Z ← \\{D\\}$\n\n::: {.incremental}\n\n1. $(\\{D\\}∩\\{CD\\})^+ ∩ \\{CD\\}=\\{D\\}^+ ∩\\{CD\\}=\\{DABC\\} ∩ \\{CD\\}=\\{CD\\}$, ajouter $C$\n\n2. $(\\{DC\\}∩ \\{BC\\})^+ ∩ \\{BC\\}=\\{C\\}^+ ∩ \\{BC\\}=\\{CDAB\\}∩ \\{BC=B\\}$, ajouter $B$\n\n3. $(\\{DCB\\}∩ \\{AB\\})^+ ∩ \\{AB\\}=\\{B\\}^+ ∩ \\{AB\\}=\\{BCDA\\} ∩ \\{AB\\}$, ajouter $A$\n\n4. $\\{DCBA\\}$ contient $A$ donc $D\\to A$ est préservée\n\n:::\n\n## Exemple II {.smaller}\n\n\n- $\\mathcal{A}=$ `{Ville, CP, Rue, Numero}`\n\n- $\\Sigma=$ `{ CP →  Ville, {Ville, Rue, Numero} → CP}`\n\n- $\\mathcal{A}_1=$ `{Ville, CP}` $\\mathcal{A}_2=$ `{Rue, Numero, CP}`\n\n- Est-ce que la décomposition  $\\{\\mathcal{A}_1, \\mathcal{A}_2 \\}$ préserve $\\Sigma$ ?\n\n. . .\n\n- `CP →  Ville` est préservée car elle est locale à $\\mathcal{A}_1$\n\n\n. . .\n\n\n- Est-ce que `{Ville, Rue, Numero} → CP` est préservée par $\\mathcal{A}_1, \\mathcal{A}_2$ ?\n\n. . .\n\n\n`Z ← {Ville, Rue, Numero}`\n\n1. $(\\texttt{Z} ∩ \\texttt{{Ville, CP}})^+$ ∩ `{Ville, CP}` = `{Ville}`  *rien à ajouter*\n\n2. $(\\texttt{Z} ∩ \\texttt{{Rue, Numero, CP}})^+$ ∩ `{Rue, Numero, CP}` = `{Rue, Numero}`, *rien à ajouter*\n\n. . .\n\nDonc `Ville, Rue, Numero → CP` n'est pas préservée  {{< fa frown >}}\n\n\n# Décomposition FNBC et pertes de DF {background-color=\"#1c191c\"}\n\n\n## Rappels  [séance précédente](/slides/DF_norm_1.qmd#/décomposition-fnbc-spi) (bis)\n\n::: {.callout-important}\n\n### Définition\n\nUn schéma $\\mathcal{A}$ est en FNBC par rapport à un ensemble de dépendances fonctionnelles $\\Sigma$ sur $\\mathcal{A}$\n\nsi\n\npour toute DF $X\\rightarrow Y$ impliquée par $\\Sigma$ avec $Y\\not\\subset X$, $X$ est une super-clef\n\n\n:::\n\n\n\n\n## Algorithme \n\n```pseudocode\n#| html-indent-size: \"1.2em\"\n#| html-comment-delimiter: \"//\"\n#| html-line-number: true\n#| html-line-number-punc: \":\"\n#| html-no-end: false\n\n\\begin{algorithm}\n\\caption{Décomposition FNBC}\n\\begin{algorithmic}\n\\Procedure{DecompositionFNBC}{$\\mathcal{A}, Σ$}\n\n\\State \\Comment{Initialisation de la décomposition}\n\\State $D ←  \\{\\mathcal{A}\\}$\n\n\n\\State\n\\While{Exists some $\\mathcal{B} \\in D$ which is not in BCNF w.r.t. $\\Sigma \\models X → X^+ \\cap \\mathcal{B}$, $X \\subsetneq \\mathcal{B}$}\n  \\State $Y \\leftarrow X^+ \\cap \\mathcal{B} \\setminus X$ \n  \\State $D \\leftarrow D \\setminus \\{\\mathcal{B}\\} \\cup \\{ X \\cup Y, \\mathcal{B} \\setminus Y \\}$\n\\EndWhile\n\\State\n\\Return $D$\n\n\\EndProcedure\n\n\\end{algorithmic}\n\\end{algorithm}\n```\n\n---\n\n\n::: {.callout-important}\n\n### Proposition\n\n- L'algorithme termine\n\n- Les éléments de la  décomposition finale sont en FNBC \n\n- La décomposition est Sans Perte d'Information (SPI)\n\n\n:::\n\n## Limites de la décomposition FNBC\n  \n::: {.callout-note}\n\nIl existe des couples schéma/Ensemble de DFs ($\\mathcal{A}, \\Sigma$) pour lesquels toute décomposition FNBC entraine une perte de dépendances fonctionnelles\n\n:::\n\n## {.smaller}\n\n\n$\\mathcal{A} =$ `{Ville, Rue, Numéro, #Bureau_vote}`\n\n`Σ = { Ville, Nom, Rue → #Bureau_vote,  #Bureau_vote  →  Ville }`\n\n. . .\n\nDeux clés `Ville, Nom, Rue` et `#Bureau_vote, Nom, Rue`\n\n. . .\n\n`#Bureau_vote  →  Ville` ne satisfait pas le critère FNBC\n\n. . .\n\nL'algorithme de décomposition en FNBC conduit à la décomposition `{#Bureau_vote,Ville}` et `{#Bureau_vote, Nom, Rue}`\n\nLa DF `Ville, Nom, Rue → #Bureau_vote` n'est pas préservée\n\nLa décomposition préserve l'information (SPI) mais pas les dépendances fonctionnelles. \n\n\n## Limites de la décomposition FNBC (suite)\n\n::: {.callout-caution title=\"À noter\"}\n\nOn peut vérifier qu'*aucune* décomposition FNBC de $\\mathcal{A}$ ne préserve toutes les dépendances fonctionnelles. \n\n:::\n\n\n## Un nouvel objectif\n\n\n::: {.callout-note title=\"Construire\"}\n\nUne décomposition :\n\n- Sans Perte d'Information (SPI)\n- Sans perte de Dépendances Fonctionnelles\n- Dont les éléments sont en FN3 par rapports aux dépendances projetées \n\n:::\n\n## Pour réaliser cet objectif\n\nUne étape cruciale : réécrire l'ensemble de DFs\n\n\n\n\n# Couverture irredondante d'un ensemble de DF {background-color=\"#1c191c\"}\n\n\n---\n\n::: {.callout-important}\n\n### Définition de la couverture irredondante d'un ensemble de DFs\n\nSoit  $\\Sigma$ un ensemble de DF, une *couverture minimale/irredondante* de  $\\Sigma$ est un ensemble $\\Sigma'$ de DF qui vérifie :\n\n- Chaque DF de $\\Sigma'$ est de la forme $X → A$, où $A$ est un attribut\n\n- $\\Sigma'$ et $\\Sigma$ sont équivalents  ($\\Sigma \\models \\Sigma'$  et $\\Sigma' \\models \\Sigma$)\n\n- Aucun sous-ensemble *propre* de $\\Sigma'$ n'implique $\\Sigma$  ($∀ \\Sigma^{\\prime\\prime} ⊊ \\Sigma^\\prime, \\Sigma^{\\prime\\prime} \\not\\models \\Sigma$)\n\n- Pour toute dépendance $X → A$ de $\\Sigma'$, $\\forall Y ⊊ X, \\Sigma \\not\\models Y→ A$ \n\n:::\n\n---\n\n\n{{< fa hand-point-right >}} Dans une couverture irredondante, toutes des DFs sont utiles, chaque DF est minimale (c'est vrai pour le membre droit comme pour le membre gauche)\n\n. . .\n\n{{< fa brain >}} {{< fa mug-hot >}}\n\n- Existence de couvertures irredondantes \n\n- Unicité\n  \n- Construction de couvertures irredondantes \n\n- Si pas unicité des couvertures irredondantes,  les couvertures irredondantes sont-elles toutes également intéressantes ?\n \n## Algorithme de construction de couverture irredondante  {.scrollable}\n\n```pseudocode\n#| html-indent-size: \"1.2em\"\n#| html-comment-delimiter: \"//\"\n#| html-line-number: true\n#| html-line-number-punc: \":\"\n#| html-no-end: false\n\n\\begin{algorithm}\n\\caption{Couverture irredondante}\n\\begin{algorithmic}\n\\Procedure{MinCover}{$Σ$}\n\\State Σ' ← ∅ \n\n\\State \\Comment{Normaliser les éléments de Σ}\n\n\\For{$(X → Y) ∈ Σ$}\n  \\For{$y ∈ Y$}\n    \\State Σ' ← Σ' ∪ {X → y}\n  \\EndFor\n\\EndFor\n\n\\State \\Comment{Éliminer les dépendances redondantes dans Σ'}\n\n\\State \\Comment{Miniser les dépendances  dans Σ'}\n\n\\Return Σ'\n\n\\EndProcedure\n\\end{algorithmic}\n\\end{algorithm}\n```\n\n## Détails\n\n::: {.columns}\n::: {.column width=\"45%\"}\n\n```pseudocode\n#| html-indent-size: \"1.2em\"\n#| html-comment-delimiter: \"//\"\n#| html-line-number: true\n#| html-line-number-punc: \":\"\n#| html-no-end: false\n\n\\begin{algorithm}\n\\caption{Éliminer les dépendances redondantes dans Σ' (détail)}\n\\begin{algorithmic}\n\n\\Repeat\n  \\State s ← \\True\n  \\For{$(X → y) ∈ Σ'$}\n    \\If{$Σ' \\setminus {X → y} ⊧ X → y$}\n      \\State $Σ' ← Σ' \\setminus {X → y}$\n      \\State s ← \\False\n    \\EndIf\n  \\EndFor\n\\Until{s}\n\n\\end{algorithmic}\n\\end{algorithm}\n```\n\n:::\n\n::: {.column width=\"55%\"}\n\n```pseudocode\n#| html-indent-size: \"1.2em\"\n#| html-comment-delimiter: \"//\"\n#| html-line-number: true\n#| html-line-number-punc: \":\"\n#| html-no-end: false\n\n\\begin{algorithm}\n\\caption{Miniser les dépendances  dans Σ' (détail)}\n\\begin{algorithmic}\n\n\\Repeat\n  \\State s ← \\True\n  \\For{$(X → y) ∈ Σ'$}\n    \\For{$x ∈ X$}\n      \\If{$Σ' \\setminus {X → y} ⊧ X \\setminus {x} → y$}\n        \\State $Σ' ← (Σ' \\setminus {X → y}) ∪ X \\setminus {x} → y$\n        \\State s ← \\False\n        \\Break\n      \\EndIf\n    \\EndFor\n  \\EndFor\n\\Until{s}\n\n\\end{algorithmic}\n\\end{algorithm}\n```\n\n:::\n::: \n\n\n\n\n# Forme Normale 3 (FN3)   {background-color=\"#1c191c\"}\n\n\n## Définition : forme normale 3 (FN3)\n\n::: {.callout-important}\n\nUn schéma relationnel $\\mathcal{A}$ est en forme normale 3 (FN3) relativement à un ensemble de DF Σ ssi \npour toute dépendance non triviale `X → Y`de Σ, on a \n\n- le membre gauche `X` est une super-clé  *ou*\n- le membre droit `Y` fait partie d'une clé\n\n:::\n\n\n::: {.aside}\n\nLe schéma $\\mathcal{A} =$ `{Ville, Rue, Numéro, #Bureau_vote}` est en FN3 relativement à `Σ = { Ville, Nom, Rue → #Bureau_vote,  #Bureau_vote  →  Ville }`\n\nMais ce schéma n'est pas en FNBC.\n\n:::\n\n\n## Pourquoi deux notions de forme normale ?\n\n::: {.callout-note}\n\n### Proposition \n\nSi un schéma $\\mathcal{A}$ est en forme normale Boyce-Codd (FNBC) relativement à un ensemble de DF Σ, alors $\\mathcal{A}$ est en forme normale 3 (FN3) relativement à  Σ\n\n:::\n\n::: {.aside}\n\nLa réciproque est fausse\n\n:::\n\n\n## Exercice \n\n$\\mathcal{A}=$ `(A, B, C, D, E)` et `Σ={A → C, BC → D, AD → E}`\n\n- Quelles sont les clés ?\n- Le schéma est-il en FNBC ?\n- Si non, propopsez une décomposition SPI en FNBC. Est-elle sans perte de DF?\n- Le schéma est-il en FN3 ? \n\n## Intérêt  de la forme normale 3 (FN3)\n\nRedondance limitée\n\n. . .\n\nPossibilité de décomposition SPI et sans perte de Dépendances Fonctionnelles\n\n\n\n# Algorithme de Décomposition en FN3  {background-color=\"#1c191c\"}\n\n## Algorithme {.smaller}\n\n```pseudocode\n#| html-indent-size: \"1.2em\"\n#| html-comment-delimiter: \"//\"\n#| html-line-number: true\n#| html-line-number-punc: \":\"\n#| html-no-end: false\n\n\\begin{algorithm}\n\\caption{Decomposition FN3}\n\\begin{algorithmic}\n\\Procedure{DecompositionFN3}{$\\mathcal{A}, Σ$}\n\n\\State \\Comment{Initialisation de la décomposition}\n\\State $D ←  ∅$\n\n\\State \\Comment{Mise en forme des courverture minimale de Σ}\n\\State Σ' ← \\Call{MinCover}{$Σ$}\n\\State\n\\For{Each distinct determinant $X$ amongst FDs in Σ'}\n  \\State $Y ← \\{y : X → y ∈ Σ'\\}$\n  \\State $D ← D \\cup \\{X \\cup Y\\}$ \\Comment{    Ajouter $X \\cup Y$ à $D$}\n\\EndFor\n\\State\n\\State $\\mathcal{B} ← $ Attributes in  $\\mathcal{A}$  that do not occur in $D$ \n\\State $D ← D \\cup \\{\\mathcal{B}\\}$\n\\State\n\\If{No component of $D$ includes a key for $\\mathcal{A}, Σ$}\n  \\State $D ← D \\cup $ some key for $\\mathcal{A}, Σ$\n\\EndIf\n\\State\n\\Return $D$\n\n\\EndProcedure\n\n\\end{algorithmic}\n\\end{algorithm}\n```\n\n\n\n---\n\n\n::: {.callout-important}\n\n### Proposition \n\nL'algorithme termine en un nombre fini d'itérations\n\nLa décomposition produite par l'algorithme est \n\n- en FN3\n\n- sans perte d'information\n\n- sans perte de dépendances fonctionnelles\n\n:::\n\n\n## Preuves \n\n### Terminaison {{< fa person-chalkboard >}}\n\n### FN3 {{< fa person-chalkboard >}}\n\n### SPI {{< fa person-chalkboard >}}\n\n### SPDF {{< fa person-chalkboard >}}\n\n\n\n\n# Fin   {background-color=\"#1c191c\"}",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}