{
  "hash": "4fcd5e5a1d43f63dc588412eb574d3c3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Normalisation II : Décompositions SPD, SPI, FN3 et FNBC\"\nsubtitle: \"Décompositions, Pertes de DF, Pertes d'informations, Décompositions FN3, Décompositions FNBC.\"\ndate: \"2025-12-08\"\n\nformat: \n  revealjs:\n    header: \"Décompositions, Pertes de DF, Pertes d'informations, Décompositions FN3, Décompositions FNBC.\"\n\nengine: knitr\n---\n\n\n\n# Décomposition d'une relation {background-color=\"#1c191c\"}\n\n## Idée\n\nDans un système de BDD *relationnelles*, les données sont représentées par des tuples qui décrivent des relations. Lorsqu'on définit des tables dans une base de données, on décompose ces relations en plusieurs relations $R_1$, $R_2$, $\\dots$, les tables de la BDD.\n\n\nMais on ne peut pas décomposer arbitrairement. Toutes les décompositions ne sont pas pertinentes.\n\n. . .\n\n::: {.callout-important}\n\n### Conditions pour une décomposition *pertinente* :\n\n- Décomposition *sans perte de dépendance fonctionnelle*.\n\n- Décomposition *sans perte d'information*.\n\n- Décomposition qui minimise les redondances : notions de Forme Normale.\n\n:::\n\n\n## Décomposition\n \n::: {.callout-important}\n### Définition \nSoit $\\mathcal{A}$ un schéma de relation, on dit que $\\left\\{\\mathcal{A}_1,\\dots ,\\mathcal{A}_k\\right\\}$ est une décomposition de $\\mathcal{A}$ si et seulement si,\n\n- pour tout $i$, $\\mathcal{A}_i  \\not=\\emptyset$,\n- ${\\displaystyle \\bigcup_{i=1}^k \\mathcal{A}_i  = \\mathcal{A}}$\n:::\n\n. . .\n\n:::{.callout-note}\n\n{{< fa hand-point-right >}} Une décomposition n'est pas une partition. On n'impose pas que les $\\mathcal{A}_i$ soient deux à deux disjoints. Comme nous le verrons, ils ne doivent pas l'être, sinon, il n'y a plus de jointure possible.\n:::\n\n\n\n## Exemple de décomposition I\n \n\n\n```{.default}\nVendeur(V#, Vnom, Vville)\nProduit(P#, Pnom, Pprix)\nLivraison(V#, P#, Qte)\n```\n\nest une décomposition de la relation\n\n\n```{.default}\nR(V#, Vnom, Vville, P#, Pnom, Pprix, Qte)\n```\n\n\n\n\n\n\n# Perte de dépendance fonctionnelle {background-color=\"#1c191c\"}\n\n\n## Projection d'un ensemble de DF\n\n::: {.callout-important}\n### Définition \nSoient $\\mathcal{A}$ et $\\mathcal{A}_1$ deux shémas tels que $\\mathcal{A}_1 \\subset \\mathcal{A}$, et $\\Sigma$ un ensemble de dépendances.\n\nOn appelle projection de $\\Sigma$ sur $\\mathcal{A}_1$  et on note $\\pi_{\\mathcal{A}_1}(\\Sigma)$ l'ensemble\n\n$$\\pi_{\\mathcal{A}_1}(\\Sigma)=\\left\\{ X\\to Y \\mid \\Sigma\\models X\\to Y \\text{ et } X,Y\\subset \\mathcal{A}_1\\right\\}$$\n\nAutrement dit, $\\pi_{\\mathcal{A}_1}(\\Sigma)$ est l'ensemble des dépendances impliquées par $\\Sigma$ qui sont locales à $\\mathcal{A}_1$.\n:::\n\n\n\n\n## Exemple {.smaller}\n\n-   ${\\mathcal{A}}=\\left\\{A,B,C\\right\\}$ et\n    $\\Sigma=\\left\\{A\\to B, B\\to C, C\\to A\\right\\}$\n\n-   $\\pi^{}_{\\left\\{A,B\\right\\}}(\\Sigma)$ est équivalent à\n    $\\left\\{A\\to B, B\\to A\\right\\}$\n\n\n## Fermeture et projection de DF\n\n::: {.callout-important}\n\n### Propriété immédiate\n\nSi $X$ et $Y$ sont des parties de ${\\mathcal{A}}_1$, on a l'équivalence\n$$X\\to Y \\in \\pi_{{\\mathcal{A}}_1}(\\Sigma) \\iff Y\\subset\\left\\{X\\right\\}^+$$\n\n:::\n\nC'est une traduction de la définition.\n\n\n## Algorithme de calcul de $\\pi_{{\\mathcal{A}}_1}(\\Sigma)$ \n\nCet algorithme utilise la propriété précédente pour calculer un ensemble de DF équivalent à $\\pi_{\\mathcal{A}_1}(\\Sigma)$\n\n```{=html}\n<pre style=\"background-color: #f0f0ffff;font-family:'Lucida Console','Courier New',monospace; color: #15093aff;font-size:1em;padding:10px;border:1px solid #220f61ff;\">\nfonction projection(A1, Σ)\n   P := ∅\n   for X ⊂ A1, X ≠ ∅, X ≠ A1\n      Y := X⁺ ∩ A1  \n      if Y ⊄ X     // X → Y n'est pas triviale\n         P := P ⋃ { X → Y\\X }\n   return P\n</pre>\n```\n\n::: {.callout-warning}\n### Très coûteux !\n\n- Le nombre de sous-ensembles $X$ considérés est $2^{\\#{\\mathcal{A}}_1}-2$.\n- $P$ n'est pas du tout irredondant.\n:::\n\n\n## Exemples {.smaller}\n\n${\\mathcal{A}}=\\left\\{A,B,C,D,E\\right\\}$ et\n    $\\Sigma=\\left\\{A\\to C, BC\\to D, AD\\to E\\right\\}$\n\n1.  $\\pi_{\\{AC\\}}(\\Sigma)$ ?\n    * on initialise $P=\\emptyset$ puis on calcule\n    * $\\left\\{A\\right\\}^+=\\left\\{A,C\\right\\}$ donc $P=\\left\\{A\\to C\\right\\}$ puis\n    * $\\left\\{C\\right\\}^+=\\left\\{C\\right\\}$ donc $P$ inchangé.\n    * L'algorithme se termine avec $P=\\left\\{A\\to C\\right\\}$\n\n\n\n2.  $\\pi_{ABD}(\\Sigma)$ ?\n    * $\\left\\{A\\right\\}^+=\\left\\{A,C\\right\\}$, $P$ vide\n    * $\\left\\{B\\right\\}^+=\\left\\{B\\right\\}$, $P$ vide\n    * $\\left\\{D\\right\\}^+=\\left\\{D\\right\\}$, $P$ vide\n    * $\\left\\{A,B\\right\\}^+=\\left\\{A,B,C,D,E\\right\\}$, $P=\\left\\{AB\\to D\\right\\}$\n    * $\\left\\{A,D\\right\\}^+=\\left\\{A,D,C,E\\right\\}$, $P$ inchangé\n    * $\\left\\{B,D\\right\\}^+=\\left\\{B,D\\right\\}$, $P$ inchangé.\n    * L'algorithme se termine avec $P=\\left\\{AB\\to D\\right\\}$\n\n## Exemples (suite)   {.smaller}\n\n${\\mathcal{A}}=\\left\\{A,B,C,D,E\\right\\}$ et\n    $\\Sigma=\\left\\{A\\to C, BC\\to D, AD\\to E\\right\\}$\n\n\n3.  $\\pi_{ABCE}(\\Sigma)$ ?\n    * $A^+=AC \\quad B^+=B \\quad C^+=C \\quad E^+=E$\\\n    * $AB^+=ABCDE \\quad AC^+=AC \\quad AE^+=AEC$\\\n    * $BC^+=BCD \\quad BE^+=BE \\quad CE^+=CE$\\\n    * $ABC^+=ABCDE \\quad ABE^+=ABECD$\\\n    * $BCE^+=BCED \\quad ACE^+=ACE$\n    * L'algorithme se termine avec $P=\\left\\{A\\to C, AB \\to CE, AE\\to C, ABC\\to E, ABE\\to C\\right\\}$.\n    * Simplification : $\\pi_{ABCE}(\\Sigma)$ équivaut à\n    $\\left\\{A\\to C, AB\\to E\\right\\}$ qui est minimal.\n\n\n\n\n##  Décomposition sans perte de DF\n\n::: {.callout-important}\n\n###  Définition\n\nSoient $\\mathcal{A}$ un schéma,  $\\Sigma$ un ensemble de DF sur $\\mathcal{A}$ et\n $\\left\\{ \\mathcal{A}_1,\\dots, \\mathcal{A}_k\\right\\}$ une décomposition de $\\mathcal{A}$.\n\nLa décomposition $\\left\\{\\mathcal{A}_1,\\dots, \\mathcal{A}_k\\right\\}$ *préserve* $\\Sigma \\quad \\quad$\nssi $\\quad \\quad{\\displaystyle \\bigcup_{i=1}^k \\pi_{\\mathcal{A}_i}(\\Sigma)}$ est équivalent à $\\Sigma$.\n\nOn dit que la décomposition est *sans perte de dépendance (SPD)*.\n:::\n\n\n::: {.callout-note}\n### Propriété immédiate\n\nSi $\\Sigma$ est équivalent à un ensemble de *dépendances fonctionnelles locales*,\nla décomposition est SPD.\n:::\n\n\n\n## Vérification qu'une DF est préservée\n\n::: {.callout-important}\n### Propriété\n$X\\to Y$ est préservée ssi la fermeture de $X$ par rapport à \n${\\displaystyle \\bigcup_{i=1}^k \\pi_{\\mathcal{A}_i}(\\Sigma)}$ contient $Y$.\n\n:::\n\n::: {.callout-note}\n### Notations\n\nDans la suite du cours, on note :\n\n- $\\Sigma_{\\mathcal{A}_1,...,\\mathcal{A}_k}={\\displaystyle \\bigcup_{i=1}^k \\pi_{\\mathcal{A}_i}(\\Sigma)}$\n- $X^+_{\\mathcal{A}_1,...,\\mathcal{A}_k}$ la fermeture de $X$ par rapport à $\\Sigma_{\\mathcal{A}_1,...,\\mathcal{A}_k}$.\n:::\n\n## Algorithme de vérification \n\nL'algorithme retourne $X^+_{\\mathcal{A}_1,...,\\mathcal{A}_k}$\n\n:::::{.columns}\n\n:::{.column width=\"60%\"}\n\n```{=html}\n<pre style=\"background-color: #f0f0ffff;font-family:'Lucida Console','Courier New',monospace; color: #15093aff;font-size:0.7em;padding:10px;border:1px solid #220f61ff;\">\nfonction fermeture_decomposition({A1,...,Ak}, Σ, X)\n   Z := X\n   go := True\n   while go\n      W := Z\n      For i ∈ {1, ..., k}\n         W := W ⋃ ((W ∩ Ai)⁺ ∩ Ai)\n      if W ≠ Z\n         Z := W\n      else\n         go := False\n   return Z\n</pre>\n```\n\n:::\n\n:::{.column width=\"5%\"}\n\n:::\n\n:::{.column width=\"35%\"} \n\n:::{.callout-warning}\n\n- Si au cours du calcul, on obtient que $Y\\subset Z$, on peut conclure immédiatement que $X\\to Y$ est préservée.\n\n- L'intérêt de cet algorithme est qu'il n'est pas nécessaire de calculer les DF locales.\n\n:::\n\n:::\n\n:::::\n\n## Vérification qu'une décomposition est SPD\n\n::: {.callout-important}\n### Propriété\n\nUne décomposition $\\left\\{\\mathcal{A}_1,\\dots ,\\mathcal{A}_k\\right\\}$ est sans perte de DF (SPD) si \n\n- Pour tout $X\\to Y \\in \\Sigma$, $\\quad X^+_{\\mathcal{A}_1,...,\\mathcal{A}_k}$ contient $Y$.\n\n:::\n\n\n\n## Exemple I  {.smaller}\n\n\n- $\\mathcal{A}=\\left\\{A,B,C,D\\right\\}$, \n- $\\mathcal{A}_1=\\left\\{A,B\\right\\}$, $\\mathcal{A}_2=\\left\\{B,C\\right\\}$, $\\mathcal{A}_3=\\left\\{C,D\\right\\}$\n\n- $\\Sigma=\\left\\{A\\to B, B\\to C, C\\to D, D\\to A\\right\\}$\n\n- Est-ce que la décomposition $\\left\\{\\mathcal{A}_1,\\mathcal{A}_2,\\mathcal{A}_3\\right\\}$ préserve $\\Sigma$ ?\n\n. . .\n\n- Les DF locales $A\\to B$, $B\\to C$, $C\\to D$ sont locales donc conservées.\n\n- Est-ce que les DF locales impliquent $D\\to A$ ? \n\n. . . \n\nVérification en appliquant l'algorithme de calcul de $\\{D\\}^+_{\\mathcal{A}_1,\\mathcal{A}_2,\\mathcal{A}_3}$.\n\nInitialisation $Z := \\{D\\}$\n\n1. $(\\{D\\}\\cap\\{CD\\})^+ \\cap \\{CD\\}=\\{D\\}^+ \\cap\\{CD\\}=\\{DABC\\} \\cap \\{CD\\}=\\{CD\\}$, $Z := \\{CD\\}$\n\n2. $(\\{DC\\}\\cap \\{BC\\})^+ \\cap \\{BC\\}=\\{C\\}^+ \\cap \\{BC\\}=\\{CDAB\\}\\cap \\{BC\\}=\\{BC\\}$, $Z := \\{BCD\\}$\n\n3. $(\\{DCB\\}\\cap \\{AB\\})^+ \\cap \\{AB\\}=\\{B\\}^+ \\cap \\{AB\\}=\\{BCDA\\} \\cap \\{AB\\}$, $Z := \\{ABCD\\}$\n\n4. $\\{DCBA\\}$ contient $A$ donc $D\\to A$ est préservée.\n\n\n## Exemple I suite   {.smaller}\n\n- $\\mathcal{A}=\\left\\{A,B,C,D\\right\\}$, \n- $\\mathcal{A}_1=\\left\\{A,B\\right\\}$, $\\mathcal{A}_2=\\left\\{B,C\\right\\}$, $\\mathcal{A}_3=\\left\\{C,D\\right\\}$\n\nOn pouvait voir aussi que \n\n- $\\Sigma=\\left\\{A\\to B, B\\to C, C\\to D, D\\to A\\right\\}$ est équivalent à l'ensemble de DF $\\Sigma' =\\left\\{A\\to B, B\\to A, B\\to C, C\\to B, C\\to D, D\\to C\\right\\}$ car la fermeture de toute partie non vide de $\\mathcal{A}$ par $\\Sigma'$ est $\\mathcal{A}$ comme pour $\\Sigma$ (chaque attribut est une clé). \n\n- les DF de $\\Sigma'$ sont locales donc préservées, la décomposition préserve  $\\Sigma'$ donc  $\\Sigma$. \n\n\n\n## Exemple II {.smaller}\n\n\n- $\\mathcal{A}= \\{\\verb!Ville, CP, Rue, Numero!\\}$\n\n- $\\Sigma= \\{\\verb!CP →  Ville ; Ville Rue Numero → CP!\\}$\n\n- $\\mathcal{A}_1=\\{\\verb!Ville, CP!\\}$ et $\\mathcal{A}_2=\\{\\verb!Rue, Numero, CP!\\}$\n\n- Est-ce que la décomposition  $\\{\\mathcal{A}_1, \\mathcal{A}_2 \\}$ préserve $\\Sigma$ ?\n\n. . .\n\n- $\\verb!CP →  Ville!$ est préservée car elle est locale à $\\mathcal{A}_1$\n\n\n. . .\n\n\n- Est-ce que $\\verb!Ville Rue Numero → CP!$ est préservée par $\\mathcal{A}_1, \\mathcal{A}_2$ ?\n\n. . .\n\non calcule la fermeture $\\{\\verb!Ville, Rue, Numero!\\}^+_{\\mathcal{A}_1,\\mathcal{A}_2}$.\n\n$\\verb!Z! := \\{\\verb!Ville, Rue, Numero!\\}$\n\n1. $(\\verb!Z !\\cap \\{\\verb!Ville, CP!\\})^+ \\cap \\{\\verb!Ville, CP!\\} = \\{\\verb!Ville!\\}$,   *rien à ajouter*.\n\n2. $\\verb!(Z !\\cap \\{\\verb!Rue, Numero, CP!\\})^+ \\cap \\{\\verb!Rue, Numero, CP!\\} = \\{\\verb!Rue, Numero!\\}$, *rien à ajouter*.\n\n. . .\n\n$\\{\\verb!Ville, Rue, Numero!\\}^+_{\\mathcal{A}_1,\\mathcal{A}_2}= \\{\\verb!Ville, Rue, Numero!\\}\\quad$ donc $\\verb!Ville Rue Numero → CP!$ n'est pas préservée.\n\n\n\n# Décomposition sans perte d'information  {background-color=\"#1c191c\"}\n\n## Décomposition sans perte d'information\n\n**Idée** : Si on remplace le schéma\n\n\n```{.default}\n(V#, Vnom, Vville, P#, Pnom, Pprix, Qte)\n```\n\npar les trois schémas\n\n\n```{.default}\nVendeur(V#, Vnom, Vville)\nProduit(P#, Pnom, Pprix)\nLivraison(V#, P#, Qte)\n```\n\n. . .\n\nalors au lieu de stocker une relation `R(V#, Vnom, Vville, P#, Pnom, Pprix, Qte)`, on stockera\nses projections:\n\n\n$$\\pi_{\\texttt{V\\#,Vnom,Vville}}(\\texttt{R}) \\qquad \\pi_{\\texttt{P\\#,Pnom,Pprix}}(\\texttt{R}) \\qquad \\pi_{\\texttt{V\\#,P\\#,Qte}}(\\texttt{R})$$\n\n. . .\n\n{{< fa brain >}} Peut-on retrouver `R` par jointure à partir de ces trois projections ?\n\n\n\n## Décomposition sans perte d'information (SPI)\n\n\n::: {.callout-important}\n\n### Définition : décomposition SPI\n\nSoit $\\mathcal{A}$ un schéma de relation et $\\Sigma$ un ensemble de DF sur $\\mathcal{A}$.\n\nUne décomposition $\\mathcal{D} = \\{\\mathcal{A}_1,..., \\mathcal{A}_n\\}$ est *sans perte d'information par rapport à* $\\Sigma$ si pour toute relation $R$  de schéma $\\mathcal{A}$ satisfaisant $\\Sigma$,  \n\n- $R = R_1 \\bowtie R_2 \\bowtie...\\bowtie R_n \\quad$ \n- où les $\\bowtie$ sont des jointures naturelles.\n- et où, pour tout $i$, $R_i$ est la projection de $R$ sur le sous-schéma  $\\mathcal{A}_i$.\n:::\n\n. . .\n\n:::{.callout-note}\n\n- La jointure est l'opération inverse de la décomposition, on recompose l'information par jointure. \n\n- La décomposition doit garantir que pour toute relation `R`, ses projections contiennent\nla même information que `R` au sens que l'on doit pouvoir reconstruire `R` par jointure à partir de ses projections.\n\n:::\n\n\n{{< fa hand-point-right >}} La propriété d'être sans perte d'information est liée à l'ensemble de DF considéré\n\n## Exemple de décomposition SPD  {.smaller}\n\nOn décompose une relation $\\verb!R!(\\texttt{V\\#, Vnom, Vville, P\\#, Pnom, Pprix, Qte})$ vérifiant\n\n$\\Sigma = \\{\\texttt{V\\#} \\to \\texttt{Vnom Vville}\\ , \\ \\texttt{P\\#} \\to \\texttt{Pnom Pprix}\\ , \\ \\texttt{V\\# P\\#} \\to \\texttt{Qte} \\}$\nen 3 relations \n\n- $\\verb!Vendeur!=\\pi_{\\texttt{V\\#,Vnom,Vville}}(R)$\n- $\\verb!Produit!=\\pi_{\\texttt{P\\#,Pnom,Pprix}}(R)$\n- $\\verb!Livraison!=\\pi_{\\texttt{V\\#,P\\#,Qte}}(R)$\n\nPeut-on affirmer que\n\n$$\\verb!R! = \\verb!Vendeur! \\bowtie \\verb!Livraison! \\bowtie \\verb!Produit! \\quad ?$$\n\nOn a envie de dire mais pourquoi et comment le prouver ?\n\n\n\n## Exemple de décomposition avec perte d'information  {.smaller}\n\n$\\mathcal{A}=\\{A,B,C\\} \\quad  \\Sigma=\\{AB\\rightarrow C\\}$\n\nDécomposition $\\mathcal{A}_1=\\{A,B\\}  \\quad  \\mathcal{A}_2=\\{B,C\\}$\n\n::::: {.columns}\n::: {.column width=\"30%\"}\n\nSoit $R$ la relation\n\n| A   |  B  |  C  |\n|:---:|:---:|:---:|\n|1 | 2 | 3 |\n|4 | 2 | 5 |\n\n:::\n\n::: {.column width=\"30%\"}\n\n$\\pi_{AB}(R)=$\n\n| A |  B |\n|:---:|:---:|\n| 1 | 2  |\n| 4 | 2  |\n\n:::\n\n\n::: {.column width=\"30%\"}\n\n$\\pi_{BC}(R)=$\n\n| B |  C |\n|:---:|:---:|\n| 2 | 3  |\n| 2 | 5  |\n\n:::\n\n:::::\n\n$\\pi_{AB}(R) \\bowtie \\pi_{BC}(R)=$\n\n| A   |  B  |  C  |\n|:---:|:---:|:---:|\n|   1 | 2   | 3   |\n|   4 | 2   | 5   |\n| **1** | **2** | **5** |\n| **4** | **2** | **3** |\n\n\n\n\n# Algorithme de poursuite  {background-color=\"#1c191c\"}\n\n\n\n## Algorithme de poursuite  (chase algorithm)\n\n- Le risque d'une mauvaise décomposition est que les jointures créent des tuples qui n'éxistaient pas dans la relation initiale (voir l'exemple précédent de décomposition avec perte d'information).\n\n- Pour le savoir, un algorithme simple existe appelé *algorithme de poursuite*\n\n\n\n## Algorithme de poursuite : exemple\n\n\nOn décompose  une relation $\\verb!R!(\\texttt{V\\#, Vnom, Vville, P\\#, Pnom, Pprix, Qte})$ vérifiant\n$\\Sigma = \\{\\texttt{V\\#} \\to \\texttt{Vnom Vville}\\ , \\ \\texttt{P\\#} \\to \\texttt{Pnom Pprix}\\ , \\ \\texttt{V\\# P\\#} \\to \\texttt{Qte} \\}$\n\nen trois relations :\n\n- $\\verb!Vendeur!=\\pi_{\\texttt{V\\#,Vnom,Vville}}(R)$\n- $\\verb!Produit!=\\pi_{\\texttt{P\\#,Pnom,Pprix}}(R)$\n- $\\verb!Livraison!=\\pi_{\\texttt{V\\#,P\\#,Qte}}(R)$\n\nPar définition des projections et des jointures, on sait que : $\\texttt{R} \\subset \\verb!Vendeur! \\bowtie \\verb!Livraison! \\bowtie \\verb!Produit!$\n\n\nOn veut prouver que : $\\verb!Vendeur! \\bowtie \\verb!Livraison! \\bowtie \\verb!Produit! \\subset \\texttt{R}$\n\n\n\n\n\n## Algorithme de poursuite : exemple  {.smaller}\n\n\nSoit $t$ un tuple dans la jointure\n\n| V# |  Vnom |  Vville |  P# |  Pnom |  Pprix |  Qte |\n|:--:|:------|:------|:---:|:------|:------|:------|\n| $a$ | $b$ | $c$ | $d$ | $e$ | $f$ | $g$ |\n\nOn veut prouver que $t \\in R$.\n\nPar définition des projections :\n\n- $(a, b, c)\\in \\texttt{Vendeur}$ donc\nil existe $e_1, f_1, g_1$ tels que  $(a, b, c, d_1, e_1, f_1, g_1) \\in \\texttt{R}$\n\n- $(d,e,f) \\in \\texttt{Produit}$ donc il existe $a_2, b_2, c_2, g_2$ tels que\n$(a_2, b_2, c_2, d, e, f, g_2)\\in \\texttt{R}$\n\n- $(a,d,g)\\in \\texttt{Livraison}$ donc il existe $b_3,c_3,e_3,f_3$ tels que\n$(a,b_3,c_3,d,e_3,f_3,g)\\in \\texttt{R}$\n\n- On peut le représenter comme ceci :\n\n|       | `V#` |  `Vnom` |  `Vville` |  `P#` |  `Pnom` |  `Pprix` |  `Qte` |\n:------:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|\n|Vendeur | $a$  | $b$  | $c$  | $d_1$ | $e_1$ | $f_1$ | $g_1$ |\n|Produit | $a_2$ | $b_2$ | $c_2$ | $d$  | $e$  | $f$  | $g_2$ |\n|Livraison | $a$  | $b_3$ | $c_3$ | $d$  | $e_3$ | $f_3$ | $g$  |\n\n\n\n\n\n## Algorithme de poursuite : exemple   {.smaller}\n\n\n|         | `V#` |  `Vnom` |  `Vville` |  `P#` |  `Pnom` |  `Pprix` |  `Qte` |\n|:------:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|\n|Vendeur | $a$  | $b$  | $c$  | $d_1$ | $e_1$ | $f_1$ | $g_1$ |\n|Produit | $a_2$ | $b_2$ | $c_2$ | $d$  | $e$  | $f$  | $g_2$ |\n|Livraison | $a$  | $b_3$ | $c_3$ | $d$  | $e_3$ | $f_3$ | $g$  |\n\n\n\n`V#` → `Vnom`, `Vville` donc $b_3=b$ et $c_3=c$\n\n| | `V#` |  `Vnom` |  `Vville` |  `P#` |  `Pnom` |  `Pprix` |  `Qte` |\n|:------: |:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|\n|Vendeur | $a$  | $b$  | $c$  | $d_1$ | $e_1$ | $f_1$ | $g_1$ |\n|Produit | $a_2$ | $b_2$ | $c_2$ | $d$  | $e$  | $f$  | $g_2$ |\n|Livraison | $a$  | $b$ | $c$ | $d$  | $e_3$ | $f_3$ | $g$  |\n\n\n\n## Algorithme de poursuite : exemple (suite)  {.smaller}\n\n`P#→ Pnom, Pprix` donc $e_3=e$ et $f_3=f$\n\n\n| | `V#` |  `Vnom` |  `Vville` |  `P#` |  `Pnom` |  `Pprix` |  `Qte` |\n|:------:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|\n|Vendeur | $a$  | $b$  | $c$  | $d_1$ | $e_1$ | $f_1$ | $g_1$ |\n|Produit | $a_2$ | $b_2$ | $c_2$ | $d$  | $e$  | $f$  | $g_2$ |\n|Livraison | $a$  | $b$ | $c$ | $d$  | $e$ | $f$ | $g$  |\n\nOn a obtenu une ligne égale au tuple $t=(a,b,c,d,e,f,g)$ donc $t\\in \\texttt{R}$ (tous les tuples qui se projettent sur $a,f,g$ coïncident avec $t$ du fait des clés des trois relations).\n\nOn en déduit que la décomposition est **Sans Perte d'Information (SPI)**.\n\n\n## Algorithme de poursuite : cas général  {.smaller}\n\n- **Entrée** : un schéma $\\mathcal{A}$, une décomposition $\\{\\mathcal{A}_1,...,\\mathcal{A}_k\\}$ et un ensemble $\\Sigma$ de DF\n\n- Pour chaque attribut de $\\mathcal{A}$, choisir un symbole (par exemple $a$, $b$, $c$,...). La correspondance doit être injective.\n\n- Construire un tableau dont les colonnes sont les attributs de $\\mathcal{A}$\n\nLe tableau a une ligne pour chaque $\\mathcal{A}_i$\n\nSur la ligne associée à $\\mathcal{A}_i$, les positions correspondant à $\\mathcal{A}_i$ sont remplies avec les symboles choisis.\n\nLes autres positions sont remplies avec les symboles indicés par $i$\n\n- Répéter tant que possible : s'il existe une DF $X\\rightarrow Y$ dans $\\Sigma$ et deux lignes du tableau\nen accord sur $X$, égaliser ces deux lignes sur $Y$\n\n- **Sortie** : Si on obtient une ligne sans valeur indicée, la décomposition est sans perte d'information, sinon il y a perte d'information\n\n<!--\n## Commentaires  sur l'algorithme de poursuite {.smaller}\n\nL'objectif de l'algorithme de poursuite est de vérifier que tout tuple de  $\\pi_{\\mathcal{A}_1}(R) \\bowtie \\pi_{\\mathcal{A}_2}(R) \\bowtie...\\bowtie\\pi_{\\mathcal{A}_k}(R)$ est aussi un tuple de $R$\n\nÀ l'initialisation, on part d'un tuple de $\\pi_{\\mathcal{A}_1}(R) \\bowtie \\pi_{\\mathcal{A}_2}(R) \\bowtie...\\bowtie\\pi_{\\mathcal{A}_k}(R)$ qu'on note symboliquement $(a, b, c, \\ldots)$ avec des symboles non indicés\n\nPour chaque $i \\leq k$, on utilise le fait que pour chaque tuple de  $\\pi_{\\mathcal{A}_i}(R)$ il existe un ensemble de tuples de $R$ \nqui coïncident avec $(a, b, c, \\ldots)$ sur $\\mathcal{A}_i$. On note génériquement ces tuples de $R$ en indiçant les noms de variables par $i$ pour toutes les variables qui ne sont pas dans $\\mathcal{A}_i$ \n\nChacun des  sous-ensembles de tuples indicés par  $i \\leq k$   définit un sous-ensemble de tuples de $R$\n\nOn veut se convaincre que $(a, b, c, \\ldots)$ appartient à l'un de ces sous-ensembles\n\n. . .\n\nL'algorithme de poursuite utilise les DF de Σ, pour restreindre les $k$ sous-ensembles  \n\n\n## Commentaires (suite)  {.smaller}\n\nL'algorithme de poursuite est un algorithme de *réécriture*\n\n. . .\n\nL'algorithme de poursuite est *non-déterministe* : à chaque étape,  il est parfois possible d'invoquer \nplusieurs DFs pour réécrire une ou plusieurs lignes\n\n. . .\n\nUn point important de l'analyse de l'algorithme de poursuite consiste à vérifier que ce non-déterminisme n'est \npas un problème : l'algorithme de poursuite termine par un succès ou un échec (blocage) quelle que soit la suite \ndes choix effectués \n\n::: {.proof}\n\n### {{< fa person-chalkboard >}}\n\n:::\n-->\n\n## Algorithme de poursuite : exemple 2 {.smaller}\n\nConsidérons l'exemple : $\\mathcal{A}=\\{A,B,C,D\\}$ avec $\\mathcal{A}_1=\\{A,B\\}$, $\\mathcal{A}_2=\\{B,C\\}$ et $\\mathcal{A}_3=\\{C,D\\}$\n\nSoit $\\Sigma=\\{{C}\\rightarrow{D}; {B}\\rightarrow{A}\\}$.\n\nSoit $t=(a,b,c,d)$. Soit $t_1,t_2,t_3$ les tuples de $R$ suivants:\n\n\n|  | A | B | C | D  |\n|:----|:----:|:----:|:----:|:----:|\n| $t_1$ | `a` | `b` | $c_1$ | $d_1$  |\n| $t_2$ | $a_2$ | `b` | `c` | $d_2$  |\n| $t_3$ | $a_3$ | $b_3$ | `c` | `d`  |\n\nOn a pris  $c_1,d_1, a_2,d_2, a_3,b_3$ comme valeurs variables et `a,b,c,d` comme constantes\n\n\n\n\n\n## Algorithme de poursuite - exemple 2  {.smaller}\n\n\n|  | A | B | C | D  |\n|:----|:----:|:----:|:----:|:----:|\n| $t_1$ | `a` | `b` |  $c_1$| $d_1$  |\n| $t_2$ | $a_2$ | `b` | `c` | $d_2$  |\n| $t_3$ | $a_3$ | $b_3$ | `c` | `d`  |\n\nPar la dépendance ${B}\\rightarrow{A}$, il vient :\n\n\n|  | A | B | C | D  |\n|:----|:----:|:----:|:----:|:----:|\n| $t_1$ | `a` | `b` |  $c_1$| $d_1$  |\n| $t_2$ | `a`  | `b` | `c` | $d_2$  |\n| $t_3$ | $a_3$ | $b_3$ | `c` | `d`  |\n\n\n\n## Algorithme de poursuite : exemple 2 {.smaller}\n\n\nPar la dépendance ${C}\\rightarrow{D}$, il vient :\n\n|  | A | B | C | D  |\n|:----|:----:|:----:|:----:|:----:|\n| $t_1$ | `a` | `b` |  $c_1$| $d_1$  |\n| $t_2$ |  `a`  | `b` | `c` |  `d`   |\n| $t_3$ | $a_3$ | $b_3$ | `c` | `d`  |\n\nOn a bien fait apparaître $t$ qui appartient donc à  $R$.\n\n\n\n## Algorithme de poursuite - exemple 3 {.smaller}\n\nConsidérons toujours l'exemple : $\\mathcal{A}=\\{A,B,C,D\\}$ avec\n\n$\\mathcal{A}_1=\\{A,B\\}$, $\\mathcal{A}_2=\\{B,C\\}$ et $\\mathcal{A}_3=\\{C,D\\}$\n\nMais avec  $\\Sigma=\\{{B}\\rightarrow{AD}\\}$.\n\n\n\n\n| A | B | C | D  |\n|:---:|:---:|:---:|:---:|\n| `a` | `b` |  $c_1$ | $d_1$  |\n| $a_2$ | `b` | `c` | $d_2$  |\n|  $a_3$ | $b_3$ | `c` | `d`  |\n\n\n\nDans ce cas, en utilisant la seule DF ${B}\\rightarrow{AD}$, on obtient $a_2=a$ et $d_1=d_2$ :\n\n| A | B | C | D  |\n|:---:|:---:|:---:|:---:|\n| `a` | `b` |  $c_1$ | $d_1$  |\n| `a` | `b` | `c` | $d_1$  |\n|  $a_3$ | $b_3$ | `c` | `d`  |\n\n\nOn ne peut pas aller plus loin, la décomposition est avec perte d'information.\n\n\n\n# Forme Normale 3 (FN3)   {background-color=\"#1c191c\"}\n\n## Objectif\n\n\n::: {.callout-note}\n\nConstruire une décomposition :\n\n- Sans Perte d'Information (SPI)\n- Sans perte de Dépendances Fonctionnelles\n- Dont les éléments sont en FN3 par rapports aux dépendances projetées \n\n:::\n\n\n## Forme normale 1 (FN1)\n\n::: {.callout-important}\n\n### Définition : forme normale 1 (FN1)\n\nUn schéma relationnel $\\mathcal{A}$ est en forme normale 1 (FN1) si tous les attributs ont des valeurs atomiques (pas de liste de valeurs).\n\n:::\n\n::: {.callout-note}\n\n### Proposition\nD'après la théorie de l'algèbrer relationnel, toute relation est en FN1.\n\n:::\n\n\n\n## Forme normale 2 (FN2)\n\n::: {.callout-note}\n### Idée\nUn schéma relationnel est en deuxième forme normale (FN2) si\ntout attribut non identifiant (extérieur à une clé) ne dépend pas d'une partie d'une clé mais de toute la clé.\n\nLa FN2 assure seulement une non-redondance partielle de l'information.\n:::\n\n. . .\n\n::: {.callout-important}\n\n### Définition : forme normale 2 (FN2)\n\nUn schéma relationnel $\\mathcal{A}$ est en forme normale 2 (FN2) relativement à un ensemble de DF $\\Sigma$ ssi \n\n- pour toute clé $X$ et tout $Y$ non inclus dans $X$, il n'existe pas $X'$ strictement inclus dans $X$ tel que $X' \\to Y$. \n\n:::\n\n. . .\n\n::: {.callout-note}\n### Méthode pour vérifier la FN2\n Pour toute clé $X$, vérifier que la fermeture de tout sous-ensemble strict de $X$ est inclus dans $X$.\n:::\n\n\n## Exemple  {.smaller}\n\nSchéma `Employé=(#projet, #employé, nom_employé, fonction)`\n\nOn suppose qu'on a les dépendances :\n\n- `#projet, #employé → fonction`\n- `#employé → nom_employé`\n\nLe schéma est-il en FN2 ?\n\n. . .\n\nLe schéma `Employé` n'est pas en FN2 à cause de la DF `#employé → nom_employé`.\n\nOn peut illustrer le problème de redondance par ces exemples de tuples :\n\n| `#projet` | `#employé` | `nom_employé` | `fonction` |\n|:---:|:---:|:---:|:---:|\n| p1 | e1 | n1 | f1 |\n| p2 | e1 | n1 | f2 |\n| p3 | e1 | n1 | f3 |\n\nOn constate bien une redondance pour la projection sur `(#employé, nom_employé)`.\n\n\n## Forme normale 3 (FN3)\n\n::: {.callout-note}\n### Idée\n\nUn schéma relationnel est en troisième forme normale (FN3) si il est en FN2 et si\ntous les attributs non identifiants (extérieur à une clé) dépendent directement d'une clé et pas par transitivité via des attributs qui ne sont pas dans une clé , autrement dit il est en FN3 s'il n'existe pas de dépendance fonctionnelle entre deux attributs non clés.\n\nLa FN3 assure une non-redondance partielle acceptable de l'information.\n:::\n\n. . .\n\n::: {.callout-important}\n### Définition : forme normale 3 (FN3)\n\nUn schéma relationnel $\\mathcal{A}$  est en forme normale 3 (FN3) relativement à un ensemble de DF $\\Sigma$ ssi pour toute dépendance non triviale $X \\to Y$ de $\\Sigma$, on a \n\n- le membre gauche $X$ est une super-clé\n- **ou** le membre droit $Y$ fait partie d'une clé.\n\n:::\n\n\n## Exemple 1 {.smaller}\n\n$\\mathcal{A_1}=(\\texttt{V\\#, Vnom, Vville}) \\quad \\mathcal{A_2}=(\\texttt{P\\#, Pnom, Pprix}) \\quad \\mathcal{A_3}=(\\texttt{V\\#, P\\#, Qte})$\n\n$\\Sigma = \\{\\texttt{V\\#} \\to \\texttt{Vnom Vville}\\ , \\ \\texttt{P\\#} \\to \\texttt{Pnom Pprix}\\ , \\ \\texttt{V\\# P\\#} \\to \\texttt{Qte} \\}$\n\nLa décomposition est-elle \n\n1. en FN3 ?\n2. SPD ?\n3. SPI ?\n\n. . .\n\n1. - $\\pi_{\\mathcal{A_1}}(\\Sigma)$ équivaut à $\\{\\texttt{V\\#} \\to \\texttt{Vnom Vville}\\}$ qui vérifie la FN3,\n   - $\\pi_{\\mathcal{A_2}}(\\Sigma)$ équivaut à $\\{\\texttt{P\\#} \\to \\texttt{Pnom Pprix}\\}$ qui vérifie la FN3, \n   - $\\pi_{\\mathcal{A_3}}(\\Sigma)$ équivaut à $\\{\\texttt{V\\# P\\#} \\to \\texttt{Qte}\\}$ qui vérifie la FN3.\n   - La décomposition est donc FN3.\n2. Elle est SPD car les DF de $\\Sigma$ sont locales à au moins un sous-schéma donc elles sont préservées.\n3. Elle est SPI (montré précédemment).\n\n\n## Exemple 2  {.smaller}\n\nSchéma `Employé=(#employé, nom_employé, #service, nom_service)`\n\nOn suppose qu'on a les dépendances :\n\n- `#employé → nom_employé, #service`\n- `#service → nom_service`\n\nLe schéma est-il en FN2, FN3 ?\n\n. . .\n\nLe schéma `Employé` a pour clé `#employé` qui est réduite à un attribut. Il est donc en FN2.\n\nIl n'est pas en FN3 à cause de la DF `#service → nom_service`.\n\nOn peut illustrer les redondances par ces exemples de tuples :\n\n| `#employé` | `nom_employé` | `#service` | `nom_service` |\n|:---:|:----:|:---:|:----:|\n| e1 | n1 | s1 | ns1 |\n| e2 | n2 | s1 | ns1 |\n| e3 | n3 | s1 | ns1 |\n\nOn constate bien une redondance pour la projection sur `(#service, nom_service)`.\n\n\n\n## Exemple 3 {.smaller}\n\n\n$\\mathcal{A}= (\\verb!A, B, C, D, E!)$ et $\\Sigma=\\{\\verb!A → C ; BC → D ; AD → E!\\}$\n\n1. Quelles sont les clés ?\n2. Le schéma est-il en FN2 ? en FN3 ?\n\n. . .\n\n1. Clé unique $\\verb!AB!$.\n   - $\\verb!A!$ et $\\verb!B!$ ne sont jamais à droite d'une dépendance donc toute clé doit contenir $\\{AB\\}$.\n   - $\\{AB\\}^+ = \\mathcal{A}$, $\\{A\\}^+ = \\mathcal{AC}$, $\\{B\\}^+ = \\mathcal{B}$.\n\n2. Ni FN2, ni FN3 car :\n   + $A \\to C$ ne vérifie pas la règle FN2.\n   + Aucune des DF de $\\Sigma$ ne vérifie la régle FN3. \n\n\n\n\n# Algorithme de décomposition en FN3 SPI et SPD {background-color=\"#1c191c\"}\n\n<!-- //idée mais non SPD chercher un algorithme\n## Décomposition en FN2\n\n::: {.callout-important}\n### Méthode\nSoit un schéma relationnel $\\mathcal{A}$ respectant les DF **irredondantes** $\\Sigma$ qui n'est pas FN2, c.a.d.\n\n- il existe une dépendance $X'\\to a$ qui n'est pas FN2, c.a.d. il existe une clé $X$, une sous-clé stricte $X'$, un attribut $a$ extérieur à $X$ tels que $X' \\to a$. \n- On pose B = \\{ b \\in \\mathcal{A}\\X | \\exists (X' \\to b) \\in \\Sigma}\n- On décompose $\\mathcal{A}$ en $\\mathcal{A_1} = (A\\B)$ et $\\mathcal{A_2} = (X' \\cup B)$\n\nAutrement dit, on enlève de $\\mathcal{A}$ les attributs déterminés par la sous clé $X'$ qui ne sont pas dans la clé $X$ et on les place dans un nouvelle relation $\\mathcal{A_2}$ avec la sous-clé $X'$.\n\nOn applique cette méthode récursivement jusqu'à avoir une décomposition FN2.\n:::\n\n::: {.callout-note}\nOn peut vérifier :\n- la décomposition est SPF.\n- la décomposition est SPI car on a laissé la clé $X$ de $\\mathcal{A}$ dans $\\mathcal{A1}$.\n:::\n\n-->\n\n\n## Algorithme de construction d'une FN3\n\n```{=html}\n<pre style=\"background-color: #f0f0ffff;font-family:'Lucida Console','Courier New',monospace; color: #15093aff;font-size:0.8em;padding:10px;border:1px solid #220f61ff;\">\nfonction decomposition_FN3(A, Σ)\n   D :=  ∅                // initialisation de la décomposition D\n   Σ' := min_cover(Σ)     // calcul d'une couverture minimale de Σ\n   \n   for each distinct left member X of a DF in Σ'\n      Y := {y | X → y ∈ Σ'}\n      D := D ⋃ {(X ⋃ Y)} // Ajouter le schéma (X ⋃ Y) à D\n   // la décomposition doit comprendre tous les attributs\n   B := {attributes in A that do not occur in D}\n   D := D ⋃ {(B)}        // Ajouter le schéma (B) à D\n   // dernière partie pour assurer une décomposition SPI\n   If no schemas includes a key of A, add a schema with a key of A\n\n   return D\n</pre>\n```\n\n::: {.callout-note}\n*Dernière partie de l'algorithme* : pour avoir une décomposition SPI, il faut s'assurer qu'il y a au-moins une clé de $\\mathcal{A}$ dans une des relations de décomposition. Si ce n'est pas le cas, il faut\najouter une relation contenant une clé de $\\mathcal{A}$.\n:::\n\n## Propriétés de l'algorithme\n\n::: {.callout-important}\n\n### Proposition \n\nL'algorithme termine en un nombre fini d'itérations.\n\nLa décomposition produite par l'algorithme est : \n\n- en FN3,\n\n- sans perte d'informations,\n\n- sans perte de dépendances fonctionnelles.\n\n:::\n\n## Exemple 1 {.smaller}\n\nSchéma $\\verb! Employé!=(\\verb!#projet, #employé, nom_employé, fonction!)$\n\n$\\Sigma = \\{\\verb! #projet #employé → fonction ; #employé → nom_employé! \\}$\n\n. . .\n\nLe schéma $\\verb!Employé!$ n'est pas en FN2 à cause de la DF $\\verb!#employé → nom_employé!$.\n\nAppliquons l'algorithme de construction d'une décomposition FN3.\n\n. . .\n\n- $\\Sigma$ est irredondante. \n\n- Pour le déterminant $\\verb! #employé!$ :  $\\  Y = \\{\\verb!nom_employé!\\}$, \n$\\ \\mathcal{A_1}= (\\verb!#employé!) \\cup Y = (\\verb!#employé!, \\verb!nom_employé!)$,\n\n- Pour le déterminant $\\verb! #projet!, \\verb!#employé!$ :  $\\  Y = \\{\\verb!fonction!\\}$, \n$\\  \\mathcal{A_2}= (\\verb!#projet!, \\verb!#employé!) \\cup Y = (\\verb!#projet!, \\verb!#employé!, \\verb!fonction!)$,\n\n- $\\  D=\\left\\{\\mathcal{A_1}, \\mathcal{A_2}\\right\\}$, tous les attributs initiaux sont présents dans la décomposition.  $B = \\emptyset$. On n'ajoute rien.\n\n- Le schéma initial a pour clé $(\\verb!#projet!, \\verb!#employé!)$ qui est présente dans $\\mathcal{A_2}$ donc on n'ajoute rien à la décomposition.\n\n- $\\left\\{\\mathcal{A_1}, \\mathcal{A_2}\\right\\}$ est une décomposition de $\\verb!Employé!$ en FN3 SPI et SPD.\n\n\n\n## Exemple 2  {.smaller}\n\nSchéma $\\verb! Employé!=(\\verb!#employé, nom_employé, #service, nom_service!)$\n\n$\\Sigma = \\{ \\verb!#employé → nom_employé ; #employé → #service ; #service → nom_service! \\}$\n\n. . .\n\nLe schéma $\\verb!Employé!$ a pour clé $\\verb!#employé!$, il est donc en FN2 mais pas en FN3 à cause de la DF $\\verb!#service → nom_service!$.\n\nAppliquons l'algorithme de construction d'une décomposition FN3.\n\n. . .\n\n- $\\Sigma$ est irredondante.\n\n- Pour le déterminant $\\verb! #employé!$ :  $\\  Y = \\{\\verb!nom_employé, #service!\\}$, \n$\\ \\mathcal{A_1}= (\\verb!#employé!) \\cup Y = (\\verb!#employé, nom_employé, #service!)$.\n\n- Pour le déterminant $\\verb! #service!$ :  $\\  Y = \\{\\verb!nom_service!\\}$, \n$\\  \\mathcal{A_2}= (\\verb!#service!) \\cup Y = (\\verb!#service!, \\verb!nom_service!)$.\n\n- $D=\\left\\{\\mathcal{A_1}, \\mathcal{A_2}\\right\\}$. Tous les attributs initiaux sont présents dans la décomposition.  $B = \\emptyset$. On n'ajoute rien.\n\n- Le schéma initial a pour clé $(\\verb!#employé!)$ qui est présente dans $\\mathcal{A_1}$ donc on n'ajoute rien à la décomposition.\n\n- $\\left\\{\\mathcal{A_1}, \\mathcal{A_2}\\right\\}$ est une décomposition de $\\verb!Employé!$ en FN3 SPI et SPD.\n\n\n\n## Exemple 3 {.smaller}\n\n$\\mathcal{A}=(\\texttt{V\\#, Vnom, Vville, P\\#, Pnom, Pprix, Qte})$\n\n$\\Sigma = \\{\\texttt{V\\#} \\to \\texttt{Vnom Vville}\\ , \\ \\texttt{P\\#} \\to \\texttt{Pnom Pprix}\\ , \\ \\texttt{V\\# P\\#} \\to \\texttt{Qte} \\}$\n\nAppliquer l'algorithme de décomposition à ce schéma relativement à $\\Sigma$.\n\n. . .\n\n$\\Sigma$ a pour couverture irredondante  $\\Sigma' = \\{\\texttt{V\\#} \\to \\texttt{Vnom}, \\ \\texttt{V\\#} \\to \\texttt{Vville},\\ \\texttt{P\\#} \\to \\texttt{Pnom}, \\ \\texttt{P\\#} \\to \\texttt{Pprix},\\ \\texttt{V\\# P\\#} \\to \\texttt{Qte} \\}$\n\n- Pour le déterminant $\\texttt{V\\#}$ :  $\\quad Y = \\{\\texttt{Vnom, Vville}\\}$, \n$\\quad \\mathcal{A_1}= (\\texttt{V\\#}) \\cup Y = (\\texttt{V\\#, Vnom, Vville})$,\n\n- Pour le déterminant $\\texttt{P\\#}$ :  $\\quad Y = \\{\\texttt{Pnom, Pprix}\\}$, \n$\\quad \\mathcal{A_2}= (\\texttt{P\\#}) \\cup Y = (\\texttt{P\\#, Pnom, Pprix})$,\n\n- Pour le déterminant $\\texttt{V\\# P\\#}$ :  $\\quad Y = \\{\\texttt{Qte}\\}$. \n$\\quad \\mathcal{A_3}= (\\texttt{V\\# P\\#}) \\cup Y = (\\texttt{V\\# P\\#, Qte})$,\n\n- $D=\\left\\{\\mathcal{A_1}, \\mathcal{A_2}, \\mathcal{A_3}\\right\\}$.\nTous les attributs initiaux sont présents dans la décomposition.  $B = \\emptyset$. On n'ajoute rien.\n\n- Le schéma initial a une clé unique $\\verb!V# P#!$. Elle est déjà incluse dans un des schémas présents donc on n'ajoute rien à la décomposition.\n\nOn obtient la même décomposition que celle déjà étudiée.\n$\\mathcal{A_1}=(\\texttt{V\\#, Vnom, Vville}), \\quad \\mathcal{A_2}=(\\texttt{P\\#, Pnom, Pprix}), \\quad \\mathcal{A_3}=(\\texttt{V\\#, P\\#, Qte})$\n\n\n## Exemple 4  {.smaller}\n\n\n$\\mathcal{A}= (\\verb!A, B, C, D, E!)$ et $\\Sigma =\\{\\verb!A → C ; BC → D ; AD → E!\\}$\n\nAppliquer l'algorithme de décomposition à ce schéma relativement à $\\Sigma$.\n\n. . .\n\n- En utilisant l'algorithme de calcul d'une couverture irredondante :\n\n   + La première phase de sélection donne $\\{A → C, BC → D, AD → E\\}$,\n   + La deuxième phase d'élimination d'attribut ne change rien.\n   + $\\Sigma$ est sous forme irredondante.\n\n. . .\n\n- Pour le déterminant $\\texttt{A}$ :  $\\quad Y = \\{\\texttt{C}\\}$, $\\quad \\mathcal{A_1}= (\\texttt{A,C})$,\n\n- Pour le déterminant $\\texttt{BC}$ :  $\\quad Y = \\{\\texttt{D}\\}$, $\\quad \\mathcal{A_2}= (\\texttt{B,C,D})$,\n\n- Pour le déterminant $\\texttt{AD}$ :  $\\quad Y = \\{\\texttt{E}\\}$, $\\quad \\mathcal{A_3}= (\\texttt{A,D,E})$,\n\n- $D=\\left\\{\\mathcal{A_1}, \\mathcal{A_2}, \\mathcal{A_3}\\right\\}$. Tous les attributs initiaux sont présents dans la décomposition.  On n'ajoute rien.\n\n- On a vu précédemment que le schéma initial a une clé unique $\\verb!AB!$. **Elle n'est incluse dans aucun des schémas présents donc on ajoute le schéma $\\mathcal{A_4}=(\\texttt{A,B})$ à la décomposition pour assurer une décomposition SPI**.\n\n- On obtient la décomposition $\\{(\\texttt{A,C}), (\\texttt{A,B,C,D}), (\\texttt{A,D,E}), (\\texttt{A,B})\\}$.\n\n\n\n\n# Forme normale de Boyce-Codd (FNBC) {background-color=\"#1c191c\"}\n\n\n## Forme normale de Boyce-Codd (FNBC)\n\n::: {.callout-important}\n\n### Définition\n\nUn schéma $\\mathcal{A}$ est en FNBC par rapport à un ensemble de dépendances fonctionnelles $\\Sigma$ sur $\\mathcal{A}$ ssi\n\n- pour toute DF non triviale $X\\rightarrow Y$ impliquée par $\\Sigma$, $X$ est une *sur-clé* (ou *super-clé*).\n\n:::\n\n\n## Vérifier la FNBC\n\n::: {.callout-important}\n\n### Proposition\n\nSoit $\\Sigma'$ un ensemble de DF équivalent à $\\Sigma$.\n\n$(\\mathcal{A},\\Sigma)$ est en FNBC si et seulement si pour toute DF non triviale de $\\Sigma'$, le membre de gauche est une sur-clé (super-clef).\n\n:::\n\n::: {.callout-important}\n\n### Méthode\n\nIl suffit de vérifier la règle FNBC pour un ensemble de DF équivalent à $\\Sigma$.\n\n:::\n\n\n\n\n\n## FNBC : exemple 1 {.smaller}\n\n$\\mathcal{A}=(\\texttt{V\\#, Vnom, Vville, P\\#, Pnom, Pprix, Qte})$\n\n$\\Sigma = \\{\\texttt{V\\#} \\to \\texttt{Vnom Vville}\\ , \\ \\texttt{P\\#} \\to \\texttt{Pnom Pprix}\\ , \\ \\texttt{V\\# P\\#} \\to \\texttt{Qte} \\}$\n\n. . .\n\n$\\mathcal{A}$ n'est pas en FNBC par rapport $\\Sigma$.\nEn effet ni $\\texttt{V\\#}$ ni $\\texttt{P\\#}$ ne sont des sur-clés.\n\n. . .\n\nMais la décomposition $\\mathcal{A_1}=(\\texttt{V\\#, Vnom, Vville}) \\quad \\mathcal{A_2}=(\\texttt{P\\#, Pnom, Pprix}) \\quad \\mathcal{A_3}=(\\texttt{V\\#, P\\#, Qte})$ est en FNBC.\n\n\n## FNBC : exemple 2 {.smaller}\n\nSchéma $\\verb!Projet! = (\\verb!#projet, #employé, localisation, fonction!)$\n\n$\\Sigma = \\{\\verb! #projet #employé! \\to \\verb!localisation fonction ! ; \\verb! localisation! \\to \\verb!#projet ! \\}$\n\n. . .\n\nLe schéma $\\verb!Projet!$ est en FN3 mais n'est pas en FNBC.\n\nD'après les DF, il subsiste des redondances que l'on peut illustrer par les tuples :\n\n| #projet | #employé | localisation | fonction |\n|:---:|:---:|:---:|:---:|\n| p1 | e1 | l1 | f1 |\n| p1 | e2 | l1 | f2 |\n| p1 | e3 | l1 | f3 |\n\n\n\n\n## Pourquoi deux notions de forme normale ?\n\n::: {.callout-note}\n\n### Proposition \n\nSi un schéma $\\mathcal{A}$ est en forme normale Boyce-Codd (FNBC) relativement à un ensemble de DF $\\Sigma$, alors $\\mathcal{A}$ est en forme normale 3 (FN3) relativement à $\\Sigma$.\n\n:::\n\n. . .\n\n::: {.aside}\n\nLa réciproque est fausse\n\n:::\n\n\n\n## Niveaux de décomposition d'une relation\n\n::: {.callout-note}\nLes formes normales correspondent à des niveaux d'élimination des redondances.\n\nLa FNBC élimine toutes les redondances dues aux DF mais toutes les contraintes d'une relation ne se modélisent pas par des DF !\n:::\n\n![](/images/fn/FN_emboitement.png){fig-align=\"center\" width=\"50%\"}\n\n\n\n\n# Algorithme de décomposition FNBC SPI {background-color=\"#1c191c\"}\n\n## Méthode de décomposition FNBC  SPI\n\n::: {.callout-important}\n### Méthode\nSoit un schéma relationnel $\\mathcal{A}$ respectant les DF $\\Sigma$. \n\n1. `D` est initialisée à `{A}`,\n2. Soit `B` une relation de `D` qui n'est pas FNBC à cause d'une DF non triviale `X → a` telle que `X` n'est pas clé de `B`.\n   + On définit `Y` comme l'ensemble des attributs de `B\\X` déterminés par `X`.\n   + On décompose alors `B` en :\n      * `B1` contenant les attributs de `X` et de `Y`.\n      * `B2` contenant tous les attributs de `B` sauf ceux de `Y`.\n 3. On boucle jusqu'à ce que toutes les relations soient FNBC.\n\n:::\n\n::: {.callout-note title=\"SPI\"}\n\nChaque étape est SPI car on laisse la clé `X` de `B1` dans `B2`. \n\n:::\n\n\n## Algorithme \n\n```{=html}\n<pre style=\"background-color: #f0f0ffff;font-family:'Lucida Console','Courier New',monospace; color: #15093aff;font-size:1em;padding:10px;border:1px solid #220f61ff;\">\nfonction decomposition_FNBC(A,Σ)\n\n   //Initialisation de la décomposition\n   D :=  {A}\n\n   while (∃ B ∈ D, B not BCNF because of Σ ⊨ X → a)\n      Y := X⁺ ⋂ (B\\X)       // X → a non triviale donc Y ≠ ∅\n      D := (D\\{B}) ⋃ { X⋃Y, B\\Y }\n   \nreturn D\n</pre>\n```\n\n## Propriétés de l'algorithme \n\n::: {.callout-important title=\"Proposition\"}\n\n- L'algorithme termine,\n\n- Les éléments de la  décomposition finale sont en FNBC, \n\n- La décomposition est Sans Perte d'Information (SPI).\n\n:::\n\n::: {.callout-note}\n\n### Preuves\n\n- La terminaison est triviale : à chaque itération le nombre de parties de $\\mathcal{A}$ dans  $D$ augmente de $1$ et ce nombre ne peut dépasser $\\# \\mathcal{A}$\n\n- La seconde propriété est triviale aussi\n\n- La propriété SPI se vérifie avec l'algorithme de poursuite (et son analyse): chaque itération de la boucle `While` est SPI. \n\n:::\n\n## Exemple 1 {.smaller}\n\n$\\mathcal{A}=(\\verb!V#, Vnom, Vville, P#, Pnom, Pprix, Qte!)$\n\n$\\Sigma = \\{\\texttt{V\\#} \\to \\texttt{Vnom Vville}\\ , \\ \\texttt{P\\#} \\to \\texttt{Pnom Pprix}\\ , \\ \\texttt{V\\# P\\#} \\to \\texttt{Qte} \\}$\n\n. . .\n\n$\\texttt{V\\#} \\to \\texttt{Vnom Vville}$ ne respecte pas la FNBC car $\\texttt{V\\#}$ n'est pas une sur-clé.\n\nOn a calculé une décomposition FN3 et on a vu qu'elle était FNBC.\nQue donne l'algorithme de décomposition FNBC ?\n\n. . .\n\n1. $\\verb!V#! \\to \\texttt{Vnom Vville}$ ne respecte pas la FNBC.\n   + l'ensemble des attributs de $\\mathcal{A}\\setminus\\{\\verb!V#!\\}$ déterminés par $\\verb!V#!$ est $Y=\\{\\verb!Vnom, Vville!\\}$\n   + on décompose $\\mathcal{A}$ en\n   $\\mathcal{A_1}=(\\verb!V#, Vnom, Vville!)$ et $\\mathcal{B_1}=\\mathcal{A}\\setminus Y=(\\verb!V#, P#, Pnom, Pprix, Qte!)$.\n\n. . .\n\n2. $\\mathcal{B_1}$ a pour clé $\\verb!(V#, P#)!$ donc $\\verb!P#! \\to \\texttt{Pnom Pprix}$ ne respecte pas la FNBC pour $\\mathcal{B_1}$.\n   + l'ensemble des attributs de $\\mathcal{B_1}\\setminus\\{\\verb!P#!\\}$ déterminés par $\\verb!P#!$ est $Y=\\{\\verb!Pnom, Pprix!\\}$\n   + on décompose $\\mathcal{B_1}$ en\n   $\\mathcal{A_2}=(\\verb!P#, Pnom, Pprix!)$ et $\\mathcal{A_3}=\\mathcal{B_1}\\setminus Y=(\\verb!V#, P#, Qte!)$.\n\n. . .\n\n3. - $\\mathcal{A_1}=(\\verb!V#, Vnom, Vville!)$ a pour clé $\\verb!V#!$ et est FNBC.\n   - $\\mathcal{A_2}=(\\verb!P#, Pnom, Pprix!)$ a pour clé $\\verb!P#!$ et est FNBC.\n   - $\\mathcal{A_3}=(\\verb!V#, P#, Qte!)$ a pour clé $\\verb!(V#, P#)!$ et est FNBC.\n\nOn a obtenue la même décomposition que celle déjà connue. On sait qu'elle est SPI et SPD.\n\n\n\n## Exemple 2 {.smaller}\n\nSchéma $\\verb!Projet! = (\\verb!#projet, #employé, localisation, fonction!)$\n\n$\\Sigma = \\{\\verb! #projet #employé! \\to \\verb!localisation fonction ! , \\verb! localisation! \\to \\verb!#projet! \\}$\n\nLe schéma $\\verb!Projet!$ est en FN3 mais n'est pas en FNBC. \nQue donne l'algorithme de décomposition FNBC ?\n\n. . .\n\n1. $\\verb! localisation! \\to \\verb!#projet!$ ne respecte pas la FNBC.\n   + l'ensemble des attributs de $\\verb!Projet!\\setminus\\{\\verb!localisation!\\}$ déterminés par $\\\\verb!localisation!\\$ est $Y=\\{\\verb!#projet!\\}$\n   + on décompose $\\verb!Projet!$ en\n   $\\mathcal{A_1}=(\\verb!localisation, #projet!)$ et $\\mathcal{A_2}=\\verb!Projet!\\setminus Y=(\\verb!#employé, localisation, fonction!)$.\n\n. . .\n\n2. + $\\mathcal{A_1}=(\\verb!localisation, #projet!)$ a pour clé $\\verb!localisation!$, toutes les DF respectent la FNBC.\n   + $\\mathcal{A_2}=(\\verb!#employé, localisation, fonction!)$ a pour clé $\\verb!(#employé,localisation)!$, toutes les DF respectent la FNBC.\n\n. . .\n\nOn peut vérifier que la décomposition est SPI avec l'algorithme de poursuite. Mais **elle n'est pas SPD**.\n\n. . .\n\nLa dépendance $\\verb! #projet #employé! \\to \\verb!localisation fonction !$ est perdue car l'algorithme de calcul de la fermeture par rapport aux DF projetées donne : $\\{\\verb!#projet, #employé!\\}^+_{\\mathcal{A_1},\\mathcal{A_2}} = \\{\\verb!#projet, #employé!\\}$.\n\n\n\n## Exemple 3 {.smaller}\n\n$\\mathcal{A}= (\\verb!A, B, C, D, E!)$ et $\\Sigma=\\{\\verb!A → C ; BC → D ; AD → E!\\}$\n\n- Quelles sont les clés ?\n- Le schéma est-il en FNBC ?\n- Si non, proposer une décomposition SPI en FNBC. Est-elle sans perte de DF?\n \n. . .\n\nOn a précédemment déterminer que l'unique clé est $\\verb!AB!$. Aucune des DF ne respecte la FNBC. \n\nOn a calculé aussi une décomposition FN3 SPI et SPD :\n\n$$\\{(\\texttt{A,C}), (\\texttt{B,C,D}), (\\texttt{A,D,E}), (\\texttt{AB})\\}$$\n\nEst-elle FNBC ?\n\n. . . \n\nOui elle est FNBC car\n\n- $(\\texttt{A,C})$ a pour clé $\\verb!A!$ donc vérifie la FNBC.\n- $(\\texttt{B,C,D})$ a pour clé $\\verb!BC!$ donc vérifie la FNBC.\n- $(\\texttt{A,D,E})$ a pour clé $\\verb!AD!$ donc vérifie la FNBC.\n- $(\\texttt{A,B})$ a pour clé $\\verb!AB!$ donc vérifie la FNBC.\n\n\n\n\n## Exemple 3 (suite) {.smaller}\n\nComparons avec la décomposition obtenue par l'algorithme de décomposition FNBC.\n\nLe schéma initial $\\mathcal{A}= (\\verb!A, B, C, D, E!)$ de clé $\\verb!AB!$, et $\\Sigma=\\{\\verb!A → C ; BC → D ; AD → E!\\}$\n\n. . .\n\n1. $\\verb!A → C!$ ne respecte pas la FNBC.\n   + l'ensemble des attributs de $\\mathcal{A}\\setminus\\{\\verb!A!\\}$ déterminés par $\\{\\verb!A!\\}$ est $Y=\\{\\verb!C!\\}$\n   + on décompose $\\mathcal{A}$ en\n   $\\mathcal{A_1}=(\\verb!A,C!)$ et $\\mathcal{B_1}=\\mathcal{A}\\setminus Y=(\\verb!A,B,D,E!)$.\n\n. . .\n\n2. $\\mathcal{B_1}$ a pour clé $\\verb!AB!$ donc $\\verb!BC → D!$ ne respecte pas la FNBC pour $\\mathcal{B_1}$.\n   + l'ensemble des attributs de $\\mathcal{B_1}\\setminus\\{\\verb!B,C!\\}$ déterminés par $\\{\\verb!B,C!\\}$ est $Y=\\{\\verb!D!\\}$\n   + on décompose $\\mathcal{B_1}$ en\n   $\\mathcal{A_2}=(\\verb!B,C,D!)$ et $\\mathcal{A_3}=\\mathcal{B_1}\\setminus Y=(\\verb!A,B,E!)$.\n\n. . .\n\n3. - $\\mathcal{A_1}=(\\verb!A,C!)$ a pour clé $\\verb!A!$ et est FNBC.\n   - $\\mathcal{A_2}=(\\verb!B,C,D!)$ a pour clé $\\verb!BC!$ et est FNBC.\n   - $\\mathcal{A_3}=(\\verb!A,B,E!)$ a pour clé $\\verb!AB!$ et est FNBC.\n\n**Nous n'obtenons pas la même décomposition qu'avec l'algorithme de décomposition FN3**.\n\nOn peut vérifier que la décomposition est SPI (exercice ?) mais elle **n'est pas SPD**.\n\n. . .\n\nLa DF $\\verb!AD → E!$ n'est pas préservée ! On le montre par le calcul de la fermeture de $\\verb!{A,D}!$ par rapport au DF projetées, on obtient  $\\verb!{A,D}!^+_{\\mathcal{A_1},\\mathcal{A_2},\\mathcal{A_3}} = \\verb!{A,D}!$\n\n\n# Décomposition FNBC et pertes de DF {background-color=\"#1c191c\"}\n\n\n## Limites de la décomposition FNBC\n  \n::: {.callout-note}\n\nIl existe des couples schéma/Ensemble de DFs ($\\mathcal{A}, \\Sigma$) pour lesquels toute décomposition FNBC entraine une perte de dépendances fonctionnelles\n\n:::\n\n## {.smaller}\n\n\n$\\mathcal{A} =$ `{Ville, Rue, Numéro, #Bureau_vote}`\n\n`Σ = { Ville, Nom, Rue → #Bureau_vote,  #Bureau_vote  →  Ville }`\n\n. . .\n\nDeux clés `Ville, Nom, Rue` et `#Bureau_vote, Nom, Rue`\n\n. . .\n\n`#Bureau_vote  →  Ville` ne satisfait pas le critère FNBC\n\n. . .\n\nL'algorithme de décomposition en FNBC conduit à la décomposition `{#Bureau_vote,Ville}` et `{#Bureau_vote, Nom, Rue}`\n\nLa DF `Ville, Nom, Rue → #Bureau_vote` n'est pas préservée\n\nLa décomposition préserve l'information (SPI) mais pas les dépendances fonctionnelles. \n\n\n## Limites de la décomposition FNBC (suite)\n\n::: {.callout-caution title=\"À noter\"}\n\nPour cet exemple, on peut vérifier qu'*aucune* décomposition FNBC de $\\mathcal{A}$ ne préserve toutes les dépendances fonctionnelles. \n\n:::\n\n\n\n# Fin   {background-color=\"#1c191c\"}\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}