{
  "hash": "2278473ee5a50585be74b3e5c36491f0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"BD IV: SQL III\"\nsubtitle: \"Langage Manipulation de Données 3 : Aggrégation/Fenêtres/Partitions\"\ndate: \"2025-10-03\"\n\nformat: \n  revealjs:\n    header: \"Requêtes SQL : Aggrégation/Fenêtres/Partition\"\n\nengine: knitr\n---\n\n\n\n# Fonctions d'agrégation  {background-color=\"#1c191c\"}\n\n\n\n\n## Limite de l'algèbre relationnelle pure \n\nL'algèbre relationnelle pure (σ, π, ⋈) ne sait pas tout calculer.\n\nCertains problèmes aisément solubles par un langage de programmation complet (`Python`, `C`, `R`, ...) ne sont pas solubles dans \nl'algèbre relationnelle pure :\n\n- compter. Exemple simple : calculer le nombre de lignes d'une table.\n\n- dans une table décrivant une arborescence (une organisation hiérarchisée), déterminer tous les descendants d'un enregistrement.\n\n\n## Fonctions d'agrégation ?\n\nPossibilité de *compter*, de *faire des moyennes*, de trouver un maximum, ... en SQL (contrairement à l'algèbre relationnelle \"classique\").\n\n\n## Extension possible de l'algèbre relationnelle\n\n::: {.callout-note}\n\n### Idée \n\nIntroduire un opérateur $Résume()$ qui admet comme arguments une table $T$ et une suite d'expressions susceptibles de calculer des *agrégats* : moyenne, somme, comptage, etc. \n\nProposition de syntaxe : \n\n$Résume(T, expr_1, ..., expr_k)$ retourne une table $S$ à **une** ligne et $k$ colonnes.\n\nLa colonne $i$ de $S$ contient l'évaluation de $expr_i$ sur la table $T$.\n\n:::\n\n::: {.callout-warning}\n\nIl n'est pas évident de définir ce que peut être une fonction d'agrégation et un agrégat.\n\nNous travaillerons  à partir d'exemples.\n\n:::\n\n<!--\n## Fonctions d'agrégation en SQL \n\n\n- [Documentation PostgreSQL](https://www.postgresql.org/docs/current/tutorial-agg.html){target=\"_blank\"}\n\n\n- [Analyse commerciale ou Buisiness Analytics](https://fr.wikipedia.org/wiki/Business_analytics){target=\"_blank\"}, \n\n- OLAP\n  \n- Statistique et Data Science \n-->\n\n\n## Fonctions d'agrégation  `SUM` et `AVG`\n\n- Somme des valeurs prises par `nomattribut`\n\n```\nRésume(T, SOMME(nomattribut))\n```\n\nse traduit en \n\n```{.sql}\nSELECT \n  SUM ([DISTINCT|ALL] <nomattribut>)  \nFROM T\n```\n\n. . . \n \n- Moyenne des valeurs prises par `nomattribut`\n\n```\nRésume(T, MOYENNE(nomattribut))\n```\n\nse traduit en \n\n```{.sql}\nSELECT \n  AVG ([DISTINCT|ALL] <nom_attribut>) \nFROM T\n```\n\n::: {.callout-warning}\nLe type de l'attribut doit correspondre à un nombre (cf. spécifications de chaque fonction dans la documentation).\n\n:::\n\n\n## Options `ALL` et `DISTINCT` des fonctions d'agrégation\n\nCes options sont disponibles pour toutes les fonctions \n\nmais sont surtout utiles pour `COUNT` : \n\n- `ALL`, option par défaut : toutes les valeurs de la colonne sont utilisées,\n\n- `DISTINCT` : les valeurs doublons ne sont utilisées qu'une fois.\n\n\n## Exemples avec `SUM` et `AVG`\n  \n- Somme des populations des villes du pays de code `FRA` (dans le schéma `world`).\n\n```{.sql}\nSELECT SUM(population)  \nFROM city \nWHERE countrycode = 'FRA';\n```\n\nTraduction de \n\n\n::: {.cell}\n\n```{.sql .cell-code}\nR1 = σ(city, countrycode = 'FRA')\nR = Résume(R1, SOMME(population))\n```\n:::\n\n\n. . .\n\n- Moyenne des populations des villes du continent `Europe` et `Afrique`.\n\n```{.sql}\nSELECT AVG(ci.population)  \nFROM city ci join country co on ci.countrycode = co.countrycode\nWHERE co.continent in ('Afrique','Europe');\n```\n\nTraduction de \n\n\n::: {.cell}\n\n```{.sql .cell-code}\nR1 = ⋈(city, country, city.countrycode = country.countrycode)\nR2 = σ(R1, continent in ('Afrique','Europe'))\nR = Résume(R1, avg(population))\n```\n:::\n\n\n\n## Fonctions de calcul  `MAX`, `MIN`\n\n- maximum des valeurs prises par `<nomattribut>` dans `T` :\n  \n```{.sql}\nSELECT \n  MAX (<nomattribut>)  \nFROM T ;\n```\n\n. . .\n\n- minimum des valeurs prises par  `<nomattribut>` dans `T` :\n\n```{.sql}\nSELECT \n  MIN (<nomattribut>)  \nFROM T \n```\n\n. . .\n\nExemple :\n```{.sql}\nSELECT max(gnp)   \nFROM country \nWHERE region = 'Caribbean';\n```\n\n\n\n## Gestion des données manquantes (`NULL`)\n\n- En statistique : données manquantes prises en compte dans les fonctions d'agrégation.\n\n- En SQL : données manquantes ignorées dans les fonctions d'agrégation,\n \n  à l'exception de `COUNT(*)`.\n\n. . .\n\n```{.sql}\nSELECT name_country, gnpold, gnp\nFROM country\nWHERE continent = 'Europe' AND (gnp IS NULL OR gnpold IS NULL)\n```\nRésultat : 10 lignes. \n\n. . .\n\nPourtant, ces données manquantes n'empèchent pas le calcul du maximum sur ces colonnes.\n\n```{.sql}\nSELECT max(gnpold) AS max_gnpold, max(gnp) AS max_gnp   \nFROM country \nWHERE continent  = 'Europe';\n```\n```\n+-------------+------------+\n|  max_gnpold |  max_gnp   |\n+-------------+------------+\n|  2102826.00 | 2133367.00 |\n+-------------+------------+\n```\n\n## Fonction d'agrégation sur des valeurs toutes `NULL`\n\n::: {.callout-warning}\n\n### {{< fa mug-hot >}}\n\nQue se passe-t-il si, après une éventuelle sélection, toutes les valeurs de du calcul d'agrégat sont `NULL` ?\n\nLa valeur calculée est alors `NULL`, ce qui signifie \"pas de valeur\".\n\nEssayez `SELECT MIN(gnpold) FROM country WHERE gnpold IS NULL;` !\n\n:::\n\n\n## Fonction d'agrégation sur une table vide\n\n::: {.callout-warning}\n\nLes fonctions d'agrégation renvoie un scalaire même sur une table vide.\n\nPour une table vide, la valeur calculée est `NULL`.\n\n:::\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT \n  SUM(population) AS urban_pop\nFROM city  ci\nWHERE ci.countrycode = 'zzz' ;\n```\n:::\n\n. . .\n\n```\n+-----------+\n| urban_pop |\n|-----------|\n| <null>    |\n+-----------+\n```\n\nEst-ce cohérent?\n\nLe résultat signifie : \"Pour le pays de code 'zzz', pas de données\"\n\n\n## Fonctions de calcul : `COUNT`\n\nOn peut aussi compter le nombre de tuples d'une table :  \n\n```{.sql}\nSELECT \n  COUNT(* |[ALL | DISTINCT] <nomattribut>)  \nFROM T\n-- | pour indiquer une alternative, [ ] pour une option.\n```\n\n::: {.callout-note}\n\nOptions de la fonction `COUNT` :\n\n- `*` : compte le nombre de lignes dans la table ou la sous-requête, **en incluant les valeurs `NULL`**.\n- `DISTINCT` : sans les doublons et sans les valeurs `NULL`,\n- `ALL` : avec les doublons mais sans les valeurs `NULL`,\n\nSi la table est vide, `COUNT` renvoie 0.\n:::\n\n. . .\n\nNombre de pays dans la région `Carribean`\n\n```{.sql}\nSELECT COUNT(*)  \nFROM country\nWHERE region = 'Caribbean'; \n```\n\n\n\n\n## Exemples d'utilisation des options de la fonction `COUNT`\n\n\n```{.sql}\nSELECT COUNT(*) FROM country;\n``` \nretourne `239`, le nombre de lignes de la table `country`.\n\n. . .\n\n&nbsp;\n```{.sql}\nSELECT COUNT (indepyear) FROM country;\nSELECT COUNT (ALL indepyear) FROM country;\n```  \nretournent `192`, le nombre de valeurs non `NULL` de la colonne `indepyear`.\n\n. . .\n\n&nbsp;\n```{.sql}\nSELECT COUNT (DISTINCT indepyear) FROM country;\n```  \nretourne `88`, le nombre de valeurs disctintes et non `NULL` de la colonne `indepyear`.\n\n. . .\n\n&nbsp;\n```{.sql}\nSELECT COUNT(*) FROM (SELECT indepyear FROM country) as T;\n``` \nretourne `239` car `T` contient une seule colonne avec `239` lignes, les 47 lignes `NULL` sont comptées comme les autres.\n\n\n\n\n\n\n## Opérations sur des fonctions d'agrégation\n\nPNB moyen par habitant du continent `South America`\n\n```{.sql}\nSELECT \n  ROUND(SUM(1e6*gnp)/SUM(population_country),2) as pnb_avg\nFROM \n  country \nWHERE \n  continent = 'South America';\n```\nRésultat : `4372,36`\n\n::: {.callout-note}\n$10^6$ s'écrit `1e6`. On a écrit `1e6*gnp` car `gnp` est exprimé en millions de USD.\n\n`ROUND(x,s)` effectue un arrondi de x avec s chiffres après la virgule. `s` négatif accepté.\n\n[Documentation des fonctions mathématiques](https://docs.postgresql.fr/current/functions-math.html){target=\"_blank\"}\n\n:::\n\n\n## Fonctions d'agrégation sur des opérations\n\n::: {.callout-note}\nLes fonctions d'agrégation peuvent s'appliquer à des opérations arithmétiques entre les différents attributs d'un même tuple...  \n:::\n\n. . .\n\nMoyenne des PNB/habitant des pays du continent 'South America'. A ne pas confondre avec la requête précédente ! \n```{.sql}\nSELECT \n  ROUND(AVG(1e6*gnp/population_country),2) as pnb_country_avg\nFROM country \nWHERE \n  continent = 'South America' AND population_country > 0 ;\n-- Le test population_country > 0 évite les divisions par 0\n```\nRésultat : `3176,44`\n\n\n\n\n<!--\n# Retour sur fonction `SUM` {background-color=\"#1c191c\"}\n\n\n## Fonction de calcul `SUM()`\n\nOn peut sommer les valeurs contenues dans une colonne numérique \n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT \n  SUM(population) AS urban_pop\nFROM city  ci\nWHERE ci.countrycode = 'GBR' ;\n```\n:::\n\n\n```{.sql}\n+-----------+\n| urban_pop |\n|-----------|\n| 22436673  |\n+-----------+\n```\n\n## Sommation sur tableau vide\n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT \n  SUM(population) AS urban_pop\nFROM city  ci\nWHERE ci.countrycode = 'zzz' ;\n+-----------+\n| urban_pop |\n|-----------|\n| <null>    |\n+-----------+\n```\n:::\n\n\nEst-ce cohérent?\n-->\n\n## Utilisation de  `CASE WHEN ...THEN ... [ELSE ...] END`\n\nDans une fonction d'agrégation, une expression `CASE WHEN` teste des conditions sur le tuple courant et renvoie la valeur correspondant à la première condition vraie.\n\n```{.sql}\nCASE\n    WHEN condition1 THEN result1\n    [WHEN condition2 THEN result2]\n    [WHEN conditionN THEN resultN]\n    [ELSE result]\nEND;\n```\n::: {.callout-warning}\nSi aucune condition n'est vraie et qu'il n'y pas de clause `ELSE`, `CASE` retourne `NULL`.\n:::\n\n\n```{.sql}\nSELECT \n  SUM(\n    CASE \n      WHEN countrycode='GBR' THEN population \n    END) AS urban_pop \n FROM city ;\n```\n```\n+-----------+\n| urban_pop |\n|-----------|\n| 22436673  |\n+-----------+\n```\n\n\n\n## Gestion des valeurs manquantes avec  `CASE WHEN ...THEN ... [ELSE ...] END`\n\n\n```{.sql}\nSELECT \n  AVG(\n    CASE \n      WHEN gnpold IS NOT NULL THEN gnpold \n      ELSE 0 \n    END)::NUMERIC(8,2) AS avg_gnpold \n FROM world.country \n WHERE continent = 'Europe';\n```\nRetourne `203956,54`\n\n```{.sql}\nSELECT \n  AVG(gnpold)::NUMERIC(8,2) AS avg_gnpold \n FROM world.country \n WHERE continent = 'Europe';\n```\nRetourne `260611,14`\n\n\n## Autres possibilités avec  `CASE WHEN ...THEN ... [ELSE ...] END`\n\n\n```{.sql}\nSELECT \n  SUM(CASE \n    WHEN governmentform LIKE '%Monarchy%' THEN population_COUNTRY \n    ELSE 0    -- résultat identique si on enlève cette ligne\n  END) AS pop_monarch,  \n  SUM(CASE \n    WHEN governmentform LIKE '%Republic%' THEN population_COUNTRY \n    ELSE 0   -- résultat identique si on enlève cette ligne\n  END) AS pop_repu \nFROM country ;\n```\n\n```\n+-------------+------------+\n| pop_monarch | pop_repu   |\n|-------------+------------|\n| 519485000   | 5502453700 |\n+-------------+------------+\n```\n\n## Agrégats sur des données filtrées `FILTER (WHERE condition)`\n\nAvec une clause `FILTER`, la fonction d'agrégation n'utilise que les tuples vérifiant la condition.\n\n:::::{.columns}\n:::{.column width=\"70%\"}\n```{.sql}\nSELECT \n  SUM(population_country) FILTER  \n    (WHERE governmentform LIKE '%Monarchy%') AS pop_monarch,  \n  SUM(population_country) FILTER \n    (WHERE governmentform LIKE '%Republic%') AS pop_repu \nFROM country ;\n```\n:::\n:::{.column width=\"30%\"}\n\n```\n+-------------+------------+\n| pop_monarch | pop_repu   |\n|-------------+------------|\n| 519485000   | 5502453700 |\n+-------------+------------+\n```\n:::\n:::::\n\n. . .\n\n::: {.callout-caution}\n\nIl est plus conforme à l'algèbre relationnelle et au SQL d'organiser les données en lignes.\n\n:::\n\n:::::{.columns}\n:::{.column width=\"70%\"}\n\n```{.sql}\nSELECT 'Monarchy' as governmentform, SUM(population_country) as population    \nFROM world.country c\nWHERE c.governmentform LIKE '%Monarchy%'\nUNION\nSELECT 'Republic' as governmentform, SUM(population_country) as population    \nFROM world.country c\nWHERE c.governmentform LIKE '%Republic%';\n```\n:::\n\n:::{.column width=\"30%\"}\n\n\n```\n+----------------+------------+\n| governmentform | population |\n|----------------+------------|\n| Monarchy       |  519485000 |\n|----------------+------------|\n| Republic       | 5502453700 |\n+----------------+------------+\n```\n:::\n:::::\n\n\n## Problèmes d'efficacité\n\nNom des régions comportant plus de $15$ pays.\n\n. . .\n\nLa requête suivante est à éviter :\n```{.sql}\nSELECT DISTINCT c.region \nFROM country c \nWHERE (\n  SELECT COUNT (*)     \n  FROM country co     \n  WHERE co.region = c.region\n) >= 15\nORDER BY c.region;  \n```\n5 lignes.\n\n::: {.callout-caution}\n\nY-a-t-il des calculs effectués plusieurs fois sur les mêmes données ?\n\n:::\n\n<!--\n## Problème d'efficacité\n\nTrouver les régions où au moins un pays possède une espérance de vie inférieure à 50 ans.\n\n```{.sql}\nSELECT DISTINCT continent, region\nFROM country c \nWHERE (\n  SELECT MIN(d.lifeexpectancy)     \n  FROM country d    \n  WHERE c.region=d.region\n  ) < 50    \nORDER BY continent, region;\n```\n\n|**Continent**    |**Region**                   |\n|:------------|:------------------------|\n|Africa       |Central Africa           |\n|Africa       |Eastern Africa           |\n|Africa       |Northern Africa          |\n|Africa       |Southern Africa          |\n|Africa       |Western Africa           |\n|Asia         |Southeast Asia           |\n|Asia         |Southern and Central Asia|\n|North America|Caribbean                |\n\n\n::: {.callout-note}\n\nPourquoi cette requête est-elle horrible ?\n\n:::\n-->\n\n## Efficacité\n\n{{< fa hand-point-right >}} On peut faire plus efficace, gràce à la suite du cours :\n\n```{.sql}\nSELECT region    \nFROM country     \nGROUP BY region\nHAVING COUNT(*) >= 15\nORDER BY region;\n```\n\n\n<!--\n\n---\n\nMais si on veut lister les régions où tous les pays ont une espèrance de  vie supérieure à 50 ?\n\n. . .\n\nPourquoi pas ?\n\n```{.sql}\nSELECT \n  DISTINCT continent, region\nFROM country c \nWHERE (\n  SELECT MIN(d.lifeexpectancy)     \n  FROM country d    \n  WHERE c.region=d.region\n  ) > 50    \nORDER BY continent, region;\n```\n\n::: {.callout-caution}\n\nCombien de fois calculez vous l'espérance de minimale pour chaque région ?\n\n:::\n-->\n\n\n\n## Pour en savoir plus ?\n\n[Documentation PostgreSQL](https://www.postgresql.org/docs/current/functions-aggregate.html){target=\"_blank\"}\n\n\n\n# Partitions,  `GROUP BY` {background-color=\"#1c191c\"}\n\n\n## Partition de résultats de requêtes\n\n\n```{.sql}\nGROUP BY <nomattribut1>, ..., <nomattributn>\n```\n\n- `GROUP BY` permet de regrouper l'ensemble des résultats d'une requête selon la  valeur de certains attributs, \n\n- Forme des sous-relations auxquelles on peut appliquer des fonctions d'agrégation (`SUM`, `MAX`, ...) renvoyant un résultat par sous-relation.\n\n. . .\n\n:::{.callout-warning}\n\n**Gestion des valeurs manquantes** : les valeurs `NULL`d'un attribut forment un groupe dans la partition selon celui-ci. \n\n:::\n\n## Utilisation `GROUP BY`\n\nCalculer la population de chaque continent.\n\n```{.sql}\nSELECT continent, SUM(population_country) as population_continent\nFROM country \nGROUP BY continent;    \n```\n```\n+--------------+----------------------+\n| continent    | population_continent |\n+--------------+----------------------+\n|Asia          |          3705025700  |\n|South America |           345780000  |\n|North America |           482993000  |\n|Oceania       |            30401150  |\n|Antarctica    |                   0  |\n|Africa        |           784475000  |\n|Europe        |           730074600  |\n+--------------+----------------------+\n\n```\n\n::: {.callout-important}\n\nOn peut afficher `continent` pour chaque groupe parce qu'on a groupé selon cet attribut\n\n:::\n\n\n## Exemple avec `GROUP BY`\n\nQuel est le `gnp` moyen, le `gnp` maximum et le `gnp` minimum par `region` sur le continent `Europe` en milliers de USD par habitant ?\n\n. . .\n\n```{.sql}\nSELECT region, \n     ROUND(1000 * SUM(gnp)/SUM(population_country),2) AS avg_gnp,  \n     ROUND(MAX(1000* gnp/population_country),2) AS max_gnp, \n     ROUND(MIN(1000* gnp/population_country),2) AS min_gnp,\nFROM country \nWHERE continent = 'Europe' \nGROUP BY region \nORDER BY avg_gnp DESC;\n```\n\n```\n+----------------+---------+---------+---------+\n| region         | avg_gnp | max_gnp | min_gnp |\n+----------------+---------+---------+---------+\n|Nordic Countries|   28.00 |   32.66 |    0.00 |\n|Western Europe  |   25.50 |   37.46 |   22.82 | \n|British Islands |   22.94 |   23.12 |   20.11 | \n|Southern Europe |   13.91 |   20.90 |    0.72 | \n|Baltic Countries|    2.96 |    3.70 |    2.64 |\n|Eastern Europe  |    2.15 |    5.35 |    0.36 |\n+----------------+---------+---------+---------+\n```\n\n\n## Précautions avec `GROUP BY`\n\nPour chaque région, indiquer le continent, la région et la population du pays le plus peuplé.\n\nLa requête suivante n'est pas correcte \n\n```{.sql}\nSELECT continent, region, MAX(population_country) \nFROM country \nGROUP BY region;\n```\n\n. . .\n\n::: {.callout-important}\n\n### {{< fa skull >}}\n\nLes attributs présents dans le `SELECT` doivent impérativement être présents dans le `GROUP BY` pour s'assurer qu'ils sont communs à tous les tuples de chaque groupe.  \n\n:::\n\n\n## Comment afficher un attribut absent de `GROUP BY` ?\n\nPour chaque continent, indiquer le nom et la population du (des) pays le(s) plus peuplé(s).\n\n. . .\n\n:::{.callout-caution}\nOn ne peut pas utiliser une seule requête puisqu'on veut afficher les pays sans grouper selon les pays. Il faut donc faire les calculs d'agrégats dans une sous-requête.\n\nPréférez les CTEs (ou éventuellement les requêtes imbriquées dans `FROM`), plus efficaces que les requêtes imbriquées dans `WHERE` qui sont ré-exécutées inutilement. \n:::\n\n## Solution\n\n```{.sql}\nWITH pmc AS\n  (SELECT continent, MAX(population_country) AS pop_max\n  FROM country\n  GROUP BY continent)\nSELECT c.continent, c.name_country AS country_max_pop, c.population_country AS population\nFROM country c JOIN pmc ON c.continent = pmc.continent\nWHERE c.population_country = pmc.pop_max\nORDER BY pmc.pop_max DESC;\n```\n\n```\n+---------------+----------------------------------------------+------------+\n| continent     | country_max_pop                              | population |\n+---------------+----------------------------------------------+------------+\n| Asia          | China                                        | 1277558000 |\n| North America | United States                                |  278357000 |\n| South America | Brazil                                       |  170115000 |\n| Europe        | Russian Federation                           |  146934000 |\n| Africa        | Nigeria                                      |  111506000 |\n| Oceania       | Australia                                    |   18886000 |\n| Antarctica    | Antarctica                                   |          0 |\n| Antarctica    | Bouvet Island                                |          0 |\n| Antarctica    | South Georgia and the South Sandwich Islands |          0 |\n| Antarctica    | Heard Island and McDonald Islands            |          0 |\n| Antarctica    | French Southern territories                  |          0 |\n+---------------+----------------------------------------------+------------+\n```\n\n## Sous-partitionnements\n\nQue fait cette requête ?\n\n```{.sql}\nWITH \n  co_urb_rate AS\n  (\n    SELECT co.countrycode, co.name_country, co.continent, SUM(ci.population)/(co.population_country::numeric) AS urb_rate\n    FROM world.country co JOIN world.city ci ON co.countrycode = ci.countrycode\n    WHERE co.population_country > 0\n    GROUP BY co.countrycode, co.name_country, co.continent\n  ),\n  cont_max_ur AS \n  (\n    SELECT continent, MAX(urb_rate) AS max_ur\n    FROM co_urb_rate\n    GROUP BY continent\n  )\nSELECT \n  co.continent, \n  co.name_country, \n  round(co.urb_rate,2)\nFROM co_urb_rate co JOIN cont_max_ur ct ON co.urb_rate = ct.max_ur;\n```\n\n---\n\nPour chaque continent, elle donne le pays le plus urbanisé avec son taux de population urbaine.\n\n:::{.callout-important}\nLa conversion du diviseur avec `::numeric` est importante sinon le résultat est un entier (ici 0 ou 1) car la division entre entiers donne un entier par division euclidienne.\n:::\n\n::: {.callout-note}\nSingapore, Gibraltar et les Cocos Islands ont un taux d'urbanisation supérieur à 1 !\n\nHypothèse :  les origines des statistisques de population sur les villes et les pays ne sont pas les mêmes et les critères utilisés sont différents.\n:::\n\n\n## Aller plus loin que `GROUP BY` ?\n\n::: {.callout-note}\n\nL'opération `GROUP BY` ne renvoie pas une table mais (implicitement) *une collection de sous-tables* indicées/étiquetées par les valeurs des attributs de groupement.\n\nL'opération `GROUP BY` ne peut pas s'intégrer dans une algèbre relationnelle, même étendue.\n\n:::\n\n::: {.callout-caution}\n\nSQL n'offre pas de moyen d'utiliser le partitionnement effectué par `GROUP BY` autrement que pour effectuer des calculs d'agrégats et/ou une projection sur les attributs de groupement.  \n\n:::\n\nCette requête n'est pas valide :\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT *  \nFROM country \nGROUP BY continent ;\n```\n:::\n\n\nCette requête est valide :\n\n```{.sql}\nSELECT continent  \nFROM country \nGROUP BY continent ;\n```\n\n\n# Sélection sur les groupes et tri des résultats {background-color=\"#1c191c\"}\n\n\n## Sélection sur les groupes `HAVING`\n    \n- La clause `HAVING` permet de poser une condition portant sur chacune des sous-relations générées par le `GROUP BY`,\n\n- Les sous-relations ne vérifiant pas la condition sont écartées du résultat.\n    \n\n\nListe des continents comportant au moins cinq régions.\n\n```{.sql}\nSELECT continent \nFROM country \nGROUP BY continent    \nHAVING COUNT(DISTINCT region) >= 5;  \n```\n\n\n\n## Tri de résultats `ORDER BY`\n\nLa clause `ORDER BY` permet de trier le résultat de la requête, en fournissant \nla liste des attributs  sur lesquels effectuer le tri et en spécifiant le sens du tri pour chacun d'eux (`ASC` ou `DESC`).\n\n:::{.callout-caution}\nL'ordre par défaut est `ASC`.\n:::\n\nListe des pays triés par ordre décroissant de population \n\n```{.sql}\nSELECT * \nFROM country \nORDER BY population_country DESC;  \n```\n\n::: {.callout-warning}\n\nQue se passe-t-il avec les valeurs nulles ?\n\nLe comportement dépend du serveur. PostgreSQL et Oracle les classent comme plus grandes que toutes les autres. SQL Server (Microsoft), MySQL, SQLite font l'inverse.\n\n:::\n\n## Ordre des opérations `WHERE`, `GROUP BY`, `HAVING`, `ORDER BY`\n\n::: {.callout-important}\n\n1. la sélection des tuples (`WHERE`), \n2. puis le partitionnement (`GROUP BY`), \n3. puis la sélection sur les groupes (`HAVING`),\n4. enfin le tri des résultats (`ORDER BY`) .\n\n:::\n\nQue fait cette requête ?\n\n```{.sql}\nSELECT continent, COUNT(*) \nFROM country \nWHERE countrycode IN (\n  SELECT countrycode \n  FROM countrylanguage \n  WHERE language='English' AND percentage > 10 \n) \nGROUP BY continent \nHAVING AVG(1e6*gnpold/population_country) >= 1000 \nORDER BY continent;\n```\n\n\n\n\n\n# Fonctions fenêtres (Window functions)  {background-color=\"#1c191c\"}\n\n\n## Principe des fonctions fenêtres\n\nUne **fonction fenêtre** effectue une partition puis un calcul sur le groupe de lignes (\"une fenêtre\") auquel la ligne courante appartient. \n\n[Documentation PostgreSQL](https://www.postgresql.org/docs/current/tutorial-window.html){target=\"_blank\"}\n\n. . .\n\n::: {.callout-note}\n\nC'est comparable au type de calcul effectué avec une fonction d'agrégation.\n\n:::\n\n. . .\n\nMais les fonctions de fenêtre permettent de faire des calculs différents de ceux réalisés avec `GROUP BY`. \n\n- Avec `GROUP BY`, le résultat rassemble les lignes d'un même groupe en une seule.\n\n- Avec les *fonctions fenêtres*, chaque ligne de la table reste présente dans le résultat.\n\n<!--En coulisses, la fonction de fenêtre est capable d'accéder à plus que la ligne actuelle du résultat de la requête.-->\n\n\n\n## Fonctions fenêtres\n\nSoit `f` est une fonction d'agrégation (`SUM`, `AVG`, `MAX`, `MIN`, `COUNT`, etc.)\n\n::: {.cell}\n\n```{.sql .cell-code}\nf(...) OVER (PARTITION BY attribut) \n```\n:::\n\neffectue le calcul sur le groupe de lignes auquel appartient la ligne courante après un partitionnement selon `attribut`.\n\nCe groupe de lignes est le cadre de la fonction fenêtre pour la ligne courante.\n\n\n\n## Exemple de fonctions fenêtres\n\n\nPrésenter pour chaque pays dont la région comprend le motif \n`Countries`, l'espérance de vie du pays et les espérance de vie maximale et minimale des pays de la région.\n\n. . .\n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT region, name_country, lifeexpectancy, \n     min(lifeexpectancy) OVER (PARTITION BY region),  \n     max(lifeexpectancy) OVER (PARTITION BY region)   \nFROM country \nWHERE region LIKE '%Countries'\nORDER BY region, lifeexpectancy  \nLIMIT 6 ;\n```\n:::\n\n\n```\n+------------------+-----------------+---------------+-----+-----+\n| Region           | Name of country |Life expectancy| min | max |\n+------------------+-----------------+---------------+-----+-----+\n| Baltic Countries | Latvia          |          68.4 | 68.4| 69.5|\n| Baltic Countries | Lithuania       |          69.1 | 68.4| 69.5|\n| Baltic Countries | Estonia         |          69.5 | 68.4| 69.5|\n| Nordic Countries | Denmark         |          76.5 | 76.5| 79.6|\n| Nordic Countries | Finland         |          77.4 | 76.5| 79.6|\n| Nordic Countries | Faroe Islands   |          78.4 | 76.5| 79.6|\n+------------------+-----------------+---------------+-----+-----+\n```\n:::{.callout-note}\nAvec des fonctions d'agrégation sur un partitionnement par `GROUP BY region`, il n'était pas possible d'afficher une ligne par pays.\n:::\n\n\n## Sans utiliser `OVER (...)` \n\n\nPour calculer ce résultat sans fonctions fenêtres :\n\n1. On effectue une partition selon la `region`, une aggrégation par groupe \npour calculer `min(lifeexpectancy)` et `max(lifeexpectancy)`. On obtient une table à trois colonnes.\n\n1. On calcule une (équi)-jointure avec la table `country` originelle sur  la colonne commune `region`.\n\n2. On projette  le résultat sur les cinq colonnes pertinentes. \n\n. . .\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nWITH R AS (\n  SELECT region, min(lifeexpectancy) AS minlex, max(lifeexpectancy) AS maxlex\n  FROM country\n  WHERE region LIKE '%Countries' AND lifeexpectancy IS NOT NULL \n  GROUP BY region\n)\n\nSELECT region, name_country, lifeexpectancy, minlex, maxlex\nFROM country co NATURAL JOIN R\n```\n:::\n\n\n\n\n\n\n## Fonctions fenêtres avec une clause `ORDER BY`\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nf(...) OVER (\n    PARTITION BY attribut1\n    ORDER BY attribut2 \n  )\n```\n:::\n\nLa clause `ORDER BY attribut2` :\n\n- ordonne les lignes de la fenêtre définie par `PARTITION BY attribut1`,\n- restreint le cadre de la fenêtre, selon cet ordre, de la première ligne jusqu'aux lignes pour lesquelles `attribut2` à la même valeur que dans la ligne courante.\n\n<!--\n. . .\n\n:::::{.columns}\n\n:::{.column width=\"70%\"}\nOn ajoute `ORDER BY lifeexpectancy` à l'exemple précédent :\n```{.sql}\nSELECT region, name_country, lifeexpectancy, \n     min(lifeexpectancy) OVER (PARTITION BY region ORDER BY lifeexpectancy),  \n     max(lifeexpectancy) OVER (PARTITION BY region ORDER BY lifeexpectancy)   \nFROM world.country \nWHERE region LIKE '%Countries'\nORDER BY region, lifeexpectancy ;\n```\n:::\n\n:::{.column width=\"30%\"}\nLes 3 premières lignes :\n```\n|name_country |lifeexpecta|min |max |\n|-------------|-----------|----|----|\n|Latvia       |68,4       |68,4|68,4|\n|Lithuania    |69,1       |68,4|69,1|\n|Estonia      |69,5       |68,4|69,5|\n...\n```\n:::\n\n:::::\n\n. . .\n\n:::{.callout-note}\nLa colonne `min` n'a pas changé car la première ligne de la fenêtre contient la valeur minimale de la fenêtre puisqu'on a fait `ORDER BY lifeexpectancy`.\n\nLa colonne `max` a changé. Elle est maintenant identique à la colonne `lifeexpectancy` car la ligne courante contient la valeur maximale parmi les lignes du cadre de la fenêtre défini par `ORDER BY lifeexpectancy`. \n:::\n-->\n\n## Exemple de fonction fenêtre avec une clause `ORDER BY`\n\n`row_number()` : fonction d'agrégation qui retourne le numéro de la ligne dans la fenêtre.\n\n. . .\n\nPour les pays d'Asie, lister la région, le nom du pays, le rang du pays dans sa région pour l'espérance de vie et le rang du pays dans sa région pour le PNB par habitant.\n\n. . .\n\n```{.sql}\nSELECT region, name_country, \n  row_number() OVER (\n    PARTITION BY region   \n    ORDER BY lifeexpectancy DESC\n  ) AS rk_lifeexpectancy,\n  row_number() OVER (\n    PARTITION BY region   \n    ORDER BY gnp / population_country DESC\n  ) AS rk_gnp \nFROM world.country \nWHERE continent LIKE 'Asi%' and lifeexpectancy IS NOT NULL and gnp IS NOT NULL\nORDER BY region, lifeexpectancy DESC;\n```\n\n::: {.callout-warning}\n\nDans cette requête, il faut rejeter les valeurs `NULL` sinon le rang n'aurait pas de sens (ces lignes seraient en tête).\n\n:::\n\n---\n\nY-a-t-il une correlation entre les deux rangs ?\n\n```\n|region                   |name_country        |rk_lifeexpectancy|rk_gnp|\n|-------------------------|--------------------|-----------------|------|\n|Eastern Asia             |Macao               |1                |3     |\n|Eastern Asia             |Japan               |2                |1     |\n|Eastern Asia             |Hong Kong           |3                |2     |\n|Eastern Asia             |Taiwan              |4                |4     |\n|Eastern Asia             |South Korea         |5                |5     |\n|Eastern Asia             |China               |6                |6     |\n|Eastern Asia             |North Korea         |7                |8     |\n|Eastern Asia             |Mongolia            |8                |7     |\n|Middle East              |Israel              |1                |2     |\n|Middle East              |Jordan              |2                |12    |\n|Middle East              |Cyprus              |3                |5     |\n|Middle East              |Kuwait              |4                |4     |\n|Middle East              |United Arab Emirates|5                |3     |\n|Middle East              |Bahrain             |6                |6     |\n|Middle East              |Qatar               |7                |1     |\n|Middle East              |Oman                |8                |7     |\n|Middle East              |Palestine           |9                |13    |\n|Middle East              |Lebanon             |10               |9     |\n|Middle East              |Turkey              |11               |11    |\n|Middle East              |Syria               |12               |10    |\n|Middle East              |Saudi Arabia        |13               |8     |\n|Middle East              |Iraq                |14               |17    |\n|Middle East              |Armenia             |15               |16    |\n|Middle East              |Georgia             |16               |14    |\n|Middle East              |Azerbaijan          |17               |15    |\n|Middle East              |Yemen               |18               |18    |\n|Southeast Asia           |Singapore           |1                |2     |\n|Southeast Asia           |Brunei              |2                |1     |\n|Southeast Asia           |Malaysia            |3                |4     |\n|Southeast Asia           |Vietnam             |4                |9     |\n|Southeast Asia           |Thailand            |5                |5     |\n|Southeast Asia           |Indonesia           |6                |8     |\n|Southeast Asia           |Philippines         |7                |6     |\n|Southeast Asia           |Cambodia            |8                |7     |\n|Southeast Asia           |Myanmar             |9                |3     |\n|Southeast Asia           |Laos                |10               |10    |\n|Southeast Asia           |East Timor          |11               |11    |\n|Southern and Central Asia|Sri Lanka           |1                |4     |\n|Southern and Central Asia|Iran                |2                |1     |\n|Southern and Central Asia|Tajikistan          |3                |10    |\n|Southern and Central Asia|Uzbekistan          |4                |6     |\n|Southern and Central Asia|Kyrgyzstan          |5                |9     |\n|Southern and Central Asia|Kazakstan           |6                |2     |\n|Southern and Central Asia|India               |7                |7     |\n|Southern and Central Asia|Maldives            |8                |5     |\n|Southern and Central Asia|Pakistan            |9                |8     |\n|Southern and Central Asia|Turkmenistan        |10               |3     |\n|Southern and Central Asia|Bangladesh          |11               |12    |\n|Southern and Central Asia|Nepal               |12               |13    |\n|Southern and Central Asia|Bhutan              |13               |14    |\n|Southern and Central Asia|Afghanistan         |14               |11    |\n\n```\n\n\n## Sommes cumulées par groupes selon un ordre \n\nAvec une clause `ORDER BY`, une fonction fenêtre `SUM()` effectue une somme cumulée selon l'ordre choisi.\n\n. . . \n\nCalculer, pour chaque pays d'Europe, le pourcentage des PNB supérieur ou égal à celui du pays parmi ceux de sa région.\n\n. . .\n\n```{.sql}\nSELECT \n  region, name_country,  \n  ROUND(SUM(gnp) OVER (\n    PARTITION BY region  \n  ORDER BY gnp DESC) \n  / sum(gnp) OVER (\n    PARTITION BY region), 4)*100  \n  AS pc_sum_GNP    \nFROM world.country c \nWHERE continent = 'Europe'\norder by region, gnp DESC;\n```\n\n---\n\n```\n|region          |name_country                 |pc_sum_gnp|\n|----------------|-----------------------------|----------|\n|Baltic Countries|Lithuania                    |47,69     |\n|Baltic Countries|Latvia                       |76,23     |\n|Baltic Countries|Estonia                      |100       |\n|British Islands |United Kingdom               |94,78     |\n|British Islands |Ireland                      |100       |\n|Eastern Europe  |Russian Federation           |41,91     |\n|Eastern Europe  |Poland                       |64,9      |\n|Eastern Europe  |Czech Republic               |73,23     |\n|Eastern Europe  |Hungary                      |80,55     |\n|Eastern Europe  |Ukraine                      |86,94     |\n|Eastern Europe  |Romania                      |92,72     |\n|Eastern Europe  |Slovakia                     |95,84     |\n|Eastern Europe  |Belarus                      |97,92     |\n|Eastern Europe  |Bulgaria                     |99,76     |\n|Eastern Europe  |Moldova                      |100       |\n|Nordic Countries|Sweden                       |33,47     |\n|Nordic Countries|Denmark                      |59,2      |\n|Nordic Countries|Norway                       |80,76     |\n|Nordic Countries|Finland                      |98,78     |\n|Nordic Countries|Iceland                      |100       |\n|Nordic Countries|Svalbard and Jan Mayen       |100       |\n|Nordic Countries|Faroe Islands                |100       |\n|Southern Europe |Italy                        |57,73     |\n|Southern Europe |Spain                        |85,23     |\n|Southern Europe |Greece                       |91,23     |\n|Southern Europe |Portugal                     |96,49     |\n|Southern Europe |Croatia                      |97,49     |\n|Southern Europe |Slovenia                     |98,48     |\n|Southern Europe |Yugoslavia                   |99,32     |\n|Southern Europe |Malta                        |99,5      |\n|Southern Europe |Albania                      |99,66     |\n|Southern Europe |Bosnia and Herzegovina       |99,8      |\n|Southern Europe |Macedonia                    |99,88     |\n|Southern Europe |Andorra                      |99,96     |\n|Southern Europe |San Marino                   |99,99     |\n|Southern Europe |Gibraltar                    |100       |\n|Southern Europe |Holy See (Vatican City State)|100       |\n|Western Europe  |Germany                      |45,65     |\n|Western Europe  |France                       |76,13     |\n|Western Europe  |Netherlands                  |84,07     |\n|Western Europe  |Switzerland                  |89,73     |\n|Western Europe  |Belgium                      |95,08     |\n|Western Europe  |Austria                      |99,61     |\n|Western Europe  |Luxembourg                   |99,96     |\n|Western Europe  |Liechtenstein                |99,98     |\n|Western Europe  |Monaco                       |100       |\n```\n\n## Clause RANGE dans une fonction fenêtre\n\nIl est possible d'ajouter une clause `RANGE` à une clause `ORDER BY` pour modifier le cadre de la fenêtre :\n\n```{.sql}\nf(...) OVER (\n    PARTITION BY attribut1\n    ORDER BY attribut2 \n    RANGE BETWEEN ... AND ...\n  )\n````\nOn utilise les mots clés `UNBOUNDED`, `PRECEDING`, `FOLLOWING` et `CURRENT ROW` pour spécifier les bornes de l'intervalle que doit respecter `attribut2`.\n\n\n:::{.callout-note}\n\n- `RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING` : le cadre s'étend à tout le groupe défini par la partition.\n- `RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW` : le cadre s'étend de la première ligne du groupe défini par la partition à la ligne courante.\n\n:::\n\n## Exemples de clause RANGE dans une fonction fenêtre\n\n::::: {.columns}\n::: {.column}\n\nCalcul d'une moyenne mobile sur l'intervalle [GNP ligne courante - 1000 , GNP ligne courante + 1000]\n\n```{.sql}\nSELECT \n  continent, name_country, \n  AVG(gnp) OVER \n  (\n    PARTITION BY continent  \n    ORDER BY gnp DESC\n    RANGE BETWEEN 10000 PRECEDING AND 10000 FOLLOWING \n  ) mob_avg_gnp\nFROM world.country c \nORDER BY continent, gnp DESC;\n```\n:::\n\n::: {.column}\nCalcul d'une moyenne mobile sur l'intervalle [GNP ligne courante - 1000 , GNP ligne courante]\n\n```{.sql}\nSELECT \n  continent, name_country, \n  AVG(gnp) OVER \n  (\n    PARTITION BY continent  \n    ORDER BY gnp DESC\n    RANGE BETWEEN 10000 PRECEDING AND CURRENT ROW \n  ) mob_avg_gnp\nFROM world.country c \nORDER BY continent, gnp DESC;\n```\n:::\n:::::\n\n## Limites d'utilisation des fonctions fenêtres\n\n::: {.callout-warning}\n\nLes fonctions de fenêtre ne sont autorisées que dans les clauses `SELECT` et  `ORDER BY` de la requête. \n\nElles sont interdites ailleurs, par exemple dans les clauses `GROUP BY`, `HAVING` et `WHERE`. \n\nEn effet, elles s'exécutent logiquement **après** le traitement de ces clauses. \n\n:::\n\n. . .\n\n::: {.callout-caution}\n\nDe même, les fonctions de fenêtre s'exécutent *après* les fonctions d'agrégation habituelles. \n\nCela signifie qu'il est pertinent d'inclure un appel de fonction d'agrégation \ndans les arguments d'une fonction de fenêtre, mais pas l'inverse.\n\n:::\n\n\n<!--\n\n## Différentes alternatives pour une même requête\n\nAfficher le pays le plus peuplé \n\n. . .\n\n::::: {.columns}\n::: {.column}\n\n```{.sql}\nSELECT S.name_country, \n  S.continent, \n  S.population_country\nFROM (\n  SELECT max(population_country) AS mpc \n  FROM country c\n  ) AS R \n  JOIN LATERAL (    \n    SELECT * \n    FROM country c2 \n    WHERE c2.population_country >= R.mpc\n    ) AS S \n  ON (TRUE) ;\n```\n\n:::\n\n\n::: {.column}\n\n```{.sql}\nSELECT c.name_country, \n       c.continent, \n       c.population_country\nFROM (\n  SELECT max(population_country) AS mpc \n  FROM country c2\n  ) AS S\n  JOIN country c \n  ON (c.population_country >= S.mpc)    \n;\n```\n\n:::\n:::::\n\n\n\n```{.sql}\nname_country|continent|population_country|\n------------+---------+------------------+\nChina       |Asia     |        1277558000|\n```\n\n\n## Différentes alternatives  (suite)\n\nAfficher le pays le plus peuplé \n\n::::: {.columns}\n::: {.column}\n\n```{.sql}\nSELECT * \nFROM world.country c  \nWHERE population_country >= ALL(\n  SELECT cc.population_country  \n  FROM world.country  cc\n) ;     \n\n```\n\n:::\n::: {.column}\n\n```{.sql}\nWITH S AS (        \n  SELECT c.*, max(population_country) \n         OVER () AS mpc  \n  FROM world.country c\n)\nSELECT * \nFROM S   \nWHERE population_country >= mpc ;\n```\n\n:::\n::::: \n\n```{.sql}\nname_country|continent|population_country|\n------------+---------+------------------+\nChina       |Asia     |        1277558000|\n```\n-->\n\n\n# Groupements avancés   {background-color=\"#1c191c\"}\n\n\n## Introduction\n\nIntroduits dans SQL avec la mode du `Data mining`  (Fouille de données) dans les années 1990.\n\nPermet de réaliser de facon apparemment simultanée des aggrégations de régularités emboîtées. \n\nDans le monde des statistiques, lorsqu'on aggrège des comptages de grains différents, on parle de tables de contingences (*contingency tables*).  \n\n[Documentation PostgreSQL](https://www.postgresql.org/docs/current/queries-table-expressions.html#QUERIES-GROUPING-SETS){target=\"_blank\"}\n\n\n\n## GROUPING SETS\n\nUn `GROUPING SETS` permet d'effectuer simultanément des calculs d'agrégats pour différentes partitions de la table.\n\nIl s'écrit dans la clause `GROUP BY` avec une liste d'ensemble d'attributs de la forme `((c1,c2), (c1), (c2))`. \n\n`GROUP BY GROUPING SETS ((c1,c2), (c1), ())` \n\nsignifie que l'on fera les calculs d'agrégats successivement pour les regroupements selon `c1,c2`, puis pour les regroupements selon `c1`, puis sans regroupement. \n\nDans le résultat, lorsque le partitionnement selon `c1` est effectué, la colonne  `c2` a la valeur `NULL` (i.e. pas de valeur), ce qui cohérent avec le fonctionnement de `GROUP BY`. \n\n---\n\nOn suppose que les colonnes `c1` et `c2` de la table `t` ne contiennent chacune que 2 valeurs distinctes.\n\nLa requête\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT c1, c2, aggregate_function( ... ) as f\nFROM t\nGROUP BY GROUPING SETS ((c1,c2), (c2), ());   \n```\n:::\n\ndonne un résultat de la forme : \n\n```\n|c1    |c2    |f    |\n|------|------|-----|\n|x1    |y1    |z1   |\n|x1    |y2    |z2   |\n|x2    |y1    |z3   |\n|x2    |y2    |z4   |\n|      |y1    |z5   |\n|      |y2    |z6   |\n|      |      |z7   |\n```\n\n\n## Exemple avec `GROUPING SETS`\n\n```{.sql}\nSELECT continent, region, max(lifeexpectancy)\nFROM country c \nWHERE continent LIKE '%America'\nGROUP BY GROUPING SETS  ((continent, region), (continent), ())  \nORDER BY continent, region ;\n```\n\n```\n|continent    |region         |max |\n|-------------|---------------|----|\n|North America|Caribbean      |78,9|\n|North America|Central America|75,8|\n|North America|North America  |79,4|\n|North America|               |79,4|\n|South America|South America  |76,1|\n|South America|               |76,1|\n|             |               |79,4|\n```\n\n\n## ROLLUP\n\n`ROLLUP ( a, b, c, ... )`\n\nest un raccourci pour\n\n```\nGROUPING SETS (\n    ( a, b, c, ... ),\n    ...\n    ( a, b ),\n    ( a ),\n    ( )\n)\n```\n\n\n## Exemple avec `ROLLUP`\n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT continent, region, max(lifeexpectancy)\nFROM country c \nWHERE continent LIKE '%America'\nGROUP BY ROLLUP  (continent, region)  \nORDER BY continent, region ;\n```\n:::\n\n\n\n\n```\n+-------------+---------------+----+\n|Continent    |Region         |max |\n+-------------+---------------+----+\n|North America|Caribbean      |78.9|\n|North America|Central America|75.8|\n|North America|North America  |79.4|\n|North America|               |79.4|\n|South America|South America  |76.1|\n|South America|               |76.1|\n|             |               |79.4|\n```\n\n\n## `CUBE`\n\n`CUBE (a, b, c)` est un raccourci pour un `GROUPING SETS` contenant toutes les parties de `(a, b, c)`, c.a.d\n\n```\nGROUPING SETS (\n    (         )\n    ( a, b, c ),\n    ( a, b    ),\n    ( a       ),\n    (    b, c ),\n    (    b    ),\n    ( a,    c ),\n    (       c ),\n)\n```\n\n\n## Exemple avec `CUBE`\n\n:::::{.columns}\n\n:::{.column width=\"43%\"}\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT continent, region, governmentform, \n       count(*) AS cnt, \n       max(lifeexpectancy)\nFROM country c \nWHERE continent LIKE '%America'\nGROUP BY CUBE (continent,region,governmentform)\nHAVING COUNT(*) > 5;\n```\n:::\n\n:::\n\n:::{.column width=\"57%\"}\n```\n|continent    |region         |governmentform               |cnt|max |\n|-------------|---------------|-----------------------------|---|----|\n|             |               |                             |51 |79,4|\n|South America|South America  |Republic                     |9  |75,7|\n|North America|Central America|Republic                     |6  |75,8|\n|North America|Caribbean      |Constitutional Monarchy      |8  |75,2|\n|North America|Caribbean      |                             |24 |78,9|\n|South America|South America  |                             |14 |76,1|\n|North America|Central America|                             |8  |75,8|\n|South America|               |                             |14 |76,1|\n|North America|               |                             |37 |79,4|\n|             |Caribbean      |Constitutional Monarchy      |8  |75,2|\n|             |South America  |Republic                     |9  |75,7|\n|             |Central America|Republic                     |6  |75,8|\n|             |South America  |                             |14 |76,1|\n|             |Central America|                             |8  |75,8|\n|             |Caribbean      |                             |24 |78,9|\n|North America|               |Constitutional Monarchy      |9  |75,2|\n|North America|               |Republic                     |10 |75,8|\n|South America|               |Republic                     |9  |75,7|\n|North America|               |Dependent Territory of the UK|6  |78,9|\n|             |               |Republic                     |19 |75,8|\n|             |               |Constitutional Monarchy      |9  |75,2|\n|             |               |Dependent Territory of the UK|7  |78,9|\n```\n:::\n\n:::::\n\n\n\n# Résumé  {background-color=\"#1c191c\"}\n\n\n## Portrait robot d'une requête \n\n```{.sql}\nSELECT <attributs>           -- les colonnes de la table résultat\n\nFROM <relations>             -- la/les table/s qui émettent les données\n\n[WHERE <condition> ]         -- filtre\n\n[GROUP BY <attributs de partitionnement>   -- découpage en groupes\n\n[HAVING <condition>]]      -- filtrage des groupes\n\n[ORDER BY <critere>]       -- trier \n```\n\n  \n- `SELECT` : attributs du résultat (avec agrégations éventuelles)\n- `WHERE` : condition de sélection indépendante du `GROUP BY`\n- `HAVING` : condition de sélection portant sur les groupes\n  \n<!--\n---\n\n::: {.callout-caution}\n\n### Avis \n\nToutes les requêtes  SQL contiennent une combinaison de ces clauses. Retenez au moins cela!\n\n:::\n\n```{.sql}\nSELECT        -- columns to display\nFROM          -- table(s) to pull from\nWHERE         -- filter\nGROUP BY      -- split rows into groups\nHAVING        -- filter within groups\nORDER BY      -- sort\n```\n-->\n\n\n\n## Ordre d'exécution des éléments d'une requête \n\n1. Rassembler les données mentionnées dans la clause `FROM`\n\n2. Filter les lignes selon la clause  `WHERE`\n\n3.  Regrouper les lignes selon la clause `GROUP BY`\n\n4. Filtrer les groupes selon la clause  `HAVING`\n\n5. Specifier les colonnes du résultat selon la clause `SELECT`\n\n6. Trier le résultat final selon la clause `ORDER BY`\n\n\n\n\n# Références {background-color=\"#1c191c\"}\n\n\n---\n\n[Tutoriel `SELECT`  de PostGreSQL](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-select/){target=\"_blank\"}\n\n[Tutoriel `joins`](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-joins/){target=\"_blank\"}\n\n[Documentation requêtes](https://www.postgresql.org/docs/current/queries.html){target=\"_blank\"}\n\n[Documentation `SELECT`](https://www.postgresql.org/docs/14/sql-select.html){target=\"_blank\"}\n\n[GROUPING SETS, ROLLUP, CUBE](https://www.postgresql.org/docs/14/queries-table-expressions.html#QUERIES-GROUPING-SETS){target=\"_blank\"}\n\n---\n\n\n# Fin {background-color=\"#1c191c\"}\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}