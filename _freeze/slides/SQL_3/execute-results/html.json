{
  "hash": "8c28778803c72cf1ec0e3ded79e53477",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"BD IV: SQL III\"\nsubtitle: \"Langage Manipulation de Données 3 : Aggrégation/Fenêtres/Partitions\"\ndate: \"2024-10-04\"\n\nformat: \n  revealjs:\n    header: \"Requêtes SQL : Aggrégation/Fenêtres/Partition\"\n\nengine: knitr\n---\n\n\n\n\n\n# Fonctions d'agrégation en SQL   {background-color=\"#1c191c\"}\n\n\n---\n\n## Limite de l'algèbre relationnelle pure \n\nL'algèbre relationnelle pure (σ, π, ⋈)ne sait pas tout calculer\n\nCertains problèmes aisément solubles par un langage de programmation complet (`Python`, `C`, `R`, ...) ne sont pas solubles dans \nl'algèbre relationnelle pure ( $\\sigma(), \\pi(), \\bowtie(), ...$ ) :\n\n- accessibilité dans un graphe non-orienté (qui puis-je contacter dans un réseau social?)\n\n- compter : quel est le nombre de lignes d'une table ?\n\n\n## Extension de l'algèbre relationnelle\n\n::: {.callout-note}\n\n### Idée générale \n\nUn opérateur `Résume()` qui admet une opérande `T` de type table et comme autres arguments une suite d'expressions susceptibles de calculer des *agrégats* \n\n`Résume(T, expr1, ..., exprk)` retourne une table `S` à **une** ligne et `k` colonnes \n\nLa colonne `i` de `S` contient l'évaluation de `expri` sur la table `T`\n\n:::\n\n::: {.callout-caution}\n\nIl n'est pas évident de définir ce que peut être une fonction d'agrégation et un agrégat\n\nNous travaillerons  à partir d'exemples concrets\n\n:::\n\n## {{< fa binoculars >}} Fonctions d'agrégation en SQL \n\n- Possibilité de *compter*, de *faire des moyennes*, de trouver un maximum, ... en SQL (contrairement à l'algèbre relationnelle \"classique\")\n\n<!-- - Possibilité de *partitionner* les données -->\n\n[Tutorial Aggregation functions PostgreSQL](https://www.postgresql.org/docs/current/tutorial-agg.html)\n\n## Usages \n\n- [Analyse commerciale ou Buisiness Analytics](https://fr.wikipedia.org/wiki/Business_analytics), \n\n- OLAP\n  \n- Statistique et Data Science \n\n\n\n## Dans la partie `SELECT`\n\n- Somme des valeurs prises par `nomattribut`\n\n```\nRésume(T, SOMME(nomattribut))\n```\n\nse traduit en \n\n```{.sql}\nSELECT \n  SUM (DISTINCT|ALL <nomattribut>)  \nFROM T\n```\n\n. . . \n \n- Moyenne des valeurs prises par `nomattribut`\n\n```\nRésume(T, MOYENNE(nomattribut))\n```\n\nse traduit en \n\n```{.sql}\nSELECT \n  AVG (DISTINCT|ALL <nom_attribut>) \nFROM T\n```\n\n. . .\n\n{{< fa triangle-exclamation >}} Le type des attributs doit être un nombre ou un entier (sinon, \nimpossible de faire des sommes, des moyennes...).\n\n\n\n## Fonctions d'agrégation  : `SUM` et `AVG`\n  \n- Somme des populations des villes du pays de code `FRA` (dans le schéma `world`).\n\n```{.sql}\nSELECT SUM (population)  \nFROM city \nWHERE countrycode = 'FRA';\n```\n\nTraduction de \n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nσ(city, countrycode = 'FRA') |>\n  Résume(SOMME(population))\n```\n:::\n\n\n\n- GNP moyen par habitant (pas pondéré!) sur le continent `South America`\n\n```{.sql}\nSELECT \n  AVG(1e6*gnp/population_country)::decimal(8,0) \nFROM \n  country \nWHERE \n  continent = 'South America'\n```\n\nTraduction de \n\n```{.sql}\nσ(country, continent = 'South America') |>\n  Résume(MOYENNE(1e6*gnp/population_country))\n```\n\n\n\n\n# Fonctions MAX et MIN   {background-color=\"#1c191c\"}\n\n\n\n## Fonctions de calcul  : `MAX`, `MIN`\n  \n```{.sql}\nSELECT \n  MAX (<nomattribut>)  \nFROM T ;\n```\n\nmaximum des valeurs prises par `<nomattribut>`\n\n. . .\n\n\n```{.sql}\nSELECT \n  MIN (<nomattribut>)  \nFROM T \n```\n\nminimum des valeurs prises par  `<nomattribut>` dans `T`\n\n\n::: {.callout-caution}\n\n### {{< fa mug-hot >}}\n\nAttention aux valeurs nulles !\n\n`NULL = MIN(NULL, 3, 100)` ou `3 = MIN(NULL, 3, 100)` ?\n\n{{< fa hand-point-right >}} Essayez `SELECT MIN(gnpold) FROM country;` !\n:::\n\n. . .\n\n```{.sql}\nSELECT MAX (gnpold), max(gnp)   \nFROM country \nWHERE region = 'Caribbean';\n   max    |   max    \n----------+----------\n 32100.00 | 34100.00\n```\n\n---\n\n::: {.callout-note}\n\n### Que se passe-t-il lorsqu'on calcule un agrégat sur une colonne contenant des données manquantes (`NULL`) ?\n\nQuelles sont les procédés mis en œuvre en statistique ?\n\nQuels sont les procédés mis en œuvre par PostgreSQL ?\n\n:::\n\n```{.sql}\nSELECT name_country, gnpold, gnp\nFROM country\nWHERE continent = 'Europe' AND (gnp IS NULL OR gnpold IS NULL)\n         name_country          | gnpold |   gnp    \n-------------------------------+--------+----------\n Andorra                       |        |  1630.00\n Bosnia and Herzegovina        |        |  2841.00\n Faroe Islands                 |        |     0.00\n Gibraltar                     |        |   258.00\n Svalbard and Jan Mayen        |        |     0.00\n Yugoslavia                    |        | 17000.00\n Monaco                        |        |   776.00\n San Marino                    |        |   510.00\n Belarus                       |        | 13714.00\n Holy See (Vatican City State) |        |     9.00\n```\n\n. . .\n\n::: {.aside}\n\nIci, les données manquantes sont *implicitement* ignorées\n\n:::\n\n```{.sql}\nSELECT max(gnpold) AS max_gnpold, max(gnp) AS max_gnp   \nFROM country \nWHERE continent  = 'Europe';\n  max_gnpold |  max_gnp \n-------------+------------\n  2102826.00 | 2133367.00\n```\n\n\n\n\n# Fonction COUNT  {background-color=\"#1c191c\"}\n\n\n\n## Fonctions de calcul : `COUNT`\n\nOn peut aussi compter le nombre de tuples dans le résultat d'une requête  \n\n```{.sql}\nSELECT \n  COUNT(* |[ ALL | DISTINCT <nomattribut>])  \nFROM T\n```\n\nNombre de valeurs prises par le résultat\n\n. . .\n\n- `DISTINCT` : sans les doublons \n- `ALL`: avec les doublons\n- `*` : y compris les valeurs nullles/manquantes\n\nNombre de territoires dans la région `Carribean`\n\n```{.sql}\nSELECT COUNT(*)  \nFROM country\nWHERE region = 'Caribbean'; \n```\n\n::: {.aside}\n\nDans `COUNT(* |[ ALL | DISTINCT <nomattribut>])`, il faut comprendre qu'on peut écrire \n`COUNT(*)` ou `COUNT (ALL country)` ou `COUNT (DISTINCT country)`. Le symbole `|` est utilisé pour décrire une alternative \n\n:::\n\n# Retour sur fonction `SUM` {background-color=\"#1c191c\"}\n\n\n## Fonction de calcul `SUM()`\n\nOn peut sommer les valeurs contenues dans une colonne numérique \n\n\n\n::: {.cell}\n\n```{.sql .cell-code  code-line-numbers=\"2|2-4|\"}\nSELECT \n  SUM(population) AS urban_pop\nFROM city  ci\nWHERE ci.countrycode = 'GBR' ;\n```\n:::\n\n\n\n```{.sql}\n+-----------+\n| urban_pop |\n|-----------|\n| 22436673  |\n+-----------+\n```\n\n## Sommation sur tableau vide\n\n\n\n\n::: {.cell}\n\n```{.sql .cell-code  code-line-numbers=\"2|2-4|\"}\nSELECT \n  SUM(population) AS urban_pop\nFROM city  ci\nWHERE ci.countrycode = 'zzz' ;\n+-----------+\n| urban_pop |\n|-----------|\n| <null>    |\n+-----------+\n```\n:::\n\n\n\nEst-ce cohérent?\n\n## Autre approche  avec  `CASE WHEN ...THEN ... ELSE ...`\n\n\n```{.sql}\nSELECT \n  SUM(\n    CASE \n      WHEN countrycode='GBR' THEN population \n      ELSE 0 \n    END) AS urban_pop \n FROM city  ci ;\n\n+-----------+\n| urban_pop |\n|-----------|\n| 22436673  |\n+-----------+\n```\n\n\n\n---\n\n\n```{.sql}\nSELECT \n  SUM(\n    CASE \n      WHEN countrycode='xxx' THEN population \n      ELSE 0 \n    END) AS urban_pop \n FROM city  ci ;\n+-----------+\n| urban_pop |\n|-----------|\n| 0         |\n+-----------+\n```\n\n\n## Calculer les populations vivant sous diﬀérents régimes \n\n\n```{.sql}\nSELECT \n  SUM(CASE \n    WHEN governmentform LIKE '%Monarchy%' THEN population_COUNTRY \n    ELSE 0 \n  END) AS pop_monarch,  \n  SUM(CASE \n    WHEN governmentform LIKE '%Republic%' THEN population_COUNTRY \n    ELSE 0 \n  END) AS pop_repu \nFROM country ;\n+-------------+------------+\n| pop_monarch | pop_repu   |\n|-------------+------------|\n| 519485000   | 5502453700 |\n+-------------+------------+\n```\n\n\n## Agrégats sur données filtrées `FILTER (WHERE condition)`\n\n```{.sql}\nSELECT \n  SUM(population_country) FILTER  \n    (WHERE governmentform LIKE '%Monarchy%') AS pop_monarch,  \n  SUM(population_country) FILTER \n    (WHERE governmentform LIKE '%Republic%') AS pop_repu \nFROM country ;\n+-------------+------------+\n| pop_monarch | pop_repu   |\n|-------------+------------|\n| 519485000   | 5502453700 |\n+-------------+------------+\n```\n\n## Pour en savoir plus ?\n\n[Documentation PostgreSQL](https://www.postgresql.org/docs/current/functions-aggregate.html)\n\n\n# Fonctions de calcul  : exemples  {background-color=\"#1c191c\"}\n\n\n## Combinaison de quelques opérations et fonctions\n\nNom des régions comportant plus de $10$ territoires.\n\n. . .\n\n```{.sql}\n--| eval: false\n--| echo: false\n--| code-line-numbers: \"1-2|4-6|\"\nSELECT DISTINCT c.region \nFROM country c \nWHERE (\n  SELECT COUNT (*)     \n  FROM country co     \n  WHERE co.region = c.region\n) >= 15;  \n```\n\n\n\n\n\n## Musée des horreurs   {.smaller}\n\nTrouver les régions où au moins un pays possède une espérance de vie inférieure à `50`\n\n```{.sql}\nSELECT DISTINCT continent, region\nFROM country c \nWHERE (\n  SELECT MIN(d.lifeexpectancy)     \n  FROM country d    \n  WHERE c.region=d.region\n  ) < 50    \nORDER BY continent, region;\n```\n\n|**Continent**    |**Region**                   |\n|:------------|:------------------------|\n|Africa       |Central Africa           |\n|Africa       |Eastern Africa           |\n|Africa       |Northern Africa          |\n|Africa       |Southern Africa          |\n|Africa       |Western Africa           |\n|Asia         |Southeast Asia           |\n|Asia         |Southern and Central Asia|\n|North America|Caribbean                |\n\n\n::: {.aside}\n\nPourquoi cette requête est-elle horrible ?\n\n:::\n\n\n## {.smaller}\n\n{{< fa hand-point-right >}} On peut faire plus simple (et plus efficace) dans le case présent\n\n```{.sql}\nSELECT \n  DISTINCT continent, region\nFROM country c \nWHERE c.lifeexpectancy <50 \nORDER BY continent, region;\n```\n\n\n|**Continent**    |**Region**                   |\n|:------------|:------------------------|\n|Africa       |Central Africa           |\n|Africa       |Eastern Africa           |\n|Africa       |Northern Africa          |\n|Africa       |Southern Africa          |\n|Africa       |Western Africa           |\n|Asia         |Southeast Asia           |\n|Asia         |Southern and Central Asia|\n|North America|Caribbean                |\n\n\n---\n\nMais si on veut lister les régions où tous les pays ont une espèrance de  vie supérieure à 50 ?\n\n. . .\n\nPourquoi pas ?\n\n```{.sql}\nSELECT \n  DISTINCT continent, region\nFROM country c \nWHERE (\n  SELECT MIN(d.lifeexpectancy)     \n  FROM country d    \n  WHERE c.region=d.region\n  ) > 50    \nORDER BY continent, region;\n```\n\n::: {.aside}\n\nCombien de fois calculez vous l'espérance de minimale pour chaque région ?\n\n:::\n\n\n\n## Fonctions de calcul : exemples (suite)\n\nUtilisation d'opérateurs arithmétique entre les différents attributs d'un même tuple...  \n\n<!-- Prix de revient des commandes livrées par le fournisseur `FD` -->\n\n```{.sql}\nSELECT \n  AVG(1e6*gnp/population_country)::decimal(8,0) \nFROM country \nWHERE \n  continent LIKE 'South Am%' AND\n  population_country > 0 ;\n```\n\n\n# Partitions,  `GROUP BY` {background-color=\"#1c191c\"}\n\n\n## Partition de résultats de requêtes\n\n\n```{.sql}\nGROUP BY <nomattribut1>, ..., <nomattributn>\n```\n\n- `GROUP BY` permet de regrouper selon la  valeur de certains attributs l'ensemble des résults d'une requête\n\n- Forme des sous-relations auxquelles on peut appliquer des opérateurs (`SUM`, `MAX`, ...) renvoyant un résultat par sous-relation\n\n\nExemple d'utilisation : regrouper les livraisons par numéro de fournisseur et prendre la quantité maximum livrée par fournisseur.\n\n\n## Partition de résultats de requêtes   {.smaller}\n\nSchéma général\n\n```{.sql}\nSELECT ... \nFROM country \nGROUP BY continent    \n```\n\n## {.smaller}\n\n\n```{.sql}\n+-------------+---------------------+---------------+\n| countrycode | name_country        | continent     |\n|-------------+---------------------+---------------|\n| DZA         | Algeria             | Africa        |\n| AGO         | Angola              | Africa        |\n| ...         |                     |               |\n| ATA         | Antarctica          | Antarctica    |\n| BVT         | Bouvet Island       | Antarctica    |\n| ...         |                     |               |\n| AFG         | Afghanistan         | Asia          |\n| ARM         | Armenia             | Asia          |\n| ...         |                     |               |\n| ALB         | Albania             | Europe        |\n| AND         | Andorra             | Europe        |\n| ...         |                     |               |\n| AIA         | Anguilla            | North America |\n| ATG         | Antigua and Barbuda | North America |\n| ...         |                     |               |\n| ASM         | American Samoa      | Oceania       |\n| AUS         | Australia           | Oceania       |\n| ...         |                     |               |\n| ARG         | Argentina           | South America |\n| BOL         | Bolivia             | South America |\n+-------------+---------------------+---------------+\n```\n\n\n\n## Partition de résultats de requêtes\n\nPopulation maximale par continent  \n\n```{.sql}\nSELECT continent, max(population_country) \nFROM country \nGROUP BY continent ; \n```\n\n```{.sql}\n+---------------+------------+\n| continent     | max        |\n|---------------+------------|\n| Asia          | 1277558000 |\n| South America | 170115000  |\n| North America | 278357000  |\n| Oceania       | 18886000   |\n| Antarctica    | 0          |\n| Africa        | 111506000  |\n| Europe        | 146934000  |\n+---------------+------------+\n```\n\nLes opérateurs (`MAX`, `SUM`, etc) s'appliquent à chaque groupe de relations.\n\n\n## Exemple   {.smaller}\n\nDans le schéma `world`, quel est le `gnp` moyen par `region` sur le continent `Europe` ?\n\n\n```{.sql}\nSELECT region, \n\t   ROUND(1000 * SUM(gnp)/SUM(population_country),2) AS avg_gnp,  \n\t   ROUND(MAX(1000* gnp/population_country),2) AS max_gnp, \n\t   ROUND(MIN(1000* gnp/population_country),2) AS min_gnp,\n\t   MIN(lifeexpectancy) AS min_life_exp\nFROM country \nWHERE continent = 'Europe' \nGROUP BY region \nORDER BY avg_gnp DESC;\n```\n\n\n|**region**      |**avg_gnp**|**max_gnp**|**min_gnp**|**min_life_exp**|\n|:---------------|------:|------:|------:|-----------:|\n|Nordic Countries|  28.00|  32.66|   0.00|        76.5|\n|Western Europe  |  25.50|  37.46|  22.82|        77.1|\n|British Islands |  22.94|  23.12|  20.11|        76.8|\n|Southern Europe |  13.91|  20.90|   0.72|        71.5|\n|Baltic Countries|   2.96|   3.70|   2.64|        68.4|\n|Eastern Europe  |   2.15|   5.35|   0.36|        64.5|\n\n\n\n\n\n## Partition de résultats de requêtes\n\nQuel est le sens de cette requête ?\n\n```{.sql}\nSELECT \n  continent, \n  COUNT(*) as nombre_pays, \n  SUM(population_country) as population_totale\nFROM country \nGROUP BY continent;\n```\n\n---\n\n\nLa requête suivante  requête n'est pas correcte \n\n```{.sql}\nSELECT continent, region, MAX(population_country) \nFROM country \nGROUP BY continent;\n```\n\n. . .\n\n::: {.callout-important}\n\n### {{< fa skull >}}\n\nLes attributs présents dans le `SELECT` sont forcémment présents dans le `GROUP BY`.  \n\n:::\n\n\n\n\n\n\n## Partition de résultats de requêtes\n  \n    \n- La clause `HAVING` permet de poser une condition portant sur chacune des sous-relations générées par le `GROUP BY`\n\n- Les sous-relations ne vérifiant pas la condition sont écartées du résultat.\n    \n\n\nListe des continents comportent au moins cinq régions.\n\n```{.sql}\nSELECT continent \nFROM country \nGROUP BY continent    \nHAVING COUNT(DISTINCT region) >= 5;  \n```\n\n\n## Operation `GROUP BY` et calcul sur les tables   {.smaller}\n\n::: {.callout-note}\n\nL'opération `GROUP BY` ne renvoie pas une table mais (implicitement) *une collection de sous-tables* indicées/étiquetées par les valeurs des attributs de groupement\n\nL'opération `GROUP BY` ne peut pas s'intégrer dans une algèbre relationnelle, même étendue.\n\n:::\n\n::: {.callout-caution}\n\nSQL n'offre pas de moyen de mémoriser le résultat d'un `GROUP BY` avant d'effectuer des agrégations ou une projection sur les attributs de groupement.  \n\n:::\n\n. . .\n\n\n\n::: {.cell}\n\n```{.sql .cell-code  code-line-numbers=\"4-5|\"}\nSELECT *  \nFROM country \nGROUP BY continent  ;\ncolumn \"country.countrycode\" must appear in the GROUP BY clause or be used in an aggregate function\nLINE 1: SELECT * FROM country GROUP BY continent\n```\n:::\n\n\n\n---\n\n```{.sql}\nSELECT continent  \nFROM country \nGROUP BY continent  ;\n+---------------+\n| continent     |\n|---------------|\n| Asia          |\n| South America |\n| North America |\n| Oceania       |\n| Antarctica    |\n| Africa        |\n| Europe        |\n+---------------+\n```\n\n\n# Tri des résultats  {background-color=\"#1c191c\"}\n\n\n\n## Présentation/tri de résultats\n\n- La clause `ORDER BY` permet de trier le résultat de la requête, en fournissant \nla liste des attributs  sur lesquels effectuer le tri et en spécifiant le sens du tri (ascendan ou descendant)\n\nListe des pays  triée par ordre décroissant de population \n\n```{.sql}\nSELECT * \nFROM country \nORDER BY population_country DESC;  \n```\n\n\n\n## Regroupement, tri, etc : exemple\n\n  \nQue fait cette requête ?\n\n```{.sql}\nSELECT continent, COUNT(*) \nFROM country \nWHERE countrycode IN (\n  SELECT countrycode \n  FROM countrylanguage \n  WHERE language='English' AND percentage > 10 \n) \nGROUP BY continent \nHAVING AVG(1e6*gnpold/population_country) >= 1000 \nORDER BY continent;\n```\n\n<!-- Sur les relations d'une base `employé` (tables `Departement`,`Employe`, ...) -->\n\n\n\n\n## Retour au musée des horreurs  {.smaller}\n\n\n\n```{.sql}\nSELECT continent, region, MIN(c.lifeexpectancy)\nFROM country c \nGROUP BY continent, region\nHAVING MIN(c.lifeexpectancy) < 50  \nORDER BY continent, region ;   \n```\n\n\n| **Continent**    | **Region**         |max |min |\n|:-------------|:------------------------|----|----|\n| Africa       |Central Africa           |65.3|38.3|\n| Africa       |Eastern Africa           |72.7|37.2|\n| Africa       |Northern Africa          |75.5|49.8|\n| Africa       |Southern Africa          |51.1|39.3|\n| Africa       |Western Africa           |76.8|41.3|\n| Asia         |Southeast Asia           |80.1|46.0|\n| Asia         |Southern and Central Asia|71.8|45.9|\n| North America|Caribbean                |78.9|49.2|\n\n\n\n## Exemple d'aggrégation {visibility=\"hidden\"}\n\nDans le schéma `world`, \n\n\n\n\n\n# Fonctions fenêtres (Window functions)  {background-color=\"#1c191c\"}\n\n---\n\n\nUne **fonction fenêtre** effectue un calcul sur un (sous)-ensemble de lignes de la table qui sont liées  à la ligne courante. \n\n. . .\n\n::: {.callout-note}\n\nC'est comparable au type de calcul effectué avec une fonction d'agrégation. \n\n:::\n\n. . .\n\nMais les fonctions de fenêtre ne regroupement pas les lignes en une seule ligne de sortie. \n\nAu contraire, les lignes conservent leurs identités distinctes. \n\nEn coulisses, la fonction de fenêtre est capable d'accéder à plus que la ligne actuelle du résultat de la requête.\n\n## Exemple {.smaller}\n\nDans le schéma `world`, présenter pour chaque pays dont la région comprend le motif \n`Countries`, l'espérance de vie, l'espérance de vie maximale et minimale dans la région.\n\n\n\n\n\n::: {.cell}\n\n```{.sql .cell-code  code-line-numbers=\"2-3|1-4|\"}\nSELECT region, name_country, lifeexpectancy, \n\t   min(lifeexpectancy) OVER (PARTITION BY region),  \n\t   max(lifeexpectancy) OVER (PARTITION BY region)   \nFROM country \nWHERE region LIKE '%Countries'\nORDER BY region, lifeexpectancy  \nLIMIT 6 ;\n```\n:::\n\n\n\n|Region          | Name of country      |Life expectancy|min |max |\n|----------------|----------------------|--------------|----|----|\n|Baltic Countries|Latvia                |          68.4|68.4|69.5|\n|Baltic Countries|Lithuania             |          69.1|68.4|69.5|\n|Baltic Countries|Estonia               |          69.5|68.4|69.5|\n|Nordic Countries|Denmark               |          76.5|76.5|79.6|\n|Nordic Countries|Finland               |          77.4|76.5|79.6|\n|Nordic Countries|Faroe Islands         |          78.4|76.5|79.6|\n\n\n## Calculer une fonction fenêtre sans invoquer `OVER (...)`   {.smaller}\n\n\nPour calculer ce résultat sans fonctions fenêtres,\n\n1. on effectue une partition selon la `region`, une aggrégation par groupe \npour calculer `min(lifeexpectancy)` et `max(lifeexpectancy)`. On obtient une table à trois colonnes.\n\n1. on calcule une (équi)-jointure avec la table `country` originelle sur  la colonne commune `region`\n\n2. on projette  le résultat sur les cinq colonnes pertinentes. \n\n. . .\n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nWITH R AS (\n  SELECT region, min(lifeexpectancy) AS minlex, max(lifeexpectancy) AS maxlex\n  FROM country\n  WHERE region LIKE '%Countries' AND lifeexpectancy IS NOT NULL \n  GROUP BY region\n)\n\nSELECT region, name_country, lifeexpectancy, minlex, maxlex\nFROM country co NATURAL JOIN R\n```\n:::\n\n\n\n\n\n\n\n## Variations   {.smaller}\n\n\n```{.sql}\nSELECT region, name_country, lifeexpectancy, \n\trank() OVER (\n    PARTITION BY region   \n\t  ORDER BY lifeexpectancy DESC\n  )  \nFROM country \nWHERE region LIKE '%Countries'\nORDER BY region, lifeexpectancy DESC \nLIMIT 6 ;\n```\n\n\n|Region          |Name of country          |life expectancy|rank|\n|:---------------|:---------------------|-------------:|:--:|\n|Baltic Countries|Estonia               |          69.5|   1|\n|Baltic Countries|Lithuania             |          69.1|   2|\n|Baltic Countries|Latvia                |          68.4|   3|\n|Nordic Countries|Svalbard and Jan Mayen|              |   1|\n|Nordic Countries|Sweden                |          79.6|   2|\n|Nordic Countries|Iceland               |          79.4|   3|\n\n::: {.aside}\n\nQue se passe-t-il avec les valeurs nulles ?\n\n:::\n\n## Sommes cumulées par groupes selon un ordre   {.smaller}\n\n```{.sql}\nSELECT \n\tregion, name_country, \n\tsum(gnp) OVER (\n    PARTITION BY region  \n\t\tORDER BY gnp\n)     \nFROM country c \nWHERE region LIKE '%Europe' \nLIMIT 6;\n```\n\n\n\n|Region        |Name Country|Sum      |\n|:-------------|:-----------|--------:|\n|Eastern Europe|Moldova     |  1579.00|\n|Eastern Europe|Bulgaria    | 13757.00|\n|Eastern Europe|Belarus     | 27471.00|\n|Eastern Europe|Slovakia    | 48065.00|\n|Eastern Europe|Romania     | 86223.00|\n|Eastern Europe|Ukraine     |128391.00|\n\n\n\n---\n\n::: {.callout-caution}\n\nLes fonctions de fenêtre ne sont autorisées que dans la liste `SELECT` et la clause `ORDER BY` de la requête. \n\nElles sont interdites ailleurs, par exemple dans les clauses `GROUP BY`, `HAVING` et `WHERE`. \n\nEn effet, elles s'exécutent logiquement après le traitement de ces clauses. \n\n:::\n\n. . .\n\n::: {.callout-caution}\n\nDe même, les fonctions de fenêtre s'exécutent *après* les fonctions d'agrégation habituelles. \n\nCela signifie qu'il est pertinent d'inclure un appel de fonction d'agrégation \ndans les arguments d'une fonction de fenêtre, mais pas l'inverse.\n\n:::\n\n\n---\n\n## Exemple  {.smaller}\n\n\nPour chaque continent, afficher les trois pays ayant l'espérance de vie à la naissance la plus élevée\n\n. . .\n\n```{.sql}\nSELECT continent, \n  name_country, \n  lifeexpectancy, \n  pos\nFROM\n  (SELECT continent, \n    name_country, \n    lifeexpectancy,\n    rank() OVER (\n      PARTITION BY continent \n      ORDER BY lifeexpectancy DESC) AS pos\n  FROM country\n  WHERE lifeexpectancy IS NOT NULL\n  ) AS ws\nWHERE pos <= 3;\n```\n\n---\n\n##  Avec `WITH ...` et les CTEs   {.smaller}\n\n\n```{.sql}\nWITH ws AS (\n  SELECT continent, \n    name_country, \n    lifeexpectancy,\n    rank() OVER (\n      PARTITION BY continent \n      ORDER BY lifeexpectancy DESC) AS pos\n  FROM country\n  WHERE lifeexpectancy IS NOT NULL\n) \nSELECT continent, \n  name_country, \n  lifeexpectancy, \n  pos\nFROM ws   \nWHERE pos <= 3;\n```\n\n\n---\n\n## Exemple  {.smaller}\n\nAfficher le pays le plus peuplé \n\n. . .\n\n::::: {.columns}\n::: {.column}\n\n```{.sql}\nSELECT S.name_country, \n  S.continent, \n  S.population_country\nFROM (\n  SELECT max(population_country) AS mpc \n  FROM country c\n  ) AS R \n  JOIN LATERAL (    \n\t  SELECT * \n\t  FROM country c2 \n\t  WHERE c2.population_country >= R.mpc\n    ) AS S \n  ON (TRUE)\n) ;\n```\n\n:::\n\n\n::: {.column}\n\n\n\n```{.sql}\nSELECT c.name_country, \n       c.continent, \n       c.population_country\nFROM (\n\tSELECT max(population_country) AS mpc \n\tFROM country c2\n  ) AS S\n  JOIN country c \n  ON (c.population_country >= S.mpc)    \n;\n```\n\n:::\n:::::\n\n\n\n```{.sql}\nname_country|continent|population_country|\n------------+---------+------------------+\nChina       |Asia     |        1277558000|\n```\n\n\n---\n\n## Exemple  (suite)  {.smaller}\n\nAfficher le pays le plus peuplé \n\n::::: {.columns}\n::: {.column}\n\n```{.sql}\nSELECT * \nFROM world.country c  \nWHERE population_country >= ALL(\n  SELECT cc.population_country  \n  FROM world.country  cc\n) ;     \n\n```\n\n:::\n::: {.column}\n\n```{.sql}\nWITH S AS (        \n\tSELECT c.*, max(population_country) \n         OVER () AS mpc  \n\tFROM world.country c\n)\nSELECT * \nFROM S   \nWHERE population_country >= mpc ;\n```\n\n:::\n::::: \n\n```{.sql}\nname_country|continent|population_country|\n------------+---------+------------------+\nChina       |Asia     |        1277558000|\n```\n\n\n---\n\n## Exemple  {.smaller}\n\nAfficher les 10 pays les plus peuplés\n\n. . .\n\n```{.sql}\nWITH S AS (        \n\tSELECT c.*, rank() \n    OVER (ORDER BY population_country DESC) AS rpc  \n\tFROM world.country c\n)\n\nSELECT name_country, continent, population_country\nFROM S   \nWHERE rpc <= 10 \nORDER BY rpc DESC;\n```\n\n. . .\n\n\n```{.sql}\nname_country      |continent    |population_country|\n------------------+-------------+------------------+\nChina             |Asia         |        1277558000|\nIndia             |Asia         |        1013662000|\nUnited States     |North America|         278357000|\nIndonesia         |Asia         |         212107000|\nBrazil            |South America|         170115000|\nPakistan          |Asia         |         156483000|\nRussian Federation|Europe       |         146934000|\nBangladesh        |Asia         |         129155000|\nJapan             |Asia         |         126714000|\nNigeria           |Africa       |         111506000|\n```\n\n\n# Groupements avancés   {background-color=\"#1c191c\"}\n\n\n---\n\nIntroduits dans SQL avec la mode du `Data mining`  (Fouille de données) dans les années 1990\n\nPermet de réaliser de facon apparemment simultanée des aggrégations de régularités emboîtées \n\nDans le monde des statistiques, lorsqu'on aggrège des comptages de grains différents, on parle \nde tables de contingences (*contingency tables*).  \n\n\n---\n\n## `ROLLUP`  {.smaller}\n\n\n\n::: {.cell}\n\n```{.sql .cell-code  code-line-numbers=\"|4\"}\nSELECT continent, region, max(lifeexpectancy)\nFROM country c \nWHERE continent LIKE '%America'\nGROUP BY ROLLUP  (continent, region)  \nORDER BY continent, region ;\n```\n:::\n\n\n\n\n\n```{.sql}\n|Continent    |Region         |max |\n|:------------|:--------------|---:|\n|North America|Caribbean      |78.9|\n|North America|Central America|75.8|\n|North America|North America  |79.4|\n|North America|               |79.4|\n|South America|South America  |76.1|\n|South America|               |76.1|\n|             |               |79.4|\n```\n\n\n## GROUPING SETS  {.smaller}\n\n\n\n::: {.cell}\n\n```{.sql .cell-code  code-line-numbers=\"|3\"}\nSELECT c1, c2, aggregate_function(c3)\nFROM table_name\nGROUP BY GROUPING SETS ((c1, c2), (c1), (c2), ());   \n```\n:::\n\n\n\n{{< fa hand-point-right >}} `ROLLUP` and `CUBE` are special cases of `GROUPING SETS`\n\n## `GROUPING SETS`  (suite)  {.smaller}\n\n```{.sql}\nSELECT continent, region, max(lifeexpectancy)\nFROM country c \nWHERE continent LIKE '%America'\nGROUP BY GROUPING SETS  ((continent, region), (continent), ())  \nORDER BY continent, region ;\n```\n\n\n```{.sql}\n|Continent    |Region         |max |\n|:------------|:--------------|---:|\n|North America|Caribbean      |78.9|\n|North America|Central America|75.8|\n|North America|North America  |79.4|\n|North America|               |79.4|\n|South America|South America  |76.1|\n|South America|               |76.1|\n|             |               |79.4|\n```\n\n## `CUBE`\n\n\n\n::: {.cell}\n\n```{.sql .cell-code  code-line-numbers=\"|4\"}\nSELECT c1, c2, c3,\n  aggregate (c4) \nFROM table_name\nGROUP BY CUBE (c1, c2, c3);  \n```\n:::\n\n\n\n---\n\n\n\n\n::: {.cell}\n\n```{.sql .cell-code  code-line-numbers=\"|2,3,6\"}\nSELECT continent, region, governmentform, \n       count(*) AS cnt, \n       max(lifeexpectancy)\nFROM country c \nWHERE continent LIKE '%America'\nGROUP BY CUBE (continent, region, governmentform)   \nHAVING COUNT(*) > 5;\n```\n:::\n\n\n\n## {.smaller}\n\n\n```{.sql}\n|Continent    |Region       |Governmentf   |cnt|max |\n|:------------|:------------|:-------------|:--|:---|\n|             |               |                             | 51|79.4|\n|South America|South America  |Republic                     |  9|75.7|\n|North America|Central America|Republic                     |  6|75.8|\n|North America|Caribbean      |Constitutional Monarchy      |  8|75.2|\n|North America|Caribbean      |                             | 24|78.9|\n|South America|South America  |                             | 14|76.1|\n|North America|Central America|                             |  8|75.8|\n|South America|               |                             | 14|76.1|\n|North America|               |                             | 37|79.4|\n|             |Caribbean      |Constitutional Monarchy      |  8|75.2|\n|             |South America  |Republic                     |  9|75.7|\n|             |Central America|Republic                     |  6|75.8|\n|             |South America  |                             | 14|76.1|\n|             |Central America|                             |  8|75.8|\n|             |Caribbean      |                             | 24|78.9|\n|North America|               |Constitutional Monarchy      |  9|75.2|\n|North America|               |Republic                     | 10|75.8|\n|South America|               |Republic                     |  9|75.7|\n|North America|               |Dependent Territory of the UK|  6|78.9|\n|             |               |Republic                     | 19|75.8|\n|             |               |Constitutional Monarchy      |  9|75.2|\n|             |               |Dependent Territory of the UK|  7|78.9|\n```\n\n\n\n---\n\n## Compter les formes de gouvernement et les région dans les Amériques  {.smaller}\n\n\n\n\n::: {.cell}\n\n```{.sql .cell-code  code-line-numbers=\"|4,5,8\"}\nSELECT  \n\t   region, \n\t   governmentform, \n\t   count(*) AS cnt, \n\t   max(lifeexpectancy)\nFROM country c \nWHERE continent LIKE '%America'\nGROUP BY CUBE   (region, governmentform)   \nHAVING COUNT(*) > 0\nORDER BY region, cnt DESC;\n```\n:::\n\n\n\n## Compter les formes de gouvernement et les région dans les Amériques  {.smaller}\n\n\n```{.sql}  \nregion         |governmentform                              |cnt|max |\n---------------+--------------------------------------------+---+----+\nCaribbean      |                                            | 24|78.9|\nCaribbean      |Constitutional Monarchy                     |  8|75.2|\nCaribbean      |Dependent Territory of the UK               |  5|78.9|\nCaribbean      |Republic                                    |  4|73.4|\n...            |                                            |   |    |\n               |Republic                                    | 19|75.8|\n               |Constitutional Monarchy                     |  9|75.2|\n               |Dependent Territory of the UK               |  7|78.9|\n               |Federal Republic                            |  5|77.1|\n               |Overseas Department of France               |  3|78.3|\n...\n```\n\n\n\n\n\n# Résumé  {background-color=\"#1c191c\"}\n\n\n\n## Portrait robot d'une requête \n\n```{.sql}\nSELECT <attributs>           -- les colonnes de la table résultat\n\nFROM <relations>             -- la/les table/s qui émettent les données\n\n[WHERE <condition> ]         -- filtre\n\n[GROUP BY <attributs de partitionnement>   -- découpage en groupes\n\n[HAVING <condition>]]      -- filtrage des groupes\n\n[ORDER BY <critere>]       -- trier \n```\n\n  \n- `SELECT` : attributs du résultat (avec agrégats éventuels)\n- `WHERE` : condition de sélection indépendante du `GROUP BY`\n- `HAVING` : condition de sélection portant sur les groupes\n  \n\n---\n\n::: {.callout-caution}\n\n### Avis \n\nToutes les requêtes  SQL contiennent une combinaison de ces clauses. Retenez au moins cela!\n\n:::\n\n```{.sql}\nSELECT        -- columns to display\nFROM          -- table(s) to pull from\nWHERE         -- filter\nGROUP BY      -- split rows into groups\nHAVING        -- filter within groups\nORDER BY      -- sort\n```\n\n\n\n\n## Ordre d'exécution des éléments d'une requête \n\n1. Rassembler les données mentionnées dans la clause `FROM`\n\n2. Filter les lignes selon la clause  `WHERE`\n\n3.  Regrouper les lignes selon la clause `GROUP BY`\n\n4. Filtrer les groupes selon la clause  `HAVING`\n\n5. Specifier les colonnes du résultat selon la clause `SELECT`\n\n6. Trier le résultat final selon la clause `ORDER BY`\n\n\n\n\n# Références {background-color=\"#1c191c\"}\n\n\n---\n\n[Tutoriel `SELECT`  de PostGreSQL](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-select/)\n\n[Tutoriel `joins`](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-joins/)\n\n[Documentation requêtes](https://www.postgresql.org/docs/current/queries.html)\n\n[Documentation `SELECT`](https://www.postgresql.org/docs/14/sql-select.html)\n\n[GROUPING SETS, ROLLUP, CUBE](https://www.postgresql.org/docs/14/queries-table-expressions.html#QUERIES-GROUPING-SETS)\n\n---\n\n\n# Fin {background-color=\"#1c191c\"}\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}