{
  "hash": "1340b7a103867c303cf110be66167a5e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"BD IV: SQL III\"\nsubtitle: \"Langage Manipulation de Données 3 : Aggrégation/Fenêtres/Partitions\"\ndate: \"2024-09-27\"\n\nformat: \n  revealjs:\n    header: \"Requêtes SQL : Aggrégation/Fenêtres/Partition\"\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n\n# Fonctions d'agrégation en SQL   {background-color=\"#1c191c\"}\n\n\n---\n\nL'algèbre relationnelle pure ne sait pas tout calculer\n\nCertains problèmes aisément solubles par un langage de programmation complet (`Python`, `C`, `R`, ...) ne sont pas solubles dans \nl'algèbre relationnelle pure ( $\\sigma(), \\pi(), \\bowtie(), ...$ ) :\n\n- accessibilité dans un graphe non-orienté (qui puis-je contacter dans un réseau social?)\n\n- compter : quel est le nombre de lignes d'une table ?\n\n\n## {{< fa binoculars >}} Fonctions d'agrégation en SQL \n\n- Possibilité de *compter*, de *faire des moyennes*, de trouver un maximum, ... en SQL (contrairement à l'algèbre relationnelle \"classique\")\n\n- Possibilité de *partitionner* les données\n\n\n\n## Usages \n\n- [Analyse commerciale ou Buisiness Analytics](https://fr.wikipedia.org/wiki/Business_analytics), \n\n- Statistique et Data Science \n\n\n\n## Dans la partie `SELECT`\n\n- Somme des valeurs prises par `nomattribut`\n\n```{.sql}\nSUM (DISTINCT|ALL <nomattribut>)  \n```\n\n. . . \n \n- Moyenne des valeurs prises par `nomattribut`\n\n```{.sql}\nAVG (DISTINCT|ALL <nom_attribut>) \n```\n\n. . .\n\n{{< fa triangle-exclamation >}} Le type des attributs doit être un nombre ou un entier (sinon, \nimpossible de faire des sommes...).\n\n\n\n## Fonctions d'agrégation  : `SUM` et `AVG`\n  \n- Le nombre de pièces 'x21' livrées.\n\n```{.sql}\nSELECT SUM (ALL Quantite)  \nFROM Livraison \nWHERE NomP = 'x21';\n```\n\n- Prix moyen des pièces livrées par la socié  `FastDelivery`\n\n```{.sql}\nSELECT AVG (ALL Prix)    \nFROM Livraison L, Piece P \nWHERE L.NomP=P.NomP AND L.NomF = 'FastDelivery';\n```\n\n\n\n##   {visibility=\"hidden\"}\n\n![](/images/prod-liv-fourn.png)\n\n\n\n\n# Fonctions MAX et MIN   {background-color=\"#1c191c\"}\n\n\n\n## Fonctions de calcul  : `MAX`, `MIN`\n  \n```{.sql}\nMAX (<nomattribut>)  \n```\n\nmaximum des valeurs prises par `<nomattribut>`\n\n. . .\n\n\n```{.sql}\nMIN (<nomattribut>)  \n```\n\nminimum des valeurs prises par  `<nomattribut>` \n\n\n::: {.callout-caution}\n\n### {{< fa mug-hot >}}\n\nAttention aux valeurs nulles !\n\n`NULL = MIN(NULL, 3, 100)` ou `3 = MIN(NULL, 3, 100)` ?\n\n:::\n\n. . .\n\nQuantité maximale livrée de pièce 'x21' lors d'une commande.\n\n```{.sql}\nSELECT MAX (Quantite)   \nFROM Livraison \nWHERE NomP = 'x21';\n```\n\n\n<!-- ![](/images/prod-liv-fourn.png) -->\n\n\n\n# Fonction COUNT\n\n\n\n## Fonctions de calcul : `COUNT`\n\nOn peut aussi compter le nombre de tuples dans un résultat  \n\n```{.sql}\nCOUNT(* |[ ALL | DISTINCT <nomattribut>])  \n```\n\nNombre de valeurs prises par le résultat\n\n. . .\n\n- `DISTINCT` : sans les doublons \n- `ALL`: avec les doublons\n- `*` : y compris les valeurs nullles/manquantes\n\nNombre de livraisons de la pièce 'x21\n\n```{.sql}\nSELECT COUNT(*)  \nFROM Livraison\nWHERE NomP = 'x21'; \n```\n\n\n<!-- ![](/images/prod-liv-fourn.png) -->\n\n\n## Fonctions de calcul  : exemples\n\nExemple de combinaison de quelques opérations et fonctions\n\nNom des fournisseurs ayant effectué plus de $10$ livraisons.\n\n. . .\n\n\n\n::: {.cell}\n\n:::\n\n\n\n<!-- ![](/images/prod-liv-fourn.png) -->\n\n\n## Musée des horreurs   {.smaller}\n\nTrouver les régions où au moins un pays possède une espérance de vie inférieure à `50`\n\n```{.sql}\nSELECT DISTINCT continent, region\nFROM country c \nWHERE (\n  SELECT MIN(d.lifeexpectancy)     \n  FROM country d    \n  WHERE c.region=d.region\n  ) < 50    \nORDER BY continent, region;\n```\n\n|**Continent**    |**Region**                   |\n|:------------|:------------------------|\n|Africa       |Central Africa           |\n|Africa       |Eastern Africa           |\n|Africa       |Northern Africa          |\n|Africa       |Southern Africa          |\n|Africa       |Western Africa           |\n|Asia         |Southeast Asia           |\n|Asia         |Southern and Central Asia|\n|North America|Caribbean                |\n\n\n::: {.aside}\n\nPourquoi cette requête est-elle horrible ?\n\n:::\n\n\n## {.smaller}\n\nOn peut faire plus simple (et plus efficace) dans le case présent\n\n```{.sql}\nSELECT DISTINCT continent, region\nFROM country c \nWHERE c.lifeexpectancy <50 \nORDER BY continent, region;\n```\n\n\n|**Continent**    |**Region**                   |\n|:------------|:------------------------|\n|Africa       |Central Africa           |\n|Africa       |Eastern Africa           |\n|Africa       |Northern Africa          |\n|Africa       |Southern Africa          |\n|Africa       |Western Africa           |\n|Asia         |Southeast Asia           |\n|Asia         |Southern and Central Asia|\n|North America|Caribbean                |\n\n\n---\n\nMais si on veut lister les régions où tous les pays ont une espèrance de  vie supérieure à 50 ?\n\n. . .\n\nPourquoi pas ?\n\n```{.sql}\nSELECT DISTINCT continent, region\nFROM country c \nWHERE (\n  SELECT MIN(d.lifeexpectancy)     \n  FROM country d    \n  WHERE c.region=d.region\n  ) > 50    \nORDER BY continent, region;\n```\n\n::: {.aside}\n\nCombien de fois calculez vous l'espérance de minimale pour chaque région ?\n\n:::\n\n\n\n## Fonctions de calcul : exemples\n\nUtilisation d'opérateur arithmétique entre les différents attributs d'un même tuple...  \n\nPrix de revient des commandes livrées par le fournisseur `FD`\n\n```{.sql}\nSELECT L.NomP, P.Prix*L.Quantite \nFROM Livraison F, Piece P \nWHERE P.NomP=L.NomP AND\n  L.NomF='FD';\n```\n\n\n# Partitions,  `GROUP BY` {background-color=\"#1c191c\"}\n\n\n## Partition de résultats de requêtes\n\n\n```{.sql}\nGROUP BY <nomattribut1>, ..., <nomattributn>\n```\n\n- `GROUP BY` permet de regrouper selon la  valeur de certains attributs l'ensemble des résults d'une requête\n\n- Forme des sous-relations auxquelles on peut appliquer des opérateurs (`SUM`, `MAX`, ...) renvoyant un résultat par sous-relation\n\n\nExemple d'utilisation : regrouper les livraisons par numéro de fournisseur et prendre la quantité maximum livrée par fournisseur.\n\n\n\n## Partition de résultats de requêtes   {.smaller}\n\nSchéma général\n\n```{.sql}\nSELECT .....  \nFROM Livraison \nGROUP BY NomF    \n```\n\n\n\n. . .\n\n\n| NomF | NomP | NumLiv |  Quantite |  DateLiv |\n|:-----|:-----|:------:|----------:|:--------:|\n| <td colspan=\"5\"> Sous-relation 1 </td>  |\n|    1 | x21  | 1      |  20       | 15/02/10 |\n|  1   | a32  | 2      | 3         | 16/02/10 | \n|   1 | x21   | 3      | 5         | 15/01/10 | \n| <td colspan=\"5\"> Sous-relation 2 </td>  |\n| 2 | b27 | 4 | 8 | 01/02/12|\n|2 | c31 | 5 | 9 | 17/09/11 |\n| <td colspan=\"5\"> Sous-relation 3 </td>  |\n|3 |x 21 |6 |17 |15/03/10 |\n\n\n\n## Partition de résultats de requêtes\n\nQuantité maximale livrée par chaque fournisseur  \n\n```{.sql}\nSELECT NomF, MAX(Quantite) \nFROM Livraison \nGROUP BY NomF;\n```\n\nLivraison\n\n|NomF |  NomP | NumL | Quantite | DateLiv |\n|:-----|:-----|:--------:|-----:|:----------:|\n|1     | x21 | 1 | 20 | 15/02/10  |\n|1-2   | c31 | 5 | 9   | 17/09/11 | \n|1     | x21 | 6 | 17 | 15/03/10  | \n\n\nLes opérateurs (`MAX`, `SUM`, etc) s'appliquent à chaque groupe de relations.\n\n\n## Exemple   {.smaller}\n\nDans le schéma `world`, quel est le `gnp` moyen par `region` sur le continent `Europe` ?\n\n\n```{.sql}\nSELECT region, \n\t   ROUND(1000 * SUM(gnp)/SUM(population_country),2) AS avg_gnp,  \n\t   ROUND(MAX(1000* gnp/population_country),2) AS max_gnp, \n\t   ROUND(MIN(1000* gnp/population_country),2) AS min_gnp,\n\t   MIN(lifeexpectancy) AS min_life_exp\nFROM country \nWHERE continent = 'Europe' \nGROUP BY region \nORDER BY avg_gnp DESC;\n```\n\n\n|**region**      |**avg_gnp**|**max_gnp**|**min_gnp**|**min_life_exp**|\n|:---------------|------:|------:|------:|-----------:|\n|Nordic Countries|  28.00|  32.66|   0.00|        76.5|\n|Western Europe  |  25.50|  37.46|  22.82|        77.1|\n|British Islands |  22.94|  23.12|  20.11|        76.8|\n|Southern Europe |  13.91|  20.90|   0.72|        71.5|\n|Baltic Countries|   2.96|   3.70|   2.64|        68.4|\n|Eastern Europe  |   2.15|   5.35|   0.36|        64.5|\n\n\n\n\n\n## Partition de résultats de requêtes\n\nQuel est le sens de cette requête ?\n\n```{.sql}\nSELECT NomP, COUNT(*), SUM(Quantite) \nFROM Livraison \nGROUP BY NomP;\n```\n\n##\n\n\nLa requête suivante  requête n'est pas correcte \n\n```{.sql}\nSELECT NomF, NomP, MAX(Quantite) \nFROM Livraison \nGROUP BY NomF;\n```\n\n. . .\n\n::: {.callout-important}\n\n### {{< fa skull >}}\n\nLes attributs présents dans le `SELECT` sont forcémment présents dans le `GROUP BY`.  \n\n:::\n\n\n\n\n\n\n## Partition de résultats de requêtes\n  \n    \n- La clause `HAVING` permet de poser une condition portant sur chacune des sous-relations générées par le `GROUP BY`\n\n- Les sous-relations ne vérifiant pas la condition sont écartées du résultat.\n    \n\n\nListe des fournisseurs qui ont effectué plus de 3 livraisons.\n\n```{.sql}\nSELECT NomF \nFROM Livraison \nGROUP BY NomF    \nHAVING COUNT(*) >= 3;  \n```\n\n\n\n\n\n# Tri des résultats  {background-color=\"#1c191c\"}\n\n\n\n## Présentation/tri de résultats\n\n- La clause `ORDER BY` permet de trier le résultat de la requête, en fournissant \nla liste des attributs  sur lesquels effectuer le tri et en spécifiant le sens du tri (ascendan ou descendant)\n\nListe des salariés triée par ordre décroissant salaire\n\n```{.sql}\nSELECT * \nFROM Employe \nORDER BY Salaire DESC;  \n```\n\n\n\n## Regroupement, tri, etc : exemple\n\n  \nQue fait cette requête ?\n\n```{.sql}\nSELECT Fonction, COUNT(*) \nFROM Employe \nWHERE NumDep IN (\n  SELECT NumDep \n  FROM Departement \n  WHERE NomDept='Financier'\n) \nGROUP BY Fonction \nHAVING AVG(Salaire) >= 10000 \nORDER BY Fonction;\n```\n\nSur les relations d'une base `employé` (tables `Departement`,`Employe`, ...)\n\n\n\n\n## Retour au musée des horreurs  {.smaller}\n\n\n\n```{.sql}\nSELECT continent, region, MIN(c.lifeexpectancy)\nFROM country c \nGROUP BY continent, region\nHAVING MIN(c.lifeexpectancy) < 50  \nORDER BY continent, region ;   \n```\n\n\n| **Continent**    | **Region**         |max |min |\n|:-------------|:------------------------|----|----|\n| Africa       |Central Africa           |65.3|38.3|\n| Africa       |Eastern Africa           |72.7|37.2|\n| Africa       |Northern Africa          |75.5|49.8|\n| Africa       |Southern Africa          |51.1|39.3|\n| Africa       |Western Africa           |76.8|41.3|\n| Asia         |Southeast Asia           |80.1|46.0|\n| Asia         |Southern and Central Asia|71.8|45.9|\n| North America|Caribbean                |78.9|49.2|\n\n\n\n## Exemple d'aggrégation {visibility=\"hidden\"}\n\nDans le schéma `world`, \n\n\n\n\n\n# Fonctions fenêtres (Window functions)\n\n\nUne **fonction fenêtre** effectue un calcul sur un (sous)-ensemble de lignes de la table qui sont liées  à la ligne courante. \n\n. . .\n\n::: {.callout-note}\n\nC'est comparable au type de calcul effectué avec une fonction d'agrégation. \n\n:::\n\n. . .\n\nMais les fonctions de fenêtre ne regroupement pas les lignes en une seule ligne de sortie. \n\nAu contraire, les lignes conservent leurs identités distinctes. \n\nEn coulisses, la fonction de fenêtre est capable d'accéder à plus que la ligne actuelle du résultat de la requête.\n\n## Exemple {.smaller}\n\nDans le schéma `world`, présenter pour chaque pays dont la région comprend le motif \n`Countries`, l'espérance de vie, l'espérance de vie maximale et minimale dans la région.\n\n\n\n\n\n::: {.cell}\n\n```{.sql .cell-code  code-line-numbers=\"2-3|1-4|\"}\nSELECT region, name_country, lifeexpectancy, \n\t   min(lifeexpectancy) OVER (PARTITION BY region),  \n\t   max(lifeexpectancy) OVER (PARTITION BY region)   \nFROM country \nWHERE region LIKE '%Countries'\nORDER BY region, lifeexpectancy  \nLIMIT 6 ;\n```\n:::\n\n\n\n|Region          | Name of country      |Life expectancy|min |max |\n|----------------|----------------------|--------------|----|----|\n|Baltic Countries|Latvia                |          68.4|68.4|69.5|\n|Baltic Countries|Lithuania             |          69.1|68.4|69.5|\n|Baltic Countries|Estonia               |          69.5|68.4|69.5|\n|Nordic Countries|Denmark               |          76.5|76.5|79.6|\n|Nordic Countries|Finland               |          77.4|76.5|79.6|\n|Nordic Countries|Faroe Islands         |          78.4|76.5|79.6|\n\n\n## Calculer une fonction fenêtre sans invoquer `OVER (...)`   {.smaller}\n\n\nPour calculer ce résultat sans fonctions fenêtres,\n\n1. on effectue une partition selon la `region`, une aggrégation par groupe \npour calculer `min(lifeexpectancy)` et `max(lifeexpectancy)`. On obtient une table à trois colonnes.\n\n1. on calcule une (équi)-jointure avec la table `country` originelle sur  la colonne commune `region`\n\n2. on projette  le résultat sur les cinq colonnes pertinentes. \n\n. . .\n\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nWITH R AS (\n  SELECT region, min(lifeexpectancy) AS minlex, max(lifeexpectancy) AS maxlex\n  FROM country\n  WHERE region LIKE '%Countries' AND lifeexpectancy IS NOT NULL \n  GROUP BY region\n)\n\nSELECT region, name_country, lifeexpectancy, minlex, maxlex\nFROM country co NATURAL JOIN R\n```\n:::\n\n\n\n\n\n\n\n## Variations   {.smaller}\n\n\n```{.sql}\nSELECT region, name_country, lifeexpectancy, \n\trank() OVER (\n    PARTITION BY region   \n\t  ORDER BY lifeexpectancy DESC\n  )  \nFROM country \nWHERE region LIKE '%Countries'\nORDER BY region, lifeexpectancy DESC \nLIMIT 6 ;\n```\n\n\n|Region          |Name of country          |life expectancy|rank|\n|:---------------|:---------------------|-------------:|:--:|\n|Baltic Countries|Estonia               |          69.5|   1|\n|Baltic Countries|Lithuania             |          69.1|   2|\n|Baltic Countries|Latvia                |          68.4|   3|\n|Nordic Countries|Svalbard and Jan Mayen|              |   1|\n|Nordic Countries|Sweden                |          79.6|   2|\n|Nordic Countries|Iceland               |          79.4|   3|\n\n::: {.aside}\n\nQue se passe-t-il avec les valeurs nulles ?\n\n:::\n\n## Sommes cumulées par groupes selon un ordre   {.smaller}\n\n```{.sql}\nSELECT \n\tregion, name_country, \n\tsum(gnp) OVER (\n    PARTITION BY region  \n\t\tORDER BY gnp\n)     \nFROM country c \nWHERE region LIKE '%Europe' \nLIMIT 6;\n```\n\n\n\n|Region        |Name Country|Sum      |\n|:-------------|:-----------|--------:|\n|Eastern Europe|Moldova     |  1579.00|\n|Eastern Europe|Bulgaria    | 13757.00|\n|Eastern Europe|Belarus     | 27471.00|\n|Eastern Europe|Slovakia    | 48065.00|\n|Eastern Europe|Romania     | 86223.00|\n|Eastern Europe|Ukraine     |128391.00|\n\n\n\n---\n\n::: {.callout-caution}\n\nLes fonctions de fenêtre ne sont autorisées que dans la liste `SELECT` et la clause `ORDER BY` de la requête. \n\nElles sont interdites ailleurs, par exemple dans les clauses `GROUP BY`, `HAVING` et `WHERE`. \n\nEn effet, elles s'exécutent logiquement après le traitement de ces clauses. \n\n:::\n\n. . .\n\n::: {.callout-caution}\n\nDe même, les fonctions de fenêtre s'exécutent *après* les fonctions d'agrégation habituelles. \n\nCela signifie qu'il est pertinent d'inclure un appel de fonction d'agrégation \ndans les arguments d'une fonction de fenêtre, mais pas l'inverse.\n\n:::\n\n\n---\n\n## Exemple  {.smaller}\n\n\nPour chaque continent, afficher les trois pays ayant l'espérance de vie à la naissance la plus élevée\n\n. . .\n\n```{.sql}\nSELECT continent, \n  name_country, \n  lifeexpectancy, \n  pos\nFROM\n  (SELECT continent, \n    name_country, \n    lifeexpectancy,\n    rank() OVER (\n      PARTITION BY continent \n      ORDER BY lifeexpectancy DESC) AS pos\n  FROM country\n  WHERE lifeexpectancy IS NOT NULL\n  ) AS ws\nWHERE pos <= 3;\n```\n\n---\n\n##  Avec `WITH ...` et les CTEs   {.smaller}\n\n\n```{.sql}\nWITH ws AS (\n  SELECT continent, \n    name_country, \n    lifeexpectancy,\n    rank() OVER (\n      PARTITION BY continent \n      ORDER BY lifeexpectancy DESC) AS pos\n  FROM country\n  WHERE lifeexpectancy IS NOT NULL\n) \nSELECT continent, \n  name_country, \n  lifeexpectancy, \n  pos\nFROM ws   \nWHERE pos <= 3;\n```\n\n\n---\n\n## Exemple  {.smaller}\n\nAfficher le pays le plus peuplé \n\n. . .\n\n::::: {.columns}\n::: {.column}\n\n```{.sql}\nSELECT S.name_country, \n  S.continent, \n  S.population_country\nFROM (\n  SELECT max(population_country) AS mpc \n  FROM country c\n  ) AS R \n  JOIN LATERAL (    \n\t  SELECT * \n\t  FROM country c2 \n\t  WHERE c2.population_country >= R.mpc\n    ) AS S \n  ON (TRUE)\n) ;\n```\n\n:::\n\n\n::: {.column}\n\n\n\n```{.sql}\nSELECT c.name_country, \n       c.continent, \n       c.population_country\nFROM (\n\tSELECT max(population_country) AS mpc \n\tFROM country c2\n  ) AS S\n  JOIN country c \n  ON (c.population_country >= S.mpc)    \n;\n```\n\n:::\n:::::\n\n\n\n```{.sql}\nname_country|continent|population_country|\n------------+---------+------------------+\nChina       |Asia     |        1277558000|\n```\n\n\n---\n\n## Exemple  (suite)  {.smaller}\n\nAfficher le pays le plus peuplé \n\n::::: {.columns}\n::: {.column}\n\n```{.sql}\nSELECT * \nFROM world.country c  \nWHERE population_country >= ALL(\n  SELECT cc.population_country  \n  FROM world.country  cc\n) ;     \n\n```\n\n:::\n::: {.column}\n\n```{.sql}\nWITH S AS (        \n\tSELECT c.*, max(population_country) \n         OVER () AS mpc  \n\tFROM world.country c\n)\nSELECT * \nFROM S   \nWHERE population_country >= mpc ;\n```\n\n:::\n::::: \n\n```{.sql}\nname_country|continent|population_country|\n------------+---------+------------------+\nChina       |Asia     |        1277558000|\n```\n\n\n---\n\n## Exemple  {.smaller}\n\nAfficher les 10 pays les plus peuplés\n\n. . .\n\n```{.sql}\nWITH S AS (        \n\tSELECT c.*, rank() \n    OVER (ORDER BY population_country DESC) AS rpc  \n\tFROM world.country c\n)\n\nSELECT name_country, continent, population_country\nFROM S   \nWHERE rpc <= 10 \nORDER BY rpc DESC;\n```\n\n. . .\n\n\n```{.sql}\nname_country      |continent    |population_country|\n------------------+-------------+------------------+\nChina             |Asia         |        1277558000|\nIndia             |Asia         |        1013662000|\nUnited States     |North America|         278357000|\nIndonesia         |Asia         |         212107000|\nBrazil            |South America|         170115000|\nPakistan          |Asia         |         156483000|\nRussian Federation|Europe       |         146934000|\nBangladesh        |Asia         |         129155000|\nJapan             |Asia         |         126714000|\nNigeria           |Africa       |         111506000|\n```\n\n\n# Groupements avancés \n\n\n---\n\nIntroduits dans SQL avec la mode du `Data mining`  (Fouille de données) dans les années 1990\n\nPermet de réaliser de facon apparemment simultanée des aggrégations de régularités emboîtées \n\nDans le monde des statistiques, lorsqu'on aggrège des comptages de grains différents, on parle \nde tables de contingences (*contingency tables*).  \n\n\n---\n\n## `ROLLUP`  {.smaller}\n\n\n\n::: {.cell}\n\n```{.sql .cell-code  code-line-numbers=\"|4\"}\nSELECT continent, region, max(lifeexpectancy)\nFROM country c \nWHERE continent LIKE '%America'\nGROUP BY ROLLUP  (continent, region)  \nORDER BY continent, region ;\n```\n:::\n\n\n\n\n\n```{.sql}\n|Continent    |Region         |max |\n|:------------|:--------------|---:|\n|North America|Caribbean      |78.9|\n|North America|Central America|75.8|\n|North America|North America  |79.4|\n|North America|               |79.4|\n|South America|South America  |76.1|\n|South America|               |76.1|\n|             |               |79.4|\n```\n\n\n## GROUPING SETS  {.smaller}\n\n\n\n::: {.cell}\n\n```{.sql .cell-code  code-line-numbers=\"|3\"}\nSELECT c1, c2, aggregate_function(c3)\nFROM table_name\nGROUP BY GROUPING SETS ((c1, c2), (c1), (c2), ());   \n```\n:::\n\n\n\n{{< fa hand-point-right >}} `ROLLUP` and `CUBE` are special cases of `GROUPING SETS`\n\n## `GROUPING SETS`  (suite)  {.smaller}\n\n```{.sql}\nSELECT continent, region, max(lifeexpectancy)\nFROM country c \nWHERE continent LIKE '%America'\nGROUP BY GROUPING SETS  ((continent, region), (continent), ())  \nORDER BY continent, region ;\n```\n\n\n```{.sql}\n|Continent    |Region         |max |\n|:------------|:--------------|---:|\n|North America|Caribbean      |78.9|\n|North America|Central America|75.8|\n|North America|North America  |79.4|\n|North America|               |79.4|\n|South America|South America  |76.1|\n|South America|               |76.1|\n|             |               |79.4|\n```\n\n## `CUBE`\n\n\n\n::: {.cell}\n\n```{.sql .cell-code  code-line-numbers=\"|4\"}\nSELECT c1, c2, c3,\n  aggregate (c4) \nFROM table_name\nGROUP BY CUBE (c1, c2, c3);  \n```\n:::\n\n\n\n---\n\n\n\n\n::: {.cell}\n\n```{.sql .cell-code  code-line-numbers=\"|2,3,6\"}\nSELECT continent, region, governmentform, \n       count(*) AS cnt, \n       max(lifeexpectancy)\nFROM country c \nWHERE continent LIKE '%America'\nGROUP BY CUBE (continent, region, governmentform)   \nHAVING COUNT(*) > 5;\n```\n:::\n\n\n\n## {.smaller}\n\n\n```{.sql}\n|Continent    |Region       |Governmentf   |cnt|max |\n|:------------|:------------|:-------------|:--|:---|\n|             |               |                             | 51|79.4|\n|South America|South America  |Republic                     |  9|75.7|\n|North America|Central America|Republic                     |  6|75.8|\n|North America|Caribbean      |Constitutional Monarchy      |  8|75.2|\n|North America|Caribbean      |                             | 24|78.9|\n|South America|South America  |                             | 14|76.1|\n|North America|Central America|                             |  8|75.8|\n|South America|               |                             | 14|76.1|\n|North America|               |                             | 37|79.4|\n|             |Caribbean      |Constitutional Monarchy      |  8|75.2|\n|             |South America  |Republic                     |  9|75.7|\n|             |Central America|Republic                     |  6|75.8|\n|             |South America  |                             | 14|76.1|\n|             |Central America|                             |  8|75.8|\n|             |Caribbean      |                             | 24|78.9|\n|North America|               |Constitutional Monarchy      |  9|75.2|\n|North America|               |Republic                     | 10|75.8|\n|South America|               |Republic                     |  9|75.7|\n|North America|               |Dependent Territory of the UK|  6|78.9|\n|             |               |Republic                     | 19|75.8|\n|             |               |Constitutional Monarchy      |  9|75.2|\n|             |               |Dependent Territory of the UK|  7|78.9|\n```\n\n\n\n---\n\n## Compter les formes de gouvernement et les région dans les Amériques  {.smaller}\n\n\n\n\n::: {.cell}\n\n```{.sql .cell-code  code-line-numbers=\"|4,5,8\"}\nSELECT  \n\t   region, \n\t   governmentform, \n\t   count(*) AS cnt, \n\t   max(lifeexpectancy)\nFROM country c \nWHERE continent LIKE '%America'\nGROUP BY CUBE   (region, governmentform)   \nHAVING COUNT(*) > 0\nORDER BY region, cnt DESC;\n```\n:::\n\n\n\n## Compter les formes de gouvernement et les région dans les Amériques  {.smaller}\n\n\n```{.sql}  \nregion         |governmentform                              |cnt|max |\n---------------+--------------------------------------------+---+----+\nCaribbean      |                                            | 24|78.9|\nCaribbean      |Constitutional Monarchy                     |  8|75.2|\nCaribbean      |Dependent Territory of the UK               |  5|78.9|\nCaribbean      |Republic                                    |  4|73.4|\n...            |                                            |   |    |\n               |Republic                                    | 19|75.8|\n               |Constitutional Monarchy                     |  9|75.2|\n               |Dependent Territory of the UK               |  7|78.9|\n               |Federal Republic                            |  5|77.1|\n               |Overseas Department of France               |  3|78.3|\n...\n```\n\n\n\n\n\n# Résumé  {background-color=\"#1c191c\"}\n\n\n\n## Portrait robot d'une requête \n\n```{.sql}\nSELECT <attributs>           -- les colonnes de la table résultat\n\nFROM <relations>             -- la/les table/s qui émettent les données\n\n[WHERE <condition> ]         -- filtre\n\n[GROUP BY <attributs de partitionnement>   -- découpage en groupes\n\n[HAVING <condition>]]      -- filtrage des groupes\n\n[ORDER BY <critere>]       -- trier \n```\n\n  \n- `SELECT` : attributs du résultat (avec agrégats éventuels)\n- `WHERE` : condition de sélection indépendante du `GROUP BY`\n- `HAVING` : condition de sélection portant sur les groupes\n  \n\n---\n\n::: {.callout-caution}\n\n### Avis \n\nToutes les requêtes  SQL contiennent une combinaison de ces clauses. Retenez au moins cela!\n\n:::\n\n```{.sql}\nSELECT        -- columns to display\nFROM          -- table(s) to pull from\nWHERE         -- filter\nGROUP BY      -- split rows into groups\nHAVING        -- filter within groups\nORDER BY      -- sort\n```\n\n\n\n\n## Ordre d'exécution des éléments d'une requête \n\n1. Rassembler les données mentionnées dans la clause `FROM`\n\n2. Filter les lignes selon la clause  `WHERE`\n\n3.  Regrouper les lignes selon la clause `GROUP BY`\n\n4. Filtrer les groupes selon la clause  `HAVING`\n\n5. Specifier les colonnes du résultat selon la clause `SELECT`\n\n6. Trier le résultat final selon la clause `ORDER BY`\n\n\n\n\n# Références {background-color=\"#1c191c\"}\n\n\n---\n\n[Tutoriel `SELECT`  de PostGreSQL](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-select/)\n\n[Tutoriel `joins`](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-joins/)\n\n[Documentation requêtes](https://www.postgresql.org/docs/current/queries.html)\n\n[Documentation `SELECT`](https://www.postgresql.org/docs/14/sql-select.html)\n\n[GROUPING SETS, ROLLUP, CUBE](https://www.postgresql.org/docs/14/queries-table-expressions.html#QUERIES-GROUPING-SETS)\n\n---\n\n\n# Fin {background-color=\"#1c191c\"}\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}