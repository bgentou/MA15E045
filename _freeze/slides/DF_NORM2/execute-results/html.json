{
  "hash": "9d7692e8ae806d845c008f262de83f6b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"BD xxx : Normalisation II\"\n---\n\n::: {.cell}\n\n:::\n\n\n\n# Introduction  {background-color=\"#1c191c\"}\n\n\n\n## Rappel : Propriétés d'une décomposition\n\n\n- Soit $\\mathcal{A}$ un schéma de relation et $\\Sigma$ un ensemble de DF sur $\\mathcal{A}$.\n\nSoit $\\left\\{\\mathcal{A}_1,\\dots, \\mathcal{A}_k\\right\\}$ une décomposition du schéma $\\mathcal{A}$, on a \n\n1. $\\mathcal{A}_i\\not=\\emptyset$, $1\\le i\\le k$ et \n2. $\\mathcal{A} = \\bigcup_{i=1}^k \\mathcal{A}_i$\n\n. . .\n\n- On ne peut pas décomposer arbitrairement, toutes les décompositions ne sont pas intéressantes\n\n- Conditions pour une décomposition *raisonnable* :\n  - [ ] *sans perte d'information*\n  - [ ] *sans perte de dépendance fonctionnelle*\n\n---\n\n\n## Projection d'un ensemble de DF\n\n\n::: {.callout-important}\n\n### Définition\n\nSoit $\\mathcal{A}$ un schéma de relation ($\\mathcal{A}$ est un ensemble d'attributs) et $\\Sigma$\nun ensemble de DF sur $\\mathcal{A}$\n\nSoit $\\mathcal{A}_1\\subset\\mathcal{A}$ un sous-ensemble d'attributs\n\n$$\\pi^{}_{\\mathcal{A}_1}(\\Sigma)=\\left\\{ X\\to Y \\mid \\Sigma⊧ X\\to Y \\text{ et } X,Y\\subset\\mathcal{A}_1\\right\\}$$\n\nAutrement dit $\\pi_{\\mathcal{A}_1}(\\Sigma)$ est l'ensemble des DF de la forme $X\\to Y$ impliquée par $\\Sigma$ et\ntelle que $X\\subset\\mathcal{A}_1$ et $Y\\subset \\mathcal{A}_1$\n\n:::\n\n\n\n## Caractérisation\n\nsi $X\\subset \\mathcal{A}_1$ on l'équivalence\n$$X\\to Y \\in \\pi_{\\mathcal{A}_1}(\\Sigma) \\iff Y\\subset\\left\\{X\\right\\}^+\\cap\\mathcal{A}_1$$\n\n\n## Exemple\n\n- $\\mathcal{A}=\\left\\{A,B,C\\right\\}$ et $\\Sigma=\\left\\{A\\to B, B\\to C, C\\to A\\right\\}$\n\n- $\\pi_{\\left\\{A,B\\right\\}}(\\Sigma)$ est équivalent à $\\left\\{A\\to B, B\\to A\\right\\}$\n\n\n\n\n\n## Calcul de $\\pi_{\\mathcal{A}_1}(\\Sigma)$\n\nOn calcule un ensemble de DF équivalent à $\\pi_{\\mathcal{A}_1}(\\Sigma)$\n\n## **Algorithme**\n\n$P := \\emptyset$\n\n- pour tout $X\\subset \\mathcal{A}_1$ tel que $X\\not=\\emptyset$ et $X\\not=\\mathcal{A}_1$ \n  - calculer $Y=X^+\\cap\\mathcal{A}_1$ et ajouter $X\\to Y$ à $P$\\\\\n  - renvoyer $P$\n\nL'ensemble de DF obtenu est équivalent à $\\pi_{\\mathcal{A}_1}(\\Sigma)$\n\n*Très coûteux !*\n\nLe nombre de sous-ensembles $X$ considérés est $2^{\\#\\mathcal{A}_1}-2$\n\n---\n\n## Exemple\n\n\n\n- $\\mathcal{A}=\\left\\{A,B,C,D,E\\right\\}$ et $\\Sigma=\\left\\{A\\to C, BC\\to D, AD\\to E\\right\\}$\n\n- $\\pi_{AC}(\\Sigma)$ est équivalent à $\\left\\{A\\to C\\right\\}$  car $\\left\\{A\\right\\}^+=\\left\\{A,C\\right\\}$ et $\\left\\{C\\right\\}^+=\\left\\{C\\right\\}$\n\n- $\\pi_{ABD}(\\Sigma)$ est équivalent à $\\left\\{AB\\to D\\right\\}$\ncar $\\left\\{A\\right\\}^+=\\left\\{A,C\\right\\}$, $\\left\\{B\\right\\}^+=\\left\\{D\\right\\}$, $\\left\\{D\\right\\}^+=\\left\\{D\\right\\}$,\n$\\left\\{A,B\\right\\}^+=\\left\\{A,B,C,D,E\\right\\}$, $\\left\\{A,D\\right\\}^+=\\left\\{A,D,C,E\\right\\}$, $\\left\\{B,D\\right\\}^+=\\left\\{B,D\\right\\}$\n\n- $\\pi_{ABCE}(\\Sigma)$ est équivalent à $\\left\\{A\\to C, AB \\to CE, AE\\to C, ABC\\to E, ABE\\to C\\right\\}$\n  - $A^+=AC \\quad B^+=B \\quad C^+=C \\quad E^+=E$\n  - $AB^+=ABCDE \\quad AC^+=AC \\quad AE^+=AEC$  $BC^+=BCD \\quad BE^+=BE \\quad CE^+=CE$\n  - $ABC^+=ABCDE \\quad ABE^+=ABECD$ $BCE^+=BCED \\quad ACE^+=ACE$\n\n- Simplification : $\\pi_{ABCE}(\\Sigma)$ équivaut à $\\left\\{A\\to C, AB\\to E\\right\\}$\n\n\n\n\n---\n\n# Décomposition sans perte de DF {background-color=\"#1c191c\"}\n\n---\n\n::: {.callout-important}\n\n### Définition\n\n- Soit $\\mathcal{A}$ un schéma de relation et $\\Sigma$ un ensemble de DF sur $\\mathcal{A}$.\n- Soit $\\left\\{\\mathcal{A}_1,\\dots, \\mathcal{A}_k\\right\\}$ une décomposition du schéma $\\mathcal{A}$\n$\\mathcal{A}_i\\not=\\emptyset$, $1\\le i\\le k$ et $\\mathcal{A} = \\bigcup_{i=1}^k \\mathcal{A}_i$\n\nLa décomposition $\\left\\{\\mathcal{A}_1,\\dots, \\mathcal{A}_k\\right\\}$ préserve $\\Sigma$\nsi l'ensemble des dépendances fonctionnelles locales $\\bigcup_{i=1}^k \\pi_{\\mathcal{A}_i}(\\Sigma)$ est équivalent à $\\Sigma$\n\n:::\n\nPuisque $\\Sigma$ implique $\\bigcup_{i=1}^k \\pi_{\\mathcal{A}_i}(\\Sigma)$, la décomposition préserve $\\Sigma$ si et seulement si toutes les DF de $\\Sigma$ sont impliquées par les DF locales\n\n\n## Algorithme\n\n- C'est une extension de l'algorithme de fermeture permet de tester si une décomposition est sans perte de DF\n(sans devoir calculer les $\\pi_{\\mathcal{A}_i}(\\Sigma)$)\n\n- Soit $X\\to Y$ une DF de $\\Sigma$\n\n\n## Algorithme pour tester si $X\\to Y$ est impliquée par $\\bigcup_{i=1}^k \\pi_{\\mathcal{A}_i}(\\Sigma)$\n\n\n- $Z := X$\n\n- tant que $Z$ change faire\n  - pour tout $i=1,\\dots, k$ faire\n    - $Z:= Z \\cup \\bigpar{ (Z\\cap \\mathcal{A}_i)^+ \\cap \\mathcal{A}_i}$\n  - fin pour tout\\\\\n- fin tant que\n\n- Si $Y\\not\\subset Z$ la réponse est NON, sinon la réponse est OUI\n\n## Exemple\n\n\n\n- $\\mathcal{A}=\\left\\{A,B,C,D\\right\\}$, $\\mathcal{A}_1=\\left\\{A,B\\right\\}$, $\\mathcal{A}_2=\\left\\{B,C\\right\\}$, $\\mathcal{A}_3=\\left\\{C,D\\right\\}$\n\n- $\\Sigma=\\left\\{A\\to B, B\\to C, C\\to D, D\\to A\\right\\}$\n\n- Est-ce que la décomposition $\\left\\{\\mathcal{A}_1,\\mathcal{A}_2,\\mathcal{A}_3\\right\\}$ préserve $\\Sigma$ :\n\n- Les DF locales impliquent $A\\to B$, $B\\to C$, $C\\to D$ (elles sont DF locales)\n\n- Est-ce que les DF locales impliquent $D\\to A$ :\n\nCommencer avec $Z=\\left\\{D\\right\\}$\n\n$(\\left\\{D\\right\\}\\cap\\left\\{CD\\right\\})^+\\cap\\left\\{CD\\right\\}=\\left\\{D\\right\\}^+\\cap\\left\\{CD\\right\\}=\\left\\{DABC\\right\\}\\cap\\left\\{CD\\right\\}=\\left\\{C\\right\\}$, ajouter $C$\n\n$(DC\\cap BC)^+\\cap BC=C^+\\cap BC=CDAB\\cap BC=B$, ajouter $B$\n\n$(DCB\\cap AB)^+\\cap AB=B^+\\cap AB=BCDA \\cap AB$, ajouter $A$\n\n$DCBA$ contient $A$ donc $D\\to A$ est préservé\n\n\n\n\n---\n\n## Exemple\n\n\n\n- $\\mathcal{A}=\\left\\{Ville, CP, Rue, Numero\\right\\}$\n\n- $\\Sigma=\\left\\{CP\\to Ville, Ville\\, Rue\\, Numero\\to CP\\right\\}$\n\n- $\\mathcal{A}_1=\\left\\{Ville, CP\\right\\}$\\quad $\\mathcal{A}_2=\\left\\{Rue, Numero, CP\\right\\}$\n\n- Est-ce que la décomposition $\\left\\{\\mathcal{A}_1,\\mathcal{A}_2$ préserve $\\Sigma$ :\n\n\n\n- $CP\\to Ville$ est préservée car elle est locale à $\\mathcal{A}_1$\n\n- Est-ce que $Ville\\, Rue\\, Numero\\to CP$ est préservée :\n\n$Z:=\\left\\{Ville, Rue, Numero\\right\\}$\n\n$\\bigpar{Z\\cap \\left\\{Ville, CP\\right\\}}^+\\cap \\left\\{Ville, CP\\right\\}=\\left\\{Ville\\right\\}$, *rien à ajouter*\n\n$\\bigpar{Z\\cap \\left\\{Rue, Numero, CP\\right\\}}^+\\cap \\left\\{Rue, Numero, CP\\right\\}=\\left\\{Rue, Numero\\right\\}$, *rien à ajouter*\n\nDonc `Ville, Rue, Numero → CP` n'est pas préservée\n\n---\n\n\n# Décomposition FNBC  {background-color=\"#1c191c\"}\n\n\n\n---\n\n\n## Conception du modèle relationnel\n\nUne première approche pour concevoir un modèle relationnel (l'ensemble des schémas d'une bd) consiste à :\n\n\n- identifier les attributs d'intérêt\n\n- répartir les attributs dans plusieurs relations\n\n\n\n\n- Comment savoir si le modèle relationnel est *bon* ?\n\n- Si ce n'est pas le cas : y a-t-il des techniques pour le transformer en un *bon* modèle :\n\n\n\n\n\n---\n\n## Qualité d'un schéma\n\nQuelles sont de ``bonnes propriétés\" d'un schéma :\n\n\n**Exemple**\n\nAttributs relatifs à des vendeurs, produits et livraisons\n\n```\t\nV# : numéro du vendeur\n\tVnom : nom du vendeur\n\tVville : ville du vendeur\n\nP# : numéro du produit\n\tPnom : nom du produit\n\tPville : ville où le produit est stocké\n\tQte : quantité de produit livrée au vendeur\n```\n\n---\n\n## Qualité d'un schéma\n\n\n\n- Un schéma relationnel possible : une seule relation R avec tous les attributs\n\n```\nR(V#, Vnom, Vville, P#, Pnom, Pville, Qte)\n```\n\n- C'est une mauvaise modélisation. \n\n. . .\n\n- Pourquoi :\n\n\n\n\n---\n\n## Qualité d'un schéma relationnel  {.smaller}\n\n\n\n- **Redondance**\n\n\\begin{tabular}{|c|c|c|c|c|c|c|}\n\\hline\n\\bf `V#` & \\bf Vnom & \\bf Vville & \\bf P\\# & \\bf Pnom & \\bf Pville & \\bf Qte \\\\\n\\hline\n3 & MagicV & Paris & \\dots & \\dots & \\dots & \\dots \\\\\n3 & MagicV & Paris & \\dots & \\dots & \\dots & \\dots \\\\\n2 & IdealB & Lyon & \\dots & \\dots & \\dots & \\dots \\\\\n2 & IdealB & Lyon & \\dots & \\dots & \\dots & \\dots \\\\\n\\hline\n\\end{tabular}\n\n\nVnom et Vville sont déterminés par `V#`, c'est-à-dire\nsi deux livraisons ont le même `V#`, elles ont aussi le même Vville et le même Vnom\n\n- **Anomalies de mise à jour**\\\\\nVnom ou Vville pourrait être mis à jour dans une livraison et pas dans une autre, ce qui donnerait une incohérence. Pour éviter cela, la mise à jour est coûteuse\n\n- Anomalies d'insertion\n\nOn ne peut pas enregistrer un vendeur s'il ne reçoit pas de livraison\n\n- **Anomalies de suppression**\n\nSi on supprime toutes les livraisons à un vendeur, on perd toute l'information sur ce vendeur\n\n\n\n---\n\n## Qualité d'un schéma relationnel\n\n\n\n- Un ``bon\" schéma\n\n\\bleu{\n\\begin{align*}\n&\\text{Vendeur(`V#`, Vnom, Vville)}\\quad \\text{Clef : `V#`}\\\\\n&\\text{Produit(P\\#, Pnom, Pville)} \\quad \\text{Clef : P\\#}\\\\\n&\\text{Livraison(`V#`, P\\#, Qte)} \\quad \\text{Clef : (`V#`,P\\#)}\n\\end{align*}\n}\n\n- Plus d'anomalie ! Comment y arriver :\n\n- La théorie de la normalisation des bd relationnelles fournit\n\n\n- la notion de forme normale : propriétés d'un schéma qui garantissent l'absence de redondance et des anomalies qui en dérivent. Ces propriétés sont définies par rapport à un ensemble de contraintes\n\n- des techniques de normalisation : passage d'un schéma arbitraire (mauvais) à un schéma en forme normale (obtenu typiquement par décomposition)\n\n\n\n\n\n\n---\n\n\n\n## Dépendances fonctionnelles\n\n\n\n- Une dépendance fonctionnelle est une forme particulière de \\bleu{contrainte d'intégrité} portant sur une relation\n\n- C'est la réalité qu'on modélise qui impose ces contraintes\n\n- Exemple :\n- \n$$ \\text{R(`V#`, Vnom, Vville, P\\#, Pnom, Pville, Qte)} $$\nUn ensemble de dépendances fonctionnelles qu'on peut raisonnablement supposer :\\\\\n\\bleu{\n`V#` $→$ Vnom Vville\\\\\nP\\# $→$ Pnom Pville\\\\\n`V#` P\\#$→$ Qte}\n\n- Cela signifie que l'on ne considère que des relations R qui satisfont :\\\\\n- si 2 tuples de R ont la même valeur de `V#` alors ils ont la même valeur de Vnom et Vville\\\\\n- si 2 tuples de R ont la même valeur de P\\# alors ils ont la même valeur de Pnom et Pville\\\\\n- \\dots\n\n\n\n\n---\n\n## DF exemple\n\n\n{\\small\n\\begin{tabular}{|c|c|c|c|c|c|c|}\n\\hline\n\\bf `V#` & \\bf Vnom & \\bf Vville & \\bf P\\# & \\bf Pnom & \\bf Pville & \\bf Qte \\\\\n\\hline\n3 & MagicV & Paris & 322 & manteau & Lille & 2 \\\\\n1 & StarV & Rome & 546 & veste & Rome & 1 \\\\\n3 & MagicV & Paris & 322 & manteau & Lille & 5 \\\\\n2 & IdealB & Lyon & 145 & jupe & Paris & 7 \\\\\n2 & IdealB & Lyon & 234 & jupe & Lille & 1 \\\\\n\\hline\n\\end{tabular}\n}\n\n\\vspace{1cm}\n\n\n-\nR satisfait `V#` $→$ Vnom Vville et P\\# $→$ Pnom Pville\n\n-\nR viole `V#` P\\#$→$ Qte\n\n\n\n---\n\n## Exemple\n\n\nSchéma Films(titre, année, durée, genre, producteur, acteur)\n\n{\\tiny\n\\begin{tabular}{|c|c|c|c|c|c|}\n\\hline\n\\bf titre & \\bf année & \\bf durée & \\bf genre & \\bf producteur & \\bf acteur \\\\\n\\hline\nStar Wars & 1977 & 124 & SciFi & Fox & Carrie Fisher \\\\\nStar Wars & 1977 & 124 & SciFi & Fox & Mark Hamill \\\\\nStar Wars & 1977 & 124 & SciFi & Fox & Harrison Ford \\\\\nGone With The Wind & 1939 & 231 & drame & MGM & Vivien Leigh\\\\\nWayne's World & 1992 & 95 & comédie & Paramount & Dana Carvey\\\\\nWayne's World & 1992 & 95 & comédie & Paramount & Mike Meyers\\\\\n\\hline\n\\end{tabular}\n}\n\n\n\n\n\n- On sait qu'il n'y a pas 2 films de même nom qui sortent la même année. On a donc la dépendance suivante\n\n```\ntitre, année → durée, genre, producteur\n```\n\n\nLa DF `titre, année → acteur` est certainement fausse\npuisqu'un film fait intervenir en général plusieurs acteurs.\n\nA-t-on la DF  `titre, acteur → année, durée, genre, producteur` ?\n\n\n\n---\n\n\n## Définition d'une dépendance fonctionnelle\n\n\n\n- Soit $\\mathcal{A}$ un schéma de relation ($\\mathcal{A}$ est un ensemble d'attributs)\n\n- Une dépendance fonctionnelle sur $\\mathcal{A}$ est une expression de la forme\n$X → Y$ où $X\\subset\\mathcal{A}$ et $Y\\subset \\mathcal{A}$\n\n- Une relation $R$ de schéma $\\mathcal{A}$ satisfait $X → Y$\nsi pour tous tuples $s,t \\in R$ on a\n$$\\bigl(\\forall A\\in X\\ s.A=t.A\\bigr) \\Longrightarrow \\bigl(\\forall A\\in Y\\ s.A=t.A\\bigr)$$\n\n(si $s$ et $t$ coïncident sur $X$ alors $s$ et $t$ coïncident sur $Y$)\n\n- Une relation $R$ satisfait un ensemble $\\Sigma$ de DF si $R$ satisfait chaque DF de $\\Sigma$\n\n\n\n\n\n## Exemples et dépendance élémentaire\n\nDans la base **pagila**, relation `Actor` : \n\n\n-  `Actor_id → last_name, first_name`\n\n- car `Actor_id` est une clé...\n\n\n\n::: {.callout-important}\n\n\n### Définition (dépendance élémentaire)\n\n$A_1,...,A_p → Y$ est une dépendance élémentaire si, \n\npour tout $j\\leq p$ :  $A_1,...,A_{j-1},A_{j+1},...,A_p \\not→ Y$\n\n:::\n\n\n\n## Exemple\n\n\n- `No_insee → sexe, mois_naiss, jour_naiss` est  élémentaire.\n\n- `No_insee, jour_naiss → sexe, mois_naiss, ville_naiss` n'est pas élémentaire ... `No_insee` suffit.\n\n\n\n\n---\n\n## Dépendance fonctionnelle triviale\n\n\nUne DF triviale est une DF satisfaite par toute relation\n\n## Définition (dépendance triviale)\n\nSoient $X,Y\\subset \\mathcal{A}$.  \n\n- $X→ Y$ est une dépendance triviale si $Y \\subset X$\n\n## Exemple\n\n\n`No_insee → No_insee` est  triviale\n\n\n\n\n---\n\n## Implication pour les  DF\n\n\n\n- Soit $\\mathcal{A}$ un schéma de relation ($\\mathcal{A}$ est un ensemble d'attributs) et $\\Sigma$\nun ensemble de DF sur $\\mathcal{A}$\n\n- Exemple : $\\mathcal{A}=\\left\\{A,B,C\\right\\}$ et $\\Sigma=\\left\\{A→ B, B→ C\\right\\}$\n\n- Les DF données impliquent d'autres DF additionnelles\n\n\n\nExemple : $A→ B$ et $B→ C$ impliquent $A→ C$\n\nc'est-à-dire\n\ntoute relation de schéma $\\mathcal{A}$ qui satisfait $A→ B$ et $B→ C$ satisfait également $A→ C$\n\n\n- Autre exemple :\n\n$A→ C$, $BC→ D$, $AD→ E$ impliquent $AB→ E$\n\n\n\n\n\n## Implication de Dépendance Fonctionnelle  \n\n\n::: {.callout-important}\n\n### Définition\n\nUn ensemble $\\Sigma$ de DF implique une autre DF $X→ Y$ si\ntoute relation qui satisfait $\\Sigma$ satisfait également $X→ Y$.\n\n:::\n\n::: {.callout-note}\n\n### Notation\n\npour $\\Sigma$ implique $X→ Y$ : $\\Sigma ⊧ X→ Y$\n\n:::\n\n\n## Exemple\n\n$\\Sigma=\\left\\{A→ B, B→ C\\right\\}$ implique\n\n$A→ B$, $B→ C$, $A→ C$, $A,B→ C$,\\dots\n\nmais aussi les DF triviales $A→ A$, $AB→ A$, ...\n\n\n---\n\n\n## Règles d'Armstrong\n\n::: {.callout-note}\n\n### Trois règles d'inférence faciles à vérifier :\n\n- *Transitivité* : $\\left\\{ X→ Y, Y→ Z\\right\\} ⊧ X→ Z$\n\n- *Augmentation* : $X→ Y ⊧ \\left\\{X,Z\\right\\} → \\left\\{Y,Z\\right\\}$\n\n- *Réflexivité* : $\\emptyset ⊧ \\left\\{X,Y\\right\\}→ X$  (DF triviale)\n\n:::\n\n\n---\n\n::: {.callout-important}\n\n### Théorème\n\n$\\Sigma ⊧ X→ Y$ \n\nsi et seulement si \n\n$X→ Y$ peut-être dérivée de $\\Sigma$ par applications successives des trois règles ci-dessus.\n\n:::\n\n---\n\nDes 3 règles d'Armstrong, on déduit d'autres règles :\n\n*Union* : $\\left\\{X→ Y, X→ Z\\right\\} ⊧ X→ \\left\\{Y,Z\\right\\}$\n\n*Séparation* : $X→\\left\\{Y,Z\\right\\} ⊧ X→ Y$\n\n\n\n---\n\n## Clef et super-clef\n\nSoit $\\mathcal{A}$ un schéma et $\\Sigma$ une ensemble de DF sur $\\mathcal{A}$.\n\n::: {.callout-important}\n\n### Définition\n\nUn ensemble d'attributs $X$ est une *super-clef* si\n\n$\\Sigma ⊧ X→ \\mathcal{A}$\n\nc-à-d si $X$ détermine tous les attributs de $\\mathcal{A}$\n\n:::\n\n---\n\n::: {.callout-important}\n\n### Définition\n\nUn ensemble d'attributs $X$ est une *clef* si \n\n- $X$ est une super-clef et \n- si tout sous-ensemble $Y\\subset X$ tel que $Y\\not=X$ n'est pas une super-clef\n\n:::\n\n---\n\n## Exemple\n\n\n$R(A,B,C)$ ET  $\\Sigma=\\left\\{A→ B, B→ C\\right\\}$\n\n- Super-clefs : $A$, $AB$, $AC$, $ABC$\n\n- Clef : $A$ (la seule)\n\n\n---\n\n\n## Equivalence de deux ensembles de DF\n\nSoit $\\Sigma$ et $\\Sigma'$ deux ensemble de DF sur un schéma $\\mathcal{A}$\n\n\n::: {.callout-important}\n\n### Définition\n\nOn dit que $\\Sigma$ implique $\\Sigma'$ \n\nsi \n\n$\\Sigma$ implique toutes les DF de $\\Sigma'$\n\nOn le note $\\Sigma⊧\\Sigma'$\n\n:::\n\n\n## Exemple\n\n\n- $\\mathcal{A}=\\left\\{A,B,C,D\\right\\}$, \n- $\\Sigma=\\left\\{AB→ C, C→ A, BC→ D\\right\\}$\n- $\\Sigma'=\\left\\{AB→ D\\right\\}$  \n\n. . .\n\n$\\Sigma⊧\\Sigma'$\n\n---\n\n::: {.callout-important}\n\n### Définition\n\n$\\Sigma$ est équivalent à $\\Sigma'$ si $\\Sigma⊧\\Sigma'$ et $\\Sigma'⊧\\Sigma$\n\n:::\n\n---\n\n### Exemples\n\n\n- $X→ A_1,\\dots,A_n$ est équivalent à $X→ A_1$, \\dots, $X→ A_n$\n\n- $XY→ YZ$ est équivalent à $XY→ Z$\n\n\n\n\n# Fermeture d'un ensemble d'attributs  {background-color=\"#1c191c\"}\n\n---\n\n::: {.callout-note}\n\n### Question principale\n\nComment vérifier si un ensemble $\\Sigma$ de DF implique une DF $X→ Y$ ?\n\n:::\n\n...\n\nPar les équivalences présentées précédemment, la question se ramène à :\n\n::: {.callout-note}\n\nComment vérifier si un ensemble $\\Sigma$ de DF implique une DF $X→ A$ ?\n\noù $A$ est un attribut\n\n:::\n\n\n---\n\n## Fermeture d'un ensemble d'attributs\n\nSoit $X \\subset\\mathcal{A}$ un sous-ensemble d'attributs et $\\Sigma$ un ensemble de DF sur $\\mathcal{A}$\n\n::: {.callout-important}\n\n### Définition\n\nLa fermeture de $X$ par rapport à $\\Sigma$ est\n$$X^+=\\left\\{ A\\in\\mathcal{A} \\mid \\Sigma ⊧ X→ A \\right\\}$$\n\nAutrement dit $X^+$ est l'ensemble des attributs déterminés par $X$\n\n:::\n\n\n\n\n\n## Exemple\n\n$R(ABCDE)$  $\\Sigma=\\left\\{AB→ C, C→ D, E→ D\\right\\}$\n\n. . .\n\n$\\left\\{A,B\\right\\}^+=\\left\\{A,B,C,D\\right\\}$\n\n\n## Algorithme pour calculer une fermeture\n\nSoit $\\Sigma$ un ensemble de DF sur un schéma $\\mathcal{A}$ et $X\\subset\\mathcal{A}$\n\n\n### Algorithme\n\n\n- $X_c := X$\n- Tant qu'il existe $Y→ Z$ dans $\\Sigma$ tel que $Y\\subset X_c$ et $Z\\not\\subset X_c$, \n  - $X_c:= X_c \\cup Z$\n  \n- renvoyer $X_c$\n\n\n---\n\n\n\n- $X_c$ grandit à chaque itération\n\n- Comme $\\mathcal{A}$ est fini, l'algorithme se termine en au plus $\\mathcal{A}$ itérations\n\n\n\n---\n\n## Exemple de calcul de fermeture\n\n$\\mathcal{A}=\\left\\{ABCDEF\\right\\}$ $\\Sigma=\\left\\{A→ C, BC→ D, AD→ E\\right\\}$ $X=\\left\\{A,B\\right\\}$\n\n\n\n- $X_c=\\left\\{A,B\\right\\}$\n\n- $A→ C$ donc on obtient $X_c=\\left\\{A,B,C\\right\\}$\n\n- $BC→ D$ donc on obtient $X_c=\\left\\{A,B,C,D\\right\\}$\n\n- $AD→ E$ donc on obtient $X_c=\\left\\{A,B,C,D, E\\right\\}$\n\n- On obtient $X^+=\\left\\{A,B,C,D, E\\right\\}$\n\n\n\n\n---\n\n\n## Correction de l'algorithme de fermeture\n\n\n\n\n- L'algorithme calcule uniquement des attributs dans la fermeture car\non a toujours $X_c\\subset X^+$\n\n- L'algorithme calcule tous les attributs dans la fermeture i.e.\\ $X_c=X^+$ quand l'algorithme se termine\n\n**Preuve :** Supposons que $A\\notin X_c$ quand l'algorithme se termine. La relation $R=\\left\\{t_1,t_2\\right\\}$ suivante (où c$\\not=$d)\n\n\n\\begin{center}\n\n{\\small\n\\begin{tabular}{c|c|c|c|}\n\\hline\n&\\bf $X_c$ & A & \\bf \\dots \\\\\n\\hline\n\\bleu{$t_1$}& aa\\dots a & c & cc\\dots c \\\\\n\\bleu{$t_2$} &aa\\dots a & d & dd\\dots d \\\\\n\\hline\n\\end{tabular}\n}\nsatisfait $\\Sigma$\n\\end{center}\n\ncar pour toute DF $Y→ Z$ telle que $Y\\subset X_c$ on a $Z\\subset X_c$.\nMais $R$ ne satisfait pas $X→ A$. Donc $A\\notin X^+$.\n\n\n\n\n---\n\n## Calcul de la fermeture transitive : exemple\n\n\n\n- soit $R$ d'ensemble d'attributs $\\mathcal{A} =\\{A,B,C,D,E,F,G\\}$ \n\n- Soit $X=\\{B,D\\}$\n\n- Soit $\\Sigma$ constituée des DF suivantes :\n\n::: {.columns}\n::: {.column}\n\n- $A,B → C$ \n- $C → A$ \n- $B,C → D$ \n- $A,C,D → B$ \n- $F→ A,C$\n\n:::\n\n::: {.column}\n\n- $D → E,G$ \n- $B,E → C$ \n- $C,G → B,D$ \n- $C,E → A,G$ \n- \n:::\n::: \n\n\n- Montrer que  $X^+=\\{A,B,C,D,E,G\\}$\n\n\n- Donner une clef de $R$\n\n\n\n\n---\n\n\n# Forme normale de Boyce-Codd (FNBC)   {background-color=\"#1c191c\"}\n\n---\n\n::: {.callout-important}\n\n### Définition\n\nUn schéma $\\mathcal{A}$ est en FNBC par rapport à un ensemble de dépendances fonctionnelles $\\Sigma$ sur $\\mathcal{A}$ si pour toute DF $X→ Y$ impliquée par $\\Sigma$ avec $Y\\not\\subset X$, $X$ est une super-clef\n\n\n:::\n\n\n\n- Autrement dit $(\\mathcal{A},\\Sigma)$ est en FNBC si pour toute DF non triviale impliquée par $\\Sigma$, le membre de gauche est une super-clef\n\n- *Ne pas représenter la même information deux fois*\n\n- Soit $\\Sigma'$ un ensemble de DF équivalent à $\\Sigma$.\n$(\\mathcal{A},\\Sigma)$ est en FNBC si et seulement si pour toute DF non triviale de $\\Sigma'$, le membre de gauche est une super-clef}\n\npuisque toute DF impliquée par $\\Sigma$ peut être obtenue à partir des DF de $\\Sigma'$ en utilisant les règles d'Armstrong.\n\n\n\n---\n\n## FNBC : exemple 1\n\n\n\n- Schéma $\\mathcal{A}=\\left\\{ \\texttt{V#, Vnom, Vville, P#, Pnom, Pville, Qte} \\right\\}$\n\n- Ensemble de dépendances fonctionnelles $\\Sigma$ :\n\n```\nV# → Vnom Vville\nP#  → Pnom Pville \nV# P# →  Qte\n```\n\n$\\mathcal{A}$ n'est pas en FNBC par rapport $\\Sigma$.\n\nEn effet:  ni `V#` ni P# ne sont des super-clefs\n\n\n\n---\n\n## FNBC : exemple 2\n\nSchéma `Films(titre, année, durée, genre, producteur, acteur)`\n\n\n\n- On a la dépendance suivante\n\n`titre, année → durée, genre, producteur`\n\n- `titre, année, acteur` est la seule clef\n\n- La DF `titre, année → durée, genre, producteur` viole la condition de FNBC\n\n\n\n---\n\n## FNBC : exemple 3\n\nTrois schémas en FNBC :\n\n\\begin{align*}\n&\\texttt{Vendeur(V#, Vnom, Vville)}\\quad \\texttt{Clef : V#}\\\\\n&\\texttt{Produit(P#, Pnom, Pville)} \\quad \\texttt{Clef : P#}\\\\\n&\\texttt{Livraison(V#, P#, Qte)} \\quad \\texttt{Clef : (V#,P#)}\n\\end{align*}\n\n\n---\n\n## Schéma avec deux attributs\n\n\n::: {.callout-important}\n\n### Proposition\n\nSoit $\\mathcal{A}=\\left\\{A,B\\right\\}$ un schéma avec deux attributs et $\\Sigma$ un ensemble de DF non triviales\n\n$\\mathcal{A}$ est toujours en FNBC par rapport à $\\Sigma$\n\n:::\n\n---\n\n## Preuve \n\non distingue 4 cas\n\n- $\\Sigma=\\emptyset$\n\n- $\\Sigma=\\left\\{A→ B\\right\\}$\n\n- $\\Sigma=\\left\\{B→ A\\right\\}$\n\n- $\\Sigma=\\left\\{A→ B, B→ A\\right\\}$\n\n\n\n\n\n\n---\n\n\n# Décomposition d'une relation   {background-color=\"#1c191c\"}\n\n\n---\n\n## Décomposition d'un schéma de relation\n\n\n\n- Soit $\\mathcal{A}$ un schéma de relation\n\n- Un décomposition de $\\mathcal{A}$ est un ensemble $\\left\\{\\mathcal{A}_1,\\dots, \\mathcal{A}_k\\right\\}$\nde sous-ensembles de $\\mathcal{A}$ tel que\n  1. $\\mathcal{A}_i\\not=\\emptyset$, $1\\le i\\le k$, et \n  2. $\\mathcal{A} = \\bigcup_{i=1}^k \\mathcal{A}_i$\n\n\n\n## Exemple\n\n\\begin{align*}\n&\\text{Vendeur(`V#`, Vnom, Vville)}\\\\\n&\\text{Produit(P\\#, Pnom, Pville)}\\\\\n&\\text{Livraison(`V#`, P\\#, Qte)}\n\\end{align*}\n\nest une décomposition du schéma\n\n`R(V#, Vnom, Vville, P#, Pnom, Pville, Qte)`\n\n\n\n---\n\n## Exemple de décomposition\n\n\n\n- Schéma : `Films(titre, année, durée, genre, producteur, acteur)`\n\n- Une décomposition :\n- \n```\nFilms1(titre, année, durée, genre, producteur)\nFilms2(titre, année, acteur)\n```\n\n- Films1 est FNBC par rapport à $\\Sigma_1=\\left\\{\\texttt{titre, année} → \\texttt{durée, genre, producteur}\\right\\}$\n\n- Films2 est en FNBC par rapport à $\\Sigma_2=\\emptyset$\n\n\n\n---\n\n## Propriétés d'une décomposition\n\n\n\n- On ne peut pas décomposer arbitrairement, toutes les décompositions ne sont pas intéressantes\n\n- Conditions pour une décomposition *raisonnable* :\n\n- Décomposition *sans perte d'information*\n\n- Décomposition sans perte de dépendance fonctionnelle\n\n\n# Décomposition sans perte d'information  {background-color=\"#1c191c\"}\n\n## Décomposition sans perte d'information\n\n\n\n- Idée : Si on remplace le schéma `(V#, Vnom, Vville, P#, Pnom, Pville, Qte)`\npar les trois schémas\n\n\\begin{align*}\n&\\texttt{Vendeur(V#, Vnom, Vville)}\\\\\n&\\texttt{Produit(P#, Pnom, Pville)}\\\\\n&\\texttt{Livraison(V#, P#, Qte)}\n\\end{align*}\n\nalors au lieu de stocker une relation $R(\\texttt{V#, Vnom, Vville, P#, Pnom, Pville, Qte})$, on stockera\nses projections\n\n$$\\pi_{\\texttt{V#,Vnom,Vville}}(R) \\quad \\pi_{\\texttt{P#,Pnom,Pville}}(R) \\quad \\pi_{\\texttt{V#,P#,Qte}}(R)$$\n\n- Peut-on retrouver $R$ à partir de ces trois projections ?\n\n\n\n\n---\n\n## Décomposition sans perte d'information\n\n\n\n- La décomposition doit garantir que pour toute relation R, ses projections contiennent\nla même information que R au sens que l'on doit pouvoir reconstruire R à partir de ses projections\n\n- Comment tenter de reconstruire R à partir de ses projections :\n- \nOn considère la *jointure naturelle*\n\n$$\\pi_{\\texttt{V#,Vnom,Vville}}(R) \\bowtie \\pi_{\\texttt{P#,Pnom,Pville}}(R) \\bowtie \\pi_{\\texttt{V#,P#,Qte}}(R) $$\n\n\n\n\n---\n\n## Décomposition sans perte d'information\n\n\n\n- La propriété souhaitée s'écrit donc\n$$R = \\pi_{\\texttt{V#,Vnom,Vville}}(R) \\bowtie \\pi_{\\texttt{P#,Pnom,Pville}}(R) \\bowtie \\pi_{\\texttt{V#,P#,Qte}}(R)$$\n\npour toute relation `R(V#, Vnom, Vville, P#, Pnom, Pville, Qte` satisfaisant les DF\n\n- Est-ce vrai ?\n\n- Intuitivement, oui : à partir d'un tuple de `Livraison(V#,P#,Qte)`\n  - `V#` permet de récupérer toutes les informations sur le vendeur `(V# → Vnom Vville)`\n  - `P#` permet de récupérer toutes les informations sur le produit `(P# → Pnom Pville)`\n\n\n{{< fa hand-point-right >}} La propriété d'être sans perte d'information est liée à l'ensemble de DF considéré\n\n\n\n---\n\n## Décomposition sans perte d'information (lossless join)\n\n::: {.callout-important}\n\n### Définition\n\n\nSoit $\\mathcal{A}$ un schéma de relation et $\\Sigma$ un ensemble de DF sur $\\mathcal{A}$.\n\nUne décomposition $\\left\\{\\mathcal{A}_1,\\dots, \\mathcal{A}_k \\right\\}$ est sans perte d'information par rapport à $\\Sigma$\nsi pour toute relation R de schéma $\\mathcal{A}$ satisfaisant $\\Sigma$ on a\n$$R= \\pi_{\\mathcal{A}_1}(R) \\bowtie \\pi_{\\mathcal{A}_2}(R) \\bowtie\\dots\\bowtie\\pi_{\\mathcal{A}_k}(R)$$\n\n:::\n\n---\n\n## Exemple de décomposition avec perte d'information\n\n\n- $\\mathcal{A}=\\left\\{A,B,C\\right\\}$ $\\Sigma=\\left\\{AB→ C\\right\\}$\n\n- décomposition $\\mathcal{A}_1=\\left\\{A,B\\right\\}$ et  $\\mathcal{A}_2=\\left\\{B,C\\right\\}$\n\n- Soit $R$ la relation\n\n\\begin{tabular}{|c|c|c|}\n\\hline\n\\bf A &\\bf  B & \\bf C \\\\\n\\hline\n 1 & 2 & 3 \\\\\n4 & 2 & 5 \\\\\n\\hline\n\\end{tabular}\n\n\n- $\\pi_{AB}(R)={\n\\begin{tabular}{|c|c|}\n\\hline\n\\bf A &\\bf  B \\\\\n\\hline\n 1 & 2  \\\\\n4 & 2  \\\\\n\\hline\n\\end{tabular}\n}$\net $\\pi_{BC}(R)={\n\\begin{tabular}{|c|c|}\n\\hline\n\\bf B &\\bf  C \\\\\n\\hline\n 2 & 3  \\\\\n2 & 5  \\\\\n\\hline\n\\end{tabular}\n}$\n\n- $\\pi_{AB}(R) \\bowtie \\pi_{BC}(R)=\n\\begin{tabular}{|c|c|c|}\n\\hline\n\\bf A &\\bf  B & \\bf C \\\\\n\\hline\n 1 & 2 & 3 \\\\\n4 & 2 & 5 \\\\\n\\mathcal{A}lert 1 & \\mathcal{A}lert 2 & \\mathcal{A}lert 5 \\\\\n\\mathcal{A}lert 4 & \\mathcal{A}lert 2 & \\mathcal{A}lert 3 \\\\\n\\hline\n\\end{tabular}$\n\n\n\n# Algorithme de poursuite  {background-color=\"#1c191c\"}\n\n## Algorithme de poursuite\n\n\n\n- Comment déterminer si une décomposition est sans perte d'information :\n\n- Si $R$ est une relation de schéma $\\mathcal{A}$ on a toujours que\n $$R\\subset \\pi_{\\mathcal{A}_1}(R) \\bowtie \\pi_{\\mathcal{A}_2}(R) \\bowtie\\dots\\bowtie\\pi_{\\mathcal{A}_k}(R)$$\n \n par définition de la jointure naturelle et de la projection\n \n - Le seul problème est que les jointures peut générer des tuples supplémentaires\n \n - Mais comme $R$ est supposée vérifier les DF de $\\Sigma$, l'inclusion inverse est garantie dans certains cas\n\n- Pour le savoir, un algorithme simple existe appelé algorithme de poursuite\n\n\n\n\n---\n\n## Algorithme de poursuite : exemple\n\nSi on remplace le schéma `(V#, Vnom, Vville, P\\#, Pnom, Pville, Qte)`\n\npar\n\n\\begin{align*}\n&\\texttt{Vendeur(V#, Vnom, Vville)}\\\\\n&\\texttt{Produit(P#, Pnom, Pville)}\\\\\n&\\texttt{Livraison(V#, P#, Qte)}\n\\end{align*}\n\nA-t-on\n$$\\pi_{\\texttt{V#,Vnom,Vville}}(R) \\bowtie \\pi_{\\texttt{P#,Pnom,Pville}}(R) \\bowtie \\pi_{\\texttt{V#,P#,Qte}}(R)\\subset R\\quad ?$$\n\nSoit $t$ un tuple dans la jointure\n\n\\begin{tabular}{|c|c|c|c|c|c|c|}\n\\hline\n\\bf `V#` &\\bf  Vnom & \\bf Vville & \\bf P\\# & \\bf Pnom & \\bf Pville & \\bf Qte \\\\\n\\hline\n $a$ & $b$ & $c$ & $d$ & $e$ & $f$ & $g$ \\\\\n\\hline\n\\end{tabular}\n\n\n---\n\n## Algorithme de poursuite : exemple\n\n\n\n-\nSoit $t$ un tuple dans la jointure\n\n\\begin{tabular}{|c|c|c|c|c|c|c|}\n\\hline\n\\bf `V#` &\\bf  Vnom & \\bf Vville & \\bf P\\# & \\bf Pnom & \\bf Pville & \\bf Qte \\\\\n\\hline\n$a$ & $b$ & $c$ & $d$ & $e$ & $f$ & $g$ \\\\\n\\hline\n\\end{tabular}\n\n\n- $(a, b, c)\\in \\pi_{`V#`,Vnom,Vville}(R)$ donc\nil existe $e_1, f_1, g_1$ tels que  $(a, b, c, d_1, e_1, f_1, g_1) \\in R$\n\n- $(d,e,f) \\in \\pi_{P\\#,Pnom,Pville}(R)$ donc il existe $a_2, b_2, c_2, g_2$ tels que\n$(a_2, b_2, c_2, d, e, f, g_2)\\in R$\n\n- $(a,d,g)\\in \\pi_{`V#`,P\\#,Qte}(R)$ donc il existe $b_3,c_3,e_3,f_3$ tels que\n$(a,b_3,c_3,d,e_3,f_3,g)\\in R$\n\n\n- On peut le représenter comme ceci :\n  \n\\begin{tabular}{c|c|c|c|c|c|c|c|}\n\\hline\n&\\bf `V#` &\\bf  Vnom & \\bf Vville & \\bf P\\# & \\bf Pnom & \\bf Pville & \\bf Qte \\\\\n\\hline\nVendeur & .red[$a$] & .red[$b$] & .red[$c$] & $d_1$ & $e_1$ & $f_1$ & $g_1$ \\\\\nProduit & $a_2$ & $b_2$ & $c_2$ & .red[$d$] & .red[$e$] & .red[$f$] & $g_2$ \\\\\nLivraison & .red[$a$] & $b_3$ & $c_3$ & .red[$d$] & $e_3$ & $f_3$ & .red[$g$] \\\\\n\\hline\n\\end{tabular}\n\n\n\n\n---\n\n## Algorithme de poursuite : exemple\n\n\n\n\n\\begin{tabular}{c|c|c|c|c|c|c|c|}\n\\hline\n&\\bf `V#` &\\bf  Vnom & \\bf Vville & \\bf P\\# & \\bf Pnom & \\bf Pville & \\bf Qte \\\\\n\\hline\nVendeur & .red[$a$] & .red[$b$] & .red[$c$] & $d_1$ & $e_1$ & $f_1$ & $g_1$ \\\\\nProduit & $a_2$ & $b_2$ & $c_2$ & .red[$d$] & .red[$e$] & .red[$f$] & $g_2$ \\\\\nLivraison & .red[$a$] & $b_3$ & $c_3$ & .red[$d$] & $e_3$ & $f_3$ & .red[$g$] \\\\\n\\hline\n\\end{tabular}\n\n\n- `V# → Vnom, Vville` donc $b_3=b$ et $c_3=c$\n\n\n\\begin{tabular}{c|c|c|c|c|c|c|c|}\n\\hline\n&\\bf `V#` &\\bf  Vnom & \\bf Vville & \\bf P\\# & \\bf Pnom & \\bf Pville & \\bf Qte \\\\\n\\hline\nVendeur & .red[$a$] & .red[$b$] & .red[$c$] & $d_1$ & $e_1$ & $f_1$ & $g_1$ \\\\\nProduit & $a_2$ & $b_2$ & $c_2$ & .red[$d$] & .red[$e$] & .red[$f$] & $g_2$ \\\\\nLivraison & .red[$a$] & $b$ & $c$ & .red[$d$] & $e_3$ & $f_3$ & .red[$g$] \\\\\n\\hline\n\\end{tabular}\n\n\n\n- P\\#$→$ Pnom, Pville donc $e_3=e$ et $f_3=f$\n\n\\begin{tabular}{c|c|c|c|c|c|c|c|}\n\\hline\n&\\bf `V#` &\\bf  Vnom & \\bf Vville & \\bf P\\# & \\bf Pnom & \\bf Pville & \\bf Qte \\\\\n\\hline\nVendeur & .red[$a$] & .red[$b$] & .red[$c$] & $d_1$ & $e_1$ & $f_1$ & $g_1$ \\\\\nProduit & $a_2$ & $b_2$ & $c_2$ & .red[$d$] & .red[$e$] & .red[$f$] & $g_2$ \\\\\nLivraison & .red[$a$] & $b$ & $c$ & .red[$d$] & $e$ & $f$ & .red[$g$] \\\\\n\\hline\n\\end{tabular}\n\n\n- On a obtenu une ligne égale au tuple $t=(a,b,c,d,e,f,g)$ donc $t\\in R$.\nOn en déduit que la décomposition est SPI.\n\n\n\n---\n\n## Algorithme de poursuite : cas général\n\n\n\n- **Entrée** : un schéma $\\mathcal{A}$, une décomposition $\\left\\{\\mathcal{A}_1,\\dots,\\mathcal{A}_k}$ et un ensemble $\\Sigma$ de DF\n\n- Pour chaque attribut de $\\mathcal{A}$, choisir un symbole (par exemple $a$, $b$, $c$, $\\dots$). La correspondance doit être injective.\n\n- Construire un tableau dont les colonnes sont les attributs de $\\mathcal{A}$\n  \nLe tableau a une ligne pour chaque $\\mathcal{A}_i$\n\nSur la ligne associée à $\\mathcal{A}_i$, les positions correspondant à $\\mathcal{A}_i$ sont remplies avec les symboles choisis.\n\nLes autres positions sont remplies avec les symboles indicés par $i$\n\n- Répéter tant que possible : s'il existe une DF $X→ Y$ dans $\\Sigma$ et deux lignes du tableau\nen accord sur $X$, égaliser ces deux lignes sur $Y$\n\n- **Sortie** : Si on obtient une ligne sans valeur indicée, la décomposition est sans perte d'information, sinon il y a perte d'information\n\n\n\n\n---\n\n## Algorithme de poursuite - cas général \n\nA nouveau, en d'autres termes:\n\n\n\n- Si deux tuples s'accordent sur la partie gauche d'une DF, leur partie droite doit être égale\n\n\n- Dans ce cas, remplacer les attributs d'un des deux tuples correspondant à  la partie droite par les valeurs de l'autre. En privilégiant si possible les valeurs sans indice (qui viennent de $R$) sur les valeurs indicées (qui sont arbitraires).\n\n\n- Si on obtient un tuple sans valeur indicées i.e. $t$, on peut déduire que  $t$ est bien dans $R$. La décomposition est sans perte.\n\n\n\n\n## Algorithme de poursuite : exemple 2\n\nConsidérons l'exemple : \n\n$$\\mathcal{A}=\\left\\{A,B,C,D\\right\\}$$\n\navec $\\mathcal{A}_1=\\{A,B\\}$, $\\mathcal{A}_2=\\{B,C\\}$ et $\\mathcal{A}_3=\\{C,D\\}$\n\nSoit $\\Sigma=\\{{C}→{D}; {B}→{A}\\}$.\n\nSoit $t=(a,b,c,d)$. Soit $t_1,t_2,t_3$ les tuples de $R$ suivants:\n\n$$\\begin{array}{c||c|c|c|c|}\n\\hline & A & B & C & D  \\\\\\hline \n\\hline t_1 & a & b &  c_1& d_1  \\\\ \n\\hline t_2 & a_2 & b & c & d_2  \\\\ \n\\hline  t_3 & a_3& b_3 & c & d  \\\\ \n\\hline \n\\end{array}$$\n\nIci, on a pris  $c_1,d_1, a_2,d_2, a_3,b_3$ comme valeurs variables et $a,b,c,d$ comme constantes.\n\n\n---\n\n## Algorithme de poursuite - exemple 2\n\n\n$$\\begin{array}{|c|c|c|c|}\n\\hline A & B & C & D  \\\\\\hline \n\\hline a & b &  c_1& d_1  \\\\ \n\\hline a_2 & b & c & d_2  \\\\ \n\\hline  a_3& b_3 & c & d  \\\\ \n\\hline \n\\end{array}$$\n\nPar la dépendance ${B}→{A}$, il vient : \n\n$$\\begin{array}{|c|c|c|c|}\n\\hline A & B & C & D  \\\\\\hline \n\\hline a & b &  c_1& d_1  \\\\ \n\\hline {\\color{red} a} & b & c & d_2  \\\\ \n\\hline  a_3& b_3 & c & d  \\\\ \n\\hline \n\\end{array}$$\n\n\n---\n\n\n\n## Algorithme de poursuite : exemple 2\n\n\n$$\\begin{array}{|c|c|c|c|}\n\\hline A & B & C & D  \\\\\\hline \n\\hline a & b &  c_1& d_1  \\\\ \n\\hline {\\color{red} a} & b & c & d_2  \\\\ \n\\hline  a_3& b_3 & c & d  \\\\ \n\\hline \n\\end{array}$$\n\nPar la dépendance ${C}→{D}$, il vient : \n\n$$\\begin{array}{|c|c|c|c|}\n\\hline A & B & C & D  \\\\\\hline \n\\hline a & b &  c_1& d_1  \\\\ \n\\hline {\\color{red} a} & b & c & {\\color{red} d}  \\\\ \n\\hline  a_3& b_3 & c & d  \\\\ \n\\hline \n\\end{array}$$\n\nOn a bien fait apparaître $t$ qui appartient donc à  $R$.\n\n---\n\n## Algorithme de poursuite - exemple 3\n\n\nConsidérons toujours l'exemple : $\\mathcal{A}=\\left\\{A,B,C,D\\right\\}$ avec\\\\\n$\\mathcal{A}_1=\\{A,B\\}$, $\\mathcal{A}_2=\\{B,C\\}$ et $\\mathcal{A}_3=\\{C,D\\}$\\\\\nMais avec  $\\Sigma=\\{{B}→{AD}\\}$.\n\n\n$$\\begin{array}{|c|c|c|c|}\n\\hline A & B & C & D  \\\\\\hline \n\\hline a & b &  c_1& d_1  \\\\ \n\\hline a_2 & b & c & d_2  \\\\ \n\\hline  a_3& b_3 & c & d  \\\\ \n\\hline \n\\end{array}$$\n\nDans ce cas, en utilisant la seule DF ${B}→{AD}$, on obtient $a_2=a$ et $d_1=d_2$ :\n\n\n$$\\begin{array}{|c|c|c|c|}\n\\hline A & B & C & D  \\\\\\hline \n\\hline a & b &  c_1& d_1  \\\\ \n\\hline a & b & c & d_1 \\\\ \n\\hline  a_3& b_3 & c & d  \\\\ \n\\hline \n\\end{array}$$\n\nMais on ne peut aller plus loin : $t=(a,b,c,d)$ n'est pas dans $R$ en général.\n\n---\n\n# Projection d'un ensemble de dépendances fonctionnelles  {background-color=\"#1c191c\"}\n\n\n\n---\n\n\n\n\n# 3NF Decomposition Algorithm {background-color=\"#1c191c\"}\n\n---\n\nGiven a set $\\Sigma$ of fd's, a minimal cover of $\\Sigma$ is a set $\\Sigma'$ of fd's such that\n\n\n- chaque DF de $\\Sigma'$ est de la forme $X→ A$, où $A$ est un attribut\n\n- $\\Sigma'$ et $\\Sigma$ sont équivalents\n\n- aucun sous-ensemble propre de $\\Sigma'$ implique $\\Sigma$\n\n- pour toute dépendance $X→ A$ de $\\Sigma'$, il n'existe pas de sous-ensemble propre $Y\\subset X$ tel que $\\Sigma⊧ Y→ A$\n\n\n\n\n---\n\n# Fin   {background-color=\"#1c191c\"}\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}