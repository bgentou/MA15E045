{
  "hash": "95e965c70c8bfec24f50228e93a4f9b7",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"BD xxx : Normalisation II\"\n---\n\n\n\n\n\n\n#  Introduction\n\n---\n\n## Rappel : Propriétés d'une décomposition\n\n-   Soit ${\\mathcal A}$ un schéma de relation et $\\Sigma$ un ensemble de\n    DF sur ${\\mathcal A}$.\n\n-   Soit $\\left\\{{\\mathcal A}_1,\\dots, {\\mathcal A}_k\\right\\}$ une\n    décomposition du schéma ${\\mathcal A}$\n    $\\text{${\\mathcal A}_i\\not=\\emptyset$, $1\\le i\\le k$ et }{\\mathcal A}= \\bigcup_{i=1}^k {\\mathcal A}_i$\n\n-   On ne peut pas décomposer arbitrairement, toutes les décompositions\n    ne sont pas intéressantes\n\n-   Conditions pour une décomposition \"raisonnable\" :\n\n    -   Décomposition sans perte d'information\n\n    -   Décomposition [sans perte de dépendance fonctionnelle]{.alert}\n\n---\n\n# Projection d'un ensemble de dépendances fonctionnelles\n\n---\n\n## Projection d'un ensemble de DF\n\n-   Soit ${\\mathcal A}$ un schéma de relation (${\\mathcal A}$ est un\n    ensemble d'attributs) et $\\Sigma$ un ensemble de DF sur\n    ${\\mathcal A}$\n\n-   Soit ${\\mathcal A}_1\\subset{\\mathcal A}$ un sous-ensemble\n    d'attributs\n\n-   **Définition**\n    $${\\color{blue}\\pi^{}_{{\\mathcal A}_1}(\\Sigma)=\\left\\{ X\\to Y \\mid \\Sigma\\models X\\to Y \\text{ et } X,Y\\subset{\\mathcal A}_1\\right\\}}$$\n    Autrement dit $\\pi^{}_{{\\mathcal A}_1}(\\Sigma)$ est l'ensemble des\n    DF de la forme $X\\to Y$ impliquée par $\\Sigma$ et telle que\n    $X\\subset{\\mathcal A}_1$ et $Y\\subset {\\mathcal A}_1$\n\n-   **Caractérisation :** si $X\\subset {\\mathcal A}_1$ on l'équivalence\n    $$X\\to Y \\in \\pi_{{\\mathcal A}_1}(\\Sigma) \\iff Y\\subset\\left\\{X\\right\\}^+\\cap{\\mathcal A}_1$$\n\n\n---\n\n## Exemple\n\n-   ${\\mathcal A}=\\left\\{A,B,C\\right\\}$ et\n    $\\Sigma=\\left\\{A\\to B, B\\to C, C\\to A\\right\\}$\n\n-   $\\pi^{}_{\\left\\{A,B\\right\\}}(\\Sigma)$ est équivalent à\n    $\\left\\{A\\to B, B\\to A\\right\\}$\n\n\n---\n\n## Calcul de $\\pi_{{\\mathcal A}_1}(\\Sigma)$ \n\nOn calcule un ensemble de DF équivalent à $\\pi_{{\\mathcal A}_1}(\\Sigma)$\n\n::: block\n**Algorithme** $P := \\emptyset$\\\npour tout $X\\subset {\\mathcal A}_1$ tel que $X\\not=\\emptyset$ et\n$X\\not={\\mathcal A}_1$\\\ncalculer $Y=X^+\\cap{\\mathcal A}_1$ et ajouter $X\\to Y$ à $P$\\\nrenvoyer $P$\n:::\n\nL'ensemble de DF obtenu est équivalent à $\\pi_{{\\mathcal A}_1}(\\Sigma)$\\\n[Très coûteux !]{.alert} Le nombre de sous-ensembles $X$ considérés est\n$2^{\\#{\\mathcal A}_1}-2$\n:::\n\n---\n\n## Exemple\n\n-   ${\\mathcal A}=\\left\\{A,B,C,D,E\\right\\}$ et\n    [$\\Sigma=\\left\\{A\\to C, BC\\to D, AD\\to E\\right\\}$]{.alert}\n\n-   $\\pi_{AC}(\\Sigma)$ est équivalent à $\\left\\{A\\to C\\right\\}$\\\n    car $\\left\\{A\\right\\}^+=\\left\\{A,C\\right\\}$ et\n    $\\left\\{C\\right\\}^+=\\left\\{C\\right\\}$\n\n-   $\\pi_{ABD}(\\Sigma)$ est équivalent à $\\left\\{AB\\to D\\right\\}$\\\n    car $\\left\\{A\\right\\}^+=\\left\\{A,C\\right\\}$,\n    $\\left\\{B\\right\\}^+=\\left\\{D\\right\\}$,\n    $\\left\\{D\\right\\}^+=\\left\\{D\\right\\}$,\n    $\\left\\{A,B\\right\\}^+=\\left\\{A,B,C,D,E\\right\\}$,\n    $\\left\\{A,D\\right\\}^+=\\left\\{A,D,C,E\\right\\}$,\n    $\\left\\{B,D\\right\\}^+=\\left\\{B,D\\right\\}$\n\n-   $\\pi_{ABCE}(\\Sigma)$ est équivalent à\n    $\\left\\{A\\to C, AB \\to CE, AE\\to C, ABC\\to E, ABE\\to C\\right\\}$\\\n    $A^+=AC \\quad B^+=B \\quad C^+=C \\quad E^+=E$\\\n    $AB^+=ABCDE \\quad AC^+=AC \\quad AE^+=AEC$\\\n    $BC^+=BCD \\quad BE^+=BE \\quad CE^+=CE$\\\n    $ABC^+=ABCDE \\quad ABE^+=ABECD$\\\n    $BCE^+=BCED \\quad ACE^+=ACE$\n\n-   Simplification : $\\pi_{ABCE}(\\Sigma)$ équivaut à\n    $\\left\\{A\\to C, AB\\to E\\right\\}$\n\n\n---\n\n\n# Décomposition sans perte de DF\n\n---\n\n##  Définition\n\n-   Soit ${\\mathcal A}$ un schéma de relation et $\\Sigma$ un ensemble de\n    DF sur ${\\mathcal A}$.\n\n-   Soit $\\left\\{{\\mathcal A}_1,\\dots, {\\mathcal A}_k\\right\\}$ une\n    décomposition du schéma ${\\mathcal A}$\n    $\\text{${\\mathcal A}_i\\not=\\emptyset$, $1\\le i\\le k$ et }{\\mathcal A}= \\bigcup_{i=1}^k {\\mathcal A}_i$\n\n::: block\nDéfinition La décomposition\n$\\left\\{{\\mathcal A}_1,\\dots, {\\mathcal A}_k\\right\\}$ préserve $\\Sigma$\nsi l'ensemble des dépendances fonctionnelles locales\n$\\bigcup_{i=1}^k \\pi_{{\\mathcal A}_i}(\\Sigma)$ est équivalent à $\\Sigma$\n:::\n\nPuisque $\\Sigma$ implique\n$\\bigcup_{i=1}^k \\pi_{{\\mathcal A}_i}(\\Sigma)$, la décomposition\npréserve $\\Sigma$ si et seulement si toutes les DF de $\\Sigma$ sont\nimpliquées par les DF locales\n\n\n---\n\n## Algorithme\n\n-   C'est une extension de l'algorithme de fermeture permet de tester si\n    une décomposition est sans perte de DF (sans devoir calculer les\n    $\\pi_{{\\mathcal A}_i}(\\Sigma)$)\n\n-   Soit $X\\to Y$ une DF de $\\Sigma$\n\n\n---\n\n## Algorithme pour tester si $X\\to Y$ est impliquée par\n$\\bigcup_{i=1}^k \\pi_{{\\mathcal A}_i}(\\Sigma)$\n\n-   $Z := X$\n\n\n\n\n```{.default}\ntant que $Z$ change faire\n    pour tout $i=1,\\dots, k$ faire\n        $Z:= Z \\cup \\bigl( (Z\\cap {\\mathcal A}_i)^+ \\cap {\\mathcal A}_i\\bigr)$\n    fin pour tout\nfin tant que\n```\n\n\n\n-   Si $Y\\not\\subset Z$ la réponse est NON, sinon la réponse est OUI\n\n---\n\n## Exemple\n\n-   ${\\mathcal A}=\\left\\{A,B,C,D\\right\\}$,\n    ${\\mathcal A}_1=\\left\\{A,B\\right\\}$,\n    ${\\mathcal A}_2=\\left\\{B,C\\right\\}$,\n    ${\\mathcal A}_3=\\left\\{C,D\\right\\}$\n\n-   $\\Sigma=\\left\\{A\\to B, B\\to C, C\\to D, D\\to A\\right\\}$\n\n-   Est-ce que la décomposition\n    $\\left\\{{\\mathcal A}_1,{\\mathcal A}_2,{\\mathcal A}_3\\right\\}$\n    préserve $\\Sigma$ ?\n\n1.  Les DF locales impliquent $A\\to B$, $B\\to C$, $C\\to D$ (elles sont\n    DF locales)\n\n2.  Est-ce que les DF locales impliquent $D\\to A$ ?\\\n    Commencer avec $Z={\\color{blue}\\left\\{D\\right\\}}$\\\n    $({\\color{blue}\\left\\{D\\right\\}}\\cap\\left\\{CD\\right\\})^+\\cap\\left\\{CD\\right\\}=\\left\\{D\\right\\}^+\\cap\\left\\{CD\\right\\}=\\left\\{DABC\\right\\}\\cap\\left\\{CD\\right\\}=\\left\\{C\\right\\}$,\n    [ajouter $C$]{.alert}\\\n    $({\\color{blue}DC}\\cap BC)^+\\cap BC=C^+\\cap BC=CDAB\\cap BC=B$,\n    [ajouter $B$]{.alert}\\\n    $({\\color{blue}DCB}\\cap AB)^+\\cap AB=B^+\\cap AB=BCDA \\cap AB$,\n    [ajouter $A$]{.alert}\\\n    $DCBA$ contient $A$ donc [$D\\to A$ est préservé]{.alert}\n\n\n---\n\n## Exemple\n\n-   ${\\mathcal A}=\\left\\{Ville, CP, Rue, Numero\\right\\}$\n\n-   $\\Sigma=\\left\\{CP\\to Ville, Ville\\, Rue\\, Numero\\to CP\\right\\}$\n\n-   ${\\mathcal A}_1=\\left\\{Ville, CP\\right\\}$${\\mathcal A}_2=\\left\\{Rue, Numero, CP\\right\\}$\n\n-   Est-ce que la décomposition\n    $\\left\\{{\\mathcal A}_1,{\\mathcal A}_2\\right\\}$ préserve $\\Sigma$ ?\n\n1.  $CP\\to Ville$ est préservée car elle est locale à ${\\mathcal A}_1$\n\n2.  Est-ce que $Ville\\, Rue\\, Numero\\to CP$ est préservée ?\\\n    $Z:=\\left\\{Ville, Rue, Numero\\right\\}$\\\n    $\\bigl(Z\\cap \\left\\{Ville, CP\\right\\}\\bigr)^+\\cap \\left\\{Ville, CP\\right\\}=\\left\\{Ville\\right\\}$,\n    [rien à ajouter]{.alert}\\\n    $\\bigl(Z\\cap \\left\\{Rue, Numero, CP\\right\\}\\bigr)^+\\cap \\left\\{Rue, Numero, CP\\right\\}=\\left\\{Rue, Numero\\right\\}$,\n    [rien à ajouter]{.alert}\\\n    Donc $Ville\\, Rue\\, Numero\\to CP$ n'est pas préservée\n\n\n\n# Fin\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}