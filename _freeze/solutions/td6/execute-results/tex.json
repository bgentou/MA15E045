{
  "hash": "85bac36ef7abc86aff069e4543d3b888",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"TD 6 : Contraintes\"\nsubtitle: \"Définition de données Contraintes\"\ndate: \"2024-10-25\"\n\n\nformat:\n  pdf:\n    code-annotations: below\n    keep-tex: false\n    code-fold: false\n    toc: false\n    output-file: td6.pdf\n    include-in-header:\n      - text: \"\\\\lhead{{\\\\sf  Base de données \\\\\\\\ TD 6: contraintes }}\"\n  html:\n    embed-resources: true\n    code-fold: true\n    output-file: td6.html\nparams:\n    year: 2024 \n    curriculum: \"L3 MIASHS/Ingémath\"\n    university: \"Université Paris Cité\"\n    homepage: \"https://stephane-v-boucheron.fr/courses/bdd\"\n    moodle: \"https://moodle.u-paris.fr/course/view.php?id=2313\"\n---\n\n\n\n\n\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-warning}\n\n### Avec solutions\n\n:::\n\n:::\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n\n- **L3 MIASHS/Ingémath**\n- **[Université Paris Cité](https://www.u-paris.fr)**\n- Année 2024-2025\n- [Course Homepage](https://stephane-v-boucheron.fr/courses/bdd)  \n- [Moodle](https://moodle.u-paris.fr/course/view.php?id=2313)\n\n::: \n\n::: {#second-column}\n![](../images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::\n\n:::\n\n\n# Contraintes SQL\n\n## Contraintes CHECK.\n\nCette contrainte permet de vérifier que les colonnes d'une ligne donnée vérifient une certaine condition. Par exemple, on pourrait vouloir vérifier que la valeur de la colonne ` percentage` de la table ` countrylanguage` est inférieure à 100 ou que la valeur de la colonne `return_date` de la table ` rental` est soit ` NULL` ou supérieure à `rental_date`. Ces contraintes se définissent lors de la création de la table. Par exemple :\n\n```{.sql}\nCREATE TABLE solde(\n\tproduit TEXT,\n\treduc_pourcentage INT,\n\tCHECK (reduc_pourcentage<=100 AND reduc_pourcentage%10=0)\n);\n```\n\nOn peut ajouter une contrainte CHECK à une table qui existe déjà. Par exemple :\n\n```{.sql}\nALTER TABLE solde ADD \n\tCHECK (reduc_pourcentage >=0);\n```\n\nou bien en nommant la contrainte :\n\n```{.sql}\nALTER TABLE solde \n\tADD CONSTRAINT reduc_positive \n\tCHECK (reduc_pourcentage >=0);\n```\n\n\n## Contraintes `DEFAULT / NOT NULL / UNIQUE`\n\n Ces contraintes s'appliquent à une colonne en particulier. La contrainte ` DEFAULT` spécifie une valeur par défaut pour remplir une colonne lorsque sa valeur n'est pas spécifiée, ` NOT NULL` que la valeur de la colonne ne peut pas être ` NULL` et ` UNIQUE` que deux lignes différentes de la table ne peuvent pas avoir la même valeur sur les colonnes indiquées. Par exemple:\n\n```{.sql}\nCREATE TABLE membre(\n\tnom VARCHAR(50) NOT NULL,\n\tprenom VARCHAR(50) NOT NULL,\n\tdate_inscription DATE DEFAULT NOW(),\n\tUNIQUE(nom, prenom)  \n);\n```\n\n\n## Contraintes `PRIMARY/FOREIGN KEY`. \n\nFormellement, la contrainte ` PRIMARY KEY` est équivalente à ` UNIQUE` et ` NOT NULL`. C'est un moyen d'identifier de façon unique chaque ligne. Chaque table est censée avoir une clé primaire. La contrainte ` FOREIGN KEY` spécifie que la valeur d'une (ou de plusieurs) colonne contient des valeurs présentes dans une autre table. Par exemple, la colonne ` capital` de ` country` contient une valeur qui doit apparaître dans la colonne ` id` de ` city`. Par exemple:\n\n```{.sql}\nCREATE TABLE membre(\n\tnom VARCHAR(50) NOT NULL, \n\tprenom VARCHAR(50) NOT NULL, \n\tid INT, \nPRIMARY KEY (id)\n);\n\nCREATE TABLE amis(\n\tid1 INT, \n\tid2 INT,\n  FOREIGN KEY (id1) REFERENCES membre (id)\n);\n```\n\nOn peut aussi ajouter une seconde clef étrangère comme ceci :\n\n```{.sql}\nALTER TABLE amis ADD \n\tFOREIGN KEY (id2) REFERENCES membre;\n```\n\n\n## Contraintes EXCLUDE.\n\nLes contraintes `NOT NULL, DEFAULT, KEY, CHECK` portent uniquement sur une ligne tandis que la contrainte `UNIQUE` permet uniquement de tester des égalités entre lignes. On veut parfois vérifier une condition plus riche sur deux lignes. Par exemple, si notre table contient des réservations d'une salle entre `start_date` et `end_date`, on ne veut pas que deux réservations se chevauchent. On écrira:\n\n```{.sql}\nCREATE TABLE reservation(\n\tstart_date DATE, \n\tend_date DATE,\n\n\tEXCLUDE USING gist (\n\t\tdaterange(start_date, end_date) WITH &&)\n);\n```\n\n\n\n# Exercices\n\nOn va travailler sur une copie du schéma ` world`. Il va donc falloir copier dans vos schémas les tables `world.country`, `world.city` et `world.countrylanguage`.\n\n```{.sql}\nCREATE TABLE chaprot.td_country (like world.country) ;\n```\n\nVa copier les champs avec leur type et les contraintes `NOT NULL`. Mais aucune autre contrainte. Par contre, la commande :\n\n```{.sql}\nCREATE TABLE chaprot.td_country (\n\tlike world.country \n\tincluding all\n) ;\n```\n\nva copier toutes les contraintes SAUF celles qui font référence à d'autres tables (clé étrangère, $\\ldots$).\n\n\n::: {.callout-note title=\"Question\"}\n\n- Copier les trois tables de ` world` dans votre schéma (`chaprot`).\n- Remplir les tables avec les valeurs qui sont dans les tables originelles.\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nINSERT INTO chaprot.td_country \n\tSELECT * FROM world.country ;\n\nINSERT INTO chaprot.td_countrylanguage \n\tSELECT * FROM world.countrylanguage;\n\nINSERT INTO chaprot.td_city \n\tSELECT * FROM world.city;\n```\n\n:::\n\n:::\n\n\n::: {.callout-note title=\"Question\"}\n\nRecréer les contraintes qui n'ont pas été copiées pour obtenir des tables qui soient réellement identiques. \n\n\nVérifier que les résultats de\n```\n\\d  world.country \n```\net \n```\n\\d  chaprot.td_country \n```\nsont bien égaux.\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nALTER TABLE chaprot.td_country \n\tADD FOREIGN KEY (capital) \n\t\tREFERENCES chaprot.td_city (id);\n\nALTER TABLE chaprot.td_countrylanguage \n\tADD FOREIGN KEY (countrycode) \n\t\tREFERENCES chaprot.td_country (countrycode);\n```\n\n:::\n\n:::\n\n\n::: {.callout-note title=\"Question\"}\n\nAjouter la contrainte : La colonne ` countrycode` de `chaprot.td_city` est une référence à la clé primaire de `chaprot.td_country`.\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nalter table chaprot.td_city \n\tadd foreign key (countrycode) \n\t\treferences chaprot.td_country(countrycode);\n```\n\n:::\n\n:::\n\n\t\n::: {.callout-note title=\"Question\"}\n\nAjouter la contrainte : La colonne ` percentage` de `chaprot.td_countrylanguage` contient un réel compris entre $0$ et $100$.\n  \n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nalter table chaprot.td_countrylanguage \n\tadd check  (cast(0.0 as real)  < percentage and \n\t\t\t\tpercentage <= cast (100 as real)  \n) ;\n```\n\nNe marche pas car c'est le cas pour certaines lignes. il faut les supprimer !\n\n:::::\n\n:::\n\n::: {.callout-note title=\"Question\"}\n\nAjouter la contrainte : Dans `chaprot.td_countrylanguage`, il n'y a pas deux lignes qui parlent du même pays et de la même langue.\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nalter table chaprot.td_countrylanguage add unique (countrycode,language)  ;\n```\n\nmais c'est inutile car (`countrycode,language`) est déjà une `PRIMARY KEY`.\n\n:::::\n\n:::\n\n\n\t\n::: {.callout-note title=\"Question\"}\n\nAjouter la contrainte : Dans `chaprot.td_country`, pour chaque pays, il n'existe pas un autre pays de la même ` region` qui n'est pas dans le même ` continent`, soit la *dépendance fonctionnelle* :  `region → continent`\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n\n::::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\ncreate or replace function chaprot.check_reg (reg text, conti text)\nreturns bigint\nlanguage sql as\n$$\nselect count (*)\nfrom chaprot.td_country a\nwhere a.region = reg and not a.continent = conti;\n$$\n\nAlter table chaprot.td_country add constraint RegionContinent check (chaprot.check_reg (region, continent) = 0) ;\n```\n\nOU \n\n```{.sql}\nALTER TABLE chaprot.td_country \n\tADD CONSTRAINT df_region_continent \n\t\tEXCLUDE USING gist (region WITH =, continent WITH <>) ;\n```\n\nLa seconde formulation de la contrainte souligne qu'il s'agit d'une contrainte de table et pas d'une contrainte de ligne. \n\n\n:::::\n\n:::\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}