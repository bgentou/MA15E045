{
  "hash": "5b7d30e3abfec0bb0363f71f7160014b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"TD 4: SQL\"\nsubtitle: \"Aggrégations, Partitions, Fenêtres\"\ncategories: [world, SQL, Aggregation, Fenêtres]\ndate: \"2024-10-11\"\n\nformat:\n  pdf:\n    output-file: td4.pdf\n    include-in-header:\n      - text: \"\\\\lhead{{\\\\sf  Base de données \\\\\\\\ TD 4}}\"\n  html:\n    output-file: td4.html\n\nengine: knitr\n---\n\n\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-warning}\n\n### Avec solutions\n\n:::\n\n:::\n\n\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n|                            |\n|:---------------------------|\n| {{< var curriculum >}}     |\n| {{< var university >}}     |\n| [Année {{< var year >}}]() |\n| {{< var homepage >}}       |\n| {{< var moodle >}}         |\n\n\n::: \n\n::: {#second-column}\n![](../images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::\n\n:::\n\n\n\n[Documentation Postgres](https://www.postgresql.org/docs/current/index.html)\n\n[Documentation Postgres en Français](https://docs.postgresql.fr)\n\n\n# Fonctions d'agrégation\n\nLes fonctions d'*agrégation* permettent d'effectuer des opérations avancées sur les solutions d'une requête (sur une table) comme : compter les lignes, sélectionner le maximum dans une colonne, etc. \n\nUne des opérations les plus courantes est de compter. `COUNT(col)` permet de compter les résultats d'une requête. \n\n## Count\n\nPour compter les pays en Europe, on écrira :\n\n```{.sql}\nSELECT COUNT(countrycode)\nFROM world.country\nWHERE continent='Europe';\n```\n\nCette requête renvoie une table ayant *une* ligne et *une* colonne contenant le nombre de lignes dans le résultat de la requête. \n\n# GROUP BY\n\nAdmettons qu'on veuille compter les pays par continent. On serait tenté d'écrire :\n\n```{.sql}\nSELECT \n  continent, COUNT(countrycode)\nFROM \n  world.country;\n```\n\nCependant, cette requête ne fonctionnera pas en SQL. SQL est incapable de deviner comment regrouper les différentes lignes pour compter. On doit lui spécifier clairement cela avec la clause `GROUP BY` :\n\n```{.sql}\nSELECT \n  continent, COUNT(countrycode)\nFROM \n  world.country\nGROUP BY \n  continent;\n```\n\nCette requête regroupe les lignes de la table `country` par modalité  de la colonne `continent` et pour chaque groupe compte le nombre de `countrycode` y apparaissant. Lorsque plusieurs lignes sont susceptibles d'avoir la même valeur, on peut compter seulement le nombre d'occurences distinctes avec `COUNT(DISTINCT col)`.\n\n::: {.callout-note title=\"Question\"}\n\nÉcrire une requête qui compte le nombre de langues parlées dans chaque pays.\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\n\nSELECT \n  countrycode, COUNT(language)\nFROM \n  world.countrylanguage\nGROUP BY \n  countrycode;\n```\n:::\n:::\n\n::: {.callout-note title=\"Question\"}\n\nÉcrire une requête qui compte le nombre de langues parlées dans le monde.\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\n\nSELECT \n  COUNT(DISTINCT language)\nFROM \n  world.countrylanguage;\n```\n:::\n:::\n\n::: {.callout-note title=\"Question\"}\n\nÉcrire une requête qui compte le nombre de langues officielles par pays.\n\n:::\n\nUne solution presque bonne :\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT countrycode, COUNT(language)\nFROM world.countrylanguage\nWHERE isofficial \nGROUP BY countrycode;\n```\n\n:::\n:::\n\nCependant, on rate les pays qui ne possèdent  pas de langue officielle. On va utiliser une superbe jointure extérieure:\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\n\nSELECT P.countrycode, COUNT(language)\nFROM \n  world.country as P \nLEFT JOIN \n  world.countrylanguage as L\n\tON (P.countrycode = L.countrycode and L.isofficial) \nGROUP BY P.countrycode;\n```\n:::\n:::\n\n\n## Sum, Max, Min, Avg\n\nUne autre fonction importante est la fonction `SUM(col)` qui effectue la somme des valeurs (numériques) d'une colonne :\n\n```{.sql}\nSELECT SUM(population_country)\nFROM world.country;\n```\n\nrenvoie la population mondiale. \n\nOn peut de même utiliser `GROUP BY` pour faire des paquets :\n\n```{.sql}\nSELECT \n  continent, SUM(population_country)\nFROM \n  world.country\nGROUP BY continent;\n```\n\nrenvoie la population de chaque continent. \n\nOn peut même faire des opérations sur la colonne à l'intérieur de `SUM`. Par exemple: `SUM(percentage/100)`.\n\n::: {.callout-note title=\"Question\"}\n\nÉcrire une requête qui renvoie le nombre de langues officielles par pays\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\n\nWITH s AS(\n    SELECT L.countrycode, sum(CAST (isofficial AS INTEGER)) AS n_official\n    FROM  world.countrylanguage as L\n    GROUP BY L.countrycode)\nSELECT s.*, c.name_country\nFROM world.country c NATURAL JOIN s\nORDER BY s.n_official DESC, s.countrycode;\n```\n:::\n:::\n\n# Requêtes (I)\n\n::: {.callout-note title=\"Question\"}\n\nÉcrire une requête qui renvoie la surface de chaque région.\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\n\nSELECT region, SUM(surfacearea)\nFROM world.country\nGROUP BY region;\n```\n:::\n:::\n\n::: {.callout-note title=\"Question\"}\n\nÉcrire une requête qui compte le nombre de francophones dans le monde.\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\n\nSELECT \n  SUM((percentage/100)*population_country)\nFROM \n  world.country \nNATURAL JOIN \n  world.countrylanguage\nWHERE \n  language = 'French';\n```\n\n:::\n:::\n\n\n\n\nOn peut utiliser de la même façon la fonction `MIN` (resp. `MAX`) qui renvoie la plus petite (resp. grande) valeur ou `AVG` qui renvoie la moyenne.\n\n::: {.callout-note title=\"Question\"}\n\nCombien de personnes vivent dans une capitale européenne ?\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\n\nSELECT \n  SUM(ci.population)\nFROM \n  world.country co \nJOIN \n  world.city ci ON co.capital=ci.id\nWHERE \n  co.continent='Europe';\n```\n\n:::\n:::\n\n::: {.callout-note title=\"Question\"}\n\nQuelle est la capitale européenne la moins peuplée ?\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\n\nWITH r as (\n\tselect ci.name, ci.population as s\n\tFROM \n    world.city ci \n  JOIN \n    world.country co ON co.capital = ci.id\n\tWHERE \n    co.continent='Europe' \n)\nSELECT \n  r.name\nFROM \n  r \nWHERE r.s = (\n  SELECT min(r.s) \n \tFROM r)\n;\n```\n:::\n:::\n\n::: {.callout-note title=\"Question\"}\n\nQuelle est la langue la plus parlée dans le monde ?\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\n\nWITH R AS (\n\tSELECT language, SUM((percentage/100)*population_country) as s\n\tFROM \n    world.country\n  NATURAL JOIN \n    world.countrylanguage\n\tGROUP BY language\n)\n\nSELECT \n  language \nFROM \n  R \nWHERE s = (\n\tSELECT MAX(s) \n\tFROM R\n);\n```\nou plus simplement\n\n```{.sql}\nSELECT \n  language, SUM((percentage/100)*population_country) as s\nFROM \n  world.country\nNATURAL JOIN \n  world.countrylanguage\nGROUP BY language\nORDER BY s DESC\nLIMIT 1 ;\n``` \n:::\n:::\n\n\n\n# Having\n\nParfois, on veut filtrer les requêtes en fonction du résultat d'une fonction d'agrégation. \n\nPar exemple, pour connaître les langues officielles dans plus de 10 pays, on serait tenté d'écrire :\n\n```{.sql}\nSELECT \n  language \nFROM \n  world.countrylanguage\nWHERE \n  COUNT(countrycode) > 10 AND isofficial \nGROUP BY language;\n```\n\n\n::: {.callout-caution}\n\nCela ne fonctionne pas. `WHERE` applique une condition sur chaque ligne de la table pour les filtrer, par exemple, garder seulement les langues officielles. Ici, on veut  *ensuite* sélectionner les lignes après avoir regroupé par langue et compté. \n\n:::\n\nOn utilisera alors `HAVING`, après la clause  `GROUP BY`:\n\n```{.sql}\nSELECT \n  language -- <5>\nFROM \n  world.countrylanguage  -- <1>\nWHERE \n  isofficial            -- <2>\nGROUP BY language           -- <3>\nHAVING \n  COUNT(countrycode) > 10; -- <4>\n```\n1. La requête concerne la table `world.countrylanguage`\n2. On filtre les lignes qui correspondent à des langues officielles\n3. On groupe/partitionne la table filtrée selon la langue\n4. On ne garde que les groupes comportant au moins 10 tuples\n5. On projette le résultat sur la colonne `language`\n\n# Requêtes (II)\n\n- Écrire une requête qui renvoie le nombre de pays par régime.\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\nSELECT \n  governmentform AS regime, COUNT(countrycode) AS nombre\nFROM \n  world.country\nGROUP BY governmentform\nORDER BY governmentform ;\n```\n:::\n:::\n\n::: {.callout-note title=\"Question\"}\n\nÉcrire une requête calculant le nombre de personnes vivant dans des villes de plus d'un million d'habitants.\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\nSELECT \n  SUM(population) AS pop\nFROM \n  world.city\nWHERE \n  population >= 1000000 ;\n```\n:::\n:::\n\n::: {.callout-note title=\"Question\"}\n\nÉcrire une requête qui calcule le nombre total de personnes vivants dans des villes qui ne sont pas  listées dans la table `city`. (Indice : comparer la population du pays avec la somme sur les villes).\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH \npop_villes AS (\n  SELECT \n    SUM(population) AS pop\n\tFROM \n    world.city),\npop_totale AS (\n  SELECT \n    SUM(population_country) AS pop\n\tFROM \n    world.country)\n\nSELECT \n  pop_totale.pop - pop_villes.pop \nFROM \n  pop_totale, pop_villes ;\n```\n:::\n:::\n\nRéponse :  (4,649,189,566)\n\n::: {.callout-note title=\"Question\"}\n\nÉcrire une requête qui compte le nombre moyen de langues parlées par pays dans chaque région.\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\n\nWITH nb_langues_parlees AS (\n\tSELECT \n    countrycode, COUNT(language) nb\n\tFROM  \n    world.countrylanguage\n\tGROUP BY countrycode\n)\n\nSELECT \n  region, SUM(nb)/COUNT(DISTINCT countrycode)\nFROM \n  world.country co\nNATURAL JOIN \n  nb_langues_parlees\nGROUP BY region ;\n```\n\nAvec la fonction `AVG()`\n\n\n```{.sql}\nWITH nb_langues_parlees AS (\n\tSELECT \n    countrycode, COUNT(language) nb\n\tFROM  \n    world.countrylanguage\n\tGROUP BY countrycode \n)\nSELECT \n  region, AVG(nb)\nFROM \n  world.country co \nNATURAL JOIN \n  nb_langues_parlees\nGROUP BY region ;\n```\n:::\n:::\n\n::: {.callout-note title=\"Question\"}\n\nÉcrire une requête qui donne la liste des pays ayant deux langues officielles parlées par plus de la moitié de la population.\n\n:::\n\n{{< fa hand-point-right >}} Pas besoin d'agrégation à cet endroit là.\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-note title=\"Solution\"}\n\n```{.sql}\nWITH R AS (\n  SELECT *\n  FROM \n    countrylanguage\n  WHERE\n    isofficial AND percentage>=25\n)\n\nSELECT \n  R1.countrycode, R1.language, R2.language\nFROM \n  R AS R1 \nJOIN \n  R AS R2 ON (\n    R1.countrycode=R2.countrycode AND \n    R1.language < R2.language\n  ) ;\n```\n\n::: \n:::\n\n::: {.callout-note title=\"Question\"}\n\nÉcrire une fonction `plus_peuplee(p_name_country text)` qui, étant donné le nom d'un pays, renvoie le nom de la ville la plus peuplée de ce pays. (schéma : `world`)\n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nCREATE FUNCTION public.plus_peuplee(p_name_country text)\nRETURNS text \nLANGUAGE sql AS $$\nWITH \n  R AS (\n  SELECT  \n    co.countrycode\n  FROM\n    world.country co\n  WHERE \n    co.name_country=p_name_country\n), \n  M AS (\n  SELECT \n    MAX(population) AS m_pop\n  FROM\n    world.city ci\n  WHERE \n    ci.countrycode IN (\n      SELECT \n        countrycode\n      FROM \n        R\n    )\n)\n\nSELECT \n  ci.name   \nFROM \n  world.city ci\nWHERE \n  ci.countrycode IN (\n    SELECT \n        countrycode\n      FROM \n        R\n  ) AND\n  ci.population >= (\n    SELECT \n      m_pop\n    FROM \n      M \n  ) ;\n$$ ;\n```\n::: \n:::\n\n::: {.callout-note title=\"Question\"}\n\nÉcrire une fonction `langues_region(p_continent text)` qui étant donné le nom d'un continent, renvoie le nombre moyen de langues parlées par pays dans chaque région (schéma : `world`). L'entête de cette fonction doit être : \n\n:::\n\n```{.sql}\nFUNCTION langues_region(p_continent TEXT) \nRETURNS TABLE(region TEXT, nbmoy NUMERIC)\n```\n\n::: {.content-visible when-profile='solution'}  \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nCREATE FUNCTION public.langues_region(p_continent TEXT)\nRETURNS TABLE(region TEXT, nbmoy NUMERIC)\nLANGUAGE SQL AS $$\nWITH S AS (\n  SELECT \n    R.region, cl.countrycode, COUNT(cl.language) AS n_l\n  FROM \n    (\n      SELECT \n        co.region, co.countrycode\n      FROM\n        world.country co\n      WHERE \n        co.continent = 'Asia'\n    ) AS R\n  JOIN \n    world.countrylanguage cl USING (countrycode)\n  GROUP BY \n    R.region, cl.countrycode\n)\n\nSELECT \n  region, AVG(n_l) AS nbmoy\nFROM \n  S\nGROUP BY \n  region ;\n$$ ;\n```\n::: \n:::\n\n::: {.callout-note title=\"Question\"}\n\nEcrire une fonction `actor_category(p_nom text, p_prenom text)` qui prend en argument le nom et le prénom d'un acteur (d'une actrice) et renvoie la liste des noms des catégories de films dans lesquels il/elle a joué (schéma : `pagila`).\n\n:::\n\n::: {.content-visible when-profile='solution'} \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nCREATE FUNCTION public.actor_category(p_nom text, p_prenom text)\nRETURNS text \nLANGUAGE SQL AS \n$$\nSELECT \n  string_agg(DISTINCT pc.name, ', ')\nFROM \n  (SELECT \n    actor_id\n  FROM\n    pagila.actor \n  WHERE \n    last_name = p_nom AND \n    first_name = p_prenom\n  ) as pa \nJOIN \n  pagila.film_actor as pfa USING(actor_id)\nJOIN \n  pagila.film_category as pfc USING(film_id)\nJOIN \n  pagila.category as pc USING(category_id) ;\n$$ ;\n\n```\n\n```{.sql}\nbd_2023-24=# SElECT public.actor_category('LOLLOBRIGIDA', 'JOHNNY') ;\n                                               actor_category                                               \n------------------------------------------------------------------------------------------------------------\n Action, Animation, Children, Comedy, Documentary, Drama, Games, Horror, Music, New, Sci-Fi, Sports, Travel\n(1 row)\n```\n::: \n:::\n\n::: {.callout-note title=\"Question\"}\n  \nEcrire une fonction `co_actors(p_nom text, p_prenom text)` qui renvoie les noms et prénoms des acteurs qui jouent dans un film où apparaît un acteur ou une actrice dont le nom et le prénom sont donnés en argument (schéma : `pagila`).\n\n:::\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nCREATE OR REPLACE FUNCTION public.co_actors(p_nom text, p_prenom text)\nRETURNS TABLE(nom text, prenom text) \nLANGUAGE SQL AS \n$$\nSELECT \n  DISTINCT pa2.last_name as nom, pa2.first_name as prenom\nFROM \n  (SELECT \n    actor_id\n  FROM\n    pagila.actor \n  WHERE \n    last_name = p_nom AND \n    first_name = p_prenom\n  ) as pa \nJOIN \n  pagila.film_actor as pfa1 USING(actor_id)\nJOIN \n  pagila.film_actor as pfa2 ON (\n    pfa1.film_id=pfa2.film_id AND \n    pfa1.actor_id<>pfa2.actor_id \n    )\nJOIN \n  pagila.actor as pa2 ON (pa2.actor_id=pfa2.actor_id) \nORDER BY nom, prenom;\n$$ ;\n```\n::: \n \n:::\n\n\n::: {.callout-note title=\"Question\"}\n\nÉcrire une vue qui contient une ligne pour chaque pays où on parle français, présente les pays par population croissante, et contient trois colonnes :\n\n  - `name_country` (même type que dans `world.country`) ;\n  - `cumul_loc` (de type `float4`) qui donne le nombre cumulé de locuteurs du français dans les pays où on parle français,  pas plus peuplés que le pays courant ;\n  - `cum_pop` (de type `float4`) qui donne la population cumulée des pays  où on parle français,  pas plus peuplés que le pays courant.\n  \n:::\n\n::: {.callout-tip}\n\nUtilisez une fenêtre (`WINDOW`) avec une clause `RANGE ...`. \n\n:::\n\n::: {.callout-caution}\n\nPour trouver les pays où on parle français, utilisez l'expression `language like '%French%'`. Vous remarquerez que dans certains pays, il existe plusieurs variétés de 'French'. Veillez à compter tous les locuteurs, et à ne compter les habitants qu'une seule fois.   \n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH f AS (\n  SELECT \n    cl.countrycode, SUM(cl.percentage) AS percentage\n  FROM \n    world.countrylanguage cl\n  WHERE \n    cl.language LIKE '%French%'\n\tGROUP BY \n    cl.countrycode\n)\n\nSELECT \n  co.name_country, \n  SUM(f.percentage * co.population_country::float4/100) OVER w AS cumul_loc,\n  SUM(co.population_country::float4) OVER w AS cum_pop   #<1>\nFROM  \n  f \nNATURAL JOIN \n  world.country co\nWINDOW w AS (\n  ORDER BY co.population_country \n  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n);\n```\n1. Pose problème !!! Si plusieurs formes de français sont utilisées dans un pays, la population de ce pays est comptabilisée plusieurs fois. \n\n\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}