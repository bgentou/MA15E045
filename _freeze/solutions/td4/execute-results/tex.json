{
  "hash": "bc975e2b22c9ac5830495b2e6690e416",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"TD 4: SQL\"\nsubtitle: \"Aggrégations, Partitions, Fenêtres\"\ncategories: [world, SQL, Aggregation, Fenêtres]\ndate: \"2024-10-11\"\n\nformat:\n  pdf:\n    code-annotations: below\n    keep-tex: false\n    code-fold: false\n    toc: false\n    output-file: td4.pdf\n    include-in-header:\n      - text: \"\\\\lhead{{\\\\sf  Base de données \\\\\\\\ TD 4}}\"\n  html:\n    embed-resources: true\n    code-fold: true\n    output-file: td4.html\nparams:\n    year: 2024 \n    curriculum: \"L3 MIASHS/Ingémath\"\n    university: \"Université Paris Cité\"\n    homepage: \"https://s-v-b.github.io/MA15Y030/\"\n    moodle: \"https://moodle.u-paris.fr/course/view.php?id=2313\"\n---\n\n\n\n\n\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-warning}\n\n### Avec solutions\n\n:::\n\n:::\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n\n\n- **L3 MIASHS/Ingémath**\n- **[Université Paris Cité](https://www.u-paris.fr)**\n- Année 2024-2025\n- [Course Homepage](https://s-v-b.github.io/MA15Y030/)  \n- [Moodle](https://moodle.u-paris.fr/course/view.php?id=2313)\n\n::: \n\n::: {#second-column}\n![](../images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::\n\n:::\n\n[Documentation Postgres](https://www.postgresql.org/docs/current/index.html)\n\n[Documentation Postgres en Français](https://docs.postgresql.fr)\n\n\n# Fonctions d'agrégation\n\nLes fonctions d'*agrégation* permettent d'effectuer des opérations avancées sur les solutions d'une requête (sur une table) comme : compter les lignes, sélectionner le maximum dans une colonne, etc. \n\nUne des opérations les plus courantes est de compter. `COUNT(col)` permet de compter les résultats d'une requête. \n\n## Count\n\nPour compter les pays en Europe, on écrira :\n\n```{.sql}\nSELECT COUNT(countrycode)\nFROM world.country\nWHERE continent='Europe';\n```\n\nCette requête renvoie une table ayant *une* ligne et *une* colonne contenant le nombre de lignes dans le résultat de la requête. \n\n# GROUP BY\n\nAdmettons qu'on veuille compter les pays par continent. On serait tenté d'écrire :\n\n```{.sql}\nSELECT continent, COUNT(countrycode)\nFROM world.country;\n```\n\nCependant, cette requête ne fonctionnera pas en SQL. SQL est incapable de deviner comment regrouper les différentes lignes pour compter. On doit lui spécifier clairement cela avec la clause `GROUP BY` :\n\n```{.sql}\nSELECT continent, COUNT(countrycode)\nFROM world.country\nGROUP BY continent;\n```\n\nCette requête regroupe les lignes de la table `country` par modalité  de la colonne `continent` et pour chaque groupe compte le nombre de `countrycode` y apparaissant. Lorsque plusieurs lignes sont susceptibles d'avoir la même valeur, on peut compter seulement le nombre d'occurences distinctes avec `COUNT(DISTINCT col)`.\n\n\n- Écrire une requête qui compte le nombre de langues parlées dans chaque pays.\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\n\nSELECT countrycode, COUNT(language)\nFROM world.countrylanguage\nGROUP BY countrycode;\n```\n:::\n:::\n\n- Écrire une requête qui compte le nombre de langues parlées dans le monde.\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\n\nSELECT COUNT(DISTINCT language)\nFROM world.countrylanguage;\n```\n:::\n:::\n\n- Écrire une requête qui compte le nombre de langues officielles par pays.\n\n\nUne solution presque bonne :\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT countrycode, COUNT(language)\nFROM world.countrylanguage\nWHERE isofficial \nGROUP BY countrycode;\n```\n\n:::\n:::\n\nCependant, on rate les pays qui ne possèdent  pas de langue officielle. On va utiliser une superbe jointure extérieure:\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\n\nSELECT P.countrycode, COUNT(language)\nFROM world.country as P LEFT JOIN world.countrylanguage as L\n\tON (P.countrycode = L.countrycode and L.isofficial) \nGROUP BY P.countrycode;\n```\n:::\n:::\n\n\n## Sum, Max, Min, Avg\n\nUne autre fonction importante est la fonction `SUM(col)` qui effectue la somme des valeurs (numériques) d'une colonne :\n\n```{.sql}\nSELECT SUM(population_country)\nFROM world.country;\n```\n\nrenvoie la population mondiale. \n\nOn peut de même utiliser `GROUP BY` pour faire des paquets :\n\n```{.sql}\nSELECT continent, SUM(population_country)\nFROM world.country\nGROUP BY continent;\n```\n\nrenvoie la population de chaque continent. \n\nOn peut même faire des opérations sur la colonne à l'intérieur de `SUM`. Par exemple: `SUM(percentage/100)`.\n\n- Écrire une requête qui renvoie le nombre de langues officielles par pays\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\n\nWITH s AS(\n    SELECT L.countrycode, sum(CAST (isofficial AS INTEGER)) AS n_official\n    FROM  world.countrylanguage as L\n    GROUP BY L.countrycode)\nSELECT s.*, c.name_country\nFROM world.country c NATURAL JOIN s\nORDER BY s.n_official DESC, s.countrycode;\n```\n:::\n:::\n\n# Requêtes (I)\n\n- Écrire une requête qui renvoie la surface de chaque région.\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\n\nSELECT region, SUM(surfacearea)\nFROM world.country\nGROUP BY region;\n```\n:::\n:::\n\n- Écrire une requête qui compte le nombre de francophones dans le monde.\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\n\nSELECT SUM((percentage/100)*population_country)\nFROM world.country NATURAL JOIN world.countrylanguage\nWHERE language = 'French';\n```\n:::\n:::\n\n\n\n\nOn peut utiliser de la même façon la fonction `MIN` (resp. `MAX`) qui renvoie la plus petite (resp. grande) valeur ou `AVG` qui renvoie la moyenne.\n\n\n- Combien de personnes vivent dans une capitale européenne ?\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\n\nSELECT SUM(ci.population)\nFROM world.country co JOIN world.city ci ON co.capital=ci.id\nWHERE co.continent='Europe';\n```\n\n:::\n:::\n\n- Quelle est la capitale européenne la moins peuplée ?\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\n\nWITH r as (\n\tselect ci.name, ci.population as s\n\tFROM world.city ci JOIN world.country co ON co.capital = ci.id\n\tWHERE co.continent='Europe' \n)\nSELECT r.name\nFROM r \nWHERE r.s = (SELECT min(r.s) \n \t\t     FROM r)\n;\n```\n:::\n:::\n\n- Quelle est la langue la plus parlée dans le monde ?\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\n\nWITH R AS (\n\tSELECT language,SUM((percentage/100)*population_country) as s\n\tFROM world.country NATURAL JOIN world.countrylanguage\n\tGROUP BY language\n)\nSELECT language \nFROM R \nWHERE s = (\n\tSELECT MAX(s) \n\tFROM R\n);\n```\n:::\n:::\n\n\n\n# Having\n\nParfois, on veut filtrer les requêtes en fonction du résultat d'une fonction d'agrégation. \n\nPar exemple, pour connaître les langues officielles dans plus de 10 pays, on serait tenté d'écrire :\n\n```{.sql}\nSELECT language \nFROM world.countrylanguage\nWHERE COUNT(countrycode) > 10 AND isofficial \nGROUP BY language;\n```\n\n\n::: {.callout-caution}\n\nCela ne fonctionne pas. `WHERE` applique une condition sur chaque ligne de la table pour les filtrer, par exemple, garder seulement les langues officielles. Ici, on veut  *ensuite* sélectionner les lignes après avoir regroupé par langue et compté. \n\n:::\n\nOn utilisera alors `HAVING`, après la clause  `GROUP BY`:\n\n```{.sql}\nSELECT language -- <5>\nFROM world.countrylanguage  -- <1>\nWHERE isofficial            -- <2>\nGROUP BY language           -- <3>\nHAVING COUNT(countrycode) > 10; -- <4>\n```\n1. La requête concerne la table `world.countrylanguage`\n2. On filtre les lignes qui correspondent à des langues officielles\n3. On groupe/partitionne la table filtrée selon la langue\n4. On ne garde que les groupes comportant au moins 10 tuples\n5. On projette le résultat sur la colonne `language`\n\n# Requêtes (II)\n\n- Écrire une requête qui renvoie le nombre de pays par régime.\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\n\nSELECT governmentform AS regime, COUNT(countrycode) AS nombre\nFROM world.country\nGROUP BY governmentform\nORDER BY governmentform ;\n```\n:::\n:::\n\n- Écrire une requête calculant le nombre de personnes vivant dans des villes de plus d'un million d'habitants.\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\n\nSELECT SUM(population) AS pop\nFROM world.city\nWHERE population >= 1000000 ;\n```\n:::\n:::\n\n- Écrire une requête qui calcule le nombre total de personnes vivants dans des villes qui ne sont pas  listées dans la table `city`. (Indice : comparer la population du pays avec la somme sur les villes).\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\n\nWITH pop_villes AS (SELECT SUM(population) AS pop\n\t\t\t\t\tFROM world.city),\n\t pop_totale AS (SELECT SUM(population_country) AS pop\n\t\t\t\t\tFROM world.country)\nSELECT pop_totale.pop - pop_villes.pop \nFROM pop_totale, pop_villes ;\n```\n:::\n:::\n\nRéponse :  (4,649,189,566)\n\n- Écrire une requête qui compte le nombre moyen de langues parlées par pays dans chaque région.\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\n\nWITH nb_langues_parlees AS (\n\tSELECT countrycode, COUNT(language) nb\n\tFROM  world.countrylanguage\n\tGROUP BY countrycode\n)\nSELECT region, SUM(nb)/COUNT(DISTINCT countrycode)\nFROM world.country co NATURAL JOIN nb_langues_parlees\nGROUP BY region ;\n```\n\nAvec la fonction `AVG()`\n\n\n```{.sql}\n\nWITH nb_langues_parlees AS (\n\tSELECT countrycode, COUNT(language) nb\n\tFROM  world.countrylanguage\n\tGROUP BY countrycode \n)\nSELECT region, AVG(nb)\nFROM world.country co NATURAL JOIN nb_langues_parlees\nGROUP BY region ;\n```\n:::\n:::\n\n\n- Écrire une requête qui donne la liste des pays ayant deux langues officielles parlées par plus de la moitié de la population.\n\nPas besoin d'agrégation à cet endroit là.\n\n\n\n\n- Écrire une fonction `city(countryname character varying(49))` qui, étant donné le nom d'un pays, renvoie le nom de la ville la plus peuplée de ce pays. (schéma : `world`)\n\n- Écrire une fonction `langue_region(c text)` qui étant donné le nom d'un continent, renvoie le nombre moyen de langue parlée par pays dans chaque région. (schéma : `world`). L'entête de cette fonction doit être : \n\n```\nFUNCTION langue_region(c TEXT) \nRETURNS TABLE(region TEXT, nbmoy NUMERIC)\n```\n\n- Ecrire une fonction `actor_category(nom character varying(49), prenom character varying(49))` qui prend en argument le nom et le prénom d'un acteur (d'une actrice) et renvoie la liste des noms des catégories de films dans lesquels il/elle a joué (schéma : `pagila`).\n\n-  Ecrire une fonction `co_actors(nom character varying(49), prenom character varying(49))` qui renvoie les noms et prénoms des acteurs qui jouent dans un film où apparaît un acteur ou une actrice dont le nom et le prénom sont donnés en argument (schéma : `pagila`).\n\n- Écrire une vue qui contient une ligne pour chaque pays où on parle français, présente les pays par population croissante, et contient trois colonnes :\n  - `name_country` (même type que dans `world.country`) ;\n  - `cumul_loc` (de type `float4`) qui donne le nombre cumulé de locuteurs du français dans les pays où on parle français,  pas plus peuplés que le pays courant ;\n  - `cum_pop` (de type `float4`) qui donne la population cumulée des pays  où on parle français,  pas plus peuplés que le pays courant.\n\n::: {.callout-tip}\nUtilisez une fenêtre (`WINDOW`) avec une clause `RANGE ...`. \n:::\n\n::: {.callout-caution}\nPour trouver les pays où on parle français, utilisez l'expression `language like '%French%'`. Vous remarquerez que dans certains pays, il existe plusieurs variétés de 'French'. Veillez à compter tous les locuteurs, et à ne compter les habitants qu'une seule fois.   \n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH f AS (\n    SELECT cl.countrycode, SUM(cl.percentage) AS percentage\n    FROM world.countrylanguage cl\n    WHERE cl.language LIKE '%French%'\n\tGROUP BY cl.countrycode)\nSELECT co.name_country, \n       SUM(f.percentage * co.population_country::float4/100) OVER w AS cumul_loc,\n       SUM(co.population_country::float4) OVER w AS cum_pop   #<1>\nFROM  f NATURAL JOIN world.country co\nWINDOW w AS (ORDER BY co.population_country \n          RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)\n;\n```\n1. Pose problème !!! Si plusieurs formes de français sont utilisées dans un pays, la population de ce pays est comptabilisée plusieurs fois. \n\n\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}