{
  "hash": "8b015f5af3410c82a02cc173af0ae750",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"TD 3: SQL\"\nsubtitle: \"SQL Interrogation de données, requêtes complexes\"\ndate: \"2024-10-04\"\n\n\nformat:\n  pdf:\n    code-annotations: below\n    keep-tex: false\n    code-fold: false\n    toc: false\n    output-file: td3.pdf\n    include-in-header:\n      - text: \"\\\\lhead{{\\\\sf  Base de données \\\\\\\\ TD 3}}\"\n  html:\n    embed-resources: true\n    code-fold: true\n    output-file: td3.html\nparams:\n    year: 2024 \n    curriculum: \"L3 MIASHS/Ingémath\"\n    university: \"Université Paris Cité\"\n    homepage: \"https://stephane-v-boucheron.fr/courses/bdd\"\n    moodle: \"https://moodle.u-paris.fr/course/view.php?id=2313\"\n\nengine: knitr\n---\n\n\n\n\n\n\n\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-warning}\n\n### Avec solutions\n\n:::\n\n:::\n\n\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n\n- **L3 MIASHS/Ingémath**\n- **[Université Paris Cité](https://www.u-paris.fr)**\n- Année 2024-2025\n- [Course Homepage](https://stephane-v-boucheron.fr/courses/bdd)  \n- [Moodle](https://moodle.u-paris.fr/course/view.php?id=2313)\n\n::: \n\n::: {#second-column}\n![](/images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::\n\n:::\n\n\nObjectifs de la séance:\n\n- requêtes imbriquées \n- jointures externes\n- vues \n- fonctions SQL\n\n\nEn plus du schéma `world`, nous allons utiliser le schéma `pagila` qui contient des informations utilisées par un magasin de location de DVD.\n\nLe schéma est visible sur [ici](./_layout-pagila-film.html).\n\nSous `psql` ou `pgli`, vous pouvez aussi inspecter les tables comme d'habitude avec\n\n```{.sql}\nbd_2023-24> \\d pagila.film\nbd_2023-24> \\d pagila.actor\n```\n\n## Requêtes imbriquées\n\n\nLes requêtes imbriquées permettent d'utiliser le résultat d'une requête dans la clause `WHERE`.\n\nOn utilisera essentiellement les opérateurs suivants: `IN, EXISTS, ALL, ANY`.\n\n`IN` permet de tester la présence d'une valeur dans le résultat d'une requête. \n\n`EXISTS` renvoie `True` si la requête donnée est non-vide et `False` sinon. On peut les combiner avec `NOT` pour inverser leur comportement: `NOT IN` et `NOT EXISTS`. Par exemple, pour connaître les régions sans monarchie, on pourra écrire:\n\n\n\n```{.sql}\nSELECT DISTINCT region \nFROM world.country\nWHERE region NOT IN (\n  SELECT region\n  FROM world.country\n  WHERE governmentform like '%Monarchy%'\n);\n```\n\nPour connaître les régions qui ont au moins une langue officielle, on pourra écrire:\n\n\n```{.sql}\nSELECT DISTINCT region \nFROM world.country AS co\nWHERE EXISTS (\n  SELECT *\n  FROM world.countrylanguage AS cl\n  WHERE co.countrycode = cl.countrycode AND \n    cl.isofficial\n);\n```\n\nRemarquez que dans ce dernier exemple, la sous-requête fait intervenir des attributs de la requête principale, c'est pourquoi on parle de requêtes imbriquées.\n\n`ANY` et `ALL` sont deux autres opérateurs. Par exemple\n\n```{.sql}\nSELECT * \nFROM table \nWHERE col < ALL(\n  requete\n)\n```\n\nsélectionnera les lignes de `table` telles que la valeur de `col` est plus petite que toutes les valeurs retournées par la requête `requete`. Ainsi, la requête\n\n```{.sql}\nSELECT * \nFROM world.country\nWHERE population_country >= ALL(\n  SELECT population_country \n  FROM world.country\n);\n```\n\nretournera la liste des pays les plus peuplés.\n\n```{.sql}\nSELECT * \nFROM table \nWHERE col < ANY(\n  requete\n)\n```\n\nsélectionnera les lignes de `table` telles que la valeur de `col` est strictement plus petite qu'au moins une des valeurs retournées par la requête `requete`.\n\nPour connaître les régions où l'on ne trouve qu'une seule forme de gouvernement, on pourra écrire:\n\n```{.sql}\nSELECT DISTINCT region \nFROM world.country as c1\nWHERE c1.governmentform = ALL(\n  SELECT c2.governmentform \n  FROM world.country as c2\n  WHERE c2.countrycode!=c1.countrycode AND \n    c2.region=c1.region\n);\n```\n\n::: {.callout-note}\n\nOn remarque que dans `EXISTS` ou `IN` on peut utiliser des attributs de notre requête globale, ce qui les rend plus *puissants* que \n\n```{.sql}\nWITH ... AS (\n  ...\n)\n```\n\n:::\n\n\n## Jointure externe\n\nLa jointure externe est une jointure un peu particulière. On a vu la semaine dernière que lorsqu'on faisait une jointure, les lignes de la table de droit étaient recollées aux lignes de la table de gauche. Si une ligne a gauche ne pouvaient pas être recollée, elle disparaissait de la jointure. La jointure extérieure permet de garder ces lignes-là malgré tout.\n\nOn utilisera `LEFT JOIN` et `RIGHT JOIN`. Par exemple, la requête suivante renvoie la liste des pays et leur langages. Les pays qui ne se trouvent pas dans la table `countrylanguage` (il y en a, l'Antarctique par exemple) seront listés quand même et les informations manquantes seront remplies avec des valeurs `NULL`.\n\n\n\n```{.sql}\nSELECT * \nFROM world.country AS p LEFT JOIN \n  world.countrylanguage AS l ON \n  p.countrycode = l.countrycode;\n```\n\nOn peut utiliser cette requête pour trouver les pays qui n'ont pas de langue officielle par exemple:\n\n\n```{.sql}\nSELECT * \nFROM world.country as p LEFT JOIN \n  world.countrylanguage AS l ON \n  p.countrycode = l.countrycode AND l.isofficial\nWHERE l.countrycode IS NULL;\n```\n\n\n## Requêtes\n\n\nQuels sont les langues qui ne sont officielles dans aucun pays ? (355 lignes)\n\nÉcrivez une version avec `EXCEPT`, une avec `NOT IN` et une autre avec `LEFT JOIN`.\n\n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\n(\n  SELECT DISTINCT language \n  FROM  world.countrylanguage\n)\n\nEXCEPT \n\n(\n  SELECT language \n  FROM world.countrylanguage \n  WHERE isofficial\n);\n```\n\n:::\n\n:::::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\nPremière  version\n\n::: {.callout-tip title=\"Solution\"}\n\n\n\n\n```{.sql}\nSELECT DISTINCT language \nFROM world.countrylanguage\nWHERE language NOT IN\n      (SELECT language \n       FROM world.countrylanguage \n       WHERE isofficial);\n```\n\n:::\n\nDeuxième version:\n\n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT DISTINCT l1.language \nFROM world.countrylanguage AS l1\n     LEFT JOIN world.countrylanguage AS l\n     ON (l1.language = l.language AND l.isofficial)\nWHERE l.language IS NULL;\n```\n\n:::\n\n\nTroisième version:\n\n::: {.callout-tip title=\"Solution\"}\n\n\n```{.sql}\nSELECT DISTINCT cl.language \nFROM world.countrylanguage cl\nWHERE  NOT EXISTS (\n  SELECT cl1.language \n  FROM world.countrylanguage cl1\n  WHERE cl1.language=cl.language AND\n  cl1.isofficial\n);\n```\n\n:::\n\n::: {.callout-note}\n\nEn calcul relationnel\n\n\n\\begin{align*}\n\\Big\\{l.\\texttt{language} :  & \\texttt{countrylanguage}(l) \\wedge \\\\\n& \\neg \\big( \\exists t \\quad \\texttt{countrylanguage}(t)  \\wedge\\\\\n&\\phantom{\\neg\\big(}l.\\texttt{language}=t.\\texttt{language}\\wedge t.\\texttt{isofficial}\\big)\\Big\\}\n\\end{align*}\n\n\n:::\n\n:::\n\nQuelles sont les régions où au moins deux pays ont la même forme de gouvernement ? (21 lignes)\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT DISTINCT region \nFROM world.country AS c1\nWHERE c1.governmentform = ANY(\n  SELECT c2.governmentform\n  FROM world.country AS c2 \n  WHERE c2.countrycode!=c1.countrycode AND c2.region=c1.region\n);\n```\n\n:::\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT DISTINCT c1.region \nFROM world.country AS c1 JOIN world.country AS c2\n  ON c1.region=c2.region AND \n    c1.countrycode!=c2.countrycode AND \n    c1.governmentform=c2.governmentform;\n```\n\n:::\n\n:::\n\n\nQuels sont les films qui n'ont jamais été loués ? (42 lignes)\n\n\n\n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"Solution\"}\n\n\n\nLà encore, plusieurs possibilités. Avec ce que l'on sait déjà  :\n\n```{.sql}\nWITH DejaLoue AS (\n  SELECT film_id \n  FROM pagila.rental JOIN pagila.inventory USING (inventory_id)\n), NonLoue AS (\n  SELECT film_id \n  FROM pagila.film \n  EXCEPT \n  SELECT * \n  FROM DejaLoue\n)\n\nSELECT title \nFROM pagila.film NATURAL JOIN NonLoue;\n```\n\nAvec les requêtes imbriquées :\n\n\n```{.sql}\nSELECT title,film_id FROM pagila.film\n                     WHERE film_id NOT IN (\n                      SELECT film_id \n                      FROM pagila.rental JOIN pagila.inventory USING (inventory_id)\n);\n```\n\n:::\n\n:::::\n\n::: {.callout-note }\n\nEn calcul relationnel\n\n\n\\begin{align*}\n\\Big\\{ f.\\texttt{title} : & \\texttt{film}(f) \\wedge \\\\\n& \\neg \\big( \\exists t, t_1  \\quad \\texttt{inventory}(t)  \\wedge  \\exists t_1  \\quad \\texttt{rental}(t_1)  \\wedge\\\\\n&\\phantom{\\neg\\big(} f.\\texttt{film\\_id}=t.\\texttt{film\\_id}\\wedge t.\\texttt{inventory\\_id}=t_1.\\texttt{inventory\\_id}\\big)\\Big\\}\n\\end{align*}\n\n\n:::\n\nCette question est exactement du même type que la précédente. On y répond de la même manière :\npour trouver *1* les objets d'un certain type  qui ne possèdent pas une propriété, on cherche\ndans la base tous les objets de ce type et on fait la différence avec l'ensemble des objets de ce type\nqui possèdent la propriété dans la base.\n\n\nQuels sont les acteurs qui ont joué dans toutes les catégories de film ? (11 lignes)\n\n::::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH ActCat AS (SELECT actor_id, category_id FROM pagila.film_actor fa\n                 JOIN pagila.film_category fc ON (fa.film_id=fc.film_id)),\nActNot AS (SELECT actor_id FROM pagila.actor,pagila.category\n    WHERE (actor_id,category_id) NOT IN (SELECT * FROM ActCat)),\nActId AS (SELECT actor_id FROM pagila.actor\n    EXCEPT SELECT * FROM ActNot)\n\nSELECT first_name,last_name FROM pagila.actor NATURAL JOIN ActId  ;\n```\n\n:::\n\n:::::\n\n\n::: {.callout-important}\n\nCette requête réalise une opération sophistiquée de l'algèbre relationnelle la *division* ou  $\\div$.\nIl ne s'agit pas d'une opération primitive comme  $\\sigma,\\pi, \\times$.\n\n\n$$\\pi_{\\texttt{actor\\_id},\\texttt{category\\_id}} \\left(\\texttt{film\\_actor} \\bowtie \\texttt{film\\_category}\\right)  \\div \\pi_{\\texttt{category}} (\\texttt{film\\_category})$$\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"Solution\"}\n\nLa version suivante  calcule le même résultat,  et\nsuit fidèlement le plan d'exécution le plus élémentaire pour réaliser la division.\n\n\n```{.sql}\nWITH \n  ActCat AS (\n    SELECT actor_id, category_id \n    FROM pagila.film_actor fa JOIN pagila.film_category fc ON (fa.film_id=fc.film_id)),\n  ActCrosCat AS (\n    SELECT  actor_id, category_id \n    FROM  pagila.actor, pagila.category),\n  ActNotCat AS (\n    SELECT * \n    FROM ActCrosCat\n    EXCEPT \n    SELECT *\n    FROM ActCat),\n  ActId AS (\n    SELECT actor_id \n    FROM pagila.actor \n    EXCEPT\n    SELECT actor_id \n    FROM ActNotCat)\n\nSELECT first_name,last_name \nFROM pagila.actor NATURAL JOIN ActId  ;\n```\n\n\nEn comptant le nombre $n$ de catégories de films dans une première requête, on peut aussi sélectionner les acteurs qui apparaissent dans au moins $n$ catégories de film.\n\n:::\n\n:::\n\nExiste-t-il des acteurs qui ne jouent avec aucun autre acteur ? (3 lignes ????)\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH Copain AS\n(SELECT R1.actor_id FROM pagila.film_actor as R1\n       JOIN pagila.film_actor as R2\n       ON (R1.film_id = R2.film_id AND R1.actor_id != R2.actor_id)\n)\nSELECT actor_id FROM pagila.actor\n    WHERE actor_id NOT IN (SELECT * FROM Copain);\n```\n\nou avec `NOT EXISTS`\n\n\n```{.sql}\nSELECT actor_id FROM pagila.actor a\nWHERE NOT EXISTS (\n  SELECT fa2.actor_id\n  FROM pagila.film_actor fa1 JOIN pagila.film_actor fa2\n  ON (fa1.actor_id=a.actor_id AND\n      fa2.actor_id<> a.actor_id AND\n      fa1.film_id=fa2.film_id)\n)\n```\n\n:::\n\n:::\n\nNom, prénom  des clients  installés dans des villes sans magasin ? (599 lignes)\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH CustomerCity AS\n(SELECT cu.first_name, cu.last_name,cu.customer_id, ad.city_id\nFROM pagila.customer cu JOIN pagila.address ad ON (cu.address_id=ad.address_id)),\nStoreCity AS\n(SELECT ad.city_id \nFROM pagila.store st JOIN pagila.address ad ON (st.address_id= ad.address_id))\n\nSELECT first_name,last_name FROM CustomerCity\nWHERE city_id NOT IN (SELECT * FROM StoreCity);\n```\n\n:::\n\n:::\n\n\n Lister les pays pour lesquels toutes les villes ont au moins un magasin. (1 ligne)\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT country_id from pagila.country C \nWHERE NOT EXISTS (\n  SELECT * \n  FROM pagila.city C2 \n  WHERE C.country_id=C2.country_id AND C2.city_id NOT IN (\n    SELECT address.city_id \n    FROM pagila.store \n    JOIN pagila.address USING (address_id)\n    )\n);\n```\n\n:::\n\n:::\n\nDéterminer la liste des films disponibles dans toutes les langues.\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"Solution\"}\n\n*Comme pour les acteurs \"toutes catégories\"*, il s'agit d'une *division*. Dans la base installée, le\nrésultat est vide.  \n\n:::\n\n:::\n\nUn même *dvd* (`inventory_id`) peut bien sûr être loué plusieurs fois, mais pas simultanément. Proposer une requête qui  vérifie que les dates de location d'un *dvd* donné sont compatibles.\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"Solution\"}\n\n`SQL` en général et `PostGres` en particulier proposent beaucoup de types et d'opérations sophistiquées pour représenter et manipuler les données temporelles.\n\n:::\n\n:::\n\n\n\n\n## Vues\n\nLes *vues* permettent de donner un nom à une requête afin de pouvoir l'appeler plus tard sans la réécrire à chaque fois. Une vue s'enregistre dans un schéma.\nPar exemple, dans le schéma `World`, on pourrait créer une vue `VillesRepublic`  qui contient toutes les villes de la table `city` qui sont dans une république.\n\nOn crée une vue avec `CREATE VIEW nom AS requete`. Étant donné que vous ne pouvez écrire que dans votre schéma personnel, il faudra nommer vos vues `entid.nom` où `entid` est votre identifiant ENT. Ainsi\n\n\n```{.sql}\nCREATE VIEW entid.VillesRepublic AS\n  SELECT B.* \n  FROM world.country as A NATURAL JOIN world.city as B\n  WHERE A.governmentform like '%Republic%';\n```\n\ncrée une vue dans votre schéma personnel. Désormais, si on veut sélectionner les villes qui sont dans une république et dont la population est supérieure à $1000000$, on pourra simplement écrire :\n\n```{.sql}\nSELECT * \nFROM entid.VillesRepublic \nWHERE population_city>=1000000;\n```\n\n\n::: {.callout-note}\n\nRemarquez la différence entre `WITH` et une vue. `WITH` nomme une requête temporairement, seulement à l'échelle de la requête courante tandis qu'une vue est enregistrée de façon permanente. Cependant, chaque fois que vous appelez votre vue, elle est réévaluée par le système de base de données.\n\n:::\n\nNotez aussi que SQL n'est pas sensible à la casse. La vue `entid.VillesRepublic`\npeut être aussi désignée par `entid.villesrepublic`.\n\nPour supprimer une vue existante on utilise la commande `DROP VIEW` suivie du nom de la vue à supprimer. Par exemple l'instruction\n\n```{.sql}\nDROP VIEW entid.VillesRepublic ;\n```\n\nsupprime la vue créée précédemment.\n\nDans votre schéma personnel (qui porte le nom de votre identifiant ENT), écrire une vue `film_id_horror` qui renvoie la liste des films de catégorie 'Horror'.\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nCREATE VIEW entid.film_id_horror\nAS\n( SELECT pagila.film_id \n  FROM pagila.film_category JOIN pagila.category USING(category_id) \n  WHERE category.name='Horror'\n) ;\n```\n\n:::\n:::\n\n\n\n\n## Fonctions SQL\n\nDans votre schéma personnel (qui porte le nom de votre identifiant ENT), écrire une fonction SQL `film_id_cat` qui prend en paramètre une chaîne de caractère `s` et renvoie la liste des films de catégorie `s`. On rappelle la syntaxe :\n\n\n\n```{.sql}\nCREATE OR REPLACE FUNCTION entid.film_id_cat(s TEXT)\nRETURNS TABLE(film_id INTEGER)\nLANGUAGE 'sql' AS\n$$\nrequete\n$$\n```\n\net l'usage \n\n```{.sql}\nCREATE OR REPLACE FUNCTION entid.film_id_cat(s text)\n RETURNS TABLE(film_id smallint) LANGUAGE sql\nAS $$\nSELECT film_id FROM film_category NATURAL JOIN category\nWHERE category.name=s ;\n$$ ;\n```\n\n\nUtilisez votre fonction pour écrire les requêtes suivantes:\n\n\nQuels sont les acteurs qui ont déjà joué dans un film d'horreur (catégorie 'Horror') ?\n\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"Solution\"}\n\nLes solutions sont données en utilisant la fonction suivante\n\n\n```{.sql}\nCREATE OR REPLACE FUNCTION entid.film_id_cat(s text)\n RETURNS TABLE(film_id smallint) LANGUAGE sql\nAS $$\nSELECT film_id FROM film_category NATURAL JOIN category\nWHERE category.name=s ;\n$$ ;\n```\n\n:::\n\n:::\n\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT DISTINCT ac.* FROM pagila.actor ac\n     NATURAL JOIN\n        (SELECT * FROM pagila.film_actor\n              WHERE film_id IN\n                (SELECT * FROM entid.film_id_cat('Horror'))\n         ) ;\n```\n\n:::\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\nou\n\n\n::: {.callout-tip title=\"Solution\"}\n \n```{.sql}\nSELECT DISTINCT ac.*\nFROM pagila.actor ac JOIN\n     pagila.film_actor NATURAL JOIN\n     entid.film_id_cat('Horror') ;\n```\n(156 tuples renvoyés).\n\n:::\n\n:::\n\nQuels sont les acteurs qui n'ont jamais joué dans une comédie (`Comedy`) ? (53 lignes)\n\n::: {.callout-caution}\n\n### Attention !  Cette requête ne répond pas à la question :\n\n```{.sql}\nSELECT DISTINCT ac.*\nFROM pagila.actor ac NATURAL JOIN\n     (SELECT * FROM pagila.film_actor\n      WHERE film_id NOT IN\n        (SELECT * FROM pagila.film_id_cat('Comedy') )\n      ) as X;\n```\n\nElle répond à la question : *Quels sont les acteurs qui ont  joué dans un film qui n'est pas une comédie ?*\n\n:::\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"Solution\"}\n\nUne réponse correcte est\n\n```{.sql}\nSELECT DISTINCT last_name, first_name\nFROM pagila.actor A1 \n WHERE NOT EXISTS \n      (SELECT * FROM pagila.film_actor A2, (pagila.film_category JOIN pagila.category using (category_id)) C WHERE A1.actor_id=A2.actor_id AND \n name='Comedy' AND A2.film_id=C.film_id); \n```\n\n:::\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\nou encore\n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT DISTINCT ac.last_name, ac_first_name\nFROM pagila.actor ac\nWHERE NOT EXISTS\n     (SELECT * FROM pagila.film_actor fa\n      WHERE film_id IN\n        (SELECT * FROM entid.film_id_cat('Comedy') )\n      AND fa.actor_id = ac.actor_id\n     )  ;\n```\n\n:::\n\n:::\n\n::: {.callout-note}\n\nEn calcul relationnel, en considérant  `film_id_cat('Comedy')` comme une relation (ce qui\nest cohérent avec la définition de la fonction) cette requête s'exprime\n\n\n\\begin{align*}\n  \\left\\{ a.\\texttt{last\\_name,}  \\right. & a.\\texttt{first\\_name}\n  :\n  \\texttt{actor}(a) \\wedge \\\\\n  & \\neg\n  \\left(\\exists \\mathrm{fa}\\quad \\texttt{film\\_actor}(\\mathrm{fa}) \\right.  \\wedge  \\mathrm{fa}.\\texttt{actor\\_id}=a.\\texttt{actor\\_id}  \\\\\n& \\left. \\left.   \\wedge \\texttt{film\\_id\\_cat}(\\mathrm{'Comedy'})(\\mathrm{fa}.\\texttt{film\\_id}) \\right) \\right\\}\n\\end{align*}\n\n\nLe calcul relationnel traduit presque littéralement la démarche que nous suivons lorsqu'il faut construire le résultat à la main : pour trouver les `actor_id` des acteurs qui n'ont jamais joué dans une comédie,\nnous examinons toutes les  valeurs $a$ de `actor_id` présentes dans la table `actor` (ou `film_actor`), et pour chacune de ces valeurs, nous verifions qu'il n'existe pas de tuple de la table `film_actor` où  l'attribut `actor_id` soit égal à $a$ et où l'attribut `film_id` désigne un film qui apparaît dans le résultat de `film_id_cat('Comedy')`.\n\nNous *décrivons/explicitons* ainsi les propriétés du résultat de la requête *Quels sont les acteurs qui n'ont jamais joué dans une comédie ('Comedy') ?*.\n\n\n\nSi maintenant nous cherchons à *1* ce résultat, nous pouvons d'abord calculer la liste des\n`actor_id`  des acteurs qui ont joué dans une comédie, calculer la liste de tous les\n`actor_id`  connus dans le schema et faire la différence, en algèbre relationnelle, cela se résume à \n\n$$\\pi_{\\texttt{actor\\_id}}\\left(\\texttt{film\\_actor}\\right) \\setminus \\pi_{\\texttt{actor\\_id}} \\left( \\texttt{film\\_actor} \\bowtie\\texttt{film\\_id\\_cat}(\\texttt{'Comedy'}) \\right)$$\n\n:::\n\nQuels sont les acteurs qui ont joué dans un film d'horreur ('Horror') et dans un film pour enfant ('Children')? (130 lignes)\n\n::: {.callout-caution}\n\nIci l'erreur la plus fréquente consiste à  écrire\n\n\n```{.sql}\nSELECT actor_id \nFROM pagila.film_actor AS fa\nWHERE fa.film_id IN (\n  SELECT * \n  FROM entid.film_id_cat('Children')\n) AND fa.film_id IN (\n  SELECT * \n  FROM entid.film_id_cat('Horror')\n);\n```\n\nLe résultat est vide et la requête ne correspond pas à la question posée. Elle calcule les\n`actor_id` des acteurs qui ont dans au moins un film qui relève simultanément\ndes catégories `Horror` et `Children` (ce genre de film est assez rare).\n\nPour calculer un résultat correct, il faut pour chaque valeur $a$  de `actor_id`\nrechercher deux tuples (pas nécessairement distincts) de  `film_actor` où\nl'attribut `actor_id` vaut $a$ et ou  dans un cas `film_id`  désigne\nun film pour enfants et dans l'autre un film d'horreur. En calcul relationnel, cela donne\n\n\n\\begin{align*}\n  \\left\\{ a.\\texttt{last\\_name,}  \\right. & a.\\texttt{first\\_name}\n  :\n  \\texttt{actor}(a) \\wedge \\\\\n  &\n  \\left(\\exists \\mathrm{fa}\\quad \\texttt{film\\_actor}(\\mathrm{fa}) \\right.  \\wedge  \\mathrm{fa}.\\texttt{actor\\_id}=a.\\texttt{actor\\_id}  \\\\\n& \\left.   \\wedge \\texttt{film\\_id\\_cat}(\\mathrm{'Children'})(\\mathrm{fa}.\\texttt{film\\_id}) \\right) \\\\\n&  \\left(\\exists \\mathrm{fa}\\quad \\texttt{film\\_actor}(\\mathrm{fa}) \\right.  \\wedge  \\mathrm{fa}.\\texttt{actor\\_id}=a.\\texttt{actor\\_id}  \\\\\n& \\left. \\left.   \\wedge \\texttt{film\\_id\\_cat}(\\mathrm{'Horror'})(\\mathrm{fa}.\\texttt{film\\_id}) \\right)\\right\\}\n\\end{align*}\n\n\nEn algèbre relationnelle \n\n\n\\begin{align*}\n\\pi_{\\texttt{last\\_name,}\\texttt{first\\_name}} \\bigg( &  \\texttt{actor} \\bowtie  \\\\\n\t & \\Big(\\pi_{\\texttt{actor\\_id}} \\left( \\texttt{film\\_actor} \\bowtie\n\t                             \\texttt{film\\_id\\_cat}(\\texttt{'Children'}) \\right) \\bigcap\\\\\n\t & \\; \\pi_{\\texttt{actor\\_id}} \\left( \\texttt{film\\_actor} \\bowtie\n\t                             \\texttt{film\\_id\\_cat}(\\texttt{'Horror'}) \\right) \\Big)\n\t                             \\bigg)\n\\end{align*}\n\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"Solution\"}\n\nEn SQL, cela peut donner\n\n\n```{.sql}\nSELECT DISTINCT a.first_name, a.last_name  FROM pagila.actor a\nWHERE EXISTS (SELECT film_id\n              FROM film_actor AS fa1 NATURAL JOIN\n                   entid.film_id_cat('Children')\n              WHERE  fa1.actor_id = a.actor_id) AND\n      EXISTS (SELECT film_id\n              FROM film_actor AS fa2 NATURAL JOIN\n                   entid.film_id_cat('Horror')\n              WHERE  fa2.actor_id = a.actor_id) ;\n```\n\nqui renvoie 129 tuples.\n\n:::\n\n:::\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}