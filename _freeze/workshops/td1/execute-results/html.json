{
  "hash": "65fc15f64ce8d3b0976fa4cc0e1abe6b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"TD 1: Algèbre relationnelle\"\ncategories: [Algèbre relationnelle, world, psql, pgcli, SQL]\nsubtitle: \"Logistique et Algèbre relationnelle\"\ndate: \"2025-09-26\"\n\nformat:\n  pdf:\n    output-file: td1.pdf\n    include-in-header:\n      - text: \"\\\\lhead{{\\\\sf  Base de données \\\\\\\\ TD 1}}\"\n  html:\n    output-file: td1.html\n\nengine: knitr\n---\n\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-warning}\n\n### Avec solutions\n\n:::\n\n:::\n\n\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n|                            |\n|:---------------------------|\n| {{< var curriculum >}}     |\n| {{< var university >}}     |\n| [Année {{< var year >}}]() |\n| {{< var homepage >}}       |\n| {{< var moodle >}}         |\n\n\n::: \n\n::: {#second-column}\n![](../images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::\n\n:::\n\n\n\n\n# Introduction\n\n## Paramétrage du client\n\nEn suivant le [guide dBeaver](/computing-dbeaver.html) :\n\n* Paramétrez la connexion au serveur dans le client dBeaver.\n\n* Utilisez l'onglet `Projet`.\n\n* Créez un sous-répertoire `tp1` dans le répertoire par défaut du projet.\n\n* Ouvrez un nouveau script dans votre projet et renommez-le en `ex1.sql`.\n\n\n## Schémas\n\nLes schémas sont une abstraction spécifique à PostgreSQL. Les schémas permettent de faire cohabiter dans une même base de données (un \"catalogue\" dans le jargon PostgreSQL) plusieurs ensembles d'informations de natures différentes.  \n\nDans ce TP, nous allons nous concentrer sur le schéma `world` qui contient des informations concernant des villes et des pays/territoires du monde entier. Au cours de ce semestre, nous serons amenés à utiliser d'autres schémas : `pagila` qui contient des informations concernant des films, ...\n\nDans dBeaver, vous pouvez lister les schémas du catalogue `bd_2023-24`, en développant la connexion  `bd_2023-24`.\n\nPuis en développant le schéma `world`, vous pouvez lister les tables qu'il contient.\n\nVous pouvez consulter la [page de présentation du schéma `world`](/schemas/schema-world.html).\n\n\n## Résolution des noms de tables et d'attributs\n\nPour résoudre les noms de tables et d'attributs, le serveur SQL utilise la syntaxe `nom_schéma.nom_table[.nom_attribut]` (rappel : les crochets signifient optionnel).\n\nPar exemple, `world.city` désigne la table `city` du schéma `world`.\n\nPour alléger cette écriture, vous pouvez utiliser le *chemin par défaut*. \n\nAfficher le chemin par défaut avec la requête SQL : `SHOW search_path ;`\n\nVous pouvez modifier ce chemin avec la requête `SET search_path TO nom_schéma1 [, nom_schéma2]`.\nIl peut y avoir plusieurs schémas dans le `search_path`.\n\nL'ordre est important. Avec `SET search_path TO world, public ;` la résolution des noms se fera d'abord dans le schéma `world` *puis en cas d'échec*, dans le schéma `public`.\n\nAprès cette instruction `city` désigne la table `city` du schéma `world` si elle existe, sinon cela désigne la table `city` du schéma `public`, sinon le serveur renverra une erreur.\n\nOn ajoute systématiquement `public` dans le `search_path`, pour permettre une bonne compatibilité car de nombreuses applications et outils s'attendent à ce que les objets (tables, vues, fonctions) soient accessibles via ce schéma.\n\n\n*Exécutez le script*\n\n```{.sql}\nSHOW search_path ;\nSET search_path TO world, public ;\nSHOW search_path ;\n```\n\n\n## Tables\n  \nPour voir le schéma d'une table avec le client dBeaver, il suffit de dérouler le schéma `world` puis de double-cliquer sur la table.\n\nVous pouvez aussi visualiser toutes les tables du schéma par un clic droit sur le schéma puis `Voir le diagramme`.\n\n[](/images/schema-world.png)\n\nDans la deuxième partie du TP, on s'intéresse aux requêtes, c'est-à-dire, les moyens d'extraire une information pertinente d'une base de données.\n\n# Écriture d'une requête\n\nPour extraire des informations d'une base de données, on utilise l'algèbre relationnelle (pour la théorie) et le langage SQL (pour la pratique).\n\nA la fin du TP, vous devez rendre sur Moodle vos fichiers scripts (a priori un par exercice). Chaque fichier contient une liste de requêtes SQL. *Lorsque c'est demandé, il faut écrire en commentaire l'expression correspondante en algèbre relationnelle*.\n\nPour écrire un commentaire en SQL : `--` en début de ligne.\n\n*NB* : pensez à documenter vos scripts en utilisant les commantaire SQL\n\n\n\n# Requêtes monotables\n<!-- L'*algèbre relationnelle* est un ensemble d'opération sur les tables. Chaque opération prend en argument une ou plusieurs tables et produit une nouvelle table. Nous commençons par introduire deux opérations importantes qui opèrent sur une table à la fois :\n\n- *Projection* : $\\pi_{\\texttt{liste de colonnes}}{R}$. Cette opération ne garde que les colonnes mentionnées de la table $R$. Par exemple $\\pi_{\\texttt{name,continent}}{\\texttt{world.country}}$ est la table avec deux colonnes `name, continent` et une ligne pour chaque ligne de la table `world.country`.\n\n- *Sélection* : $\\sigma_{\\texttt{condition}}{R}$. Cette opération ne garde que les lignes qui respectent la condition indiquée. Par exemple $\\sigma_{\\texttt{lifeexpectancy < 50}}\\texttt{world.country}$ renvoie la table contenant les pays ayant une espérance de vie de moins de 50 ans.\n\n\nCes deux opérations peuvent être écrites en SQL ainsi :\n-->\n\nOn rappele que la requête SQL\n\n```{.sql}\nSELECT colonne1, colonne2, ... \nFROM table \nWHERE condition;\n```\n\naffiche les colonnes de `table` indiquées après le `SELECT` qui respectent la `condition`. \n\nC'est la transcription de \n\n$${\\Pi}_{\\texttt{colonne1, colonne2}}\\left({\\Large \\sigma}_{\\texttt{condition}}\\left(\\texttt{table}\\right)\\right)$$\n\nPar exemple:\n\n```{.sql}\nSELECT name_country, lifeexpectancy\nFROM world.country\nWHERE lifeexpectancy < 50 and continent = 'Asia';\n```\n\naffichera le nom et l'espérance de vie des pays d'Asie ayant une espérance de vie inférieure à 50 ans. \n\nRemarquez l'utilisation des apostrophes simples pour délimiter les chaînes de caractères ('Asia').\n\n\n\n## Éxercice 1\n\nEcrire des requêtes en algèbre relationnelle et en SQL pour extraire les informations suivantes du schéma `world`:\n\n@. Quelles sont les régions ? (25 lignes)\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$\\Pi_{\\texttt{region}} (\\texttt{world.country})$\n\n```{.sql}\nSELECT DISTINCT region\nFROM world.country ;\n```\n\n:::\n:::\n\n\n@. Quelles sont les régions situées en Europe ? (6 lignes)\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$\\Pi_{\\texttt{region}} \\big( \\sigma_{\\texttt{continent = 'Europe'}}(\\texttt{world.country})\\big)$\n\n```{.sql}\nSELECT DISTINCT region\nFROM world.country\nWHERE continent = 'Europe' ;\n```\n\n:::\n:::\n\n\n\n@. Quels sont les pays situés en Europe du sud ('Southern Europe') ? (15 lignes)\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$\\Pi_{\\texttt{name\\_country}} \\big( {\\Large \\sigma}_{\\texttt{region = 'Southern Europe'}}(\\texttt{world.country})\\big)$\n\n```{.sql}\nSELECT name_country\nFROM world.country\nWHERE region = 'Southern Europe' ;\n```\n\n:::\n:::\n\n\n\n@. Quelles sont les capitales des pays situés en Europe de l'Ouest ? (quel est le type de la colonne `capital` dans la table `country`?) (9 lignes)\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$$\\Pi_{\\texttt{capital}} \\big( {\\Large \\sigma}_{\\texttt{region = 'Western Europe'}}(\\texttt{world.country})\\big)$$\n\n```{.sql}\nSELECT capital\nFROM world.country\nWHERE region = 'Western Europe' ;\n```\n\n:::\n:::\n\n\n@. A partir de la table `countrylanguage`, quels sont les langues qui sont officielles dans au moins un pays ? (102 lignes)\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$\\Pi_{\\texttt{language}} \\big( {\\Large \\sigma}_{\\texttt{isofficial}}(\\texttt{world.countrylanguage})\\big)$\n\n```{.sql}\nSELECT DISTINCT language \nFROM world.countrylanguage \nWHERE isofficial ;\n```\n\nLa variante de l'algèbre relationnelle vue en cours opérant sur les ensembles, `DISTINCT` est toujours implicitement implémenté par la requête algébrique. Ce n'est pas le cas en SQL (variante multi-ensembliste de l'algèbre relationnelle), il existe donc un opérateur d'élimination des doublons : `DISTINCT`.\n\n:::\n:::\n\n\n@. Quels sont les codes des pays où le français est langue officielle ? (18 lignes) Même question pour les langues de votre choix ?\n  \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$\\Pi_{\\texttt{countrycode}} \\big( {\\Large \\sigma}_{ \\texttt{language = 'French'} \\wedge \\texttt{isofficial}}(\\texttt{world.countrylanguage})\\big)$\n\n```{.sql}\nSELECT countrycode\nFROM world.countrylanguage\nWHERE language = 'French' AND isofficial ;\n```\n\n:::\n:::\n\n\n\n@. Quelle est la date d'indépendance de la France ?\n  \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$\\Pi_{\\texttt{indepyear}} \\big( {\\Large \\sigma}_{ \\texttt{name\\_country = 'French'}}(\\texttt{world.country})\\big)$\n\n```{.sql}\nSELECT indepyear\nFROM world.country\nWHERE name_country = 'France' ;\n```\n\n:::\n:::\n\n\n\n@. Quelles sont les dates d'indépendance des pays d'Europe ? (46 lignes)\n  \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$\\Pi_{\\texttt{name\\_country, indepyear}} \\big( {\\Large \\sigma}_{ \\texttt{continent = 'Europe' }}(\\texttt{world.country})\\big)$\n\n```{.sql}\nSELECT name_country , indepyear\nFROM world.country\nWHERE continent = 'Europe' ;\n```\n\n:::\n:::\n\n\n\n@. Quelles sont les villes françaises de plus de 200 000 habitants ? (10 lignes)\n  \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$\\Pi_{\\texttt{name, population}} \\big( {\\Large \\sigma}_{ \\texttt{countrycode = 'FRA' }\\wedge \\texttt{population > 200000}}(\\texttt{world.city})\\big)$\n\n```{.sql}\nSELECT name , population\nFROM world.city\nWHERE countrycode = 'FRA' AND population > 200000 ;\n```\n\n:::\n:::\n\n\n\n@. Pour chaque pays européen, calculer la densité, le GNP par habitant,\net l'espérance de vie, ordonner par densité décroissante. (46 lignes)\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$${\\Large \\rho}_{\\texttt{population\\_country} / \\texttt{surfacearea} \\mapsto \\texttt{density}, \\texttt{gnp} / \\texttt{population\\_country} \\mapsto \\texttt{gnp\\_per\\_hab}}(\\\\\n\\Pi_{\\texttt{name\\_country, population\\_country / surfacearea}} \\big( {\\Large \\sigma}_{ \\texttt{continent = 'Europe' }}(\\texttt{world.country})\\big))$$\n\n```{.sql}\nSELECT name_country , population_country / surfacearea as density ,\n       gnp / population_country as gnp_per_hab , lifeexpectancy\nFROM country \nWHERE continent = 'Europe'\nORDER BY density DESC;\n```\n\n:::\n:::\n\n\n\n@. Quels sont les pays où l'espérance de vie n'est pas inférieure à 77 ans et le pnb par habitant n'est pas supérieur à \\(0.010\\) ? (10 lignes)\n    \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$$\\Pi_{\\texttt{name\\_country}} \\big( {\\Large \\sigma}_{ \\neg \\texttt{lifeexpectancy < 77}\\wedge \\neg \\texttt{(gnp / population\\_country) > 0.01}}(\\texttt{world.country})\\big)$$\nou, de manière équivalente \\\\\n$$\\Pi_{\\texttt{name\\_country}} \\big( \\sigma_{\\texttt{lifeexpectancy >= 77}\\wedge \\texttt{(gnp / population\\_country) >= 0.01}}(\\texttt{world.country})\\big)$$\n\n```{.sql}\nSELECT name_country \nFROM world.country\nWHERE NOT (lifeexpectancy < 77) AND \n      NOT (gnp / population_country) > 0.01 ;\n```\n\n:::\n:::\n\n\n\n@. Quels sont les pays tels que la condition (espérance de vie supérieure\nou égale à 77 ans ou PNB par habitant inférieur à \\(0.01\\)) n'est pas\nvérifée ? (16 lignes)\n    \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$$\\Pi_{\\texttt{name\\_country}} \\big( {\\Large \\sigma}_{\\neg({\\texttt{lifeexpectancy >= 77}\\vee \\texttt{(gnp / population\\_country) < 0.01})}}(\\texttt{world.country})\\big)$$\nou, de manière équivalente             \n$$\\Pi_{\\texttt{name\\_country}} \\big( {\\Large \\sigma}_{\\texttt{lifeexpectancy < 77}\\wedge \\texttt{(gnp / population\\_country) >= 0.01}}(\\texttt{world.country})\\big)$$\n\n\n```{.sql}\nSELECT name_country\nFROM world.country\nWHERE NOT (lifeexpectancy >= 77 OR (gnp / population_country) < 0.0@. ;\n```\n\n:::\n:::\n\n\n\n@. Quels sont les pays où une langue est officielle sans être parlée par\nau moins la moitié de la population ? (92 lignes)\n    \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$$\\Pi_{\\texttt{countrycode}} \\big( {\\Large \\sigma}_{\\texttt{isofficial}\\wedge\\texttt{percentage < 50}}(\\texttt{world.countrylanguage})\\big)$$    \n\n```{.sql}\nSELECT DISTINCT countrycode\nFROM world.countrylanguage\nWHERE isofficial AND percentage < 50 ;\n```\n\n:::\n:::\n\n\n\n@. Quels sont les pays qui ont au moins une langue officielle ? (190 lignes)\n    \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$$\\Pi_{\\texttt{countrycode}} \\big( {\\Large \\sigma}_{\\texttt{isofficial}}(\\texttt{world.countrylanguage})\\big)$$   \n\n```{.sql}\nSELECT DISTINCT countrycode \nFROM world.countrylanguage \nWHERE isofficial ;\n```\n\n:::\n:::\n\n\n\n@. Quels sont les noms des pays qui comptent plus de 100 000 000\nd'habitants ? (10 lignes)\n    \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$$\\Pi_{\\texttt{name\\_country}} \\big( {\\Large \\sigma}_{\\texttt{population\\_country > 100000000}}(\\texttt{world.country})\\big)$$ \n\n```{.sql}\nSELECT name_country \nFROM world.country\nWHERE population_country > 100000000 ;\n```\n\n:::\n:::\n\n\n\n\n\n\n# Requêtes multi-tables\n\nOn peut aussi combiner plusieurs tables. Pour ce TP, nous allons seulement présenter le produit cartésien de deux tables: $T \\times S$ est la table dont les colonnes sont les colonnes de $S$ et les colonnes de $T$ et dont les lignes sont tous les couples $(l_1,l_2)$ où $l_1$ est une ligne de $T$ et $l_2$ est une ligne de $S$. En SQL, on écrira:\n\n```{.sql}\nSELECT col1,col2 \nFROM table1,table2 \nWHERE condition;\n```\n\nPar exemple,\n\n```{.sql}\nSELECT language\nFROM world.country as c, world.countrylanguage as l\nWHERE c.countrycode = l.countrycode and c.continent = 'Europe';\n```\n\naffichera les langues parlées en Europe. Remarquez l'utilisation des `as` pour donner de nouveaux noms aux tables et l'utilisation de `c.countrycode` pour lever l'ambiguité sur des noms de colonnes qui seraient éventuellement les mêmes.\n\n## Éxercice 2\n\n\n\nEcrire des requêtes pour les questions suivantes:\n\n\n1. Quels sont les noms des capitales sud-américaines ? (14 lignes)\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n      $$\\Pi_{\\texttt{name}} \\big( \\sigma_{\\texttt{capital = id}\\wedge \\texttt{region = 'South America'}}(\\rho_{\\texttt{countrycode} \\mapsto {city\\_countrycode}}(\\texttt{world.city}) \\times \\texttt{world.country})\\big)$$\n\n      ```{.sql}\n      SELECT name\n      FROM world.country , world.city\n      WHERE capital = id AND region = 'South America' ;\n      ```\n\n      Attention ! En toute rigueur le produit cartésien ne s'applique que sur des relations de schémas disjoints, d'où le renommage utilisé dans la requête algébrique ci-dessus. En pratique on utilisera tout de même :\n\n      $$\\Pi_{\\texttt{name}} \\big( {\\Large \\sigma}_{\\texttt{capital = id}\\wedge \\texttt{region = 'South America'}}(\\texttt{world.country}\\times \\texttt{world.city})\\big)$$\n\n      comme abréviation pour :\n\n      $$\\Pi_{\\texttt{name}} \\big( \\sigma_{\\texttt{capital = id}\\wedge \\texttt{region = 'South America'}}(\\rho_{\\texttt{countrycode} \\mapsto \\texttt{country.countrycode}}(\\texttt{world.country}) \\times \\rho_{\\texttt{countrycode} \\mapsto \\texttt{city.countrycode}}(\\texttt{world.city}))\\big)$$\n\n      Donc, dès que l'on opère un produit cartésien sur deux tables, on supposera implicitement que les attributs en commun sont renommés en les préfixant par le nom de la relation à laquelle ils appartiennent. Si les deux tables sont deux copies d'une seule et même table (cf plus loin question 4, on parle alors d'auto-jointure) on fera suivre le nom de la première copie par 1 et le nom de la seconde copie par 2 et on renommera tous les attributs de chacune des copies en les préfixant par ce nouveau nom.\n\n:::\n:::\n\n\n2. Quels sont les noms des pays où le français est langue officielle ? (18 lignes)\n  \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n      $$\\Pi_{\\texttt{name\\_country}} \\big( \\sigma_{\\texttt{isofficial}\\wedge \\texttt{language = 'French'}}(\\texttt{world.country} \\bowtie \\texttt{world.countrylanguage})\\big)$$\n\n      ```{.sql}\n      SELECT name_country\n      FROM world.country NATURAL JOIN world.countrylanguage\n      WHERE isofficial AND \n            language = 'French' ;\n      ```\n\n      Dans la variante algébrique, pour utiliser la jointure naturelle on a bien vérifié au préalable que le seul attribut en commun sur les deux relations était bien `countrycode`. En effet, si au contraire, certains attributs s'étaient trouvé avoir le même nom de manière fortuite, il aurait fallu les renommer au préalable dans l'une des deux relations. Une autre solution aurait combiné sélection et produit cartésien afin d'émuler la requête SQL ci-dessus, mais il aurait alors fallu en toute rigueur renommer au préalable l'attribut en commun `countrycode` dans l'une des deux tables en utilisant l'opérateur $\\rho$, le produit cartésien ne pouvant être réalisé que sur des relations de schémas disjoints (c.f. question précédente). \n\n\n:::\n:::\n\n\n\n3. Quelles sont les pays où l'espagnol est langue officielle et la forme\nde gouvernement est 'Federal Republic' ? (3 lignes)\n    \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$$\\Pi_{\\texttt{name\\_country}} \\big( \\sigma_{\\texttt{ttisofficial}\\wedge \\texttt{language = 'Spanish'}\\wedge \\texttt{governmentform = 'Federal Republic'}}(\\texttt{world.country} \\bowtie \\texttt{world.countrylanguage})\\big)$$\n\n```{.sql}\nSELECT name_country\nFROM country NATURAL JOIN countrylanguage\nWHERE isofficial AND \n      language = 'Spanish' AND \n      governmentform = 'Federal Republic' ;\n```\n\n:::\n:::\n\n\n\n4.  Quels sont les pays qui ont au moins deux langues officielles ? (38 lignes)\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$$\\Pi_{\\texttt{name\\_country}}$$\n      \n$$\\big( \\sigma_{\\texttt{c1.isofficial}\\wedge \\texttt{c2.isofficial} \\wedge \\texttt{c1.language}\\neq \\texttt{c2.language}\\wedge\n       \\texttt{countrycode = c1.countrycode} \\wedge \\texttt{countrycode = c2.countrycode}}(\\\\\n      \\texttt{world.country} \\times \\texttt{world.c1}\\times \\texttt{world.c2})\\big)$$\n\n```{.sql}\nSELECT DISTINCT name_country\nFROM country AS c , countrylanguage AS l1 , countrylanguage AS l2\nWHERE c.countrycode = l1.countrycode AND \n      c.countrycode = l2.countrycode AND \n      l1.isofficial AND \n      l2.isofficial AND \n      NOT (l1.language = l2.language) ;\n```\n\nAttention à bien noter que l'on a utilisé ici dans la requête\nalgébrique l'abréviation de renommage mentionné à la question 1. Pour\nsimplifier l'écriture de la requête on a également abrévié\n`countrylanguage` en `ci` pour $i \\in \\{1,2\\}$.\n\nOn dispose aussi de la syntaxe `JOIN … USING (a₁,…,aₖ)` pour\nfaire des jointures qui ne considèrent que les attributs communs\n`a₁` à `aₖ`.\n\n```{.sql}\nSELECT DISTINCT name_country\nFROM country NATURAL JOIN\n     countrylanguage AS l1 JOIN \n     countrylanguage AS l2 USING (countrycode)\nWHERE l1.isofficial AND l2.isofficial\nAND l1.language <> l2.language ;\n```\n\n\n:::\n:::\n\n\n\n5. Quels sont les pays qui n'ont pas de langue officielle ? (49 lignes)\n    \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$$\\Pi_{\\texttt{name\\_country}}\\big(\n      \\texttt{world.country})-\n     \\Pi_{\\texttt{name\\_country}}\\big( \\sigma_{\\texttt{isofficial}}(\\texttt{world.country} \\bowtie \\texttt{world.countrylanguage}))$$\n\n```{.sql}\n(SELECT name_country \n FROM world.country\n)\n\nEXCEPT\n\n(SELECT name_country \n FROM world.country NATURAL JOIN world.countrylanguage \n WHERE isofficial\n);\n```\n\n:::\n:::\n\n\n\n6. Quels sont les pays qui comportent au moins deux villes de plus de\n  1 000 000 habitants ? (32 lignes)\n    \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$$\\Pi_{\\texttt{name\\_country}}$$\\\\\n\n$$\\big( \\sigma_{\\texttt{c1.population\\_city  > 1000000}\\wedge \\texttt{c2..population\\_city  > 1000000} \\wedge \\texttt{c1.id}\\neq \\texttt{c2.id}\\wedge\n \\texttt{countrycode = c1.countrycode} \\wedge \\texttt{countrycode = c2.countrycode}}(\\\\\n\\texttt{world.country} \\times \\texttt{world.c1}\\times \\texttt{world.c2})\\big)$$\n\n```{.sql}\nSELECT DISTINCT name_country\nFROM country as c , city as v1 , city as v2\nWHERE c.countrycode = v1.countrycode  AND \n      c.countrycode = v2.countrycode AND \n      v1.population > 1000000 AND \n      v2.population > 1000000 AND \n      (NOT v1.id = v2.id) ;\n```\n\nIci `c1` (respectivement, `c2`) est utilisé comme abbréviation pour `city1` (respectivement, `city2`).\n\n\n:::\n:::\n\n\n\n7. Quelles sont les régions qui ne comportent qu'une seule forme de gouvernement ? (3 lignes)\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$$\\Pi_{\\texttt{region}}\\big( \\texttt{world.country})- \\Pi_{\\texttt{region}}$$\n     \n$$\\big( \\sigma_{\\texttt{c1.region = c2.region}\\wedge\\texttt{c1.countrycode<>c2.countrycode}\\wedge c1.governmentform<>c2.governmentform}(\\texttt{world.c1} \\bowtie \\texttt{world.c2}))$$\n\n```{.sql}\n(SELECT region \nFROM country)\nEXCEPT\n(SELECT c1.region \n FROM country as c1 , country as c2\nWHERE c1.region = c2.region AND \n      c1.countrycode <> C2.countrycode AND NOT \n      c1.governmentform = c2.governmentform ) ;\n```\n\nIci `c1` (respectivement, `c2`) est utilisé comme abbréviation pour `country1` (respectivement, `country2`).\n\n:::\n:::\n\n\n\n\n8. Quelles sont les régions où on ne trouve pas de monarchie ? (9 lignes)\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\nUne solution algébrique aurait la forme générale de la requête de la question 5. En revanche, nous n'avons pas présenté en cours d'implémentation pour l'opérateur de comparaison `LIKE` qui devrait être utilisé dans l'opérateur de sélection. Nous préférons donc en toute rigueur ne pas proposer ici de traduction algébrique.\n\n```{.sql}\n(SELECT region \nFROM country)\n\nEXCEPT\n\n(SELECT region \nFROM country\nWHERE governmentform LIKE '%Monarchy%') ;\n```\n\n:::\n:::\n\n\n\n",
    "supporting": [
      "td1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}