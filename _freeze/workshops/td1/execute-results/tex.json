{
  "hash": "cd25a82a0f80f29fae9b1afd25049847",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"TD 1: Algèbre relationnelle\"\nsubtitle: \"Logistique et Algèbre relationnelle\"\ndate: \"2024-09-20\"\n\nformat:\n  pdf:\n    code-annotations: below\n    keep-tex: false\n    code-fold: false\n    toc: false\n    output-file: td1.pdf\n    include-in-header:\n      - text: \"\\\\lhead{{\\\\sf  Base de données \\\\\\\\ TD 1}}\"\n  html:\n    embed-resources: true\n    code-fold: true\n    output-file: td1.html\nparams:\n    year: 2024 \n    curriculum: \"L3 MIASHS/Ingémath\"\n    university: \"Université Paris Cité\"\n    homepage: \"https://stephane-v-boucheron.fr/courses/bdd\"\n    moodle: \"https://moodle.u-paris.fr/course/view.php?id=2313\"\n\nengine: knitr\n---\n\n\n\n\n\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-warning}\n\n### Avec solutions\n\n::: \n\n:::\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n\n- **L3 MIASHS/Ingémath**\n- **[Université Paris Cité](https://www.u-paris.fr)**\n- Année 2024-2025\n- [Course Homepage](https://stephane-v-boucheron.fr/courses/bdd)\n- [Moodle](https://moodle.u-paris.fr/course/view.php?id=2313)\n\n::: \n\n::: {#second-column}\n![](../images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::\n\n:::\n\n\n# Récapitulatif\n\n\n## Schémas\n\nLes schémas sont une abstraction spécifique à PostgreSQL. Les schémas permettent de faire cohabiter sur une même base de données (ou catalogue dans le jargon PostgreSQL) plusieurs ensembles d'informations de nature différentes. On peut indiquer à `pgcli`, `psql` ou un autre client (`dbeaver` ou autre) quels schémas on veut utiliser *par défaut*. \n\nDans ce TP, nous allons nous concentrer sur le schéma `world` qui contient des informations concernant des villes et des pays/territoires du monde entier. Au cours de ce semestre, nous serons amenés à utiliser d'autres schémas : `pagila` qui contient des informations concernant des films, ...\n\nPour lister et modifier  les schémas de votre environnement de travail:\n\n```{.sql}\nbd_2023-24> SHOW search_path ;                  -- lister\nbd_2023-24> SET search_path TO world, public ;  -- modifier\nbd_2023-24> SHOW search_path ;       -- visualiser \n```\n\nLister les schémas du catalogue `bd_2023-24`.\n\n```{.sql}\n\\dn\n```\n\nPour lister les tables des schemas inscrits sur votre `search_path`.\n\n```{.sql}\nbd_2023-24> \\d\n+----------+---------------------+--------+----------+\n| Schema   | Name                | Type   | Owner    |\n|----------+---------------------+--------+----------|\n| world    | city                | table  | postgres |\n| world    | country             | table  | postgres |\n| world    | countrylanguage     | table  | postgres |\n+----------+---------------------+--------+----------+\n```\n\n\n[Vue d'ensemble du schéma `world`](../images/layout-world.png)\n\n\n## Suggestion\n\nSi vous travaillez avec `pgcli`/`psql`, utilisez en local votre éditeur préféré (emacs, vi, sublime text, visual studio code, ...), transférez votre script sql grâce à `scp`, et chargez le script dans votre session `psql/pgcli` à l'aide de `\\\\i`.    \n\n## Tables\n  \nPour voir la définition (c'est-à-dire les différentes colonnes) d'une table:\n\n```{.sql}\nbd_2023-24> \\d world.country\n\n+--------------------+---------------+-------------+\n| Column             | Type          | Modifiers   |\n|--------------------+---------------+-------------|\n| countrycode        | character(3)  |  not null   |\n| name_country       | text          |  not null   |\n| continent          | text          |  not null   |\n| region             | text          |  not null   |\n| surfacearea        | real          |  not null   |\n| indepyear          | smallint      |             |\n| population_country | integer       |  not null   |\n| lifeexpectancy     | real          |             |\n| gnp                | numeric(10,2) |             |\n| gnpold             | numeric(10,2) |             |\n| localname          | text          |  not null   |\n| governmentform     | text          |  not null   |\n| headofstate        | text          |             |\n| capital            | integer       |             |\n| code2              | character(2)  |  not null   |\n+--------------------+---------------+-------------+\n```\n\n## Explorer les possibilités de `psql` ou de `pgcli` \n\n```\nbd_2023-24> \\?\n```\n\nDans la deuxième partie du TP, on s'intéresse aux requêtes, c'est-à-dire, les moyens d'extraire une information pertinente d'une base de données.\n\n# Écriture d'une requête\n\nPour extraire des informations d'une base de données, on utilise l'algèbre relationnelle (pour la théorie) et le langage SQL (pour la pratique).\n\nL'*algèbre relationnelle* est un ensemble d'opération sur les tables. Chaque opération prend en argument une ou plusieurs tables et produit une nouvelle table. Nous commençons par introduire deux opérations importantes qui opèrent sur une table à la fois :\n\n- *Projection* : $\\pi_{\\texttt{liste de colonnes}}{R}$. Cette opération ne garde que les colonnes mentionnées de la table $R$. Par exemple $\\pi_{\\texttt{name,continent}}{\\texttt{world.country}}$ est la table avec deux colonnes `name, continent` et une ligne pour chaque ligne de la table `world.country`.\n- *Sélection* : $\\sigma_{\\texttt{condition}}{R}$. Cette opération ne garde que les lignes qui respectent la condition indiquée. Par exemple $\\sigma_{\\texttt{lifeexpectancy < 50}}\\texttt{world.country}$ renvoie la table contenant les pays ayant une espérance de vie de moins de 50 ans.\n\n\nCes deux opérations peuvent être écrites en SQL ainsi :\n\n```{.sql}\nSELECT colonne1, colonne2, ... \nFROM table \nWHERE condition;\n```\n\nCette opération affiche les colonnes de `table` indiquées après le `SELECT` qui respectent la `condition`. \n\nC'est la transcription de \n\n$${\\Pi}_{\\texttt{colonne1, colonne2}}\\left({\\Large \\sigma}_{\\texttt{condition}}\\left(\\texttt{table}\\right)\\right)$$\n\nPar exemple:\n\n```{.sql}\nSELECT name_country, lifeexpectancy\nFROM world.country\nWHERE lifeexpectancy < 50 and continent = 'Asia';\n```\n\naffichera le nom et l'espérance de vie des pays d'Asie ayant une espérance de vie inférieure à 50 ans. Remarquez l'utilisation des apostrophes simples pour délimiter les chaînes de caractères ('Asia').\n\n\n\n# Requêtes monotables\n\nEcrivez des requêtes en algèbre relationnelle et en SQL (dans `pgcli/psql, ...`) pour extraire les informations suivantes du schéma `world`:\n\n- Quelles sont les régions ? (25 lignes)\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$\\Pi_{\\texttt{region}} (\\texttt{world.country})$\n\n```{.sql}\nSELECT DISTINCT region\nFROM world.country ;\n```\n\n:::\n:::\n\n\n\n- Quelles sont les régions situées en Europe ? (6 lignes)\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$\\Pi_{\\texttt{region}} \\big( \\sigma_{\\texttt{continent = 'Europe'}}(\\texttt{world.country})\\big)$\n\n```{.sql}\nSELECT DISTINCT region\nFROM world.country\nWHERE continent = 'Europe' ;\n```\n\n:::\n:::\n\n\n\n- Quels sont les pays situés en Europe du sud ? (15 lignes)\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$\\Pi_{\\texttt{name\\_country}} \\big( {\\Large \\sigma}_{\\texttt{region = 'Southern Europe'}}(\\texttt{world.country})\\big)$\n\n```{.sql}\nSELECT name_country\nFROM world.country\nWHERE region = 'Southern Europe' ;\n```\n\n\n:::\n:::\n\n\n\n- Quelles sont les capitales des pays situés en Europe de l'Ouest ? (quel est le type de la colonne `capital` ?) (9 lignes)\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$$\\Pi_{\\texttt{capital}} \\big( {\\Large \\sigma}_{\\texttt{region = 'Western Europe'}}(\\texttt{world.country})\\big)$$\n\n```{.sql}\nSELECT capital\nFROM world.country\nWHERE region = 'Western Europe' ;\n```\n\n:::\n:::\n\n\n- A partir de la table `countrylanguage`, quels sont les langues qui sont officielles dans au moins un pays ? (102 lignes)\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$\\Pi_{\\texttt{language}} \\big( {\\Large \\sigma}_{\\texttt{isofficial}}(\\texttt{world.countrylanguage})\\big)$\n\n```{.sql}\nSELECT DISTINCT language \nFROM world.countrylanguage \nWHERE isofficial ;\n```\n\nLa variante de l'algèbre relationnelle vue en cours opérant sur les ensembles, `DISTINCT` est toujours implicitement implémenté par la requête algébrique. On peut noter qu'il existe un opérateur d'élimination des doublons dans les variantes multi-ensemblistes de l'algèbre relationnelle.\n\n:::\n:::\n\n\n- Quels sont les codes des pays où le français est langue officielle ? (18 lignes) Même question pour les langues de votre choix?\n  \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$\\Pi_{\\texttt{countrycode}} \\big( {\\Large \\sigma}_{ \\texttt{language = 'French'} \\wedge \\texttt{isofficial}}(\\texttt{world.countrylanguage})\\big)$\n\n```{.sql}\nSELECT countrycode\nFROM world.countrylanguage\nWHERE language = 'French' AND isofficial ;\n```\n\n:::\n:::\n\n\n\n- Quelle est la date d'indépendance de la France ?\n  \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$\\Pi_{\\texttt{indepyear}} \\big( {\\Large \\sigma}_{ \\texttt{name\\_country = 'French'}}(\\texttt{world.country})\\big)$\n\n```{.sql}\nSELECT indepyear\nFROM world.country\nWHERE name_country = 'France' ;\n```\n\n:::\n:::\n\n\n\n- Quelles sont les dates d'indépendance des pays d'Europe ? (46 lignes)\n  \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$\\Pi_{\\texttt{name\\_country, indepyear}} \\big( {\\Large \\sigma}_{ \\texttt{continent = 'Europe' }}(\\texttt{world.country})\\big)$\n\n```{.sql}\nSELECT name_country , indepyear\nFROM world.country\nWHERE continent = 'Europe' ;\n```\n\n:::\n:::\n\n\n\n- Quelles sont les villes françaises de plus de 200 000 habitants ? (10 lignes)\n  \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$\\Pi_{\\texttt{name, population}} \\big( {\\Large \\sigma}_{ \\texttt{countrycode = 'FRA' }\\wedge \\texttt{population > 200000}}(\\texttt{world.city})\\big)$\n\n```{.sql}\nSELECT name , population\nFROM world.city\nWHERE countrycode = 'FRA' AND population > 200000 ;\n```\n\n:::\n:::\n\n\n\n- Pour chaque pays européen, calculer la densité, le GNP par habitant,\net l'espérance de vie, ordonner par densité décroissante. (46 lignes)\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$${\\Large \\rho}_{\\texttt{population\\_country} / \\texttt{surfacearea} \\mapsto \\texttt{density}, \\texttt{gnp} / \\texttt{population\\_country} \\mapsto \\texttt{gnp\\_per\\_hab}}(\\\\\n\\Pi_{\\texttt{name\\_country, population\\_country / surfacearea}} \\big( {\\Large \\sigma}_{ \\texttt{continent = 'Europe' }}(\\texttt{world.country})\\big))$$\n\n```{.sql}\nSELECT name_country , population_country / surfacearea as density ,\n       gnp / population_country as gnp_per_hab , lifeexpectancy\nFROM country \nWHERE continent = 'Europe'\nORDER BY density DESC;\n```\n\nLa contrepartie algébrique de `ORDER BY` n'a pas été présentée dans la variante de l'algèbre relationnelle vue en cours, même si elle est évidemment implémentée (via des opérateurs de tri) dans les variantes utilisées en pratique par les SGBDs.\n\n\n:::\n:::\n\n\n\n- Quels sont les pays où l'espérance de vie n'est pas inférieure à 77 ans et le pnb par habitant n'est pas supérieur à \\(0.010\\) ? (10 lignes)\n    \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$$\\Pi_{\\texttt{name\\_country}} \\big( {\\Large \\sigma}_{ \\neg \\texttt{lifeexpectancy < 77}\\wedge \\neg \\texttt{(gnp / population\\_country) > 0.01}}(\\texttt{world.country})\\big)$$\nou, de manière équivalente \\\\\n$$\\Pi_{\\texttt{name\\_country}} \\big( \\sigma_{\\texttt{lifeexpectancy >= 77}\\wedge \\texttt{(gnp / population\\_country) >= 0.01}}(\\texttt{world.country})\\big)$$\n\n```{.sql}\nSELECT name_country \nFROM world.country\nWHERE NOT (lifeexpectancy < 77) AND \n      NOT (gnp / population_country) > 0.01 ;\n```\n\n:::\n:::\n\n\n\n- Quels sont les pays tels que la condition (espérance de vie supérieure\nou égale à 77 ans ou PNB par habitant inférieur à \\(0.01\\)) n'est pas\nvérifée ? (16 lignes)\n    \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$$\\Pi_{\\texttt{name\\_country}} \\big( {\\Large \\sigma}_{\\neg({\\texttt{lifeexpectancy >= 77}\\vee \\texttt{(gnp / population\\_country) < 0.01})}}(\\texttt{world.country})\\big)$$\nou, de manière équivalente             \n$$\\Pi_{\\texttt{name\\_country}} \\big( {\\Large \\sigma}_{\\texttt{lifeexpectancy < 77}\\wedge \\texttt{(gnp / population\\_country) >= 0.01}}(\\texttt{world.country})\\big)$$\n\n\n```{.sql}\nSELECT name_country\nFROM world.country\nWHERE NOT (lifeexpectancy >= 77 OR (gnp / population_country) < 0.01) ;\n```\n\n:::\n:::\n\n\n\n- Quels sont les pays où une langue est officielle sans être parlée par\nau moins la moitié de la population ? (92 lignes)\n    \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$$\\Pi_{\\texttt{countrycode}} \\big( {\\Large \\sigma}_{\\texttt{isofficial}\\wedge\\texttt{percentage < 50}}(\\texttt{world.countrylanguage})\\big)$$    \n\n```{.sql}\nSELECT DISTINCT countrycode\nFROM world.countrylanguage\nWHERE isofficial AND percentage < 50 ;\n```\n\n:::\n:::\n\n\n\n- Quels sont les pays qui ont au moins une langue officielle ? (190 lignes)\n    \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$$\\Pi_{\\texttt{countrycode}} \\big( {\\Large \\sigma}_{\\texttt{isofficial}}(\\texttt{world.countrylanguage})\\big)$$   \n\n```{.sql}\nSELECT DISTINCT countrycode \nFROM world.countrylanguage \nWHERE isofficial ;\n```\n\n:::\n:::\n\n\n\n- Quels sont les noms des pays qui comptent plus de 100 000 000\nd'habitants ? (10 lignes)\n    \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$$\\Pi_{\\texttt{name\\_country}} \\big( {\\Large \\sigma}_{\\texttt{population\\_country > 100000000}}(\\texttt{world.country})\\big)$$ \n\n```{.sql}\nSELECT name_country \nFROM world.country\nWHERE population_country > 100000000 ;\n```\n\n:::\n:::\n\n\n\n\n\n\n# Requêtes multi-tables\n\nOn peut aussi combiner plusieurs tables. Pour ce TP, nous allons seulement présenter le produit cartésien de deux tables: $T \\times S$ est la table dont les colonnes sont les colonnes de $S$ et les colonnes de $T$. Ces lignes contient tous les couples $(l_1,l_2)$ où $l_1$ est une ligne de $T$ et $l_2$ est une ligne de $S$. En SQL, on écrira:\n\n```{.sql}\nSELECT col1,col2 \nFROM table1,table2 \nWHERE condition;\n```\n\nPar exemple,\n\n```{.sql}\nSELECT language\nFROM world.country as c, world.countrylanguage as l\nWHERE c.countrycode = l.countrycode and c.continent = 'Europe';\n```\n\naffichera les langues parlées en Europe. Remarquez l'utilisation des `as` pour donner de nouveaux noms aux tables et l'utilisation de `c.countrycode` pour lever l'ambiguité sur des noms de colonnes qui seraient éventuellement les mêmes.\n\nAvec ça, écrivez des requêtes pour les questions suivantes:\n\n- Quels sont les noms des capitales Sud-Américaines ? (14 lignes)\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$$\\Pi_{\\texttt{name}} \\big( \\sigma_{\\texttt{capital = id}\\wedge \\texttt{region = 'South America'}}(\\rho_{\\texttt{countrycode} \\mapsto {city\\_countrycode}}(\\texttt{world.city}) \\times \\texttt{world.country})\\big)$$\n\n```{.sql}\nSELECT name\nFROM world.country , world.city\nWHERE capital = id AND region = 'South America' ;\n```\n\nAttention ! En toute rigueur le produit cartésien ne s'applique que sur des relations de schémas disjoints, d'où le renommage utilisé dans la requête algébrique ci-dessus. En pratique on utilisera tout de même :\n\n$$\\Pi_{\\texttt{name}} \\big( {\\Large \\sigma}_{\\texttt{capital = id}\\wedge \\texttt{region = 'South America'}}(\\texttt{world.country}\\times \\texttt{world.city})\\big)$$\n\ncomme abréviation pour :\n\n$$\\Pi_{\\texttt{name}} \\big( \\sigma_{\\texttt{capital = id}\\wedge \\texttt{region = 'South America'}}(\\rho_{\\texttt{countrycode} \\mapsto \\texttt{country.countrycode}}(\\texttt{world.country}) \\times \\rho_{\\texttt{countrycode} \\mapsto \\texttt{city.countrycode}}(\\texttt{world.city}))\\big)$$\n\nDonc, dès que l'on opère un produit cartésien sur deux tables, on supposera implicitement que les attributs en commun sont renommés en les préfixant par le nom de la relation à laquelle ils appartiennent. Si les deux tables sont deux copies d'une seule et même table (cf plus loin question 4, on parle alors d'auto-jointure) on fera suivre le nom de la première copie par 1 et le nom de la seconde copie par 2 et on renommera tous les attributs de chacune des copies en les préfixant par ce nouveau nom.\n\n\n\n:::\n:::\n\n\n\n- Quels sont les noms des pays où le français est langue\nofficielle ? (18 lignes)\n  \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$$\\Pi_{\\texttt{name\\_country}} \\big( \\sigma_{\\texttt{isofficial}\\wedge \\texttt{language = 'French'}}(\\texttt{world.country} \\bowtie \\texttt{world.countrylanguage})\\big)$$\n\n```{.sql}\nSELECT name_country\nFROM world.country NATURAL JOIN world.countrylanguage\nWHERE isofficial AND \n      language = 'French' ;\n```\n\nDans la variante algébrique, pour utiliser la jointure naturelle on a bien vérifié au préalable que le seul attribut en commun sur les deux relations était bien `countrycode`. En effet, si au contraire, certains attributs s'étaient trouvé avoir le même nom de manière fortuite, il aurait fallu les renommer au préalable dans l'une des deux relations. Une autre solution aurait combiné sélection et produit cartésien afin d'émuler la requête SQL ci-dessus, mais il aurait alors fallu en toute rigueur renommer au préalable l'attribut en commun `countrycode` dans l'une des deux tables en utilisant l'opérateur $\\rho$, le produit cartésien ne pouvant être réalisé que sur des relations de schémas disjoints (c.f., question précédente). \n\n\n:::\n:::\n\n\n\n- Quelles sont les pays où l'espagnol est langue officielle et la forme\nde gouvernement est `Federal Republic` ? (3 lignes)\n    \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$$\\Pi_{\\texttt{name\\_country}} \\big( \\sigma_{\\texttt{ttisofficial}\\wedge \\texttt{language = 'Spanish'}\\wedge \\texttt{governmentform = 'Federal Republic'}}(\\texttt{world.country} \\bowtie \\texttt{world.countrylanguage})\\big)$$\n\n```{.sql}\nSELECT name_country\nFROM country NATURAL JOIN countrylanguage\nWHERE isofficial AND \n      language = 'Spanish' AND \n      governmentform = 'Federal Republic' ;\n```\n\n:::\n:::\n\n\n\n-  Quels sont les pays qui ont au moins deux langues officielles ? (38 lignes)\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$$\\Pi_{\\texttt{name\\_country}}$$\n      \n$$\\big( \\sigma_{\\texttt{c1.isofficial}\\wedge \\texttt{c2.isofficial} \\wedge \\texttt{c1.language}\\neq \\texttt{c2.language}\\wedge\n       \\texttt{countrycode = c1.countrycode} \\wedge \\texttt{countrycode = c2.countrycode}}(\\\\\n      \\texttt{world.country} \\times \\texttt{world.c1}\\times \\texttt{world.c2})\\big)$$\n\n```{.sql}\nSELECT DISTINCT name_country\nFROM country AS c , countrylanguage AS l1 , countrylanguage AS l2\nWHERE c.countrycode = l1.countrycode AND \n      c.countrycode = l2.countrycode AND \n      l1.isofficial AND \n      l2.isofficial AND \n      NOT (l1.language = l2.language) ;\n```\n\nAttention à bien noter que l'on a utilisé ici dans la requête\nalgébrique l'abréviation de renommage mentionné à la question 1. Pour\nsimplifier l'écriture de la requête on a également abrévié\n`countrylanguage` en `ci` pour $i \\in \\{1,2\\}$.\n\nOn dispose aussi de la syntaxe `JOIN … USING (a₁,…,aₖ)` pour\nfaire des jointures qui ne considèrent que les attributs communs\n`a₁` à `aₖ`.\n\n```{.sql}\nSELECT DISTINCT name_country\nFROM country NATURAL JOIN\n     countrylanguage AS l1 JOIN \n     countrylanguage AS l2 USING (countrycode)\nWHERE l1.isofficial AND l2.isofficial\nAND l1.language <> l2.language ;\n```\n\n\n:::\n:::\n\n\n\n- Quels sont les pays qui n'ont pas de langue officielle ? (49 lignes)\n    \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$$\\Pi_{\\texttt{name\\_country}}\\big(\n      \\texttt{world.country})-\n     \\Pi_{\\texttt{name\\_country}}\\big( \\sigma_{\\texttt{isofficial}}(\\texttt{world.country} \\bowtie \\texttt{world.countrylanguage}))$$\n\n```{.sql}\n(SELECT name_country \n FROM world.country\n)\n\nEXCEPT\n\n(SELECT name_country \n FROM world.country NATURAL JOIN world.countrylanguage \n WHERE isofficial\n);\n```\n\n:::\n:::\n\n\n\n- Quels sont les pays qui comportent au moins deux villes de plus de\n  1 000 000 habitants ? (32 lignes)\n    \n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$$\\Pi_{\\texttt{name\\_country}}$$\\\\\n\n$$\\big( \\sigma_{\\texttt{c1.population\\_city  > 1000000}\\wedge \\texttt{c2..population\\_city  > 1000000} \\wedge \\texttt{c1.id}\\neq \\texttt{c2.id}\\wedge\n \\texttt{countrycode = c1.countrycode} \\wedge \\texttt{countrycode = c2.countrycode}}(\\\\\n\\texttt{world.country} \\times \\texttt{world.c1}\\times \\texttt{world.c2})\\big)$$\n\n```{.sql}\nSELECT DISTINCT name_country\nFROM country as c , city as v1 , city as v2\nWHERE c.countrycode = v1.countrycode  AND \n      c.countrycode = v2.countrycode AND \n      v1.population_city > 1000000 AND \n      v2.population_city > 1000000 AND \n      (NOT v1.id = v2.id) ;\n```\n\nIci `c1` (respectivement, `c2`) est utilisé comme abbréviation pour `city1` (respectivement, `city2`).\n\n\n:::\n:::\n\n\n\n- Quelles sont les régions qui ne comportent qu'une seule forme de gouvernement ? (3 lignes)\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n$$\\Pi_{\\texttt{region}}\\big( \\texttt{world.country})- \\Pi_{\\texttt{region}}$$\n     \n$$\\big( \\sigma_{\\texttt{c1.region = c2.region}\\wedge\\texttt{c1.countrycode<>c2.countrycode}\\wedge c1.governmentform<>c2.governmentform}(\\texttt{world.c1} \\bowtie \\texttt{world.c2}))$$\n\n```{.sql}\n(SELECT region \nFROM country)\nEXCEPT\n(SELECT c1.region \n FROM country as c1 , country as c2\nWHERE c1.region = c2.region AND \n      c1.countrycode <> C2.countrycode AND NOT \n      c1.governmentform = c2.governmentform ) ;\n```\n\nIci `c1` (respectivement, `c2`) est utilisé comme abbréviation pour `country1` (respectivement, `country2`).\n\n:::\n:::\n\n\n\n\n- Quelles sont les régions où on ne trouve pas de monarchie ? (9 lignes)\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\nUne solution algébrique aurait la forme générale de la requête de la question 5. En revanche, nous n'avons pas présenté en cours d'implémentation pour l'opérateur de comparaison `LIKE` qui devrait être utilisé dans l'opérateur de sélection. Nous préférons donc en toute rigueur ne pas proposer ici de traduction algébrique.\n\n```{.sql}\n(SELECT region \nFROM country)\n\nEXCEPT\n\n(SELECT region \nFROM country\nWHERE governmentform LIKE '%Monarchy%') ;\n```\n\n:::\n:::\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}