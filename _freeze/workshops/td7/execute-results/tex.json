{
  "hash": "917cf6c29fc4f6d3b71fadc2d6b50bd2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"TD 7 : Contraintes (suite)\"\nsubtitle: \"Définition de données et Contraintes\"\ncategories: [Contraintes, Définition de Données, Référemces, Clés, Exclusion, pagila, nycflights]\ndate: \"2024-11-08\"\n\n\nformat:\n  pdf:\n    code-annotations: below\n    keep-tex: false\n    code-fold: false\n    toc: false\n    output-file: td7.pdf\n    include-in-header:\n      - text: \"\\\\lhead{{\\\\sf  Base de données \\\\\\\\ TD 7: contraintes }}\"\n  html:\n    embed-resources: true\n    code-fold: true\n    output-file: td7.html\nparams:\n    year: 2024 \n    curriculum: \"L3 MIASHS/Ingémath\"\n    university: \"Université Paris Cité\"\n    homepage: \"https://s-v-b.github.io/MA15Y030/\"\n    moodle: \"https://moodle.u-paris.fr/course/view.php?id=2313\"\n\nengine: knitr\n---\n\n\n\n\n\n\n\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-warning}\n\n### Avec solutions\n\n:::\n\n:::\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n\n- **L3 MIASHS/Ingémath**\n- **[Université Paris Cité](https://www.u-paris.fr)**\n- Année 2024-2025\n- [Course Homepage](https://s-v-b.github.io/MA15Y030/)  \n- [Moodle](https://moodle.u-paris.fr/course/view.php?id=2313)\n\n::: \n\n::: {#second-column}\n![](../images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::\n\n:::\n\n::: {.callout-important title=\"Ojectifs\"}\n\nCette séance est consacrée à l'enrichissement des schémas [`pagila`](/schemas/schema-pagila.qmd)\net [`nycflights`](/schemas/schema-nycflights.qmd). \n\nL'objectif est d'ajouter des contraintes aux schémas, en particulier, des contraintes d'exclusion.\n\nCette séance est l'occasion de se familiariser avec les types `timestamp` et `tsrange` et avec les opérateurs de recouvrement. \n\n:::\n\n# Contraintes SQL (suite)\n\n## [Schéma `pagila`](/schemas/schema-pagila.qmd)\n\n\n\n::: {.callout-note}\n\n### Question\n\nImposer la contrainte suivante : un client ne peut emprunter plusieurs DVD simultanément.\n\n:::\n\n::: {.callout-tip}\n\nÉcrire d'abord une requête correspondant à la contrainte. \n\nLa requête est facile à écrire si on est prêt à utiliser le type `tsrange`, l'opérateur de recouvrement `&&` (`overlap`).\n\n[Postgresql documentation on range types](https://www.postgresql.org/docs/current/rangetypes.html)\n\nDans l'instance du schéma `pagila` disponible sur le serveur `etu-pgsql`, la contrainte est-elle vérifiée ?\n\n::: \n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nselect \n  r1.customer_id, \n  r1.inventory_id,\n  r1.rental_date, \n  r1.return_date, \n  r2.inventory_id,\n  r2.rental_date, \n  r2.return_date \nfrom \n  rental r1 \njoin \n  rental r2 \non (r1.customer_id=r2.customer_id AND r1.rental_id<>r2.rental_id)  \nwhere \n  tsrange(r1.rental_date, r1.return_date, '[)') && \n  tsrange(r2.rental_date, r2.return_date, '[)') ;\n```\n\n{{< fa skull-crossbones >}} La contrainte n'est pas du tout satisfaite par l'instance de `pagila`\n\n\n```{.sql}\nALTER TABLE \n  pagila.rental \nADD CONSTRAINT \n  xcl_simul_rental\nEXCLUDE USING gist (\n  customer_id with =,\n  rental_id with <>,\n  tsrange(rental_date, return_date) with &&\n) ;\n```\n\n{{< fa hand-point-right >}} Sur l'instance disponible de `pagila`, \ncette contrainte ne peut pas être surimposée.\n\n```{.sql}\nERROR:  could not create exclusion constraint \"xcl_simul_rental\"\nDETAIL:  Key (customer_id, rental_id, tsrange(rental_date, return_date))=(408, 3, [\"2005-05-24 23:03:39\",\"2005-06-01 22:12:39\")) conflicts with key (customer_id, rental_id, tsrange(rental_date, return_date))=(408, 59, [\"2005-05-25 08:56:42\",\"2005-06-01 09:52:42\")).\n```\n\n::: \n\n:::\n\n::: {.callout-note}\n\n### Question\n\nImposer la contrainte : un  film est identifié par son titre, son année de sortie et sa langue originale. \n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\nLa requête correspondante est\n\n```{.sql}\nSELECT \n  COUNT(*)\nFROM \n  pagila.film AS f1 \nJOIN \n  pagila.film AS f2\nON (\n    f1.title = f2.title AND\n    f1.release_year = f2.release_year AND \n    f1.original_language_id = f2.original_language_id AND\n    f1.film_id < f2.film_id)\n```\n\nIl s'agit d'une contrainte d'unicité. Elle est satisfaite dans l'instance de `pagila`\n\n```{.sql}\nALTER TABLE pagila.film\nADD CONSTRAINT uq_film_title_release_year_original_language_id \nUNIQUE (title, release_year, original_language_id) ;\n```\n\nLa description du schéma de `pagila.film` (`\\d pagila.film`) nous renvoie alors :\n\n```{.sql}\n...\nIndexes:\n    \"film_pkey\" PRIMARY KEY, btree (film_id)\n    \"film_fulltext_idx\" gist (fulltext)\n    \"idx_fk_language_id\" btree (language_id)\n    \"idx_fk_original_language_id\" btree (original_language_id)\n    \"idx_title\" btree (title)\n    \"uq_film_title_release_year_original_language_id\" UNIQUE CONSTRAINT, btree (title, release_year, original_language_id)\n...\n```\n::: \n:::\n\n\n::: {.callout-note}\n\n### Question\n\nImposer la contrainte : le prix de location doit être croissant en fonction de la durée du film\n\n:::\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT\n  COUNT(*)\nFROM\n  pagila.film AS f1 \nJOIN \n  pagila.film AS f2\nON (\n  f1.rental_rate < f2.rental_rate AND\n  f1.length > f2.length\n) ;\n```\n\n{{< fa skull-crossbones >}} La contrainte n'est pas satisfaite dans l'instance courante de `pagila`. \n\nLa contrainte devrait pouvoir être formulée comme une contrainte d'exclusion.\n\n```{.sql}\nALTER TABLE \n  pagila.film \nADD CONSTRAINT \n  xcl_anomalous_rental_rate\nEXCLUDE USING gist (\n  \"length\" with <,\n  rental_rate with >\n) ;\n```\n\nmais :\n\n```{.sql}\nERROR:  operator <(smallint,smallint) is not commutative\nDETAIL:  Only commutative operators can be used in exclusion constraints.\n```\n\nEst-ce que l'impossiblité d'utiliser un opérateur non-commutatif est de principe ou technique ? \n\n{{< fa hand-point-right >}} On peut utiliser un contournement laborieux en utilisant une contrainte de ligne (`CHECK`) qui va simuler la contrainte de table (voir [td6](/solutions/td6.qmd)).\n\n::: \n \n:::\n\n\n::: {.callout-note}\n\n### Question\n\nImposer la contrainte : un même DVD ne peut pas être loué simultanément \nà deux clients différents.\n\n:::\n\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nALTER TABLE \n  pagila.rental \nADD CONSTRAINT \n  xcl_simul_rental_inventory\nEXCLUDE USING gist (\n  inventory_id with =,\n  rental_id with <>,\n  tsrange(rental_date, return_date) with &&\n) ;\n```\n\nL'examen de la deéfinition de la table `rental` nous révèle maintenant :\n\n```{.sql}\nIndexes:\n    \"rental_pkey\" PRIMARY KEY, btree (rental_id)\n    \"idx_fk_inventory_id\" btree (inventory_id)\n    \"idx_unq_rental_rental_date_inventory_id_customer_id\" UNIQUE, btree (rental_date, inventory_id, customer_id)\n    \"xcl_simul_rental_inventory\" EXCLUDE USING gist (inventory_id WITH =, rental_id WITH <>, tsrange(rental_date, return_da\nte) WITH &&)\nForeign-key constraints:\n    \"rental_customer_id_fkey\" FOREIGN KEY (customer_id) REFERENCES customer(customer_id) ON UPDATE CASCADE ON DELETE RESTRICT\n    \"rental_inventory_id_fkey\" FOREIGN KEY (inventory_id) REFERENCES inventory(inventory_id) ON UPDATE CASCADE ON DELETE RESTRICT\n    \"rental_staff_id_fkey\" FOREIGN KEY (staff_id) REFERENCES staff(staff_id) ON UPDATE CASCADE ON DELETE RESTRICT\n```\n\n::: \n \n:::\n\n## [Schéma `nycflights`](/schemas/schema-nycflights.qmd)\n\n::: {.callout-note}\n\n### Question\n\nDans `flights`  et `weather` imposer les contraintes \n```\nyear, month, day, hour ⟶ time_hour\ntime_hour  ⟶  year, month, day, hour\n```\n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n\n```{.sql}\nALTER TABLE nycflights_sandbox.weather \nADD CONSTRAINT weather_fd_1 \nEXCLUDE USING gist (\n  year WITH =,\n  month WITH =, \n  day WITH =, \n  hour WITH =,\n  time_hour WITH <>\n) ;\n```\n\n\n```{.sql}\nALTER TABLE nycflights_sandbox.flights \nADD CONSTRAINT flights_fd_1 \nEXCLUDE USING gist (\n  year WITH =,\n  month WITH =, \n  day WITH =, \n  hour WITH =,\n  time_hour WITH <>\n) ;\n```\n\n\n{{< fa hand-point-right >}} Nous sommes dans une situation où une colonne peut être calculée à partir d'autres colonnes. PostgreSQL propose des [genrated columns](https://www.postgresql.org/docs/current/ddl-generated-columns.html) pour traîter ce genre de situations. \n\n\n> Une colonne générée est une colonne spéciale qui est toujours calculée à partir d'autres colonnes. Elle est donc pour les colonnes ce qu'une vue est pour les tables. Il existe deux types de colonnes générées : les colonnes stockées et les colonnes virtuelles. Une colonne générée stockée est calculée lorsqu'elle est écrite (insérée ou mise à jour) et occupe l'espace de stockage comme s'il s'agissait d'une colonne normale. Une colonne générée virtuelle n'occupe pas d'espace de stockage et est calculée lorsqu'elle est lue. Ainsi, une colonne générée virtuelle est similaire à une vue et une colonne générée stockée est similaire à une vue matérialisée (sauf qu'elle est toujours mise à jour automatiquement). PostgreSQL n'implémente actuellement que les colonnes générées stockées.\n\n::: \n\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nDans `flights` imposer la contrainte : un aéronef ne peut pas effectuer deux missions simultanément.\n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nALTER TABLE nycflights_sandbox.flights \nADD COLUMN t1 timestamp GENERATED ALWAYS AS (\n  make_timestamp(\n    year::int, \n    month::int, \n    day::int, \n    hour::int, \n    minute::int, \n    0.0::float)\n) STORED ;\n```\n\n```{.sql}\nCREATE FUNCTION nycflights_sandbox.foo (\n  p_air_time float\n)\nRETURNS interval immutable \nLANGUAGE SQL AS \n$$\n  SELECT \n    CASE WHEN p_air_time IS NULL THEN '0 minutes'::interval\n       ELSE (p_air_time::text || ' minutes')::interval \n  END \n$$ ;\n```\n\n```{.sql}\nALTER TABLE nycflights_sandbox.flights \nADD COLUMN dtt interval GENERATED ALWAYS AS (\n  CASE WHEN air_time IS NULL THEN '0 minutes'::interval\n       ELSE (air_time::text || ' minutes')::interval \n  END \n) STORED ;\n```\n\n```{.sql}\nCREATE VIEW nycflights.flightspp AS (\n  SELECT \n    f.*,\n    make_timestamp(\n      year::int, \n      month::int, \n      day::int, \n      hour::int, \n      minute::int, \n      0.0::float)  as t1,\n    nycflights_sandbox.foo(air_time) as dt, \n    tsrange( make_timestamp(\n      year::int, \n      month::int, \n      day::int, \n      hour::int, \n      minute::int, \n      0.0::float),\n       make_timestamp(\n      year::int, \n      month::int, \n      day::int, \n      hour::int, \n      minute::int, \n      0.0::float) + nycflights_sandbox.foo(air_time,\n      '[]')) as in_ze_air_time\n  FROM nycflights.flights f\n) ;\n```\n\n```{.sql}\nCREATE VIEW nycflights.flightspp AS (\n  SELECT \n    f.*,\n    make_timestamp(\n      year::int, \n      month::int, \n      day::int, \n      hour::int, \n      minute::int, \n      0.0::float)  as t1,\n    nycflights_sandbox.foo(air_time) as dt, \n    tsrange( \n      make_timestamp(\n        year::int, \n        month::int, \n        day::int, \n        hour::int, \n        minute::int, \n        0.0::float),\n      make_timestamp(\n        year::int, \n        month::int, \n        day::int, \n        hour::int, \n        minute::int, \n        0.0::float) + \n      nycflights_sandbox.foo(air_time), '[]'\n      ) as in_ze_air_time\n  FROM nycflights.flights f\n) ;\n```\n\n```{.sql}\nALTER TABLE nycflights_sandbox.flights \nADD CONSTRAINT xcl_simul_flights \nEXCLUDE USING gist (\n  tailnum with =, \n  tsrange(t1, t1+nycflights_sandbox.foo(air_time), '[]') with &&\n);\n```\n\n```{.sql}\nwith r as (\n  select \n    f.*, \n    make_timestamp(f.year::int, f.month::int, f.day::int, f.hour::int, f.minute::int, 0.0::float) as t1, \n    (f.air_time::text || ' minutes')::interval as dt  \n  from \n    nycflights.flights f \n)\n\nselect \n  r.t1, \n  r.dt, \n  tsrange(r.t1, r.t1+r.dt, '[]'), \n  r.* \nfrom \n  r ;\n\n```\n```{.sql}\nALTER TABLE nycflights_sandbox.flights \nADD CONSTRAINT flights_exclusivity\nEXCLUDE USING gist (\n  tailnum WITH =,\n  month WITH =, \n  day WITH =, \n  hour WITH =,\n  time_hour WITH <>\n) ;\n```\n\n:::\n \n:::\n\n::: {.callout-note}\n\n### Question\n\nDans `flights` imposer la contrainte : un aéronef ne peut pas être exploité par deux compagnies différentes à la même date.\n\n:::\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-tip title=\"Solution\"}\n\n::: \n \n:::\n\n::: {.callout-note}\n\n### Question\n\nDans `planes`, imposer les contraintes `model ⟶ manufacturer` et \n`model ⟶ type`\n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n\n \n:::\n\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\ncreate function nycflights.lldistance(\n  p_lat_1 float8, \n  p_lon_1 float8, \n  p_lat_2 float8, \n  p_lon_2 float8\n) returns float8\nlanguage SQL AS \n$$\nselect\n  earth_distance(\n    ll_to_earth(p_lat_1, p_lon_1),\n    ll_to_earth(p_lat_2, p_lon_2)\n  ) ;\n$$ ;\n```\n\n```{.sql}\nselect\n  A_1.faa, A_2.faa, nycflights.lldistance(A_1.lat, A_1.lon, A_2.lat, A_2.lon) as dista\nfrom \n  (select \n    *\n  from \n    nycflights.airports \n  where \n    faa in ('LGA', 'JFK', 'EWR')\n  ) A_1\ncross join \n  (select \n    *\n  from \n    nycflights.airports \n  where \n    not faa in ('LGA', 'JFK', 'EWR')\n  ) A_2 ;\n```\n\n\n```{.sql}\nselect \n  a_1.faa, a_2.faa, \n  (point(a_1.lon, a_1.lat) <@> point(a_2.lon, a_2.lat))/1.609   \nFROM \n  nycflights.airports a_1 \ncross join \n  nycflights.airports a_2 \nwhere \n  a_1.faa in ('EWR', 'LGA', 'JFK')  AND \n  a_2.faa in ('LAX', 'ATL') \nORDER BY a_2.faa, a_1.faa ;\n```\n::: \n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}