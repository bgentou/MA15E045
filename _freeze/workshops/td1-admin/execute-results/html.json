{
  "hash": "b52f5d092f1025b74aac99a060128ce3",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat:\n  pdf:\n    code-annotations: below\n    keep-tex: false\n    code-fold: false\n    toc: false\n    output-file: td-admin.pdf\n    include-in-header:\n      - text: \"\\\\lhead{{\\\\sf  Base de données \\\\\\\\ TD Admin}}\"\n  html:\n    embed-resources: true\n    code-fold: true\n    output-file: td-admin.html\nparams:\n    year: 2024 \n    curriculum: \"L3 MIASHS/Ingémath\"\n    university: \"Université Paris Cité\"\n    homepage: \"https://stephane-v-boucheron.fr/courses/bdd\"\n    moodle: \"https://moodle.u-paris.fr/course/view.php?id=2313\"\n---\n\n\n\n\n\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n\n- **L3 MIASHS/Ingémath**\n- **[Université Paris Cité](https://www.u-paris.fr)**\n- Année 2024-2025\n- [Course Homepage](https://stephane-v-boucheron.fr/courses/bdd)  \n- [Moodle](https://moodle.u-paris.fr/course/view.php?id=2313)\n\n::: \n\n::: {#second-column}\n![](../images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::\n\n:::\n\n\n## Administration sous Postgres\n\nDes outils d'administration importants d'une base de données postgres se trouvent dans deux schémas appelés :\n\n\n- `information_schema`\n- `pg_catalog`\n\n\n\nCes deux schémas et les tables qu'ils contiennent permettent de retrouver toutes les informations concernant les schémas, tables, utilisateurs, fonctions, etc présentes dans la base de données.\n\nPour faciliter l'administration de la base et obtenir un certain nombre d'informations basiques,  des commandes sont définies dans postgres. On peut en avoir la liste par l'instruction `\\?` (vous connaissez déjà `\\d`). Ces commandes sont, en fait, des raccourcis (des macros) en lieu et place de requêtes SQL plus ou moins complexes portant sur les objets des schémas `information_schema` et `pg_catalog`.\n\n\nLes questions ci-dessous permettent de faire connaissance avec les schémas d'administration à travers quelques requêtes à générer.\n\n\n\n\n- Dans `information_schema` la table `tables` contient le nom (et bien plus) des tables de la base. Examinez la structure de la table `tables` par l'instruction\n`\\d information_schema.tables` (il faut au préalable fixer le `search_path` pour y inclure `information_schema`).\n\nLister juste les noms de toutes les tables.\n\n::: {.content-visible when-profile=\"solution\"}\n\n```{.sql}\nselect table_name \nfrom information_schema.tables\n```\n\n:::\n\n\n\n- En utilisant seulement la table `tables` de `information_schema`, lister les noms des tables du schema `world`  puis du schéma `information_schema`\n\n::: {.content-visible when-profile=\"solution\"}\n\n```{.sql}\nselect table_name \nfrom information_schema.tables\nwhere table_schema='world';\n\nselect table_name \nfrom information_schema.tables\nwhere table_schema='information_schema'\n```\n\n:::\n\n\n- D'après la requête précédente, une des tables du schéma `information_schema` s'appelle `schemata`.\n\nExaminer cette table et en déduire une liste de tous les schémas de la base\n\n::: {.content-visible when-profile=\"solution\"}\n\n\n```{.sql}\nselect schema_name \nfrom information_schema.schemata\n```\n\n\n:::\n\n\n- Une des tables du schéma `information_schema` s'appelle `columns`. Essayez de comprendre la nature des informations présentes dans cette table.\nÉcrire une requête qui renvoie les mêmes informations que l'instruction `\\d world.country`. Améliorer votre requête pour qu'elle affiche exactement la même chose que  `\\d world.country`.\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n```{.sql}\n\nselect column_name as Column, data_type as Type, is_nullable as Modifiers\nfrom information_schema.columns\nwhere table_name='country' and table_schema='world'\n\n```\n\nAlternativement\n\n```{.sql}\nselect column_name as Column, data_type as Type, (CASE\n WHEN is_nullable='NO'\n THEN 'not null'\n ELSE NULL\n END) as Modifiers\n\tfrom information_schema.columns\n\twhere table_name='country' and table_schema='world'\n```\n\n:::\n\n\n\n- Listez les noms de tables qui apparaissent dans au moins deux schémas. On donnera aussi les (deux) schémas concernés dans le résultat.\n\n::: {.content-visible when-profile=\"solution\"}\n\n```{.sql}\nselect t.table_name, q.table_schema, t.table_schema\nfrom information_schema.tables t, information_schema.tables q\nwhere t.table_schema<>q.table_schema and t.table_name=q.table_name;\n```\n\n:::\n\n\n- Listez les noms de colonnes (attributs) qui apparaissent dans au moins deux tables du même schéma. On donnera aussi le nom des tables et du schéma dans le résultat (on pourra exclure `information_schema` et `pg_catalog`).\n\n::: {.content-visible when-profile=\"solution\"}\n\n```{.sql}\nselect t1.column_name as Column, t1.table_name as table1,\nt2.table_name as table2, t1.table_schema as schema\nfrom information_schema.columns t1, information_schema.columns t2\nwhere\nt1.table_name<>t2.table_name and t1.table_schema=t2.table_schema and\nt1.column_name=t2.column_name and t1.table_schema<>'pg_catalog' and\nt1.table_schema<>'information_schema';\n```\n\n:::\n\n\n- Listez les définitions de toutes les vues que vous avez écrites. Listez celles qui commencent pas 'q'.\n\n::: {.content-visible when-profile=\"solution\"}\n\n\t```{.sql}\nselect schemaname, definition from pg_views\nwhere schemaname=current_USER;\n\nselect schemaname,  definition from pg_views\nwhere schemaname=current_USER and viewname like 'q%';\n\t```\n\n:::\n\n\n\n\n\n\n- La vue `pg_roles` contient les identifiants des différents rôles. Trouvez celui du rôle `isifar2022`.\n\n::: {.content-visible when-profile=\"solution\"}\n\n```{.sql}\nselect rolname,oid  from pg_roles where rolname='isifar2022'\n```\n\n:::\n\n\n\n- À l'aide de la réponse à la question précédente, listez les noms des schémas des utilisateurs (rôles) qui ont aussi le rôle `isifar2022`\n\n::: {.content-visible when-profile=\"solution\"}\n\nAttention, nécessite de changer les droits de consultation de ces tables pour les utilisateurs standards.\n\n```{.sql}\nselect schema_name from information_schema.schemata, pg_roles\nwhere schemata.schema_name=pg_roles.rolname and\npg_roles.oid in (select member from pg_auth_members where roleid=78094)\n```\n\n:::\n\n\n\n\n\n\n\n\n## Droits\n\n\n- Créer dans votre schéma une table `matable_etudiant` par copie de la table `datatpadmin` du schema `durand`. Sélectionner les tuples de la table crée : il contiennent des informations (aléatoire) pour chacun des utilisateurs du groupe.\n  - Donner les droits de sélection sur cette table à l'utilisateur de votre choix ou au groupe entier). Vérifier que cela marche.\n  - Enlever les droits de sélection à cet utilisateur\n\n\n- On suppose maintenant que vous souhaitez accorder des droits de sélection à chacun des étudiants du groupe mais uniquement pour les données qui le concerne. Par exemple, s'il existe des tuples dont la valeur pour identifiant est `johnsmith`, l'utilisateur johnsmith doit pouvoir sélectionner ces tuples  mais aucun autre. Proposez une manière de réaliser cette politique de sécurité ?\n\nIndication: on pourra s'appuyer sur la création d'une vue. Regardez aussi la documentation de la variable `CURRENT_USER`.\n\n::: {.content-visible when-profile=\"solution\"}\n\nOn peut prendre temporairement l'identité d'un utilisateur `x` par : `set role x`.\n\n% la table datatpadmin contient deux colonnes : identifiant et écart. Identifiant prend ses valeurs dans la liste des schémas d'étudiants ISIFAR2022. La table a été obtenue à partir de celle des résultats du contrôle continu.\n\n```{.sql}\ncreate view student_view as select * from durand.datatpadmin\nwhere identifiant=current_user;\ngrant usage on schema durand  to isifar2022;\ngrant select on durand.student_view to isifar2022;\n```\n\n:::\n\n\n\n\n- Dans la continuité de la question précédente, accordez à chaque utilisateur le droit de modifier les tuples qui le concerne dans votre table.\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}