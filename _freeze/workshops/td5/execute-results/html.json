{
  "hash": "b16d443aeed020eb13cd766e8e4dfa65",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"TD 5: SQL\"\nsubtitle: \"Fenêtres et fonctions SQL\"\ncategories: [world, babynames, SQL, Aggregation, Fenêtres, Fonctions]\ndate: \"2024-10-18\"\n\nformat:\n  pdf:\n    code-annotations: below\n    keep-tex: false\n    code-fold: false\n    toc: false\n    output-file: td5.pdf\n    include-in-header:\n      - text: \"\\\\lhead{{\\\\sf  Base de données \\\\\\\\ TD 5}}\"\n  html:\n    embed-resources: true\n    code-fold: true\n    output-file: td5.html\nparams:\n    year: 2024 \n    curriculum: \"L3 MIASHS/Ingémath\"\n    university: \"Université Paris Cité\"\n    homepage: \"https://s-v-b.github.io/MA15Y030/\"\n    moodle: \"https://moodle.u-paris.fr/course/view.php?id=2313\"  \n---\n\n\n\n\n\n\n\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-warning}\n\n### Avec solutions\n\n::: \n\n:::\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n\n\n- **L3 MIASHS/Ingémath**\n- **[Université Paris Cité](https://www.u-paris.fr)**\n- Année 2024-2025\n- [Course Homepage](https://s-v-b.github.io/MA15Y030/)  \n- [Moodle](https://moodle.u-paris.fr/course/view.php?id=2313)\n\n::: \n\n::: {#second-column}\n![](../images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::\n\n:::\n\n\n\n\n# Fonctions fenêtres/Window functions\n\n\nUne *fonction fenêtre* effectue un calcul sur un ensemble de lignes de table \nqui sont liées d'une manière ou d'une autre à la ligne actuelle. \nCeci est comparable au type de calcul qui peut être effectué avec une *fonction d'agrégation*. \nToutefois, les *fonctions de fenêtre* n'entraînent pas le regroupement des \nlignes en une unique ligne de sortie, comme le feraient des appels d'agrégats sans fenêtre. \nAu contraire, avec les *fonctions fenêtres* les lignes conservent leurs identités distinctes. \n\nPour chaque ligne du résultat, les fonctions fenêtres calculent sur un ensemble de lignes. Cet \nensemble de lignes est défini par l'adverbe `OVER`.\n\n## OVER (PARTITION BY  ...)\n\nCette construction peut être combinée avec n'importe quelle fonction d'aggrégation.\n\nCette requête indique pour chaque ville, la \"population moyenne\" des villes de ce pays\n(cette moyenne n'a aucun sens).\n\n```{.sql}\nSELECT id, name_city, population_city, \n       avg(population_city) OVER (PARTITION BY countrycode)  AS avg_pop\nFROM world.city;  \n```\n\nSans le mécanisme de fenêtrage, on pourrait obtenir le résultat au prix d'une jointure\n```{.sql}\n WITH tmp AS (\n  SELECT c.countrycode, AVG(c.population_city) AS avg_pop\n  FROM world.city c\n  GROUP BY c.countrycode\n ) \n  SELECT cc.id, cc.name_city, cc.population_city, tmp.avg_pop\n  FROM world.city cc NATURAL JOIN tmp;  \n```\n\n## OVER (PARTITION BY  ... ORDER BY)\n\nOn peut partitioner et trier. \n\nCette construction est très pratique pour ranger les tuples d'un sous-groupe.\n\nDans `world`, si on veut ranger les langues parlées dans un pays par popularité décroissante, \non peut procéder ainsi. \n\n```{.sql}\nSELECT countrycode, LANGUAGE, \nRANK() OVER (PARTITION BY countrycode ORDER BY percentage DESC)  AS rnk\nFROM world.countrylanguage ;\n```\n\n## RANK() OVER ()\n\nOn peut ne pas partitionner en utilisant l'expression `OVER ()`. Par exemple, si on veut obtenir \nle rang des tuples d'une table sur un tri particulier.\n\n```{.sql}\nSELECT countrycode, name_country, \n       RANK() OVER (ORDER BY population_country DESC)  AS rnk\nFROM world.country ;  \n```\n\n\n## Autres types de fenêtres\n\nLa construction `OVER ( ...)` n'est pas utilisée exclusivement avec des partitions (peut-être triviales), \non peut aussi définir des fenêtres glissantes. \n\nLes *fonctions fenêtre* ne sont autorisées que dans la liste `SELECT` et la clause `ORDER BY` \nde la requête. Elles sont interdites ailleurs, par exemple dans les clauses `GROUP BY`, `HAVING` \net `WHERE`. \n\n\n# Fonctions en langage SQL\n\n## Forme générale\n\n\n```{.sql}\nCREATE OR REPLACE FUNCTION  schema_name.func_name(p_arg1 p_arg1_datatype, ..., [OUT o_arg1 o_arg1_datatype, ...])\nRETURNS some type | RECORD | SETOF some type | TABLE (..) \nLANGUAGE SQL AS\n$$\nSQL statement ;\nSQL statement ;\n...\nSQL statement ;\n$$ ;\n```\n\n\n\n## Fonctions qui retournent un type simple\n\nDans le schéma `world`, on veut écrire une fonction qui prend en argument une région et \nrenvoie la population maximale parmi les capitales de la région (voir td2 requête 1). \n\n```{.sql}\nCREATE OR REPLACE FUNCTION username.taille_max_capitale_region(p_region text)\nRETURNS INTEGER LANGUAGE SQL AS\n$$\nSELECT MAX(population_city) AS max_pop\nFROM world.country c JOIN world.city cc ON (c.capital=cc.id)\nWHERE c.region=p_region AND cc.population_city IS NOT NULL;\n$$ ;\n```\n\n## Fonctions qui retournent un type composé\n\nDans le schéma `world`, on veut écrire une fonction qui prend en argument une région et  renvoie le nom et la population de la capitale la plus peuplée de cette région (voir td2 requête 1). \n\nOn peut utiliser le *qualifiant* `OUT` pour désigner des paramètres de sortie.\n\n```{.sql}\nCREATE OR REPLACE FUNCTION username.capitale(p_region text, OUT o_name_capital TEXT, OUT o_population_capital INTEGER)\nRETURNS RECORD  LANGUAGE SQL AS\n$$\nWITH r AS(\n  SELECT cc.*, RANK() OVER (PARTITION BY c.region \n                            ORDER BY cc.population_city DESC) AS rnk\n  FROM world.country c JOIN world.city cc ON (c.capital=cc.id)\n  WHERE c.region=p_region)\nSELECT r.name_city,  r.population_city\nFROM r \nWHERE r.rnk = 1 ;\n$$ ;\n```\n\n## Fonctions qui retournent un type composé défini par les lignes d'une table\n\nDans le schéma `world`, on veut écrire une fonction qui prend en argument une région et \nrenvoie la description de la capitale la plus peuplée de cette région (voir td2 requête 1). \n\n```{.sql}\nCREATE OR REPLACE FUNCTION username.capitale(p_region text)\nRETURNS world.city  LANGUAGE SQL AS\n$$\nWITH r AS(\n  SELECT cc.*, RANK() OVER (PARTITION BY c.region \n                            ORDER BY cc.population_city DESC) AS rnk\n  FROM world.country c JOIN world.city cc ON (c.capital=cc.id)\n  WHERE c.region=p_region\n)\nSELECT r.id, r.name_city, r.countrycode, r.district, r.population_city\nFROM r \nWHERE r.rnk = 1 ;\n$$ ;\n```\n\n## Fonctions qui retournent une table\n\nDans le schéma `world`, on veut écrire une fonction qui prend en argument une région et \nrenvoie la table des capitales de la région (voir td2 requête 1). \n\n### Table de schéma explicite\n\nOn se contente d'abord de renvoyer le nom de la capitale. On explicite le schéma \nde la table résultat\n```{.sql}\nCREATE OR REPLACE FUNCTION username.capitales_region(p_region text)\nRETURNS TABLE (name_capital text) LANGUAGE SQL AS\n$$\nSELECT cc.name_city \nFROM world.country c JOIN world.city cc ON (c.capital=cc.id)\nWHERE c.region=p_region ;\n$$ ;\n```\n  \n### Table de même schéma qu'une autre table\n\n[Documentation](https://www.postgresql.org/docs/15/xfunc-sql.html)\n\n\nOn veut maintenant récupérer une table de même schéma que `city`. \n\n::: {.callout-tip}\n\nLa solution est très simple. On profite de ce qu'à chaque table correspond  un type de même nom et on utilise le mot-clé `SETOF`. \n\n:::\n\n```{.sql}\nCREATE OR REPLACE FUNCTION username.capitales_region_large(p_region text)\nRETURNS SETOF world.city  LANGUAGE SQL AS\n$$\nSELECT cc.* \nFROM world.country c JOIN world.city cc ON (c.capital=cc.id)\nWHERE c.region=p_region ;\n$$ ;\n```\n\n# Schéma `babynames`\n\nLes données sont construites et mises à disposition par l'INSEE [https://www.insee.fr/fr/accueil](https://www.insee.fr/fr/accueil), disponibles  ici: [https://www.insee.fr/fr/statistiques/fichier/2540004/nat2021_csv.zip](https://www.insee.fr/fr/statistiques/fichier/2540004/nat2021_csv.zip)\n\nCet ensemble de données s'est développé depuis un certain temps. Il a été pris en compte par les des chercheurs en sciences sociales depuis des décennies.  Les prénoms sont censés donner un aperçu d'une variété de phénomènes, y compris l'observance religieuse.\nphénomènes, y compris l'observance religieuse.\n\nUn aperçu de l'ensemble des travaux peut être trouvé dans *L'archipel français* de Jérome Fourquet, Le Seuil, 2019.\n\n[https://www.seuil.com/ouvrage/l-archipel-francais-jerome-fourquet/9782021406023](https://www.seuil.com/ouvrage/l-archipel-francais-jerome-fourquet/9782021406023).\n\n```{.sql}\nSET search_path TO babynames ;\n\n\\d  bebes\n\nTable \"babynames.bebes\"\nColumn |  Type   | Collation | Nullable | Default \n--------+---------+-----------+----------+---------\nsexe   | text    |           |          | \nprenom | text    |           |          | \nannee  | integer |           |          | \nnombre | integer |           |          | \n```\n\nChaque tuple nous indique le `nombre` de nouveaux-nés de genre `sexe`, prénommés `prenom`\nmis au monde durant l'année `annee` en France. \n\n# Exercices\n\n\n- Pour chaque année, chaque sexe, donner les dix prénoms les plus populaires et leur rang  de popularité. \n\n```{.sql}\nWITH R AS (\n  SELECT annee, sexe, prenom, RANK() OVER(PARTITION BY (annee, sexe)\n                                          ORDER BY nombre DESC) AS rnk\n  FROM babynames.bebes\n)\nSELECT annee, sexe, prenom, rnk\nFROM R\nWHERE rnk <= 10 ;\n```\n\n- Créer dans votre schéma personnel une vue `top_10` qui, interrogée, renvoie le résultat de la requête précédente\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n\n```{.sql}\nCREATE OR REPLACE VIEW babynames.top_10 AS   -- <1>\n  WITH R AS (\n    SELECT annee, sexe, prenom, RANK() OVER(PARTITION BY (annee, sexe) ORDER BY nombre DESC) AS rnk\n    FROM babynames.bebes\n  )\n  \n  SELECT annee, sexe, prenom, rnk\n  FROM R\n  WHERE rnk <= 10\n;\n```\n1. Remplacer `babynames.top_10`  par `username.top_10`.\n\n:::\n:::\n\n\n- Écrire une fonction qui prend en argument un prénom et renvoie une table de schéma `(annee, sexe, rang)`\net indique le rang du prénom pour chaque année et chaque sexe.\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n\n```{.sql}\n\nCREATE OR REPLACE FUNCTION babynames.fonc_td4bis_1(p_prenom TEXT) \nRETURNS TABLE(annee INT4, sexe TEXT, rang INT4)\nLANGUAGE SQL AS  \n$$\nWITH R AS (\n  SELECT annee, sexe, prenom, RANK() OVER(PARTITION BY (annee, sexe) ORDER BY nombre DESC) AS rnk\n  FROM babynames.bebes\n)\nSELECT annee::int4, sexe::text, rnk::int4\nFROM R\nWHERE prenom = p_prenom ;\n$$ ;\n```\n::: {.callout-caution}\nRemplacer `babynames.fonc_td4bis_1`  par `username.fonc_td4bis_1`.\n:::\n\n:::\n:::\n\n- Pour chaque année et sexe, calculez le nombre total de naissances. \n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\n# unilur-solution: true\n\nSELECT b.annee, b.sexe, SUM(nombre) AS nb\nFROM babynames.bebes b\nGROUP BY b.annee, b.sexe  ;\n```\n\n:::\n:::\n\n\n- Créer dans votre schéma personnel une vue `naissances_sexe_annee`  qui, interrogée, renvoie\nle résultat de la requête précédente\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\n# unilur-solution: true\n\nCREATE OR REPLACE VIEW babynames.naissances_sexe_annee AS(\n\tSELECT b.annee, b.sexe, SUM(nombre)  AS nb\n \tFROM babynames.bebes b\n \tGROUP BY b.annee, b.sexe\n) ;\n```\n:::\n:::\n\n- Pour chaque année, calculez le rapport entre  nombre total de naissances féminines et nombre total de naissances masculines.\n\n::: {.callout-note}\nOn effectue avec les outils SQL une opération qui s'appelle un *pivot en forme élargie*.\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH R AS (\n SELECT b.annee, b.sexe, SUM(nombre)  AS nb\n FROM babynames.bebes b\n GROUP BY b.annee, b.sexe\n)\nSELECT r1.annee, r1.nb::float4/r2.nb::float4 AS ratio\nFROM R r1 JOIN R r2 ON(r1.annee=r2.annee)\nWHERE r1.sexe=2 AND r2.sexe=1 ;\n```\n\n:::\n:::\n\n- Créer dans votre schéma personnel une vue `naissances_sexe_annee` qui, interrogée, renvoie\nle résultat de la requête précédente.\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nCREATE OR REPLACE VIEW babynames.naissances_f_h_annee AS (\nSELECT r1.annee, r1.nb AS nb_f, r2.nb AS nb_h\nFROM babynames.naissances_sexe_annee r1 JOIN babynames.naissances_sexe_annee r2 ON(r1.annee=r2.annee)\nWHERE r1.sexe='2' AND r2.sexe='1'\n) ;\n```\n:::\n:::\n\n- Pour chaque année, calculez le rapport entre  nombre total de naissances féminines et nombre total de naissances\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n\n```{.sql}\nWITH R AS (\n SELECT b.annee, b.sexe, SUM(nombre)  AS nb\n FROM babynames.bebes b\n GROUP BY b.annee, b.sexe\n)\nSELECT r1.annee, r1.nb::float4/(r1.nb::float4 + r2.nb::float4) AS ratio -- <1>\nFROM R r1 JOIN R r2 ON(r1.annee=r2.annee)\nWHERE r1.sexe='2' AND r2.sexe='1' ;\n```\n1.   Pourquoi est-il utile de réaliser une coercition de type sur `nb` avec `nb::float4` ? \n\n:::\n:::\n\n- Créer dans votre schéma personnel une vue `naissances_sexe_annee qui, interrogée, renvoie\nle résultat de la requête précédente\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nCREATE OR REPLACE VIEW babynames.naissances_sexe_annee AS (\n\tSELECT b.annee, b.sexe, SUM(nombre)  AS nb\n \tFROM babynames.bebes b\n \tGROUP BY b.annee, b.sexe\n) ;\n```\n\n:::\n:::\n\n\n- Écrire une fonction qui prend en argument une année `yyyy` et\nrenvoie une table de schéma `(annee, sexe, prenom, prop)`\noù `prenom` est un des dix prénoms les plus populaires donné en l'aneee `yyyy`\net calculer la proportion de nouveaux-nés portant ce prénom année par année.\n\nTenez compte du fait que certains noms peuvent avoir une occurrence nulle pendant certaines années.\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nCREATE OR REPLACE FUNCTION babynames.fonc_td4bis_2(p_annee int4)\nRETURNS TABLE(annee int4, sexe TEXT, prenom TEXT, prop float4) LANGUAGE SQL AS\n$$\nWITH r AS (\n  SELECT sexe, prenom\n  FROM babynames.top_10 t\n  WHERE t.annee=p_annee\n), s AS (\n  SELECT b.annee, r.sexe, r.prenom, b.nombre\n  FROM r  LEFT OUTER JOIN babynames.bebes b\n  ON(r.sexe=b.sexe AND r.prenom=b.prenom)\n)\nSELECT s.annee, s.sexe, s.prenom, s.nombre::float4/nsa.nb::float4 AS prop\nFROM s JOIN babynames.naissances_sexe_annee nsa\nON (s.annee=nsa.annee  AND  s.sexe=nsa.sexe) ;\n$$ ;\n```\n:::\n:::\n\n\n[https://www.postgresql.org/docs/15/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS](https://www.postgresql.org/docs/15/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS)\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}