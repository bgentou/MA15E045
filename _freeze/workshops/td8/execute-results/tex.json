{
  "hash": "ad7faaba1fe103baef89b087a772eb25",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"TD 8 : Modélisation\"\nsubtitle: \"Modélisation\"\ncategories: [Modélisation EA, Pattes de corbeau, Crowfoot notation]\ndate: \"2024-11-15\"\n\n\nformat:\n  pdf:\n    code-annotations: below\n    keep-tex: false\n    code-fold: false\n    toc: false\n    output-file: td8.pdf\n    include-in-header:\n      - text: \"\\\\lhead{{\\\\sf  Base de données \\\\\\\\ TD 8: Modélisation}}\"\n  html:\n    embed-resources: true\n    code-fold: true\n    output-file: td8.html\nparams:\n    year: 2024 \n    curriculum: \"L3 MIASHS/Ingémath\"\n    university: \"Université Paris Cité\"\n    homepage: \"https://s-v-b.github.io/MA15Y030/\"\n    moodle: \"https://moodle.u-paris.fr/course/view.php?id=2313\"\n\nengine: knitr\n---\n\n\n\n\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-warning}\n\n### Avec solutions\n\n:::\n\n:::\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n\n- **L3 MIASHS/Ingémath**\n- **[Université Paris Cité](https://www.u-paris.fr)**\n- Année 2024-2025\n- [Course Homepage](https://s-v-b.github.io/MA15Y030/)  \n- [Moodle](https://moodle.u-paris.fr/course/view.php?id=2313)\n\n::: \n\n::: {#second-column}\n![](../images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::\n\n:::\n\n\n::: {.callout-important title=\"Objectifs\"}\n\nL'objectif de cette séance est construire des modèles Entité-Association sur des problèmes miniatures. \n\n\n:::\n\n\n# Modélisation Entité-Association (E/A ou E/R)\n\n## Exercice (Supermarché)\n\n::: {.callout-note}\n\n### Question \n\nProduire un schéma E/R qui décrit des informations concernant les\nproduits d'un supermarché. \n\n:::\n\n\nChaque *produit* a un *nom* et un *prix* et\nappartient à une *catégorie*. \n\nLe supermarché a plusieurs *rayons*, un rayon\nétant caractérisé par un *étage* et un *numéro de rangée*. On veut maintenir\nl'emplacement des produits dans les rayons. Les produits d'une même\ncatégorie sont placés dans le même rayon, mais un rayon peut contenir\ndes produits de plusieurs catégories.\n\n\n::: {.callout-note}\n\n### Question\n\nTraduire le schéma EA dans le formalisme des pattes de corbeau\n\n:::\n\n::: {.callout-note}\n\n### Question\n\nDéfinir le schéma relationnel correspondant en SQL\n\n:::\n\n\n## Exercice (Location de voitures)\n\n::: {.callout-note}\n\n### Question\n\nProduire un schéma E/R qui décrit des informations concernant des voitures à louer. \n\n:::\n\nChaque *voiture* a une plaque d'*immatriculation*, une\n*couleur* et une *marque*. Le *prix* de la location dépend de la *catégorie*, \noù chaque catégorie est identifiée par un nom.\n\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-tip title=\"Solution\"}\n\n\n\n\n\n```{dot}\n//| label: er1\n//| eval: true\n//| echo: false\ngraph ER {\n\tfontname=\"Helvetica,Arial,sans-serif\"\n\tnode [fontname=\"Helvetica,Arial,sans-serif\"]\n\tedge [fontname=\"Helvetica,Arial,sans-serif\"]\n\tlayout=neato\n\tnode [shape=box]; Voiture; Marque; Catégorie;\n\tnode [shape=ellipse]; {node [label=<<u>nom</u>>]  name1; name2;}\n\t\t{node [label=<<u>immatriculation</u>>] immatriculation}; couleur; {node [label=\"prix location\"] prix_location};\n  node [shape=diamond];  \"fabriqué-par\" ; \"appartient-à\" ;\n  \n\tname2 -- Marque;\n  name1 -- Catégorie\n\timmatriculation -- Voiture;\n  couleur -- Voiture; \n  Catégorie -- prix_location;\n  Voiture -- \"fabriqué-par\" [label=\"1:1\",len=1.00];\n  \"fabriqué-par\" -- Marque   [label=\"0:n\",len=1.00] ;\n  Voiture -- \"appartient-à\"  [label=\"1:1\",len=1.00] ;\n  \"appartient-à\" -- Catégorie  [label=\"0:n\",len=1.00] ;\n  //\tlabel = \"\\n\\nEntity Relation Diagram\\ndrawn by NEATO\";\n//\tfontsize=20;\n}\n```\n\n\n\n\nPas d'entités faibles car chaque entité a son propre identifiant. \n\nÀ discuter : pourrait-on utiliser un lien `est-un` ( ◃ ) pour modéliser le fait qu'un véhicule relève d'une catégorie ?\n\n::: \n \n:::\n\n\n::: {.callout-note}\n\n### Question\n\nModifier ensuite le schéma pour représenter les modèles de voitures.\n\n:::\n\nUn *modèle* a un *nom*, une *marque* et un *nombre de sièges*. \n\nToutes les\nvoitures du même modèle doivent appartenir à la même catégorie de\nprix. \n\n\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-tip title=\"Solution\"}\n\n\n\n\n\n```{dot}\n//| label: er2\n//| eval: true\n//| echo: false\ngraph ER {\n\tfontname=\"Helvetica,Arial,sans-serif\"\n\tnode [fontname=\"Helvetica,Arial,sans-serif\"]\n\tedge [fontname=\"Helvetica,Arial,sans-serif\"]\n\tlayout=neato\n\tnode [shape=box]; Voiture; Marque; Catégorie; Modèle\n\tnode [shape=ellipse]; {node [label=<<u>nom</u>>]  name1; name2; name3}\n\t\t{node [label=<<u>immatriculation</u>>] immatriculation}; couleur; {node [label=\"prix location\"] prix_location};\n  {node [label=\"nombre de sièges\"] nbre_sieges};\n  node [shape=diamond];  \"fabriqué-par\" ; \"appartient-à\" ; \"relève-de\" ;\n  \n  nbre_sieges -- Modèle [len=2.00]; \n\tname2 -- Marque;\n  name1 -- Catégorie ;\n  name3 -- Modèle ;\n\timmatriculation -- Voiture;\n  couleur -- Voiture; \n  Catégorie -- prix_location;\n\n  Voiture -- \"relève-de\" [label=\"1:1\",len=1.00];\n  \"relève-de\" -- Modèle [label=\"0:n\",len=1.00] ;\n  Modèle -- \"fabriqué-par\" [label=\"1:1\",len=1.00];\n  \"fabriqué-par\" -- Marque   [label=\"0:n\",len=1.00] ;\n  Modèle -- \"appartient-à\"  [label=\"1:1\",len=2.00] ;\n  \"appartient-à\" -- Catégorie  [label=\"0:n\",len=2.00] ;\n  //\tlabel = \"\\n\\nEntity Relation Diagram\\ndrawn by NEATO\";\n//\tfontsize=20;\n}\n```\n\n\n\n\n\n::: \n \n:::\n\n\n::: {.callout-note title=\"Question\"}\n\nDe plus, on veut distinguer les voitures *disponibles* des\nvoitures en *location*. Pour les voitures disponibles on représente\nl'*emplacement*. Pour les voitures en location on représente la *date*\net la *durée de la location*, ainsi que le *nom du client*.\n\n:::\n\n\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-tip title=\"Solution\"}\n\n\n\n\n\n```{dot}\n//| label: er3\n//| eval: true\n//| echo: false\ngraph ER {\n\tfontname=\"Helvetica,Arial,sans-serif\"\n\tnode [fontname=\"Helvetica,Arial,sans-serif\"]\n\tedge [fontname=\"Helvetica,Arial,sans-serif\"]\n\tlayout=neato\n\tnode [shape=box]; Voiture; Marque; Catégorie; Modèle ; Disponible ;  \"En location\" ;\n\tnode [shape=ellipse]; {node [label=<<u>nom</u>>]  name1; name2; name3}\n\t\t{node [label=<<u>immatriculation</u>>] immatriculation}; couleur; {node [label=\"prix location\"] prix_location};\n  {node [label=\"nombre de sièges\"] nbre_sieges}; \"nom client\" ; emplacement ; date ; durée ;\n  node [shape=diamond];  \"fabriqué-par\" ; \"appartient-à\" ; \"relève-de\" ;\n  {node [shape=triangle, label=\"Est Un\"] estun1 ; estun2 }; \n\n  nbre_sieges -- Modèle [len=2.00]; \n\tname2 -- Marque;\n  name1 -- Catégorie ;\n  name3 -- Modèle ;\n\timmatriculation -- Voiture;\n  couleur -- Voiture; \n  Catégorie -- prix_location;\n  Disponible -- estun1 ;\n  estun1 -- Voiture ; \n  \"En location\" -- estun2 ;\n  estun2 -- Voiture ; \n  Disponible -- emplacement\n  \"En location\" -- date ;\n  \"En location\" -- durée ;\n  \"En location\" -- \"nom client\"\n\n  Voiture -- \"relève-de\" [label=\"1:1\",len=1.00];\n  \"relève-de\" -- Modèle [label=\"0:n\",len=1.00] ;\n  Modèle -- \"fabriqué-par\" [label=\"1:1\",len=1.00];\n  \"fabriqué-par\" -- Marque   [label=\"0:n\",len=1.00] ;\n  Modèle -- \"appartient-à\"  [label=\"1:1\",len=2.00] ;\n  \"appartient-à\" -- Catégorie  [label=\"0:n\",len=2.00] ;\n  //\tlabel = \"\\n\\nEntity Relation Diagram\\ndrawn by NEATO\";\n//\tfontsize=20;\n}\n```\n\n\n\n\nOn utilise ici les liens `Est Un` pour décrire le statut des voitures (spécialisation). \n\nIl faudrait ajouter une  contrainte d'exclusion totale : une voiture est soit en location, soit disponible. \n\nOn pourrait aussi passer par des attributs `statut`, `emplacement` et une entité faible `Location`. \n\n\n::: \n \n:::\n\n::: {.callout-note}\n\n### Question\n\nTraduire le schéma EA dans le formalisme des pattes de corbeau\n\n:::\n\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-tip title=\"Solution\"}\n\n\n\n\n```{mermaid}\n%%| eval: true\n%%| echo: false\nerDiagram\n    VOITURE\n    MODELE \n    CATEGORIE\n    MARQUE\n    LOCATION\n    MODELE ||..o{ VOITURE : \"releve de\"\n    VOITURE {\n      string  immatriculation  PK\n      string couleur\n      boolean disponible \n      string emplacement \n      string nom_modele FK\n    }\n    MARQUE ||..o{ MODELE : \"fabrique par\"\n    MODELE {\n      string nom PK\n      integer nombre_de_sieges \n      string nom_marque FK\n      string nom_categorie FK\n    }\n    MARQUE {\n      string nom PK\n    }\n    CATEGORIE ||..o{ MODELE : \"appartient a\"\n    CATEGORIE {\n      string nom PK\n      numeric prix_location\n    }\n    LOCATION |o--|| VOITURE : concerne\n    LOCATION {\n      string date \n      integer immatriculation PK, FK\n      string duree\n      integer numero_client\n    }\n```\n\n\n\n\nContraintes externes: \n\n- Dans `VOITURE`, `disponible` si et seulement si `emplacement` est `NOT NULL`\n- Dans `VOITURE` et `LOCATION`, `NOT disponible` si et seulement si dans `LOCATION`, il existe une instance qui réfère à l'instance de `VOITURE`. \n \n{{< fa brain >}} Trouver une meilleure modélisation pour la spécialisation `DISPONIBLE/EN LOCATION`.\n\n::: \n \n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution avec dbSchema\"}\n\n![Schema Avis d'après dbSchema](/images/schema_avis.png)\n\n:::\n\n:::\n\n\n::: {.callout-note}\n\n### Question\n\nDéfinir le schéma relationnel correspondant en SQL\n\n:::\n\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nCREATE SCHEMA IF NOT EXISTS schema_avis;\n\nCREATE  TABLE schema_avis.categorie ( \n\tnom                  text  NOT NULL  ,\n\tprix_location        numeric    ,\n\tCONSTRAINT pk_categorie PRIMARY KEY ( nom )\n );\n\nCREATE  TABLE schema_avis.marque ( \n\tnom                  text  NOT NULL  ,\n\tCONSTRAINT pk_marque PRIMARY KEY ( nom )\n );\n\nCREATE  TABLE schema_avis.modele ( \n\tnom                  text  NOT NULL  ,\n\tnombre_sieges        bigint    ,\n\tnom_marque           text    ,\n\tname_categorie       text    ,\n\tCONSTRAINT pk_modele PRIMARY KEY ( nom )\n );\n```\n\n:::\n\n::: {.callout-tip title=\"suite\"}\n\n```{.sql}\nCREATE  TABLE schema_avis.voiture ( \n\timmatriculation      bigint  NOT NULL  ,\n\tname_modele          text    ,\n\tcouleur              text    ,\n\tdisponible           boolean  NOT NULL  ,\n\templacement          text    ,\n\tCONSTRAINT pk_voiture PRIMARY KEY ( immatriculation )\n );\n\nCREATE  TABLE schema_avis.location ( \n\timmatriculation      bigint  NOT NULL  ,\n\t\"date\"               date  NOT NULL  ,\n\tduree                bigint  NOT NULL  ,\n\tnumero_client        bigint  NOT NULL  ,\n\tCONSTRAINT pk_location PRIMARY KEY ( immatriculation )\n );\n\n```\n:::\n\n::: {.callout-tip title=\"suite\"}\n\n```{.sql}\n\nALTER TABLE schema_avis.location \nADD CONSTRAINT \n  fk_location_voiture \nFOREIGN KEY ( immatriculation ) \nREFERENCES schema_avis.voiture( immatriculation );\n\nALTER TABLE schema_avis.modele \nADD CONSTRAINT \n  fk_modele_marque \nFOREIGN KEY ( nom_marque ) \nREFERENCES schema_avis.marque( nom ) \nON DELETE CASCADE ON UPDATE CASCADE;\n\nALTER TABLE schema_avis.modele \nADD CONSTRAINT \n  fk_modele_categorie \nFOREIGN KEY ( name_categorie ) \nREFERENCES schema_avis.categorie( nom );\n\nALTER TABLE schema_avis.voiture \nADD CONSTRAINT \n  fk_voiture_modele \nFOREIGN KEY ( name_modele ) \nREFERENCES schema_avis.modele( nom ) \nON DELETE CASCADE ON UPDATE CASCADE;\n```\n\n::: \n \n:::\n\n\n## Exercice (Gestion du personnel d'une entreprise)\n\nDans une entreprise, chaque *employé* (identifié par un *numéro*) est\nattaché à un *département* de l'entreprise. Il occupe un *bureau* et\nparticipe à un ou plusieurs *projets* développés par l'entreprise.\n\nDe chaque employé, on connait : le *nom*, le *prénom*, les *emplois* qu'il a\noccupés à différentes dates et les *salaires* qu'il a *perçus* dans ces\nemplois.\n\nChaque *département* est identifié par un *numéro*, a son *budget* propre et\nest dirigé par un *directeur* faisant partie du personnel de l'entreprise.\n\nChaque *bureau* est identifié par un *numéro*, est rattaché à un *département*\net est caractérisé par sa *surface* en mètres carrés. Il possède un numéro\nde *téléphone* associé.\n\nChaque *projet* est identifié par un *numéro*, possède un certain *budget* et\n*emploie* plusieurs *personnes* appartenant à différents *départements*.\nChaque employé est *affecté* pour un *certain nombre d'heures* à un projet.\n\n::: {.callout-note}\n\n### Question \n\nDonner un modèle entité-association correspondant à la description\nci-dessus.\n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n\n\n\n```{dot}\n//| label: er4\n//| eval: true\n//| echo: false\ngraph ER {\n\tfontname=\"Helvetica,Arial,sans-serif\"\n\tnode [fontname=\"Helvetica,Arial,sans-serif\"]\n\tedge [fontname=\"Helvetica,Arial,sans-serif\"]\n\tlayout=neato\n\t\n  node [shape=box]; Employé; Département; Bureau; Projet ; Emploi ;\n\t\n  node [shape=ellipse]; \n  {node [label=<<u>numéro</u>>]  num1; num2; num3; num4; num5}\t; \n  surface; \n  {node [label=\"budget\"] budget1; budget2};\n  {node [label=\"nom\"] nom1; nom2; nom3; nom4}; \n  {node [label=\"debut\"] debut1} ;\n  {node [label=\"fin\"] fin1} ;\n  \"nombre heures\" ; téléphone ; salaire ;\n\n  node [shape=diamond];  \"dirige\" ; \"attaché à\" ; \"affecté à\" ; \"occupe\" ; \"participe à\"\n  \n  num1 -- Employé ;\n  num2 -- Département ;\n  num3 -- Bureau ;\n  num4 -- Projet ;\n  num5 -- Emploi ;\n  nom1 -- Employé ;\n  nom2 -- Département ;\n  nom3 -- Projet ;\n  nom4 -- Emploi ;\n  \n  surface --  Bureau ;\n  téléphone -- Bureau ;\n  budget1 -- Département ;\n  budget2 -- Projet ;\n  \"nombre heures\" -- \"participe à\";\n  debut1 -- \"occupe\" ;\n  fin1 -- \"occupe\" ;\n  salaire -- \"occupe\" ;\n\n  Employé -- \"attaché à\" [label=\"1:1\",len=1.00];\n  \"attaché à\" -- Département [label=\"0:n\",len=1.00] ;\n\n  Employé -- \"dirige\" [label=\"0:1\",len=1.00];\n  \"dirige\" -- Département [label=\"1:1\",len=1.00] ;\n\n  Employé -- \"affecté à\" [label=\"1:1\",len=1.00];\n  \"affecté à\" -- Bureau [label=\"0:n\",len=1.00] ;\n\n  Employé -- \"participe à\" [label=\"0:n\",len=1.00];\n  \"participe à\" -- Projet [label=\"0:n\",len=1.00] ;\n\n  Employé -- \"occupe\" [label=\"0:n\",len=1.00];\n  \"occupe\" -- Emploi [label=\"0:n\",len=1.00] ;\n\n\n}\n```\n\n\n\n\n::: \n:::\n\n::: {.callout-note}\n\n### Question \n\nModifier votre modélisation pour tenir compte de l'évolution dans le\ntemps de la vie de l'entreprise : les projets ont des durées de vie\nlimitées, chaque employé est affecté à un projet (mais aussi un\ndépartement) pendant une certaines durée, etc\n\n:::\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-tip title=\"Solution\"}\n\nOn munit les associations d'attributs `début` et `fin`. \n\n{{< fa hand-point-right >}} Il faut aussi changer les cardinalités `0:1` (respectivement `1:1`)  \nen `0:n` (respectivement `1:n`). Les relations *un-plusieurs* deviennent \ndes relations *plusieurs-plusieurs*. La traduction vers les modèles \nen pattes de corbeau sera plus compliquée. Il faudra transformer les \nassociations *plusieurs-plusieurs* en entité faible, relier ces entités \nfaibles aux entités fortes participant aux associations *plusieurs-plusieurs*\npar des associations faibles *plusieurs-un*.   \n\n\n\n\n```{dot}\n//| label: er5\n//| eval: true\n//| echo: false\ngraph ER {\n\tfontname=\"Helvetica,Arial,sans-serif\"\n\tnode [fontname=\"Helvetica,Arial,sans-serif\"]\n\tedge [fontname=\"Helvetica,Arial,sans-serif\"]\n\tlayout=neato\n\t\n  node [shape=box]; Employé; Département; Bureau; Projet ; Emploi ;\n\t\n  node [shape=ellipse]; \n  {node [label=<<u>numéro</u>>]  num1; num2; num3; num4}\t; \n  surface; {node [label=\"budget\"] budget1; budget2};\n  {node [label=\"nom\"] nom1; nom2; nom3 ; nom4}; \n  \"nombre heures\" ; téléphone ; \n  {node [label=\"début\"] début1; début2; début3; début4; début5}; \n  {node [label=\"fin\"] fin1; fin2; fin3; fin4; fin5}; \n  salaire ;\n  \n  node [shape=diamond];  \"dirige\" ; \"attaché à\" ; \"affecté à\" ; \"occupe\" ; \"participe à\"\n  \n  num1 -- Employé ;\n  num2 -- Département ;\n  num3 -- Bureau ;\n  num4 -- Projet ;\n  nom1 -- Employé ;\n  nom2 -- Département ;\n  nom3 -- Projet\n  nom4 -- Emploi ;\n  surface --  Bureau ;\n  téléphone -- Bureau ;\n  budget1 -- Département ;\n  budget2 -- Projet ;\n  \"nombre heures\" -- \"participe à\";\n  salaire -- \"occupe\" ;\n\n  Employé -- \"attaché à\" [label=\"0:n\",len=2.00];\n  \"attaché à\" -- Département [label=\"0:n\",len=2.00] ;\n  \n  Employé -- \"dirige\" [label=\"0:n\",len=2.00];\n  \"dirige\" -- Département [label=\"0:n\",len=2.00] ;\n\n  Employé -- \"affecté à\" [label=\"0:n\",len=2.00];\n  \"affecté à\" -- Bureau [label=\"0:n\",len=1.00] ;\n\n  Employé -- \"participe à\" [label=\"0:n\",len=2.00];\n  \"participe à\" -- Projet [label=\"0:n\",len=1.00] ;\n\n  Employé -- \"occupe\" [label=\"0:n\", len=2.00] ;\n  \"occupe\" -- Emploi [label=\"0:n\", len=1.00] ;\n\n  début1 -- \"participe à\" ;\n  fin1 -- \"participe à\" ;\n\n  début2 -- \"occupe\" ;\n  fin2 -- \"occupe\" ;\n\n  début3 -- \"attaché à\" ;\n  fin3 -- \"attaché à\" ;\n\n  début4 -- \"dirige\" ;\n  fin4 -- \"dirige\" ;\n\n  début5 -- \"affecté à\" ;\n  fin5 -- \"affecté à\" ;\n\n\n}\n```\n\n\n\n\n:::\n\n::: {.callout-tip title=\"Solution\"}\n\n\n\n\n```{dot}\n//| label: er6\n//| eval: true\n//| echo: false\ngraph ER {\n\tfontname=\"Helvetica,Arial,sans-serif\"\n\tnode [fontname=\"Helvetica,Arial,sans-serif\"]\n\tedge [fontname=\"Helvetica,Arial,sans-serif\"]\n\tlayout=neato\n\t\n  node [shape=box]; Employé; Département; Bureau; Projet ; Emploi ;\n\t\n  node [shape=ellipse]; \n  {node [label=<<u>numéro</u>>]  num1; num2; num3; num4}\t; \n  surface; {node [label=\"budget\"] budget1; budget2};\n  {node [label=\"nom\"] nom1; nom2; nom3 ; nom4}; \n  \"nombre heures\" ; téléphone ; \n  {node [label=\"début\"] début1; début2; début3; début4; début5}; \n  {node [label=\"fin\"] fin1; fin2; fin3; fin4; fin5}; \n  salaire ;\n  \n  node [shape=box, peripheries=2];  \"dirige\" ; \"attaché à\" ; \"affecté à\" ; \"occupe\" ; \"participe à\"\n  \n  node [shape=diamond, peripheries=2, label=\"\"] many1 ; many2 ; many3 ; many4 ; many5 ;\n  one1 ; one2 ; one3 ; one4 ; one5 ;\n\n\n\n  num1 -- Employé ;\n  num2 -- Département ;\n  num3 -- Bureau ;\n  num4 -- Projet ;\n  nom1 -- Employé ;\n  nom2 -- Département ;\n  nom3 -- Projet\n  nom4 -- Emploi ;\n  surface --  Bureau ;\n  téléphone -- Bureau ;\n  budget1 -- Département ;\n  budget2 -- Projet ;\n  \"nombre heures\" -- \"participe à\";\n  salaire -- \"occupe\" ;\n\n  Employé -- \"many1\" [label=\"0:n\",len=2.00]; \n  \"many1\"  -- \"attaché à\" [label=\"1:1\",len=1.00];\n  \"attaché à\" -- \"one1\" [label=\"1:1\",len=1.00];\n  \"one1\" -- Département [label=\"0:n\",len=2.00] ;\n  \n\n\n  Employé -- \"many2\" [label=\"0:n\",len=2.00]; \n  \"many2\" -- \"dirige\" [label=\"1:1\",len=2.00];\n  \"dirige\" -- \"one2\" [label=\"1:1\",len=1.00];\n  \"one2\"  -- Département [label=\"0:n\",len=2.00] ;\n\n  Employé -- \"many3\" [label=\"0:n\",len=2.00]; \n  \"many3\" -- \"affecté à\" [label=\"1:1\",len=1.00];\n  \"affecté à\"-- \"one3\" [label=\"1:1\",len=1.00];\n  \"one3\"  -- Bureau [label=\"0:n\",len=1.00] ;\n\n  Employé -- \"many4\" [label=\"0:n\",len=2.00]; \n  \"many4\" -- \"participe à\" [label=\"1:1\",len=1.00];\n  \"participe à\" -- \"one4\" [label=\"1:1\",len=1.00];\n  \"one4\"  -- Projet [label=\"0:n\",len=1.00] ;\n\n  Employé -- \"many5\" [label=\"0:n\",len=2.00]; \n  \"many5\" -- \"occupe\" [label=\"1:1\", len=1.00] ;\n  \"occupe\" -- \"one5\" [label=\"1:1\",len=1.00];\n  \"one5\"  -- Emploi [label=\"0:n\", len=1.00] ;\n\n  début1 -- \"participe à\" ;\n  fin1 -- \"participe à\" ;\n\n  début2 -- \"occupe\" ;\n  fin2 -- \"occupe\" ;\n\n  début3 -- \"attaché à\" ;\n  fin3 -- \"attaché à\" ;\n\n  début4 -- \"dirige\" ;\n  fin4 -- \"dirige\" ;\n\n  début5 -- \"affecté à\" ;\n  fin5 -- \"affecté à\" ;\n\n\n}\n```\n\n\n\n\n{{< fa hand-point-right >}} Parmi les contraintes externes, il faut ajouter quelques contraintes de non-recouvrement:\n\n- un employé ne peut pas occuper plusieurs emplois simultanément. \n- un employé ne peut pas être affecté dans  plusieurs bureaux simultanément.\n- un employé ne peut pas être attaché à   plusieurs départements simultanément.\n- un employé ne peut pas participer à  un même projet plusieurs fois simultanément.\n\n{{< fa hand-point-right >}} À un instant donné, \nla somme des nombres d'heures de participation\nd'un même employé à différents projets ne devrait \npas dépasser la durée légale du travail.\n\n{{< fa hand-point-right >}} À un instant donné, le nombre d'occupants d'un bureau ne devrait pas excéder \nune borne déterminée par la surface du bureau.\n\n:::\n\n\n:::\n\n\n\n::: {.callout-note}\n\n### Question\n\nTraduire le schéma EA dans le formalisme des pattes de corbeau\n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n\n\n\n\n```{mermaid}\n%%| eval: true\n%%| echo: false\nerDiagram\n    OCCUPE }o--|| EMPLOYE : employe_num \n    OCCUPE }o--|| EMPLOI  : emploi_num\n    PARTICIPE }o--|| EMPLOYE : employe_num \n    PARTICIPE }o--|| PROJET : projet_num\n    MEMBRE }o--|| EMPLOYE : employe_num \n    MEMBRE }o--|| DEPARTEMENT : departement_num\n    AFFECTE }o--|| EMPLOYE : employe_num\n    AFFECTE }o--|| BUREAU : bureau_num\n    DIRIGE }o--|| EMPLOYE : employe_num\n    DIRIGE }o--|| DEPARTEMENT : departement_num\n\n    EMPLOYE {\n      integer num PK\n      string nom  \n      string prenom\n    }\n\n    BUREAU {\n      integer num  PK\n      numeric surface \n      string adresse\n      integer etage \n    }\n\n    EMPLOI {\n      integer num PK\n      string nom\n      text description\n    }\n\n    DEPARTEMENT {\n      integer num PK\n      string nom\n    }\n\n    PROJET {\n      integer num PK\n      string nom\n      numeric budget\n      date debut\n      date fin\n    }\n\n    PARTICIPE {\n      integer num_employe PK, FK  \n      integer num_projet  PK, FK  \n      date debut PK\n      date fin \n      integer nbre_heures\n    }\n\n    OCCUPE {\n      integer num_employe PK, FK\n      integer num_emploi PK, FK\n      date debut PK\n      date fin \n      numeric salaire\n    }\n    \n    MEMBRE {\n      integer num_employe PK, FK\n      integer num_departement PK, FK\n      date debut PK\n      date fin \n    }\n\n    DIRIGE {\n      integer num_employe PK, FK\n      integer num_departement PK, FK\n      date debut PK\n      date fin \n    }\n\n    AFFECTE {\n      integer num_employe PK, FK\n      date debut PK\n      date fin \n    }\n\n```\n\n\n\n\n`MEMBRE` et `DIRIGE` ont en apparence le même schéma. Ce sont les contraintes qui distinguent les deux tables. \n\n:::\n\n\n::: {.callout-tip title=\"Solution\"}\n\n![Schema entreprise](/images/schema_cho.png)\n\n:::\n\n\n:::\n\n\n\n::: {.callout-note}\n\n### Question\n\nDéfinir le schéma relationnel correspondant en SQL\n\n:::\n\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nCREATE SCHEMA IF NOT EXISTS cho;\n\nCREATE  TABLE cho.bureau ( \n\tnum                  bigint  NOT NULL  ,\n\tsurface              numeric    ,\n\tetage                integer    ,\n\ttelephone            text    ,\n\tCONSTRAINT unq_bureau_num UNIQUE ( num ) \n );\n\nCREATE  TABLE cho.departement ( \n\tnum                  bigint  NOT NULL  ,\n\tnom                  text    ,\n\tCONSTRAINT pk_departement PRIMARY KEY ( num )\n );\n\nCREATE  TABLE cho.emploi ( \n\tnum                  bigint  NOT NULL  ,\n\tintitule             text    ,\n\tdescription          text    ,\n\tCONSTRAINT pk_emploi PRIMARY KEY ( num )\n );\n\nCREATE  TABLE cho.employe ( \n\tnum                  bigint  NOT NULL  ,\n\tnom                  text    ,\n\tprenom               text    ,\n\tCONSTRAINT pk_employe PRIMARY KEY ( num )\n );\n```\n:::\n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\n-- tables intermédiaires\n--\nCREATE  TABLE cho.membre ( \n\tnum_employe          bigint  NOT NULL  ,\n\tnum_departement      bigint  NOT NULL  ,\n\tdebut_date           date DEFAULT CURRENT_DATE NOT NULL  ,\n\tfin_date             date DEFAULT NULL   ,\n\tCONSTRAINT pk_membre PRIMARY KEY ( num_employe, num_departement, debut_date )\n );\n\nCREATE  TABLE cho.occupe ( \n\tnum_employe          bigint  NOT NULL  ,\n\tnum_emploi           bigint  NOT NULL  ,\n\tdebut_date           date DEFAULT CURRENT_DATE NOT NULL  ,\n\tfin_date             date DEFAULT NULL   ,\n\tsalaire              money    ,\n\tCONSTRAINT pk_occupe PRIMARY KEY ( num_employe, num_emploi, debut_date )\n );\n\nCREATE  TABLE cho.projet ( \n\tnum                  bigint  NOT NULL  ,\n\tnom                  text    ,\n\tbudget               money    ,\n\tdebut_date           date DEFAULT CURRENT_DATE NOT NULL  ,\n\tfin_date             date DEFAULT NULL   ,\n\tCONSTRAINT pk_projet PRIMARY KEY ( num )\n );\n\nCREATE  TABLE cho.affecte ( \n\tnum_employe          bigint  NOT NULL  ,\n\tnum_bureau           bigint  NOT NULL  ,\n\tdebut_date           date DEFAULT CURRENT_DATE NOT NULL  ,\n\tfin_date             date DEFAULT NULL   ,\n\tCONSTRAINT pk_affecte PRIMARY KEY ( num_employe, num_bureau, debut_date )\n );\n\nCREATE  TABLE cho.dirige ( \n\tnum_directrice       bigint  NOT NULL  ,\n\tnum_departement      bigint  NOT NULL  ,\n\tdebut_date           date DEFAULT CURRENT_DATE NOT NULL  ,\n\tfin_date             date DEFAULT NULL   ,\n\tCONSTRAINT pk_dirige PRIMARY KEY ( num_directrice, num_departement, debut_date )\n );\n\nCREATE  TABLE cho.participe ( \n\tnum_employe          bigint  NOT NULL  ,\n\tnum_projet           bigint  NOT NULL  ,\n\tdebut_date           date DEFAULT CURRENT_DATE NOT NULL  ,\n\tfin_date             date DEFAULT NULL   ,\n\tnbre_heures          bigint DEFAULT 0   ,\n\tCONSTRAINT pk_participe PRIMARY KEY ( num_employe, num_projet, debut_date )\n );\n```\n:::\n\n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\n-- contraintes de tuple\n\nALTER TABLE cho.participe \nADD CONSTRAINT cns_participe \nCHECK (fin_date IS NULL OR fin_date >= debut_date );\n\nALTER TABLE cho.affecte \nADD CONSTRAINT cns_affecte\nCHECK (fin_date IS NULL OR fin_date >= debut_date );\n\nALTER TABLE cho.dirige \nADD CONSTRAINT cns_dirige\nCHECK (fin_date IS NULL OR fin_date >= debut_date );\n\nALTER TABLE cho.membre \nADD CONSTRAINT cns_membre\nCHECK (fin_date IS NULL OR fin_date >= debut_date );\n\nALTER TABLE cho.occupe \nADD CONSTRAINT cns_occupe\nCHECK (fin_date IS NULL OR fin_date >= debut_date );\n```\n:::\n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\n-- contraintes referentielles \n--\nALTER TABLE cho.affecte \nADD CONSTRAINT fk_affecte_employe \nFOREIGN KEY ( num_employe ) REFERENCES cho.employe( num );\n\nALTER TABLE cho.affecte \nADD CONSTRAINT fk_affecte_bureau \nFOREIGN KEY ( num_bureau ) REFERENCES cho.bureau( num );\n\nALTER TABLE cho.dirige \nADD CONSTRAINT fk_dirige_employe \nFOREIGN KEY ( num_directrice ) REFERENCES cho.employe( num );\n\nALTER TABLE cho.dirige \nADD CONSTRAINT fk_dirige_departement \nFOREIGN KEY ( num_departement ) REFERENCES cho.departement( num );\n\nALTER TABLE cho.membre \nADD CONSTRAINT fk_membre_employe \nFOREIGN KEY ( num_employe ) REFERENCES cho.employe( num );\n\nALTER TABLE cho.membre \nADD CONSTRAINT fk_membre_departement \nFOREIGN KEY ( num_departement ) REFERENCES cho.departement( num );\n\nALTER TABLE cho.occupe \nADD CONSTRAINT fk_occupe_employe \nFOREIGN KEY ( num_employe ) REFERENCES cho.employe( num );\n\nALTER TABLE cho.occupe \nADD CONSTRAINT fk_occupe_emploi \nFOREIGN KEY ( num_emploi ) REFERENCES cho.emploi( num );\n\nALTER TABLE cho.participe \nADD CONSTRAINT fk_participe_employe \nFOREIGN KEY ( num_employe ) REFERENCES cho.employe( num );\n\nALTER TABLE cho.participe \nADD CONSTRAINT fk_participe_projet \nFOREIGN KEY ( num_projet ) REFERENCES cho.projet( num );\n```\n\n\n\n::: \n\n:::\n\n::: {.callout-note title=\"Question\"}\n\nEssayer de coder les contraintes externes (exclusion, vérification, unicité, ...)\n\nOn s'intéresse d'abord aux contraintes qui pèsent sur les associations entre `employe` et\n`departement`.\n\n- Un employé ne peut être membre de plusieurs  départements simultanément\n- Un département ne peut pas être dirigé simultanément par plusieurs employés\n- Un employé ne peut pas diiger plusieurs  départements simultanément\n\n:::\n\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n\n\n```{.sql}\n-- Un employé ne peut être membre de plusieurs  départements simultanément\nALTER TABLE cho.membre\nADD CONSTRAINT exc_membre_1 EXCLUDE USING gist (\n  num_employe WITH =,\n  num_departement WITH <>, \n  daterange(debut_date, fin_date) WITH &&\n) ;\n```\n\n```{.sql}\n-- Un département ne peut pas être dirigé simultanément par plusieurs employés\nALTER TABLE cho.dirige\nADD CONSTRAINT exc_dirige_1 EXCLUDE USING gist (\n  num_directrice WITH <>,\n  num_departement WITH =, \n  daterange(debut_date, fin_date) WITH &&\n) ;\n\n```\n\n```{.sql}\n-- Un employé ne peut pas diriger simultanément par plusieurs  départements\nALTER TABLE cho.dirige\nADD CONSTRAINT exc_dirige_2 EXCLUDE USING gist (\n  num_directrice WITH =,\n  num_departement WITH <>, \n  daterange(debut_date, fin_date) WITH &&\n) ;\n\n```\n\n::: \n\n\n:::\n\n::: {.callout-note title=\"Question\"}\n\nEssayer de coder les contraintes externes (exclusion, vérification, unicité, ...)\n\nOn s'intéresse maintenant  aux contraintes qui pèsent sur les associations entre `employe` et\n`projet`.\n\n- Un employé ne peut participer à un projet que pendant la durée de vie du projet \n- Un employé ne peut pas travailler plus de 50 heures par semaine\n\n\nLa première contrainte concerne deux tables `projet`  et `participe`: il \nfaut que l'intervalle spécifié par `debut_date, fin_date` dans \n`participe` soit inclus dans l'intervalle `debut_date, fin_date` de l'instance \nde `projet` désignée par `num_projet`. Cette vérification\ndevrait être effectuée lors des insertions/mises à jour  dans `participe`\nmais aussi lors des mises à jour dans `projet`. \n\nPour mettre en place de genre de contraintes, `SQl`  et `PostgreSQL` offre un cadre : celui des \ngachettes (`TRIGGER`). Cela va au delà de ce cours. Nous allons \nessayer de faire avec les moyens dont nous disposons : les fonctions `SQL` et les contraintes `CHECK`.\n\n\n```{.sql}\nCREATE FUNCTION cho.chk_participation_in_project_range(\n  p_num_projet bigint,\n  p_debut_date date,\n  p_fin_date date\n)\nRETURNS integer\nLANGUAGE SQL AS \n$$\nSELECT \n  COUNT(*)\nFROM \n  cho.projet pr\nWHERE \n  p_num_projet=pr.num \n  AND \n  daterange(p_debut_date, p_fin_date) <@ daterange(pr.debut_date, pr.fin_date) ;\n$$ ;\n```\n\n```{.sql}\nALTER TABLE cho.participe \nADD CONSTRAINT cns_participe_2 \nCHECK (\n  1 = cho.chk_participation_in_project_range(\n        num_projet,\n        debut_date,\n        fin_date \n  )\n)\n;\n```\n\nIl faudrait créer une fonction et une contrainte `CHECK` du côté `projet`. \n\nIl faudrait aussi vérifier que la directrice d'un département est membre du \ndépartement ...\n\n\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}