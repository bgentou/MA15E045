{
  "hash": "5ea478e2ce800567e2e708ca3dcbb249",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"TD Fonctions I : Langage `plpgsql`\"\nsubtitle: \"Fonctions PL/PGSQL sur pagila\"\ndate: \"2025-02-28\"\n\n\nformat:\n  pdf:\n    code-annotations: below\n    keep-tex: false\n    code-fold: false\n    toc: false\n    output-file: td-fonction1.pdf\n    include-in-header:\n      - text: \"\\\\lhead{{\\\\sf  Base de données \\\\\\\\ TD Fonctions 1}}\"\n  html:\n    embed-resources: true\n    code-fold: true\n    output-file: td-fonction1.html\nparams:\n    year: 2024 \n    curriculum: \"L3 MIASHS/Ingémath\"\n    university: \"Université Paris Cité\"\n    homepage: \"https://stephane-v-boucheron.fr/courses/bdd\"\n    moodle: \"https://moodle.u-paris.fr/course/view.php?id=2313\"\n\nengine: knitr\n---\n\n\n\n\n\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-warning}\n\n### Avec solutions\n\n::: \n\n:::\n\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n# {{< meta title >>}}\n\n- **L3 MIASHS/Ingémath**\n- **[Université Paris Cité](https://www.u-paris.fr)**\n- Année 2024-2025\n- [Course Homepage](https://stephane-v-boucheron.fr/courses/bdd)  \n- [Moodle](https://moodle.u-paris.fr/course/view.php?id=2313)\n\n::: \n\n::: {#second-column}\n![](../images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::\n\n:::\n\n\nDans Postgres, il est possible de définir des fonctions. Ces fonctions deviennent des objets permanents d'un schéma (comme les tables, vues, utilisateurs, etc). Elles permettent de regrouper un traitement complexe en un seul programme que l'on peut appeler à tout moment. La syntaxe (simplifiée) d'une fonction est la suivante:\n\n\n```{.sql}\n#| eval: false\n#| echo: true\n\nCREATE FUNCTION function_name(p1 type, ..., pk type)\nRETURNS type AS $$\nDECLARE\n-- declaration de variables locales (facultatif)\nBEGIN\n-- corps de la fonction\nEND;\n$$ LANGUAGE plpgsql;\n```\n\n\n\nUne particularité intéressante des fonctions est qu'elles permettent d'utiliser des paramètres. Les types de ces paramètres peuvent être des types classiques de SQL  (`TEXT,INT(n), VARCHAR(n)`,...) mais aussi des références à des types de colonnes de tables (par exemple: `country.countrycode%TYPE`) ou des types de tuples (exemple: `country%ROWTYPE`).\n\nLes fonctions renvoient des résultats dont le type est spécifié en en-tête. Il peut s'agit des types ci-dessus ou même de type complexe comme des tables (cf exemple plus bas).\n\nLe corps d'une fonction peut contenir une ou plusieurs requêtes mais aussi d'autres instructions que l'on verra par la suite (comme des affectations, test, boucles etc) formant un programme complexe. L'extension de SQL en un véritable langage de programmation impératif s'appelle PGPLSQL. Un exemple (simple) :\n\n\n```{.sql}\nCREATE \n\tinteger, y integer) RETURNS INTEGER AS $$\nDECLARE\nq INTEGER := 0;\nBEGIN\nq := x+y;\nRETURN q;\nEND\n$$ LANGUAGE plpgsql;\n```\n\n\n\n\n## Exemples simples\n\nDans cette partie, on se contente de construire des fonctions contenant simplement des requêtes avec paramètres.\n\nConsidérons par exemple,  une fonction SQL `film_id_cat` qui prend en paramètre une chaîne de caractère *s* et renvoie la liste des films de catégorie *s*. La forme générale (plus simple) sera :\n\n```{.sql}\nCREATE OR RE\n\tentid.film_id_cat(s TEXT)\nRETURNS TABLE(film_id INTEGER)\nAS\n$$\nrequete\n$$ LANGUAGE sql;\n```\n\n\n\n\n\n- Préciser le corps de la fonction ci-dessus pour qu'elle renvoie  la liste des films de catégorie *s*. Créez cette fonction dans votre schéma.\n\n\n::: {.content-visible when-profile=\"solution\"}\n\nAttention, dans certaines implémentations de sakila, il y a un champs `last_update` qui du coup rend impossible l'utilisation de la jointure naturelle.\n\n```{.sql}\nCREATE OR RE\ndurand.film_id_cat(s text)\nRETURNS TABLE(film_id smallint)\nAS $$\nSELECT fc.film_id\nFROM sakila.film_category  fc,  sakila.category c\nWHERE  c.category_id = fc.category_id AND  c.name=s;\n$$ language sql;\n```\n:::\n\n- Utilisez cette fonction pour déterminer dans une requête les acteurs qui ont déjà joué dans un film d'horreur (catégorie `Horror`) ?\n\n::: {.content-visible when-profile=\"solution\"}\n\n\n```{.sql}\nSELECT\n\n         FROM sakila.actor ac  JOIN\n         (SELECT * FROM sakila.film_actor\n         WHERE film_id IN (SELECT * FROM durand.film_id_cat('Horror') )) fa\nusing(actor_id);\n```\n\nou\n```{.sql}\nSELECT\nFROM sakila.actor ac NATURAL JOIN\nsakila.film_actor NATURAL JOIN\nfilm_id_cat('Horror') ;\n```\n:::\n\n- De même pour connaitre les acteurs qui n'ont jamais joué dans une comédie\n\n::: {.content-visible when-profile=\"solution\"}\n\n\n```{.sql}\nSELECT DISTINCT \n, ac_first_name\nFROM sakila.actor ac\nWHERE NOT EXISTS\n(SELECT * FROM sakila.film_actor fa\nWHERE film_id IN (SELECT * FROM entid.film_id_cat('Comedy'))\nAND fa.actor_id = ac.actor_id);\n```\n\n:::\n\n\n\n- Écrire une fonction `actor_category(nom character varying(49), prenom character varying(49))` qui prend en argument le nom et le prénom d'un acteur (d'une actrice)\net renvoie la liste des noms des catégories de films dans lesquels il/elle a joué (schéma : `sakila`).\n\n-  Écrire une fonction `co_actors(nom character varying(49), prenom character varying(49))` qui renvoie les noms et prénoms des acteurs qui jouent dans un film où apparaît un acteur ou une actrice dont le nom et le prénom sont donnés en argument (schéma : `sakila`).\n\n## Fonctions plpgsql\n\nOn considère maintenant des fonctions un tout petit peu plus évoluées contenant des requêtes et des structures de contrôle pgplsql.\n\n\n- Ecrire une fonction `inventory_in_stock(p_inventory_id integer)` prenant en entrée un numéro d'inventaire de DVD et renvoyant vrai si le DVD est en stock et faux sinon. Un DVD est en stock s'il n'a jamais été loué ou si toutes les lignes le concernant dans la table d'emprunt ont des champs de retour d'emprunt (`return_date`) renseignés.\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n```{.sql}\nCREATE OR REPLACE FUNCTION\n inventory_in_stock(p_inventory_id integer)\nRETURNS boolean\nLANGUAGE plpgsql\nAS $$\nDECLARE\nv_rentals INTEGER;\nv_out     INTEGER;\nBEGIN\nSELECT count(*) INTO v_rentals\nFROM rental\nWHERE inventory_id = p_inventory_id;\n\nIF v_rentals = 0 THEN RETURN TRUE;\nEND IF;\n\nSELECT COUNT(rental_id) INTO v_out\nFROM inventory LEFT JOIN rental USING(inventory_id)\nWHERE inventory.inventory_id = p_inventory_id\nAND rental.return_date IS NULL;\n\nIF v_out > 0 THEN\nRETURN FALSE;\nELSE\nRETURN TRUE;\nEND IF;\nEND $$;\n```\n\n:::\n\n\n\n- Écrire une fonction `film_in_stock(f_id sakila.film.film_id%TYPE)` prenant en paramètre l'identifiant d'un film et renvoyant le nombre d'exemplaires en stock. On se servira de la fonction de la question précédente.\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n```{.sql}\nCREATE OR REPLACE FUNCTION\n film_in_stock(f_id sakila.film.film_id%TYPE)\nRETURNS INTEGER\nLANGUAGE plpgsql\nAS $$\nDECLARE\nnb INTEGER;\nBEGIN\nSELECT count(*) into nb\nfrom film JOIN inventory USING(film_id)\nWHERE film_id=f_id AND inventory_in_stock(inventory.inventory_id)=TRUE;\n\nreturn NB;\nEND $$;\n```\n\n:::\n\n\n- Écrire une fonction `stock_total()` renvoyant pour chaque film le nombre d'exemplaires en stock. On donnera deux versions :\n\n- Une première renvoyant une table avec deux colonnes :  une pour l'identifiant de film et une autre pour le nombre d'exemplaires en stock.\n- Une renvoyant, pour chaque film, une phrase du genre : \"le film A a N exemplaires en stock\"\n\nPour s'aider, regarder la documentation des instructions  `RETURN NOTICE` et `RAISE NOTICE`.\n\n::: {.content-visible when-profile=\"solution\"}\n\n```{.sql}\nCREATE OR REPLACE FUNCTION\n stock_total()\nRETURNS TABLE(f_id sakila.film.film_id%TYPE, nb INTEGER)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n\nFor f_id in select film_id from film\nLOOP\nSELECT count(*) into nb\nfrom film JOIN inventory USING(film_id)\nWHERE film_id=f_id AND inventory_in_stock(inventory.inventory_id)=TRUE;\nRETURN NEXT;\nEND LOOP;\nEND $$\n;\n\n\nCREATE OR REPLACE FUNCTION stock_total_bis()\nRETURNS void\nLANGUAGE plpgsql\nAS $$\nDECLARE\nf_id sakila.film.film_id%TYPE;\nnb INTEGER;\nBEGIN\n\nFor f_id in select film_id from film\nLOOP\nSELECT count(*) into nb\nfrom film JOIN inventory USING(film_id)\nWHERE film_id=f_id AND inventory_in_stock(inventory.inventory_id)=TRUE;\nRAISE NOTICE 'le film % a % exemplaires en stock',f_id,nb;\nEND LOOP;\nEND $$;\n```\n\n:::\n\n\n\n- Comment trouver le nombre total d'exemplaires en stock, tous films confondus  ? donner une requête.\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n```{.sql}\nselect *  from stock_total();\n```\n\n:::\n\n\n\n\n\n\n",
    "supporting": [
      "td-fonction1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}