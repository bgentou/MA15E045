{
  "hash": "e68132080035cab5b26ea1c4db3c5e85",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"TD 4 : SQL\"\nsubtitle: \"Aggrégations, Partitions, Fenêtres\"\ncategories: [world, SQL, Aggregation, Fenêtres]\ndate: \"2025-10-17\"\n\nformat:\n  pdf:\n    output-file: td4.pdf\n    include-in-header:\n      - text: \"\\\\lhead{{\\\\sf  Base de données \\\\\\\\ TD 4}}\"\n  html:\n    output-file: td4.html\n\nengine: knitr\n---\n\n\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-warning}\n\n### Avec solutions\n\n:::\n\n:::\n\n\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n|                            |\n|:---------------------------|\n| {{< var curriculum >}}     |\n| {{< var university >}}     |\n| [Année {{< var year >}}]() |\n| {{< var homepage >}}       |\n| {{< var moodle >}}         |\n\n\n::: \n\n::: {#second-column}\n![](../images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::\n\n:::\n\n\n\n[Documentation Postgres](https://www.postgresql.org/docs/current/index.html){target=\"_blank\"}\n\n[Documentation Postgres en Français](https://docs.postgresql.fr){target=\"_blank\"}\n\n\n@. Écrire une requête qui compte le nombre de langues parlées dans chaque pays.\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\nSELECT \n  countrycode, COUNT(language)\nFROM \n  world.countrylanguage\nGROUP BY \n  countrycode;\n```\n:::\n:::\n\n\n\n@. Écrire une requête qui compte le nombre de langues parlées dans le monde.\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\n\nSELECT \n  COUNT(DISTINCT language)\nFROM \n  world.countrylanguage;\n```\n:::\n:::\n\n\n@. Écrire une requête qui compte le nombre de langues officielles par pays.\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\nUne solution presque bonne :\n\n```{.sql}\nSELECT countrycode, COUNT(language) AS nb_lg_official\nFROM world.countrylanguage\nWHERE isofficial \nGROUP BY countrycode\nORDER BY nb_lg_official, countrycode;\n```\n\nCependant, on perd les pays qui ne possèdent  pas de langue officielle. On va utiliser une jointure extérieure pour les conserver:\n\n```{.sql}\nSELECT c.countrycode, c.name_country, COUNT(cl.language) AS nb_lg_official\nFROM world.country c LEFT JOIN world.countrylanguage cl\n\t  ON (c.countrycode = cl.countrycode AND cl.isofficial)\nGROUP BY c.countrycode, c.name_country\nORDER BY nb_lg_official, c.countrycode;\n```\n\n*NB* : `L.isofficial` doit être dans la condition de jointure et pas dans un `WHERE`pour ne pas perdre les pays qui n'ont pas de langue officielle.\n:::\n:::\n\n\n\n\n@. Écrire une requête qui renvoie le nombre de langues officielles par pays en utilisant la fonction `SUM`.\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\nPresque correct :\n```{.sql}\nWITH s AS(\n    SELECT L.countrycode, sum(CAST (isofficial AS INTEGER)) AS nb_lg_official\n    FROM  world.countrylanguage as L\n    GROUP BY L.countrycode)\nSELECT s.*, c.name_country\nFROM world.country c JOIN s USING (countrycode)\nORDER BY s.nb_lg_official, s.countrycode;\n```\n\nMais on a perdu les pays qui n'apparaissent pas dans la table `countrylanguage`. Pour y remédier, il faut faire une jointure gauche et faire un `CASE WHEN` pour gérer les valeurs `NULL`. Ici, les valeurs `NULL` entrent dans le cas par défaut `ELSE`.\n\n```{.sql}\nSELECT c.countrycode, c.name_country, SUM(CASE WHEN cl.isofficial THEN 1 ELSE 0 END) AS nb_lg_official\nFROM world.country c LEFT JOIN world.countrylanguage cl USING (countrycode)\nGROUP BY c.countrycode, c.name_country\nORDER BY nb_lg_official, c.countrycode;\n```\n\nAu final, compter en faisant une somme n'est pas la meilleure idée.\n:::\n:::\n\n\n@. Écrire une requête qui renvoie la surface de chaque région.\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\nSELECT region, SUM(surfacearea)\nFROM world.country\nGROUP BY region;\n```\n:::\n:::\n\n\n@. Écrire une requête qui compte le nombre de francophones dans le monde.\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT ROUND(SUM((percentage/100)*population_country))\nFROM world.country JOIN world.countrylanguage USING (countrycode)\nWHERE language = 'French';\n```\n\n:::\n:::\n\n\n@. Combien de personnes vivent dans une capitale européenne ?\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\nSELECT SUM(ci.population)\nFROM world.country co \nJOIN world.city ci ON co.capital=ci.id\nWHERE co.continent='Europe';\n```\n\n:::\n:::\n\n\n@. Quelle est la capitale européenne la moins peuplée ?\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\nWITH r AS (\n   SELECT min(population) AS min\n   FROM world.country co \n      JOIN world.city ci ON co.capital=ci.id\n   WHERE co.continent='Europe' \n)\nSELECT ci.name, ci.population \nFROM city ci join r ON ci.population = r.min;\n```\n:::\n:::\n\n\n@. Quelle est la langue la plus parlée dans le monde ?\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\nWITH r AS \n(\n   SELECT language, ROUND(SUM((percentage/100)*population_country)) AS sum\n   FROM world.country JOIN world.countrylanguage USING (countrycode)\n   GROUP BY language\n),\ns AS\n(\n   SELECT MAX(sum) AS max\n   FROM r\n)\nSELECT language, r.sum AS nb_speaker \nFROM r JOIN s ON r.sum = s.max;\n```\n\nOn peut aussi utiliser un ordre descendant sur le nombre de locuteurs en faisant attention à bien gérer les valeurs nulles possibles. Car celles-ci fausses l'ordre.\n\nIci, pas de souci car les valeurs nulles sont interdites pour les attributs `country.population_country` et `countrylanguage.percentage`.\n\n```{.sql}\nSELECT \n   cl.language, ROUND(SUM((percentage/100)*population_country)) as nb_speaker\nFROM \n   world.country co JOIN world.countrylanguage cl USING(countrycode)\nGROUP BY cl.language\nORDER BY nb_speaker DESC\nLIMIT 1 ;\n``` \n:::\n:::\n\n\n\n@. Écrire une requête qui renvoie le nombre de pays par régime.\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\nSELECT governmentform AS regime, COUNT(countrycode) AS nb\nFROM  world.country\nGROUP BY governmentform\nORDER BY governmentform ;\n```\n:::\n:::\n\n\n@. Écrire une requête calculant le nombre de personnes vivant dans des villes de plus d'un million d'habitants.\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n```{.sql}\nSELECT \n  SUM(population) AS pop\nFROM \n  world.city\nWHERE \n  population >= 1000000 ;\n```\n:::\n:::\n\n\n@. Écrire une requête qui calcule le nombre total de personnes dans le monde qui n'habitent pas une ville listée dans la table `city`.\n   Réponse :  (4,649,189,566)\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH \n  pop_villes AS \n  (\n    SELECT \n      SUM(population) AS pop\n    FROM \n      world.city\n  ),\n  pop_totale AS \n  (\n    SELECT \n      SUM(population_country) AS pop\n    FROM \n      world.country\n  )\nSELECT \n  (pop_totale.pop - pop_villes.pop) as non_urban_population\nFROM \n  pop_totale, pop_villes ;\n```\n:::\n:::\n\n\n@. Écrire une requête qui compte le nombre moyen de langues parlées par pays dans chaque région.\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\nAvec la fonction `AVG()` :\n```{.sql}\nWITH nb_langues_parlees AS (\n   SELECT \n    countrycode, COUNT(language) nb\n   FROM  \n    world.countrylanguage\n   GROUP BY countrycode\n)\nSELECT \n  co.region, AVG(nb)\nFROM \n  world.country co JOIN nb_langues_parlees USING(countrycode)\nGROUP BY co.region\nORDER BY co.region;\n```\n\nSinon on faisant le calcul de moyenne \"à la main\" : \n\n```{.sql}\nWITH nb_langues_parlees AS (\n\tSELECT \n    countrycode, COUNT(language) nb\n\tFROM  \n    world.countrylanguage\n\tGROUP BY countrycode\n)\nSELECT \n  region, SUM(nb)/COUNT(DISTINCT countrycode)\nFROM \n  world.country co JOIN nb_langues_parlees USING(countrycode)\nGROUP BY region ;\n```\nLe `DISTINCT` dans `COUNT(DISTINCT countrycode)` est utile en général pour faire un calcul correct de moyenne. Cependant, ici, il est inutile car nous avons fait une jointure sur `countrycode` qui est à valeur unique dans les deux tables jointes.\n\n:::\n:::\n\n\n@. Écrire une requête qui donne la liste des pays ayant deux langues officielles parlées chacune par plus du quart de la population.\n\n   {{< fa hand-point-right >}} Pas besoin d'agrégation à cet endroit là.\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-note title=\"Solution\"}\n\n```{.sql}\nSELECT \n  cl1.countrycode, cl1.language, cl2.language\nFROM \n  countrylanguage AS cl1 \nJOIN \n  countrylanguage AS cl2 ON (\n    cl1.countrycode=cl2.countrycode AND \n    cl1.language < cl2.language AND\n    cl1.isofficial AND cl2.isofficial\n  ) \nWHERE cl1.percentage > 25 AND cl2.percentage > 25;\n```\n\n::: \n:::\n\n\n@. Écrire une fonction `plus_peuplee(p_countrycode text)` qui, étant donné le code d'un pays, renvoie le nom de la ville la plus peuplée de ce pays.\n\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\nEn remplaçant `monschema` par votre nom de schéma personnel :\n```{.sql}\nCREATE OR REPLACE monschema.plus_peuplee(p_countrycode text)\nRETURNS text \nLANGUAGE sql AS $$\nWITH  m AS (\n  SELECT \n    MAX(population) AS m_pop\n  FROM\n    world.city ci\n  WHERE \n    ci.countrycode = p_countrycode\n)\nSELECT \n  ci.name   \nFROM \n  world.city ci, m  \nWHERE ci.countrycode = p_countrycode\n  AND ci.population = m_pop;\n$$ ;\n-- Utilisation de la fonction\nSELECT monschema.plus_peuplee('FRA');\nSELECT monschema.plus_peuplee('USA');\n```\n::: \n:::\n\n\n@. Écrire une fonction `langues_region(p_continent text)` qui étant donné le nom d'un continent, renvoie le nombre moyen de langues parlées par pays dans chaque région. L'entête de cette fonction doit être : \n\n\n```{.sql}\nFUNCTION langues_region(p_continent TEXT) \nRETURNS TABLE(region TEXT, nbmoy NUMERIC)\n```\n\n::: {.content-visible when-profile='solution'}  \n::: {.callout-tip title=\"Solution\"}\nEn remplaçant `monschema` par votre nom de schéma personnel :\n\n```{.sql}\nCREATE OR REPLACE FUNCTION monschema.langues_region(p_continent TEXT)\nRETURNS TABLE(region TEXT, nbmoy NUMERIC)\nLANGUAGE SQL AS $$\nWITH S AS (\n  SELECT \n    R.region, cl.countrycode, COUNT(cl.language) AS n_l\n  FROM \n    (\n      SELECT \n        co.region, co.countrycode\n      FROM\n        world.country co\n      WHERE \n        co.continent = p_continent\n    ) AS R\n  JOIN \n    world.countrylanguage cl USING (countrycode)\n  GROUP BY \n    R.region, cl.countrycode\n)\nSELECT \n  region, AVG(n_l) AS nbmoy\nFROM \n  S\nGROUP BY \n  region ;\n$$ ;\nSELECT * FROM monschema.langues_region('Europe');\nSELECT * FROM monschema.langues_region('Asia');\n```\n::: \n:::\n\n\n@. Écrire une requête qui liste trois attributs, pour chaque pays où on parle français, ordonné par population croissante :\n\n  - `name_country`,\n  - `cumul_loc` qui donne le nombre cumulé de locuteurs du français dans les pays où on parle français, dans l'ordre croissant des populations des pays,\n  - `cum_pop` qui donne la population cumulée des pays où on parle français, dans l'ordre croissant des populations des pays. \n    \n::: {.callout-tip}\n\nUtilisez une fonction fenêtre (`WINDOW`) sans partition. \n\n:::\n\n::: {.callout-caution}\n\nPour trouver les pays où on parle français, utilisez l'expression `language like '%French%'`. Vous remarquerez que dans certains pays, il existe plusieurs variétés de 'French'. Veillez à compter les locuteurs de toutes les formes du Français. \n\nQue se passe-t-il si un locuteur parle plusieurs formes de Français ?   \n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH f AS (\n  SELECT \n    cl.countrycode, SUM(cl.percentage) AS percentage\n  FROM \n    world.countrylanguage cl\n  WHERE \n    cl.language LIKE '%French%'\n   GROUP BY \n    cl.countrycode\n)\nSELECT \n  co.name_country, \n  SUM(ROUND(f.percentage * co.population_country/100)) OVER w AS cumul_loc,\n  SUM(co.population_country) OVER w AS cum_pop\nFROM  \n  f JOIN world.country co USING(countrycode)\nWINDOW w AS (\n  ORDER BY co.population_country \n);\n```\n**Problème** : si une même personne parle plusieurs formes de Français, elle est comptabilisée autant de fois comme locuteur du Français. Mais aucune information dans la table ne permet de distinguer ce cas de figure.\n\n\n:::\n:::\n\n\n<!--\n@. Ecrire une fonction `actor_category(p_nom text, p_prenom text)` qui prend en argument le nom et le prénom d'un acteur (d'une actrice) et renvoie la liste des noms des catégories de films dans lesquels il/elle a joué (schéma : `pagila`).\n\n\n::: {.content-visible when-profile='solution'} \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nCREATE FUNCTION public.actor_category(p_nom text, p_prenom text)\nRETURNS text \nLANGUAGE SQL AS \n$$\nSELECT \n  string_agg(DISTINCT pc.name, ', ')\nFROM \n  (SELECT \n    actor_id\n  FROM\n    pagila.actor \n  WHERE \n    last_name = p_nom AND \n    first_name = p_prenom\n  ) as pa \nJOIN \n  pagila.film_actor as pfa USING(actor_id)\nJOIN \n  pagila.film_category as pfc USING(film_id)\nJOIN \n  pagila.category as pc USING(category_id) ;\n$$ ;\n```\n\n```{.sql}\nbd_2023-24=# SElECT public.actor_category('LOLLOBRIGIDA', 'JOHNNY') ;\n                                               actor_category                                               \n------------------------------------------------------------------------------------------------------------\n Action, Animation, Children, Comedy, Documentary, Drama, Games, Horror, Music, New, Sci-Fi, Sports, Travel\n(1 row)\n```\n::: \n:::\n\n::: {.callout-note title=\"Question\"}\n  \n@. Ecrire une fonction `co_actors(p_nom text, p_prenom text)` qui renvoie les noms et prénoms des acteurs qui jouent dans un film où apparaît un acteur ou une actrice dont le nom et le prénom sont donnés en argument (schéma : `pagila`).\n\n:::\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nCREATE OR REPLACE FUNCTION public.co_actors(p_nom text, p_prenom text)\nRETURNS TABLE(nom text, prenom text) \nLANGUAGE SQL AS \n$$\nSELECT \n  DISTINCT pa2.last_name as nom, pa2.first_name as prenom\nFROM \n  (SELECT \n    actor_id\n  FROM\n    pagila.actor \n  WHERE \n    last_name = p_nom AND \n    first_name = p_prenom\n  ) as pa \nJOIN \n  pagila.film_actor as pfa1 USING(actor_id)\nJOIN \n  pagila.film_actor as pfa2 ON (\n    pfa1.film_id=pfa2.film_id AND \n    pfa1.actor_id<>pfa2.actor_id \n    )\nJOIN \n  pagila.actor as pa2 ON (pa2.actor_id=pfa2.actor_id) \nORDER BY nom, prenom;\n$$ ;\n```\n::: \n \n:::\n\n\n-->\n\n\n<!--\n# Fonctions d'agrégation\n\nLes fonctions d'*agrégation* permettent d'effectuer des opérations avancées sur les solutions d'une requête (sur une table) comme : compter les lignes, sélectionner le maximum dans une colonne, etc. \n\nUne des opérations les plus courantes est de compter. `COUNT(col)` permet de compter les résultats d'une requête. \n\n## Count\n\nPour compter les pays en Europe, on écrira :\n\n```{.sql}\nSELECT COUNT(countrycode)\nFROM world.country\nWHERE continent='Europe';\n```\n\nCette requête renvoie une table ayant *une* ligne et *une* colonne contenant le nombre de lignes dans le résultat de la requête. \n\n# GROUP BY\n\nAdmettons qu'on veuille compter les pays par continent. On doit alors utiliser la clause `GROUP BY` :\n\n```{.sql}\nSELECT \n  continent, COUNT(countrycode)\nFROM \n  world.country\nGROUP BY \n  continent;\n```\n\nCette requête regroupe les lignes de la table `country` par valeur de la colonne `continent` et pour chaque groupe, compte le nombre de `countrycode` y apparaissant. Lorsque plusieurs lignes sont susceptibles d'avoir la même valeur, on peut compter seulement le nombre d'occurences distinctes avec `COUNT(DISTINCT col)`.\n\n-->\n\n<!--\n\n## Sum, Max, Min, Avg\n\nUne autre fonction importante est la fonction `SUM(col)` qui effectue la somme des valeurs (numériques) d'une colonne :\n\n```{.sql}\nSELECT SUM(population_country)\nFROM world.country;\n```\n\nrenvoie la population mondiale. \n\nOn peut de même utiliser `GROUP BY` pour faire des paquets :\n\n```{.sql}\nSELECT \n  continent, SUM(population_country)\nFROM \n  world.country\nGROUP BY continent;\n```\n\nrenvoie la population de chaque continent. \n\nOn peut même faire des opérations sur la colonne à l'intérieur de `SUM`. Par exemple: `SUM(percentage/100)`.\n-->\n\n<!--\n# Having\n\nParfois, on veut filtrer les requêtes en fonction du résultat d'une fonction d'agrégation. \n\nPar exemple, pour connaître les langues officielles dans plus de 10 pays, on serait tenté d'écrire :\n\n```{.sql}\nSELECT \n  language \nFROM \n  world.countrylanguage\nWHERE \n  COUNT(countrycode) > 10 AND isofficial \nGROUP BY language;\n```\n\n\n::: {.callout-caution}\n\nCela ne fonctionne pas. `WHERE` applique une condition sur chaque ligne de la table pour les filtrer, par exemple, garder seulement les langues officielles. Ici, on veut  *ensuite* sélectionner les lignes après avoir regroupé par langue et compté. \n\n:::\n\nOn utilisera alors `HAVING`, après la clause  `GROUP BY`:\n\n```{.sql}\nSELECT \n  language -- <5>\nFROM \n  world.countrylanguage  -- <1>\nWHERE \n  isofficial            -- <2>\nGROUP BY language           -- <3>\nHAVING \n  COUNT(countrycode) > 10; -- <4>\n```\n1. La requête concerne la table `world.countrylanguage`,\n2. On filtre les lignes qui correspondent à des langues officielles,\n3. On groupe/partitionne la table filtrée selon la langue,\n4. On ne garde que les groupes comportant au moins 10 tuples,\n5. On projette le résultat sur la colonne `language`.\n-->",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}