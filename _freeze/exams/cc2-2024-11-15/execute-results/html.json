{
  "hash": "106af4a2cd5381990574291ceb440650",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat:\n  pdf:\n    code-annotations: below\n    code-fold: false\n    toc: false\n    output-file: cc2-2024-11-15.pdf\n    include-in-header:\n      - text: \"\\\\lhead{{\\\\sf  Base de données (BD5) \\\\\\\\ CC 2 2024-11-15  17h00-18h15}}\"\n  html:\n    standalone: true\n    code-fold: true\n    output-file: cc2-2024-11-15.html\nparams:\n    year: 2024 \n    curriculum: \"L3 MIASHS/Ingémath/METIS\"\n    university: \"Université Paris Cité\"\n    homepage: \"https://stephane-v-boucheron.fr/courses/bdd\"\n    moodle: \"https://moodle.u-paris.fr/course/view.php?id=2313\"\n\nengine: knitr\n---\n\n\n\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n\n- **L3 MIASHS/Ingémath/METIS**\n- **[Université Paris Cité](https://www.u-paris.fr)**\n- Année 2024-2025\n- [Course Homepage](https://stephane-v-boucheron.fr/courses/bdd)  \n- [Moodle](https://moodle.u-paris.fr/course/view.php?id=2313)\n\n::: \n\n::: {#second-column}\n![](../images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::\n\n:::\n\n::: {.content-hidden when-profile=\"solution\"}\n::: {.callout-caution}\n\n- Pas de documents autorisés\n- Pas de téléphone portable \n- Merci d'écrire vos requêtes en respectant les habitudes  d'indentation et de mise en page suivies en cours et dans les documents.\n\n:::\n:::\n\n::: {.callout-warning}\n\nToutes les questions portent sur les schémas `pagila`  et `world` rappelés ci-dessous.\n\nPour chaque question, proposer une requête écrite en algèbre relationnelle *OU* en `SQL`. \n\n:::\n\n\n![Schéma `world`](../images/schema-world.png){width=\"70%\"}\n\n\n\n![Schéma `pagila`, films](../images/schema-pagila.png){width=12cm}\n\n\n{{< pagebreak >}}\n\n## Schéma `pagila` {{< fa file-video >}}\n\n1. Lister  la somme des paiments encaissés par année et par magasin. \n\n\n\n::: {.callout-tip}\n\nEn PostgreSQL, on obtient le (numéro du) mois à partir d'une valeur de type `timestamp` avec la fonction  `EXTRACT()`. On peut extraire les autres éléments de l'estampille de façon semblable, par exemple :\n\n```sql\nSELECT \n  EXTRACT(YEAR FROM rental_date) AS annee\nFROM \n  pagila.rental;\n```\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT \n  st.store_id,\n  EXTRACT(YEAR FROM pay.payment_date) AS annee,\n  SUM(amount) AS payments\nFROM \n  pagila.payment pay \nJOIN \n  pagila.staff st USING(staff_id)\nGROUP BY \n  st.store_id, \n  EXTRACT(YEAR FROM pay.payment_date)\n;\n```\n\n:::\n:::\n\n\n2. Lister l'identifiant, le nom, le prénom, de chaque employé ainsi que le total des paiements perçus par cet employé, et sa part dans le revenu de son magasin.\n   \n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT \n  st.store_id,\n  st.staff_id,\n  SUM(pay.amount) AS encaisse\nFROM  \n  pagila.staff st\nJOIN \n  pagila.payment pay USING(staff_id)\nGROUP BY ROLLUP(st.store_id, st.staff_id) ;   \n```\n\n{{< pagebreak >}}\n\n:::\n:::\n\n\n\n\n3. Lister par catégorie de film, les cinq titres qui ont engendré le plus gros chiffre d'affaire/revenu (somme des paiements perçus)\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH film_payment AS (\n   SELECT\n     film_id, \n     fi.title,\n     SUM(amount) AS caffaires\n   FROM\n     pagila.payment pay \n   JOIN \n     pagila.rental re USING(rental_id)\n   JOIN \n     pagila.inventory inv USING(inventory_id)\n   JOIN \n     pagila.film fi USING(film_id)\n   GROUP BY \n     film_id, fi.title\n), rank_per_cat AS (\n  SELECT \n    category_id,\n    ca.name, \n    film_id,\n    title, \n    caffaires,\n    RANK() OVER win AS rnk\n  FROM \n    film_payment fp \n  JOIN  \n    pagila.film_category fc USING(film_id)\n  JOIN\n    pagila.category ca USING(category_id)\n  WINDOW win AS (PARTITION BY category_id ORDER BY caffaires DESC)\n)\n\nSELECT \n  name, \n  title, \n  caffaires, \n  rnk\nFROM rank_per_cat\nWHERE rnk <= 5\nORDER BY name, rnk\n;\n```\n\n\n{{< pagebreak >}}\n\n:::\n:::\n\n\n\n\n\n## Schéma `world`   {{< fa globe >}}\n\n\n4. Lister pour chaque pays, la proportion de la population qui utilise l'une des deux \nlangues les plus populaires du pays, \n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH ranking AS (\n   SELECT \n     countrycode, name_country, language, percentage,\n     RANK() OVER win AS rnk\n   FROM \n     world.country co\n   JOIN \n     world.countrylanguage cl USING(countrycode)\n   WINDOW \n     win AS (PARTITION by countrycode ORDER BY percentage DESC)\n) \n\nSELECT\n  countrycode, name_country, \n  SUM(percentage) AS prop\nFROM \n  ranking\nWHERE \n  rnk <= 2\nGROUP BY countrycode, name_country \nORDER BY prop DESC;\n\n\n```\n\n:::\n\n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\n```\n{{< pagebreak >}}\n:::\n\n:::\n\n\n\n5. Lister pour chaque région (attribut `region` de `country`) les 10 villes les plus peuplées.\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH R AS (\n   SELECT \n     co.countrycode, co.name_country,\n     ci.name,\n     RANK() OVER win AS rnk\n   FROM \n     world.country co\n   JOIN \n     world.city ci USING(countrycode)\n   WINDOW win AS (PARTITION BY co.countrycode ORDER BY ci.population DESC)\n )\n \nSELECT\n  name_country, \n  string_agg(name, ', ')\nFROM \n  R\nWHERE rnk <= 2\nGROUP BY countrycode, name_country\n ;\n\n```\n{{< pagebreak >}}\n:::\n:::\n\n\n\n6. Lister pour chaque langue, les deux pays où on trouve le plus grand nombre d'utilisateurs.\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH R AS (\n   SELECT \n     language, \n     name_country, \n     percentage*population_country/100.0 AS pop_loc,\n     RANK() OVER win AS rnk \n   FROM \n     world.countrylanguage cl \n   NATURAL JOIN \n     world.country\n   WHERE \n     population_country IS NOT NULL\n   WINDOW win AS (PARTITION BY language ORDER BY percentage*population_country DESC)\n)\n\nSELECT \n  language, \n  string_agg(name_country, ', ') AS pays, SUM(pop_loc) AS loc \nFROM \n  R \nWHERE rnk <=  2\nGROUP BY language ;\n```\n\n:::\n:::\n\n7. Lister les pays en donnant leur rang par `gnp` (`pnb`) par habitant décroissant et leur rang par espérance de vie à la naissance (`lifeexpectancy`) décroissante.  \n\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT \n  name_country, \n  lifeexpectancy , \n  RANK() OVER win_gnp AS rnk_gnppercap,\n  RANK() OVER win_life AS rnk_lifeexp\nFROM \n  world.country\nWHERE \n  gnp IS NOT NULL AND \n  population_country IS NOT NULL AND \n  lifeexpectancy IS NOT NULL\nWINDOW \n  win_gnp AS (ORDER BY gnp/population_country DESC),\n  win_life AS (ORDER BY lifeexpectancy DESC)\nORDER BY lifeexpectancy DESC ;\n```\n:::\n:::",
    "supporting": [
      "cc2-2024-11-15_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}