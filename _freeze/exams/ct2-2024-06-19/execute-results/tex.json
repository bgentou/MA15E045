{
  "hash": "022d2e8d890066ab1e9243f18d3cee47",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat:\n  pdf:\n    code-annotations: below\n    keep-tex: false\n    code-fold: false\n    toc: false\n    output-file: ct-2024-06-19.pdf\n    include-in-header:\n      - text: \"\\\\lhead{{\\\\sf  Base de données \\\\\\\\ CT 2024-06-19 14h-16h}}\"\n  html:\n    standalone: true\n    code-fold: true\n    output-file: ct-2024-06-19.html\nparams:\n    year: 2023 \n    curriculum: \"L3 MIASHS/Ingémath\"\n    university: \"Université Paris Cité\"\n    homepage: \"https://stephane-v-boucheron.fr/courses/bdd\"\n    moodle: \"https://moodle.u-paris.fr/course/view.php?id=2313\"\nengine: knitr\nexecute: \n  eval: true\n  echo: false\n  include: false\n---\n\n\n\n\n\n\n::: {layout=\"[80,20]\"} \n\n::: {#first-column}\n\n\n\n- **L3 MIASHS/Ingémath** \n- **[Université Paris Cité](https://www.u-paris.fr)**\n- Année 2023-2024\n- [Course Homepage](https://stephane-v-boucheron.fr/courses/bdd)  \n- [Moodle](https://moodle.u-paris.fr/course/view.php?id=2313)\n\n::: \n\n::: {#second-column}\n\n![](/images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n\n:::\n\n:::\n\n\n\n::: {.content-hidden when-profile=\"solution\"}\n\n::: {.callout-caution}\n\n- Pas de documents autorisés\n- Pas de téléphone portable \n\n:::\n\n:::\n\n::: {.callout-warning}\n\nLes requêtes portent sur \nle schéma `nycflights` légèrement nettoyé. \n\n:::\n\n\n![NYCFlights en relationel à pattes de corbeau](/images/nycflights_layout_crop.png){width=\"80%\"}\n\n\n\n\n{{< pagebreak >}}\n\n\n\n\n\n\n<!-- {{< include nycflights_layout.qmd >}} -->\n\n\n\n### Définition du schéma en SQL\n\n\n::: {layout=\"[50,50]\"}\n\n::: {#first-column}\n\n\n```{.sql}\nCREATE TABLE airlines (\n\tcarrier text NOT NULL,\n\t\"name\" text NULL,\n\tCONSTRAINT airlines_pk \n        PRIMARY KEY (carrier),\n\tCONSTRAINT airlines_un \n        UNIQUE (name)\n);\n```\n\n```{.sql}\nCREATE TABLE airports (\n\tfaa text NOT NULL,\n\t\"name\" text NULL,\n\tlat float8 NULL,\n\tlon float8 NULL,\n\talt float8 NULL,\n\ttz float8 NULL,\n\tdst text NULL,\n\ttzone text NULL,\n\tCONSTRAINT airports_pk \n        PRIMARY KEY (faa),\n\tCONSTRAINT airports_un \n        UNIQUE (name),\n\tCONSTRAINT airports_un_ll \n        UNIQUE (lat, lon)\n);\n```\n\n\n\n:::\n\n::: {#second-column}\n\n\n```{.sql}\nCREATE TABLE weather (\n\torigin text NOT NULL,\n\t\"year\" int4 NULL,\n\t\"month\" int4 NULL,\n\t\"day\" int4 NULL,\n\t\"hour\" int4 NULL,\n\t\"temp\" float8 NULL,\n\tdewp float8 NULL,\n\thumid float8 NULL,\n\twind_dir float8 NULL,\n\twind_speed float8 NULL,\n\twind_gust float8 NULL,\n\tprecip float8 NULL,\n\tpressure float8 NULL,\n\tvisib float8 NULL,\n\ttime_hour timestamptz NOT NULL,\n\tCONSTRAINT weather_pk \n        PRIMARY KEY (origin, time_hour)\n);\n```\n\n```{.sql}\nALTER TABLE weather ADD \n    CONSTRAINT weather_fk \n    FOREIGN KEY (origin) \n    REFERENCES airports(faa) \n    ON DELETE CASCADE \n    ON UPDATE CASCADE;\n```\n\n:::\n\n:::\n\n```{.sql}\nCREATE TABLE planes (\n\ttailnum text NOT NULL,\n\t\"year\" int4 NULL,\n\t\"type\" text NULL,\n\tmanufacturer text NULL,\n\tmodel text NULL,\n\tengines int4 NULL,\n\tseats int4 NULL,\n\tspeed int4 NULL,\n\tengine text NULL,\n\tCONSTRAINT planes_pk   PRIMARY KEY (tailnum)\n);\n```\n\n\n::: {layout=\"[50,50]\"}\n\n::: {#first-column}\n\n```{.sql}\nCREATE TABLE flights (\n\t\"year\" int4 NULL,\n\t\"month\" int4 NULL,\n\t\"day\" int4 NULL,\n\tdep_time int4 NULL,\n\tsched_dep_time int4 NULL,\n\tdep_delay float8 NULL,\n\tarr_time int4 NULL,\n\tsched_arr_time int4 NULL,\n\tarr_delay float8 NULL,\n\tcarrier text NULL,\n\tflight int4 NULL,\n\ttailnum text NOT NULL,\n\torigin text NOT NULL,\n\tdest text NULL,\n\tair_time float8 NULL,\n\tdistance float8 NULL,\n\t\"hour\" float8 NULL,\n\t\"minute\" float8 NULL,\n\ttime_hour timestamptz NOT NULL,\n\tCONSTRAINT flights_pk \n        PRIMARY KEY (\n            tailnum, origin, time_hour)\n);\n```\n\n:::\n\n\n\n::: {#second-column}\n\n```{.sql}\nALTER TABLE flights ADD \n    CONSTRAINT flights_fk \n    FOREIGN KEY (carrier) \n    REFERENCES airlines(carrier) \n    ON DELETE SET NULL \n    ON UPDATE CASCADE;\n```\n\n```{.sql}\nALTER TABLE flights ADD \n    CONSTRAINT flights_fk_dest \n    FOREIGN KEY (dest) \n    REFERENCES airports(faa) \n    ON DELETE SET NULL \n    ON UPDATE CASCADE;\n```\n\n```{.sql}\nALTER TABLE flights ADD \n    CONSTRAINT flights_fk_origin \n    FOREIGN KEY (origin) \n    REFERENCES airports(faa) \n    ON DELETE SET NULL \n    ON UPDATE CASCADE;\n```\n\n```{.sql}\nALTER TABLE flights ADD \n    CONSTRAINT flights_fk_planes \n    FOREIGN KEY (tailnum) \n    REFERENCES planes(tailnum) \n    ON DELETE SET NULL \n    ON UPDATE CASCADE;\n```\n\n:::\n\n:::\n\n\n\n\n\n\nDans le schéma `nycflights`, on a aussi les dépendances fonctionnelles suivantes:\n\nTable `airports`\n\n- `faa`, `name`, et `(lon, lat)` sont des clés. \n\nTable `airlines`\n\n- `carrier` et `name` sont des clés\n\nTable `weather`\n\n- `origin, time_hour` est une clé\n- `time_hour → year, month, day, hour`\n- `year, month, day, hour  → time_hour`\n\nTable `planes`\n\n- `tailnum` est une clé\n- `model → manufacturer, engines, engine, type`\n\nTable `flights`\n\n- `tailnum, time_hour → carrier`\n- `time_hour → sched_dep_time`\n- `sched_dep_time, dep_time → dep_delay`\n- `sched_arr_time, arr_time → arr_delay`\n- `origin, dest, dep_time, arr_time → airtime`\n- `time_hour → year, month, day, hour, minute`\n- `year, month, day, hour, minute → time_hour`\n- `origin, dest → distance`\n- `(tailnum, origin, time_hour)` est une clé\n- `(flight, dest, origin, year, month, day)` est une clé\n\n\n<!-- Pour chaque exercice -->\n\n::: {.content-hidden}\n\n::: {.callout-note title=\"Exercice : Modélisation\" icon=\"false\"}\n\n<!-- Énoncé --> \n\nLe schéma entité-association est une tentative de rétro-ingénieurie du schéma \nrelationnel `nycflights`.\n\n![](../images/nycflight_er.png){width=\"70%\" fig-align=\"right\"}\n\n\n:::\n\n\n:::\n\n\n::: {.content-hidden}\n\n\n::: {.callout-note}\n\n### Question\n\n\n\nProposez une variation de la représentation de l'entité `plane` où \non définit une entité `model` (dont les instances seraient par exemple `Airbus A350`, `Boeing 777`, ...), et où chaque avion/aéronef serait considéré comme une réalisation d'une instance de `model`). \n\nPréciser la nature de l'association entre `plane`  et `model` et les cardinalités.\n\nPrécisez la répartition des attributs entre `plane` et `model`.\n\n:::\n\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n\n:::\n:::\n\n<!-- {{< pagebreak >}} -->\n\n<!-- Pour chaque exercice -->\n::: {.content-hidden}\n\n::: {.callout-note title=\"Exercice : Normalisation\" icon=\"false\"}\n\n<!-- Énoncé --> \n\n\n\n\n\n\n\n\n\n:::\n:::\n\n::: {.content-hidden}\n\n::: {.callout-note}\n\n### Question 1\n\n\n\n\n\n\n\n\n\nPour chaque table, préciser si elle est en FNBC ou non.\n\n:::\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n\n:::\n:::\n\n::: {.content-hidden}\n\n::: {.callout-note}\n\n### Question 2\n\n\n\n\n\n\n\n\n\n\n\n:::\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.callout-note title=\"Exercice : Requêtes  (schéma `nycflights`)\" icon=\"false\"}\n\n\n\n\n\n\n\n:::\n\n\n::: {.callout-note}\n\n### Requête 1\n\n\n\n\n\n\n\n\n\n<!-- Énoncé --> \n<!-- jointure + requête imbriquée -->\nPour chaque couple origine/destination, lister les caractéristiques de l'avion le plus rapide sur la liaison. \n\n:::\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH R As (\n  SELECT f.origin, f.dest, f.tailnum, RANK() OVER w AS rnk\n  FROM flights AS f\n  WHERE f.airtime IS NOT NULL\n  WINDOW w AS (PARTITION BY f.origin, f.dest ORDER by f.airtime DESC)\n) \n\nSELECT R.origin, R.dest, p.* \nFROM (SELECT * FROM R WHERE R.rnk=1) AS S \n  JOIN planes as p \n  ON (R.tailnum=p.tailnum) ;\n```\n\n\n```{.sql}\nWITH R As (\n  SELECT f.origin, f.dest, min(f.airtime) as min_time\n  FROM flights AS f\n  WHERE f.airtime IS NOT NULL\n  GROUP BY f.origin, f.dest \n), S AS (\n  SELECT f.origin, f.dest, f.tailnum\n  FROM flights AS f NATURAL JOIN R \n  WHERE f.airtime = R.min_time\n)\n\nSELECT S.origin, S.dest, p.* \nFROM S  \n  JOIN planes as p \n  ON (S.tailnum=p.tailnum) ;\n```\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Requête 2\n\n\n\n\n\n\n\n\n\n<!-- Énoncé --> \n<!-- Énoncé --> \n<!-- jointure + agregation -->\n\nPour chaque aéroport d'origine, déterminer pour chaque heure de la jourńee, les températures maximales et minimales\n\n:::\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH o AS (\n  SELECT DISTINCT f.origin\n  FROM flights as f \n)\nSELECT w.origin, w.hour, MAX(w.temp), MIN(w.temp)\nFROM o NATURAL JOIN weather w \nGROUP BY w.hour ;\n```\n\n\n:::::\n\n:::\n\n\n::: {.callout-note}\n\n### Requête 3\n\n\n\n\n\n\n\n\n\n<!-- deux jointures ou plutôt une requête imbriquée et une jointure  -->\n\nPour chaque aéroport d'origine, pour chaque température enregistrée en début d'heure, arrondie à l'entier le plus proche, indiquer la proportion de vols avec un retard supérieur à 30 mn au décollage.\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH R AS (\n  SELECT f.origin, f.year. f.month, f.day, f.hour, f.flight, f.dep_delay, ROUND(w.temp, 0) as t\n  FROM flights f JOIN weater w ON\n    (f.origin=w.origin AND \n     f.year=w.year AND \n     f.month=w.month AND\n     f.day=w.day AND \n     f.hour=w.hour)\n)\n\nSELECT f.origin, f.t, SUM(f.dep_delay > 30)/COUNT(*) AS p\nFROM R AS f \nGROUP BY f.origin, f.t ;\n```\n\n:::::\n\n:::\n\n\n::: {.callout-note}\n\n### Requête 4\n\n\n\n\n\n\n\n\n\n<!-- Énoncé --> \n<!-- agrégation  simple  -->\n\nPour chaque aéroport de destination, lister les modèles d'avion qui ont atterri au moins une fois dans cet aéroport.\n\n:::\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT DISTINCT(f.dest, p.models)\nFROM flights f JOIN planes p ON (f.tailnum=p.tailnum) ;\n```\n\n:::::\n\n:::\n\n\n::: {.callout-note}\n\n### Requête 5\n\n\n\n\n\n\n\n\n\n<!-- Énoncé --> \n<!-- agrégation + filtrage sur agrégation + jointure -->\n\nPour chaque modèle d'avion, lister pour chaque semaine, le nombre de vols efectivement réalisés.\n\n\n:::\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT p.model, DATE_PART('week', f.time_hour) AS semaine, COUNT(*) AS n\nFROM flights f JOIN planes p ON (f.tailnum=p.tailnum)\nWHERE f.dep_time IS NOT NULL \nGROUP BY p.model, DATE_PART('week', f.time_hour) AS semaine ; \n```\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Requête 6\n\n\n\n\n\n\n\n\n\n<!-- Énoncé --> \n<!-- fonction fenetre  -->\n\nQuelles sont les destinations qui ne sont pas desservies le jeudi ?\n\n\n:::\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH R AS (\n  SELECT DISTINCT f.dest\n  FROM flights f\n  WHERE DATE_PART('week', f.time_hour) = 'Thursday'\n), S AS (\n  SELECT DISTINCT f.dest\n  FROM flights f\n)\n\nSELECT * FROM S\n\nEXCEPT\n\nSELECT * FROM R; \n```\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Requête 7\n\n\n\n\n\n\n\n\n\n<!-- Énoncé --> \nQuelles sont les villes desservies par une seule compagnie le dimanche ?\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT f.dest\nFROM flights f\nWHERE DATE_PART('week', f.time_hour) = 'Sunday'\nGROUP BY f.dest\nHAVING COUNT(DISTINCT f.carrier) = 1 ;\n\n```\n\n{{< fa hand-point-right >}} L'utilisation d'une clause `WITH` (Common Table Expression) plutôt que d'une requête imbriquée rend le code plus lisible. \n\n{{< fa hand-point-right >}} Dans la réponse, nous donnons plus que ce qui était demandé. On aurait pu se contenter de ;\n\n```{.sql}\n...\n\n\n```\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Requête 8\n\n\n\n\n\n\n\n\n\n<!-- Énoncé --> \n<!-- division -->\n\nQuelles sont les compagnies pour lesquelles le retard médian au décollage est supérieur à 15 minutes ?\n\n\n:::\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT f.carrier\nFROM flights f\nWHERE f.dep_delay IS NOT NULL\nGROUP BY f.carrier\nHAVING MEDIAN(f.dep_delay) > 15 ;\n```\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Requête 9\n\n\n\n\n\n\n\n\n\n<!-- Énoncé --> \n<!-- Division avec fonction fenetre -->\n\nQuelles sont les destinations qui sont desservies quotidiennement par une compagnie ?\n\n\n\n:::\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\n\n```\n\n\n\n\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Requête 10\n\n\n\n\n\n\n\n\n\n<!-- Énoncé --> \n<!-- fenêtres -->\n\nQuelles sont les compagnies qui exploitent des avions de tous les constructeurs ?\n\n\n:::\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\n\n```\n\n:::::\n\n:::\n\n::: {.callout-tip}\n\n### Quelques conseils\n\n- Préférez les clauses `WITH` et les jointures aux requêtes imbriquées sauf si la requête imbriquée est très simple. C'est une question de lisibilité et donc souvent de correction.\n\n- Ne mélangez pas les fonctions fenêtres et les clauses `GROUP BY ...`\n\n```{.sql}\nSELECT ..., FOO() OVER w\nFROM R\nWINDOW w AS (PARTITION BY ... ORDER BY ...)\nGROUP BY ... ;  \n```  \n\nest tout simplement incorrect. \n\n- Lorsque vous effectuez un partitionnement par `GROUP BY ...`, la clause `SELECT ...` est sévèrement contrainte, vous n'y trouverez que \n  - les colonnes qui ont servi dans la clause `GROUP BY ...`, normalement elles devraient toutes y figurer\n  - des fonctions d'aggrégation, comme `COUNT(...)`, `SUM(...)`, `VAR(...)`  \n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}