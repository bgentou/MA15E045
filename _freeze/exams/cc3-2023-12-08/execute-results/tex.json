{
  "hash": "0e7f99c52f689b949996a990cb6609ae",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat:\n  pdf:\n    code-annotations: below\n    keep-tex: false\n    code-fold: false\n    toc: false\n    output-file: cc3-2023-12-08.pdf\n    include-in-header:\n      - text: \"\\\\lhead{{\\\\sf  Base de données (BD5) \\\\\\\\ CC 3 2023-12-08  16h30-17h45}}\"\n  html:\n    standalone: true\n    code-fold: true\n    output-file: cc3-2023-12-08.html\nparams:\n    year: 2023 \n    curriculum: \"L3 MIASHS/Ingémath\"\n    university: \"Université Paris Cité\"\n    homepage: \"https://stephane-v-boucheron.fr/courses/bdd\"\n    moodle: \"https://moodle.u-paris.fr/course/view.php?id=2313\"\n---\n\n\n\n\n\n\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n\n\n- **L3 MIASHS/Ingémath**\n- **[Université Paris Cité](https://www.u-paris.fr)**\n- Année 2023-2024\n- [Course Homepage](https://stephane-v-boucheron.fr/courses/bdd)  \n- [Moodle](https://moodle.u-paris.fr/course/view.php?id=2313)\n\n::: \n\n::: {#second-column}\n![](/images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::\n\n:::\n\n::: {.content-hidden when-profile=\"solution\"}\n::: {.callout-caution}\n\n- Pas de documents autorisés\n- Pas de téléphone portable \n\n:::\n:::\n\n\n\n\n\n\n\n\n\n::: {.callout-note title=\"Rappel de notation\"}\n\nDans le formalisme Entité-Association, nous utilisons les *pattes de corbeau* (*crowfoot*) pour décrire les contraintes de cardinalités.  \n\n:::\n\n::: {layout=\"[50,50]\"}\n\n::::: {#first-column}\n\n\n\n\n```{mermaid}\n%%| eval: true\n%%| echo: false\nerDiagram\n\nA }|..|{ B : foo\n```\n\n\n\nL'entité `A` est reliée à l'entité `B` par l'association `foo`. Une instance de `A` peut apparaître  de $1$ à $n$ fois parmi les instances de l'association `foo`, de même une instance de `B` peut apparaître de $1$ à $n$ fois parmi les instances de l'association `foo`.\n\n:::::\n\n::::: {#second-column}\n\n\n\n\n```{mermaid}\n%%| eval: true\n%%| echo: false\nerDiagram\n\nA }|..o| B : bar\n```\n\n\n\nL'entité `A` est reliée à l'entité `B` par l'association `bar`. Une instance de `A` peut apparaître  de $0$ à $1$ fois parmi les instances de l'association `bar`, une instance de `B` peut apparaître de $1$ à $n$ fois parmi les instances de l'association `bar`.\n\n\n:::::\n\n:::\n\n::: {.callout-note}\n\nNotez que la contrainte portant sur le nombre de participations des instances d'une entité à une association apparaît _à l'opposé_ de l'entité. \n\n:::\n\n#### Un système d'information pour l'administration\n\nUn pays (par exemple *France*) est organisé en régions (par exemple *Bretagne*, ...). Les régions sont identifiées par leur nom. Ces régions sont-elles même divisées en départements (par exemple *Finistère*). Les départements sont identifiés par de numéros (par exemple *29* pour le *Finistère*). Les départments possèdent aussi un nom qui les distingue.\n\nDans chaque département, il y a des communes qui portent des noms, éventuellement précédés d'un article  (par exemple *Le Mans*, *Le Bourget*, ...). Pour chaque département, les communes sont numérotées à l'aide de leur rang dans l'ordre alphabétique construit sur les noms privés de l'éventuel article (dans la *Sarthe*, 72, *Le Mans* est au rang 181 entre  *Mamers* et *Mansigné*). \n\nPour chaque commune et chaque année, on connaît le montant total perçu au titre de la taxe foncière. \n\nChaque année, on procède à un recensement dans chaque commune. On en connaît la population. \n\nChaque région a une préfecture de région, et chaque département a une préfecture de département.\n\nOn a cherché à modéliser cette description en formalisme Entité-Association comme suit. \n\n\n\n\n```{mermaid}\n%%| eval: true\n%%| echo: false\n%%{init: { \"sequence\": { \"wrap\": true} } }%%\nerDiagram \n    DEPARTEMENT }|..|{ REGION : contient\n    DEPARTEMENT {\n        string nom\n        int departement \n    }\n    REGION ||..o| VILLE : prefecture\n    REGION {\n        string nom   \n    }\n    REGION ||..|{ VILLE : contient\n    DEPARTEMENT |o..|| VILLE : prefecture\n    VILLE {\n        string nom\n        string article\n        int numero       \n    }\n    \n    RECENSEMENT ||..|{ VILLE : concerne\n    RECENSEMENT {\n      int annee \n      int population\n    }\n    TAXE ||..|{ VILLE : rapporte\n    TAXE {\n      int annee\n      int valeur\n    }\n```\n\n\n\n\n::: {.callout-note  title=\"Question 1\"}  \n\n1. Un certain nombre d'erreurs se sont glissées dans ce schéma Entité-Association. Corrigez-le.\n2. Proposez un identifiant pour chaque entité. \n3. Désignez les entités faibles. \n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution\"}\n\n\n\n```{mermaid}\n%%| eval: true\n%%| echo: false\nerDiagram \n    REGION |o..|| VILLE : prefecture\n    REGION {\n        string nom  PK \n    }\n    REGION ||..|{ DEPARTEMENT : contient\n    DEPARTEMENT {\n        string nom\n        int departement PK \n    }\n    DEPARTEMENT ||--|{ VILLE : contient\n    DEPARTEMENT |o..|| VILLE : prefecture\n    VILLE {\n        string nom\n        string article\n        int numero PK      \n    }\n    RECENSEMENT }|--|| VILLE : concerne\n    RECENSEMENT {\n      int annee PK\n      int population\n    }\n    TAXEFONCIERE }|--|| VILLE : recoit\n    TAXEFONCIERE {\n      int annee PK\n      int montant\n    }\n```\n\n\n\n\n:::::\n\n::::: {.callout-tip title=\"Solution (suite)\"}\nLes numéros des communes sont des identifiants relatifs. Ils apparaissent sur nos numéros de sécurité sociale (chiffres en position 4, 5, 6). \n\n`VILLE`, `RECENSEMENT` et `TAXE` sont des entités faibles. \n\nL'identifiant de `VILLE` est le couple `departement, numero` \n\nL'identifiant de `TAXE` est le triplet `departement, numero, annee`. Idem pour `RECENSEMENT`. \n\nLes associations notées en trait plein sont dites *identifiantes*. \nL'identifiant d'une entité faible est formé en assemblant l'identifiant \nde l'entité de cardinalité $0:n$ et l'identifiant relatif de l'entité faible (cardinalité $1:1$).\n:::::\n\n:::\n\n---\n\nSoit le schéma\n$\\mathcal{A}=\\left\\{\\texttt{A},\\texttt{B},\\texttt{C},\\texttt{D},\\texttt{E},\\texttt{F}\\right\\}$\net l'ensemble $\\Sigma$ de DF\n```\n   A,B → C\n     B → F  \n   C,E → A  \n     F → E\n```\n\n::: {.callout-note  title=\"Question 2\"}  \nCalculer la clôture/fermeture  $\\{\\texttt{A},\\texttt{B}\\} = [\\{\\texttt{A},\\texttt{B}\\}]_{\\Sigma}^+$ de $\\{\\texttt{A},\\texttt{B}\\}$ en utilisant l'ensemble de DF $\\Sigma$.\n::: \n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution 2\"}\n$\\{\\texttt{A},\\texttt{B}\\}^+$ contient forcément `A` et `B`. Par la DF `A,B → C`, elle contient aussi `C`. Comme `B → F`, elle contient `F`. Comme `F → E`, elle contient `E`. Donc elle contient les attributs : $\\{\\texttt{A},\\texttt{B}\\}^+=\\{\\texttt{A},\\texttt{B},\\texttt{C},\\texttt{E},\\texttt{F}\\}$ (tous sauf `D`).\n\n:::::\n\n:::\n\n::: {.callout-note  title=\"Question 3\"}  \nQuelles sont les clefs du schéma $\\mathcal{A}$ en utilisant l'ensemble de DF $\\Sigma$ ?\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution 3\"}\n\nComme `D` n'apparaît dans aucune DF (en membre gauche, ou en membre droit), toute clé est formée de la réunion de $\\{\\texttt{D}\\}$  et d'une clé pour $\\mathcal{A} \\setminus \\{\\texttt{D}\\}$ muni de $\\Sigma$. \n\nOn vient de voir que $\\{\\texttt{A},\\texttt{B}\\}$ est une super-clef de $\\mathcal{A} \\setminus \\{\\texttt{D}\\}$ muni de $\\Sigma$. C'est aussi une clef de $\\mathcal{A} \\setminus \\{\\texttt{D}\\}$ puisque $[\\{\\texttt{A}\\}]_\\Sigma^+=\\{\\texttt{A}\\}$ et $[\\{\\texttt{B}\\}]_{\\Sigma}^+=\\{\\texttt{B},\\texttt{E},\\texttt{F}\\}$ pour ses deux sous-ensembles.\n\nDonc $\\{\\texttt{A},\\texttt{B}, \\texttt{D}\\}$ est une clé.\n\nCe n'est pas la seule clef : $\\{\\texttt{B},\\texttt{C}\\}$ en est aussi une.\n\nToutes les super-clefs doivent contenir `B` (qui ne dépend d'aucun autre attribut), et comme $\\texttt{B}^+=\\{\\texttt{B},\\texttt{E},\\texttt{F}\\}$, `E` et `F` n'apportent rien par rapport à `B` seul.\n\nLes clefs sont donc $\\{\\texttt{A},\\texttt{B}, \\texttt{D}\\}$ et $\\{\\texttt{B},\\texttt{C}, \\texttt{D}\\}$.\n\n:::::\n\n:::\n\n\n---\n\nOn travaillera par la suite sur le schéma relationnel `villes` et les tables définies par  le code `SQL` suivant.\n\n <!-- résumé dans la figure suivante  -->\n\n<!-- ![](./villes_schema.png) -->\n\n<!-- {{< include villes_layout.md >}} -->\n\n\n::: {.smaller}\n\n\n```{.sql}\nCREATE SCHEMA villes;\n\nCREATE TABLE villes.region (\n  nom varchar NOT NULL PRIMARY KEY,\n  prefecture_num int4 NULL,\n  prefecture_dep int4 NULL\n);\n\nCREATE TABLE villes.departement (\n  nom varchar NULL UNIQUE,\n  departement int4 NOT NULL PRIMARY KEY,\n  region varchar NULL REFERENCES villes.region(nom)\n    ON DELETE SET NULL ON UPDATE CASCADE,\n  numero int4 NULL\n);\n\nCREATE TABLE villes.ville (\n  nom varchar NULL,\n  article varchar NULL,\n  departement int4 NOT NULL REFERENCES villes.departement\n    ON DELETE RESTRICT ON UPDATE CASCADE,\n  numero int4 NOT NULL,\n  CONSTRAINT ville_pkey PRIMARY KEY (departement, numero)\n);\n\nALTER TABLE villes.region ADD \n  CONSTRAINT region_prefecture_fk FOREIGN KEY (prefecture_dep,prefecture_num) \n  REFERENCES villes.ville(departement,numero) \n  ON DELETE RESTRICT ON UPDATE CASCADE;\n\nALTER TABLE villes.departement ADD \n  CONSTRAINT departement_prefecture_fk FOREIGN KEY (departement,numero) \n  REFERENCES villes.ville(departement,numero) \n  ON DELETE SET NULL ON UPDATE CASCADE;\n\nCREATE TABLE villes.recensement (\n  annee year NOT NULL,\n  departement int4 NOT NULL,\n  numero int4 NOT NULL,\n  population int4 NULL,\n  CONSTRAINT recensement_pk PRIMARY KEY (annee, departement, numero),\n  CONSTRAINT recensement_fk FOREIGN KEY (departement,numero) \n    REFERENCES villes.ville(departement,numero) \n    ON DELETE RESTRICT ON UPDATE CASCADE\n);\n\nCREATE TABLE villes.taxe (\n  annee year NOT NULL,\n  departement int4 NOT NULL,\n  numero int4 NOT NULL,\n  valeur int4 NULL,\n  CONSTRAINT taxe_pk PRIMARY KEY (annee, departement, numero),\n  CONSTRAINT taxe_fk  FOREIGN KEY (departement,numero) \n    REFERENCES villes.ville(departement,numero) \n    ON DELETE RESTRICT ON UPDATE CASCADE\n);\n```\n\n:::\n\n::: {.callout-note}\nToutes les questions qui suivent se rapportent au schéma `villes`.\n\nPour chaque question, proposer une requête écrite en algèbre relationnelle ou en `SQL`. \n:::\n\n\n\n::: {.callout-note  title=\"Question 4\"}  \n\nLister par région le nombre de communes. \n\n::: \n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution 4\"}\n\n```{.sql}\nSELECT departement.region, COUNT(*)\n  FROM villes.departement JOIN\n       villes.ville USING (departement)\n GROUP BY departement.region ;\n```\n\n:::::\n\n::::: {.callout-note}\n\n`nom` n'est pas une clé pour `ville`. `COUNT(DISTINCT ville.nom)` ne donnera pas nécessairement le résultat attendu. \n\n\n:::::\n\n:::\n::: {.callout-note  title=\"Question 5\"}  \n\nQuel département contient le plus de communes ?\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution 5\"}\n\nVersion avec `>= ALL` :\n```{.sql}\nWITH counts AS (\n  SELECT departement, COUNT(*)\n  FROM villes.ville\n  GROUP BY departement\n)        \n\nSELECT departement\nFROM counts\nWHERE count >= ALL (SELECT count FROM counts);\n```\n\nVersion avec `RANK()` :\n```{.sql}\nWITH counts AS (\n  SELECT departement.nom, departement, COUNT(ville.numero)\n    FROM villes.departement JOIN villes.ville USING (departement)\n   GROUP BY departement),\nrangs AS (\n  SELECT nom, departement,\n         RANK() OVER (PARTITION BY departement ORDER BY count DESC)\n    FROM counts)\nSELECT nom, departement\n  FROM rangs\n WHERE rank = 1;\n```\n:::::\n\n:::\n\n\n::: {.callout-note  title=\"Question 6\"}  \n\nQuel département a connu la plus forte croissance démographique relative \nentre 2010 et 2020 ?\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution 6\"}\n```{.sql}\nWITH dpop10 AS (SELECT departement, SUM(population) as pop10\n    FROM villes.ville NATURAL JOIN villes.recensement\n   WHERE annee = 2010\n   GROUP BY departement),\ndpop20 AS (SELECT departement, SUM(population) as pop20\n    FROM villes.ville NATURAL JOIN villes.recensement\n   WHERE annee = 2020\n   GROUP BY departement),\ncroissance AS (SELECT departement, (pop20 - pop10)/pop10 as delta\n    FROM dpop10 NATURAL JOIN dpop20)\nSELECT departement\n  FROM croissance\n WHERE delta >= ALL (SELECT delta FROM croissance);\n```\n:::::\n\n:::\n\n::: {.callout-note  title=\"Question 7\"}  \n\nPour chaque région, quelle est la proportion de la population qui vit dans des préfectures départementales en 2020 ? \n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution 7\"}\n\n\n```{.sql}\nWITH totalpop AS (\n  SELECT d.region, SUM(r.population) AS total\n  FROM villes.departement d JOIN\n       villes.recensement r ON (d.departement = r.departement)\n  WHERE r.annee = '2020'\n  GROUP BY d.region),\n\n  prefpop AS (\n  SELECT d.region, SUM(population) AS pref\n  FROM villes.departement d JOIN \n       villes.recensement r ON (d.departement=r.departement AND \n                                d.numero=r.numero)\n  WHERE annee = '2020'\n  GROUP BY region.nom)\n\nSELECT region, (pref + 0.0)/total\nFROM totalpop NATURAL JOIN \n     prefpop;\n```\n\n:::::\n\n:::\n\n <!--::: {.callout-note  title=\"Question 6\"}  \n\n Quel est le nom de ville présent dans le plus grand nombre de départements ?\n\n :::\n\n\n ::: {.content-visible when-profile=\"solution\"}\n\n ::::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\n\n```\n\n:::::\n\n:::\n\n\n::: {.callout-note  title=\"Question 8\"}  \n\nDans chaque département, lister pour l'année 2015, les trois communes où\nla taxe foncière par habitant est la plus élevée. \n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution 8\"}\n\n\n```{.sql}\n\n```\n\n:::::\n\n:::-->\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}