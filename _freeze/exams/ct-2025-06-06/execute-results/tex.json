{
  "hash": "2f5c683b8dc4cba384f230b1c487013b",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat:\n  pdf:\n    code-annotations: below\n    code-fold: false\n    toc: false\n    output-file: ct-2025-06-06.pdf\n    include-in-header:\n      - text: \"\\\\lhead{{\\\\sf  Base de données (BD5) \\\\\\\\ CT  2025-06-06  9h30-12h30}}\"\n  html:\n    standalone: true\n    code-fold: true\n    output-file: ct-2025-06-06.html\nparams:\n    year: 2024 \n    curriculum: \"L3 MIASHS/Ingémath/METIS\"\n    university: \"Université Paris Cité\"\n    homepage: \"https://stephane-v-boucheron.fr/courses/bdd\"\n    moodle: \"https://moodle.u-paris.fr/course/view.php?id=2313\"\n\nengine: knitr\nexecute: \n  eval: true\n  echo: false\n---\n\n\n\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n\n- **L3 MIASHS/Ingémath/METIS**\n- **[Université Paris Cité](https://www.u-paris.fr)**\n- Année 2024-2025\n- [Course Homepage](https://stephane-v-boucheron.fr/courses/bdd)  \n- [Moodle](https://moodle.u-paris.fr/course/view.php?id=2313)\n\n::: \n\n::: {#second-column}\n![](../images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::\n\n:::\n\n::: {.content-hidden when-profile=\"solution\"}\n::: {.callout-caution}\n\n- Pas de documents autorisés\n- Pas de téléphone portable \n- Merci d'écrire vos requêtes en respectant les habitudes  d'indentation et de mise en page suivies en cours et dans les documents.\n\n:::\n:::\n\n\n\n::: {layout=\"[35,65]\"}\n\n::: {#first-column}\n\n<!-- ![](/images/taburin_9782070411962_1_75.jpg){width=180px fig-align=\"left\"}  -->\n\n:::\n\n::: {#second-column}\n\n::: {.content-visible when-profile=\"english\"}\n\nA shared bike service allows subscribers to use either mechanical or electrical bikes. Each bike has a number.\n\nEach subscriber enrolls for a one year subscription at a given starting date. Each subscriber has a subscription number, a  name, a  given name, an age, and a gender.\n\nA subscriber borrows a bike from a docklet at a given starting time on a given day. Once the trip has been completed,\nthe subscriber locks the bike on a docklet at arrival time.\n\nBornettes are located  on stations. Each station contains a fixed number of docklets. Stations are numbered, they have names,  each station has a longitude and alatitude,  and also an address.\n\n:::\n\n\n<br>\n\n\n<br>\n\n\n\n:::\n\n:::\n\n\n{{< fa bicycle >}}  Un service de vélos partagés permet aux abonnés d'utiliser des vélos mécaniques ou électriques. Chaque vélo porte un numéro.\nUn vélo entre en service à une date donnée, Il est retiré du service à une date donnée (pas connue à l'avance).  \n\n\n{{< fa biking >}} Chaque abonné souscrit un abonnement pour une durée d'un an à une date donnée. Chaque abonnement possède un numéro, et  un titulaire qui possède  un nom, un prénom, un âge et un sexe. Un abonnement n'est pas renouvelable. Cela n'empêche pas une personne de souscrire un autre abonnement.  \n\n{{< fa flag-checkered >}} Un abonné emprunte un vélo à une bornette à un instant de départ donné. Une fois le trajet effectué, l'abonné verrouille le vélo sur une bornette à l'instant d'arrivée.\n\n{{< fa map-marked >}} Les bornettes  sont situées sur des stations. Chaque station contient un nombre $n$ (qui peut varier d'une station à l'autre, mais est constant pour une station donnée) de bornettes numérotées de $1$ à $n$. Les stations sont numérotées, elles ont un nom et une adresse. Chaque station a une longitude et une latitude.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n::: {.callout-note}\n\n### Question 1 (4pts)\n\n::: {.cell}\n\n:::\n\n\nProposer un diagrammme entité-association (EA) correspondant à cette modélisation.  \n\nOn attend un dessin selon les conventions du cours, pas une énumération. \n\n:::\n\n\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-tip title=\"Conseils\"}\n\n- Distinguer entités fortes et faibles\n- Distinguer associations fortes et faibles\n- Pour chaque entité préciser l'identifiant (éventuellement relatif)\n- Préciser les cardinalités pour chaque participation à une association\n\n:::\n\n::: {.callout-tip title=\"Solution\"}\n\n### Entités \n\n::: {}\n\n(@) `Abonné`\n\n    - `AbonnéID` (Identifiant)\n    - `Nom`\n    - `Prénom`\n    - `Age`\n    - `Genre`\n    - `DébutDate` (de souscription)\n\n(@) `Velo`\n\n    - `VeloID` (PK)\n    - `Type` (Mecanique ou  Electrique)\n    - `DebutServiceDate` \n    - `FinServiceDate`\n\n\n(@) `Bornette`  (entité faible)\n\n    - `BornetteID` (Identifiant relatif)\n\n(@) `Station` \n\n    - `StationID` (Identifiant)\n    - `Nom`\n    - `Longitude`\n    - `Latitude`\n    - `Addresse`\n    - `#bornettes` \n\n:::\n\n:::\n\n\n::: {.callout-tip title=\"Solution\"}\n\n\n### Associations\n\n::: {}\n\n1. Trajet\n\n    - `StartTime`\n    - `EndTime`\n\n    Entités participantes \n\n    - `Abonné`  0:n\n    - `Vélo` 0:n\n    - `Bornette`  (rôle : Départ)  0:n\n    - `Bornette` (rôle : Arrivée)  0:n\n\n\n2. Station–Bornette\n\n    Entités participantes \n\n    - `Bornette` 1:1\n    - `Station` 1:n\n\nC'est un lien *partie de* entre une entité faible (`Bornette`) et une entité forte (`Station`). Une station comporte plusieurs bornettes. \n\n:::\n\n:::\n\n\n```{dot}\n//| label: er1\n//| eval: true\n//| echo: false\n//| include: true\ngraph ER {\n\tfontname=\"Helvetica,Arial,sans-serif\"\n\tnode [fontname=\"Helvetica,Arial,sans-serif\"]\n\tedge [fontname=\"Helvetica,Arial,sans-serif\"]\n\tlayout=neato\n\tnode [shape=box]; \"abonne\"; \"velo\" ; \"station\"  ;\n\n\t{\n    node [shape=ellipse]   ; \n    {node [label=<<u>abonne_id</u>>] abonne_id}  ;\n    {node [label=<<u>velo_id</u>>] velo_id}  ;\n    {node [label=<<u>bornette_id</u>>] bornette_id}  ;\n    {node [label=<<u>station_id</u>>] station_id} ;\n  }\n\n  {\n    node [shape=diamond];  \"trajet\"  ;\n    node [shape=diamond, peripheries=2];  \"partie-de\"  ;  \n    node [shape=box, peripheries=2];  \"bornette\"  ; \n  }\n\n  \"abonne\" -- \"trajet\" [label=\"0:n\",len=1.00] ;\n  \"velo\" -- \"trajet\" [label=\"0:n\", len=1.00] ;\n  \"bornette\" -- \"partie-de\" [label=\"1:1\",len=1.00] ;\n  \"bornette\" -- \"trajet\" [label=\"0:n depart\", len=1.00] ;\n  \"bornette\" -- \"trajet\" [label=\"0:n arrivee\", len=1.00] ;\n  \"partie-de\" -- \"station\" [label=\"0:n\",len=1.00] ; \n  abonne_id -- abonne ;\n  station_id -- station\n  bornette_id -- bornette ;\n  velo_id -- velo ; \n    //\tlabel = \"\\n\\nEntity Relation Diagram\\ndrawn by NEATO\";\n//\tfontsize=20;\n}\n```\n\n\n::: \n\n\n \n\n::: {.callout-note}\n\n\n### Question 2   (2pts)\n\n::: {.cell}\n\n:::\n\n\nLister les contraintes externes\n\n:::\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-note}\n\n- Un vélo ne peut pas être emprunté simultanément par deux abonnés\n- Le nombre de bornettes rattachées à une station ne peut excéder la limite fixée pour la station\n- Un vélo ne peut effectuer de trajets qu'entre sa date de début de service et sa date de retrait de service.\n- Un abonné ne peut pas effectuer de trajet avant la date de début ou après la date de fin d'abonnement.\n- Une bornette ne peut pas être occupée par deux vélos simultanément.\n\n:::\n\n\n:::\n\n::: {.callout-note}\n\n\n### Question 3   (2pts)\n\n\n::: {.cell}\n\n:::\n\n\nProposer une traduction en pattes de corbeau du diagramme EA proposé en réponse   \nà la première question. \n\n:::\n\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-tip title=\"Conseil\"}\n\nPrécisez \n\n- une clé primaire pour chaque table,\n- les tables dites intermédiaires,\n- pour les liens matérialisant les contraintes référentielles, préciser s'ils sont identifiant ou non.\n\n:::\n\n::: {.callout-tip title=\"Solution\"}\n\n```{mermaid}\n%%| label: crow2\n%%| eval: true\n%%| include: true\n%%| echo: false\n%%| fig-width: 6\nerDiagram\n    TRAJET }o..|| VELO : velo_id \n    TRAJET }o..|| ABONNE  : abonne_id\n    TRAJET }o..|| BORNETTE : bornette_depart_id \n    TRAJET }o..|| BORNETTE : bornette_arrivee_id \n    BORNETTE }o--|| STATION : station_id\n\n  VELO {\n    num velo_id PK\n    date DebutServiceDate \n    date FinServiceDate\n    text type\n  }\n\n  ABONNE {\n    num abonne_id PK\n    text nom\n    text prenom\n    num age\n    date debut\n    text genre \n  }\n\n  TRAJET {\n    num trajet_id PK\n    num velo_id  FK\n    num abonne_id   FK\n    %% date depart_ts\n    %% date arrivee_ts\n    num bornette_depart_id FK\n    num station_depart_id FK\n    num bornette_arrivee_id FK\n    num station_arrivee_id FK\n  }\n\n  BORNETTE {\n    num station_id PK, FK\n    num bornette_id PK\n  }\n\n  STATION {\n    num station_id PK\n    text nom\n    text adresse\n    num latitude\n    num longitude\n    num bornettes\n  }\n```\n\n:::\n\n\n\n:::\n\n\n\n\n::: {.callout-note}\n\n\n### Question 3   (1pt)\n\n::: {.cell}\n\n:::\n\n\nProposer un mécanisme pour mettre en place les  contraintes externes  en SQL lorsque c'est possible sans utiliser les gachettes \n(`TRIGGER`).\n  \n\n\n:::\n\n::: {.content-visible when-profile='solution'} \n \nOn écrit ici en SQL, le schéma correspondant,\n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nCREATE TABLE Abonné (\n    AbonnéId INT PRIMARY KEY,\n    Nom VARCHAR(100),\n    Prénom VARCHAR(100),\n    Age INT,\n    Genre CHAR(1),\n    DébutDate DATE\n);\n```\n\n```{.sql}\nCREATE TABLE Velo (\n    VéloId INT PRIMARY KEY,\n    Type ENUM('Mecanique', 'Electrique'),\n\n);\n```\n\n\n```{.sql}\nCREATE TABLE Station (\n    StationID INT PRIMARY KEY,\n    Nom VARCHAR(100),\n    Longitude DECIMAL(9,6),\n    Latitude DECIMAL(9,6),\n    Adresse VARCHAR(255),\n    `#Bornettes` INT\n);\n```\n\n```{.sql}\nCREATE TABLE Bornette (\n  StationID INT, \n  BorneID INT, \n  PRIMARY KEY (StationID, BorneID),\n  FOREIGN KEY (StationID) REFERENCES Station.StationID\n)\n```\n\n```{.sql}\nCREATE TABLE Trajet (\n    TrajetID INT PRIMARY KEY,\n    DébutTS TIMESTAMP,\n    FinTS TIMESTAMP,\n    AbonnéID INT,\n    VéloID INT,\n    BornetteDépartID INT,\n    BornetteArriveeID INT,\n    StationDepartID INT,\n    StationArriveeID INT,\n    FOREIGN KEY (AbonnéID) REFERENCES Abonné(AbonnéID),\n    FOREIGN KEY (VeloID) REFERENCES Velo(VeloID),\n    FOREIGN KEY (StationDepartID, BornetteDépartID) \n      REFERENCES Bornette(StationID, BornetteID),\n    FOREIGN KEY (StationArriveeID, BornetteArriveeID) \n      REFERENCES Bornette(StationID, BornetteID)\n);\n```\n:::\n\n::: {.callout-tip title=\"Solution\"}\n\n\n\n:::\n\n\n:::\n\nOn suppose que le schéma est muni des dépendances fonctionnelles déduites de la question précédente\net de celles qui se déduisent des contraintes de clé primaire. On note cet ensemble de dépendances \nfonctionnelles $\\Sigma$. \n\n\n::: {.callout-note}\n\n### Question 4  (1pt)\n\n\n::: {.cell}\n\n:::\n\n\nVotre schéma est-il en Forme Normale de Boyce-Codd ? \n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n\n:::\n\n:::\n\n\n{{< pagebreak >}}\n\n::: {.callout-note}\n\n### Question 5  (2pt)\n\n\n::: {.cell}\n\n:::\n\n\nQuelles actions faut-il effectuer sur votre base pour traduire les événements suivants:\n\na. Souscription d'un abonnement.\na. Mise en service d'un vélo.\na. Retrait de service d'un vélo.\na. Décrochage d'un vélo.\na. Accrochage d'un vélo.\n\n{{< fa hand-point-right >}} On n'attend pas du code. Juste une phrase qui décrit l'opération\nà effectuer. \n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\na. Insertion d'un nouveau tuple dans la table `ABONNE`\na. Insertion d'un nouveau tuple dans la table `VELO` avec une date de retrait de service `NULL` ou `'infinity'::date`\na. Mise à jour d'un tuple dans la table `VELO`, `RetraitServiceDate` est affecté de la date courante \na. Insertion d'un nouveau tuple dans la table `TRAJET`. `FinTS`, `BornetteArriveeID` `StationArriveeID` sont `NULL`\na. Mise à jour d'un tuple dans la table `TRAJET` (le tuple correspondant au trajet en cours \ndu vélo raccroché), modification de  `FinTS`, `BornetteArriveeID` `StationArriveeID`.\n\n\nOn note que l'accrochage d'un vélo, supposera la recherche du trajet en cours dans la table `TRAJET`, puis la mise à jour du tuple concerné. \n\nUne partie des requêtes qui suivent sera compliquée à écrire, parce qu'avec cette modélisation, les trajets en cours sont noyés dans la table `TRAJET`.\nPour les repérer, il faut examiner la vaneur de  `FinTS` (`NULL` ou `'infinity'::timestamp`). \n\nPour se faciliter la vie, nous allons retoucher la modélisation présentée plus haut, introduire une nouvelle table `TRAJET_EN_COURS`. \n\n::: \n\n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nCREATE TABLE Trajet (\n    TrajetID INT PRIMARY KEY,\n    DébutTS TIMESTAMP,\n    FinTS TIMESTAMP,\n    AbonnéID INT,\n    VéloID INT,\n    BornetteDépartID INT,\n    BornetteArriveeID INT,\n    StationDepartID INT,\n    StationArriveeID INT,\n    FOREIGN KEY (AbonnéID) REFERENCES Abonné(AbonnéID),\n    FOREIGN KEY (VeloID) REFERENCES Velo(VeloID),\n    FOREIGN KEY (StationDepartID, BornetteDépartID) \n      REFERENCES Bornette(StationID, BornetteID),\n    FOREIGN KEY (StationArriveeID, BornetteArriveeID) \n      REFERENCES Bornette(StationID, BornetteID)\n);\n```\n\n```{.sql}\nCREATE TABLE Trajet_en_cours (\n    TrajetID INT PRIMARY KEY,\n    DébutTS TIMESTAMP,\n    AbonnéID INT UNIQUE,\n    VéloID INT  UNIQUE,\n    BornetteDépartID INT,\n    StationDepartID INT,\n    FOREIGN KEY (AbonnéID) REFERENCES Abonné(AbonnéID),\n    FOREIGN KEY (VeloID) REFERENCES Velo(VeloID),\n    FOREIGN KEY (StationDepartID, BornetteDépartID) \n      REFERENCES Bornette(StationID, BornetteID),\n);\n```\n\n:::\n\n\n::: {.callout-tip title=\"Solution\"}\n\n```{mermaid}\n%%| label: crow3\n%%| eval: true\n%%| include: true\n%%| echo: false\n%%| caption: \"Schéma pattes de corbeau étendu\"\n%%| fig-width: 6\nerDiagram\n    TRAJET }o..|| VELO : velo_id \n    TRAJET }o..|| ABONNE  : abonne_id\n    TRAJET }o..|| BORNETTE : bornette_depart_id \n    TRAJET_EN_COURS }o..|| VELO : velo_id \n    TRAJET_EN_COURS }o..|| ABONNE  : abonne_id\n    TRAJET_EN_COURS }o..|| BORNETTE : bornette_depart_id \n    TRAJET }o..|| BORNETTE : bornette_arrivee_id \n    BORNETTE }o--|| STATION : station_id\n\n  VELO {\n    num velo_id PK\n    date DebutServiceDate \n    date FinServiceDate\n    text type\n  }\n\n  ABONNE {\n    num abonne_id PK\n    text nom\n    text prenom\n    num age\n    date debut\n    text genre \n  }\n\n  TRAJET {\n    num trajet_id PK\n    num velo_id  FK\n    num abonne_id   FK\n    time depart_ts\n    time arrivee_ts\n    num bornette_depart_id FK\n    num station_depart_id FK\n    num bornette_arrivee_id FK\n    num station_arrivee_id FK\n  }\n\n  TRAJET_EN_COURS {\n    num trajet_id PK\n    num velo_id  FK\n    num abonne_id   FK\n    time depart_ts\n    num bornette_depart_id FK\n    num station_depart_id FK\n  }\n\n  BORNETTE {\n    num station_id PK, FK\n    num bornette_id PK\n  }\n\n  STATION {\n    num station_id PK\n    text nom\n    text adresse\n    num latitude\n    num longitude\n    num bornettes\n  }\n```\n\n:::\n\n\n::: {.callout-tip title=\"Solution\"}\n\nCe modification du schéma, facilite la mise en place de certaines contraintes.\n\n- Pour les tuples de la table `TRAJET_EN_COURS`, les contraintes d'exclusions se réduisent à des contraintes d'unicité sur `velo_id` et `abonne_id`.\n-  \n\n:::\n\n:::\n\n\n::: {.callout-warning title=\"Attention\"}\n\nDans la suite, vous formulerez les requêtes dans le schéma relationnel défini  par votre schéma en pattes de corbeau. \n\n{{< fa graduation-cap >}} : 1 point par requête \n \n:::\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.callout-note}\n\n### Requête 1 \n\nListe des trajets en cours à un instant donné\n\n\n::: {.cell}\n\n:::\n\n\n:::\n\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\n\n```\n::: \n\n:::\n\n::: {.callout-note}\n\n### Requête 2 \n\nListe des vélos en trajet depuis plus d'une heure.\n\n\n::: {.cell}\n\n:::\n\n\n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\n```\n\n::: \n\n:::\n\n::: {.callout-note}\n\n### Requête 2 \n\n\nNombre de trajets initiés durant chaque heure de la journée pendant le mois de juin 2024.  \n\n\n\n::: {.cell}\n\n:::\n\n\n\n:::\n\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\n```\n\n\n::: \n:::\n\n::: {.callout-note}\n\n### Requête 3 \n\nListe des velos qui ont participé à un trajet commencé et achevé dans la même station\npendant la dernière semaine. \n\n\n::: {.cell}\n\n:::\n\n\n\n\n:::\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\n\n```\n::: \n \n::: {.callout-note}\n\n### Remarque\n\n\n:::\n\n:::\n\n::: {.callout-note}\n\n### Requête 4 \n\nLister d'éventuels couples de trajets suspects impliquant le même vélo à un même instant.  \n\n\n::: {.cell}\n\n:::\n\n\n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\n\n```\n\n::: \n\n:::\n\n::: {.callout-note}\n\n### Requête 5 \n\nListe des stations  qui ont été vides ou pleines pendant la semaine écoulée.\n\n\n::: {.cell}\n\n:::\n\n\n\n:::\n\n\n::: {.content-visible when-profile='solution'}  \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\n```\n\n::: \n:::\n\n::: {.callout-note}\n\n### Requête 6 \n\nListe des vélos en service qui n'ont pas roulé depuis plus d'un mois.\n\n\n::: {.cell}\n\n:::\n\n\n\n:::\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\n\n```\n\n::: \n \n:::\n\n\n::: {.callout-note}\n\n### Requête 7 \n\nPour chaque couple de stations, durée moyenne des trajets entre la station de départ \net la station d'arrivée.   \n\n\n::: {.cell}\n\n:::\n\n\n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\n\n```\n::: \n:::\n\n::: {.callout-note}\n\n### Requête 8\n\nLister pour chaque station le nombre de bornettes occupées à l'instant courant. \n\n\n::: {.cell}\n\n:::\n\n\n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\n```\n::: \n:::\n\n::: {.callout-note}\n\n### Requête 9 \n\nLister les trajets suspects dont le vélo n'est pas en service.\n\n\n\n::: {.cell}\n\n:::\n\n\n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\n\n```\n::: \n\n::: {.callout-tip title=\"Solution\"}\n\n\n```{.sql}\n```\n::: \n\n:::\n\n---\n\n::: {.callout-tip}\n\nEn PostgreSQL, pour définir un intervalle à l'aide de deux dates `debut`  et `fin`, il suffit d'écrire `(début, fin)`.\nL'intervalle ne contient pas la date de fin. \n\nPour tester l'intersection/le recouvrement de deux intervalles, on utilise l'opérateur `OVERLAPS` \n\n```{.sql}\nbd_2023-24=# SELECT \n  ('2025-01-03'::date, '2025-01-10'::date) OVERLAPS \n  ('2025-01-10'::date, '2025-01-15'::date)  ; \n overlaps \n----------\n false\n(1 row)\n\nSELECT \n  ('2025-01-03 20:26:00'::timestamp, '2025-01-03  21:31:01'::timestamp) OVERLAPS                                              \n  ('2025-01-03 20:50:04'::timestamp, '2025-01-03 21:45:00'::timestamp)  ; \n overlaps \n----------\n t\n(1 row)\n```\n\n:::\n\n::: {.callout-tip}\n\nPour spécifier un intervalle semi-infini (dont la fin n'est pas connue), \non peut utiliser `'infinity'::timestamp` pour décrire la borne supérieure. \n\n\n```{.sql}\nbd_2023-24=#  SELECT \n  ('2025-01-03 20:26:00'::timestamp, 'infinity'::timestamp) OVERLAPS \n  ('2025-01-03 21:32:04'::timestamp, '2025-01-03 21:45:00'::timestamp)  ; \n overlaps \n----------\n t\n(1 row)\n```\n:::\n\n::: {.callout-tip}\n\nEn PostgreSQL, `current_timestamp` s'évalue à l'instant courant (de type `timestamp` avec `timezone`).\n\nEn PostgreSQL, pour extraire le mois d'un objet `dd` de type `date`, vous pouvez utiliser \n`EXTRACT(MONTH FROM dd)`. Le résultat est un entier entre 1 et 12, 1 pour janvier, ...  \n\n```{.sql}\npostgres=# SELECT \n  current_timestamp AS instant, \n  EXTRACT( MONTH FROM current_timestamp::date) AS le_mois ;\n            instant            | le_mois \n-------------------------------+---------\n 2025-06-05 20:26:12.556256+02 |       6\n```\n:::\n\n\n::: {.callout-tip}\nPour définir un intervalle de temps, il suffit de décrire l'intervalle par une chaine de \ncaratères et de convertir le résultat en type `interval`\n\n```{.sql}\nbd_2023-24=# select '2025-06-05 21:10:38.732237+02'::timestamp - '7 days'::interval ;\n          ?column?          \n----------------------------\n 2025-05-29 21:10:38.732237\n\n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}