{
  "hash": "8a5c911f4df3d8b467c68e3054076444",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat:\n  pdf:\n    code-annotations: below\n    code-fold: false\n    toc: false\n    output-file: cc1-2023-10-27.pdf\n    include-in-header:\n      - text: \"\\\\lhead{{\\\\sf  Base de données (BD5) \\\\\\\\ CC 1 2023-10-27  16h30-17h45}}\"\n  html:\n    standalone: true\n    code-fold: true\n    output-file: cc1-2023-10-27.html\nparams:\n    year: 2023 \n    curriculum: \"L3 MIASHS/Ingémath\"\n    university: \"Université Paris Cité\"\n    homepage: \"https://stephane-v-boucheron.fr/courses/bdd\"\n    moodle: \"https://moodle.u-paris.fr/course/view.php?id=2313\"\n---\n\n\n\n\n\n\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n\n- **L3 MIASHS/Ingémath**\n- **[Université Paris Cité](https://www.u-paris.fr)**\n- Année 2023-2024\n- [Course Homepage](https://stephane-v-boucheron.fr/courses/bdd)  \n- [Moodle](https://moodle.u-paris.fr/course/view.php?id=2313)\n\n::: \n\n::: {#second-column}\n![](../images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::\n\n:::\n\n::: {.content-hidden when-profile=\"solution\"}\n::: {.callout-caution}\n\n- Pas de documents autorisés\n- Pas de téléphone portable \n\n:::\n:::\n\n\n\n\n\n\n\n\n\nToutes les questions portent sur le schéma `world` rappelé ci-dessous.\n\n![Schéma `world`](../images/world.png){width=8cm}\n\n\n\n::: {.callout-warning}\n\nLes territoires qui sont inscrits dans la table `country` ne sont pas tous des pays, et pour certaines lignes, `population_country`, `gnp`, `governmentform`, ... ne sont pas renseignés. \n\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n\n\\newpage \n\n:::\n\n::: {.callout-note}\nPour chaque question, proposer une requête écrite en algèbre relationnelle ou en `SQL`. \n:::\n\n\n\n\n1. Donner pour chaque pays, chaque district,  la population totale qui réside dans des villes répertoriées dans `city`. \n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\nUn `district` est une unité territoriale incluse dans un territoire. Pour la France, les `district` correspondent aux *régions*, pour l'Allemagne aux *Laender*, ... \n\n\n```{.sql}\nSELECT DISTINCT ci.district\nFROM world.city ci\nWHERE ci.countrycode='FRA' ;\n```\n\n\nComme on doit sommer les populations des villes situées dans un district (et donc dans un pays), il faut partitionner `city` par district et pays.\n\n```{.sql}\nSELECT ci.countrycode, ci.district, -- <2>\n       SUM(ci.population) as pop   -- <3>\nFROM world.city ci \nGROUP BY ci.countrycode, ci.district  -- <1>\n```\n1. Deux colonnes pour le partitionnement (même si `countrycode` est peut-être déterminé par `district`)\n2. On ne peut projeter que sur les colonnes utilisées pour partitionner et ...\n3. Sur des colonnes agrégées.\n\nAprès partition/aggrégation, la table résultat contient une ligne  pour chaque combinaison des attributs/colonnes servant au partitionnement. Sur chaque ligne du résultat, on peut faire figurer des aggrégations.\n\nSi on veut disposer des totaux par pays en plus, on peut utiliser la construction `GROUP BY ROLLUP(...)`\n\n```{.sql}\nSELECT ci.countrycode, ci.district, \n       SUM(ci.population) as pop    \nFROM world.city ci \nGROUP BY ROLLUP(ci.countrycode, ci.district) \nORDER BY ci.countrycode, ci.district\nLIMIT 20 ; \n```\n\nOn peut chercher à imiter le résultat de `GROUP BY ROLLUP`  avec les constructions vues en cours.\n\n```{.sql}\nWITH r AS (\n  SELECT ci.countrycode, ci.district, \n       SUM(ci.population) as pop  \n  FROM world.city ci \n  GROUP BY ci.countrycode, ci.district\n), s AS (\n  SELECT r.countrycode, NULL AS district, sum(r.pop_district) AS pop\n  FROM r\n  GROUP BY r.countrycode\n)\n\n(SELECT * FROM s)\nUNION \n(SELECT * FROM r) \nORDER BY countrycode, district ;\n```\n\nLa construction `GROUP BY ROLLUP (...)` ne permet pas définir des requêtes qui seraient hors de portée de `GROUP BY ...`, elle permet une écriture plus concise et plus claire. \n:::\n:::\n\n\n2. Donner pour chaque pays le nombre d'habitants qui ne parlent pas une langue officielle.\nOn suppose ici que chaque habitant ne parle qu'une seule langue.\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH cc_pop_not_official AS (     -- <1>\n  SELECT countrycode, SUM(percentage) as percentage\n  FROM world.countrylanguage\n  WHERE NOT(isofficial)\n  GROUP BY countrycode\n)\n\nSELECT name_country, (population_country * percentage / 100)::INTEGER\nFROM world.country NATURAL JOIN cc_pop_not_official;  -- <2>\n```\n1. La requête intermédiaire `cc_pop_not_official` nous donne pour chaque pays le pourcentage de locuteurs des langues non-officielles du pays\n2. Grâce à une jounture avec `country`, on peut combiner ce pourcentage avec la population du pays.\n\nOn peut chercher à vérifier la convention avancée dans l'énoncé:\n\n```{.sql}\nSELECT cl.countrycode, SUM(cl.percentage) AS total_percent\nFROM world.countrylanguage cl \nGROUP BY cl.countrycode\nHAVING SUM(cl.percentage) > 100\nORDER BY total_percent DESC \nLIMIT 10 ;\n```\n:::\n:::\n\n\n3. Donner, pour chaque région ayant au moins 50 millions d'habitants, le ou les pays les moins peuplés de la région.\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH r_minpop_g50M AS (\n  SELECT region, MIN(population_country) AS population_country\n  FROM world.country\n  GROUP BY region\n  HAVING SUM(population_country) >= 50000000)\n\nSELECT co.region, co.name_country\n  FROM world.country co NATURAL JOIN r_minpop_g50M ;\n```\n\n::: {.callout-warning}\nNe pas confondre les régions ayant au moins 50 millions d'habitants et les régions où au moins un pays a plus de 50 millions d'habitants.\n:::\n\n:::\n:::\n\n\n\n4. Liste des pays où la langue la plus parlée n'est pas officielle\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH r AS (\n  SELECT cl.*, \n    co.name_country, \n    rank() OVER w AS rang\n    FROM world.countrylanguage cl NATURAL JOIN \n         world.country co\n  WINDOW w AS (PARTITION BY cl.countrycode ORDER BY cl.percentage DESC) \n)\n\nSELECT DISTINCT r.name_country\nFROM r\nWHERE r.rang=1 AND NOT r.isofficial ;\n```\n\nL'usage d'une fonction fenêtre est commode, mais c'est un marteau-pilon pour \ncasser un œuf.\n:::\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\nAlternatives sans fonction fenêtre :\n```{.sql}\nWITH langmax AS (\n  SELECT countrycode, \n         MAX(percentage) AS percentage\n  FROM world.countrylanguage\n  GROUP BY countrycode)\n\nSELECT DISTINCT name_country\nFROM world.country NATURAL JOIN \n     world.countrylanguage NATURAL JOIN \n     langmax\nWHERE NOT(isofficial);\n```  \n\n```{.sql}\nSELECT DISTINCT cl.countrycode\nFROM world.countrylanguage cl\nWHERE NOT cl.isofficial AND \n      NOT EXISTS (\n        SELECT *\n        FROM world.countrylanguage cl1\n        WHERE cl1.isofficial AND \n              cl1.countrycode = cl.countrycode\n              cl1.percentage > cl.percentage\n) ;\n```\n:::\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-caution}\nUne erreur fréquente consiste à lister les pays où il existe une langue officielle qui est moins parlée qu'une langue non-officelle. Ce n'est pas la même chose que la liste des pays où toutes les langues officielles sont moins parlées qu'une certaine langue non-officiele\n:::\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution en calcul des tuples\"}\n\n$$\\begin{array}{rl}\\left\\{ t : \\texttt{country}(t) \\right. & \\wedge \\exists s, s \\in \\texttt{countrylanguage} \\wedge \\neg  s.\\texttt{isofficial}  \\wedge \\\\ & \\left. \\phantom{\\wedge}\\forall u \\neg \\left(\\texttt{countrylanguage}(u)  \\wedge u.\\texttt{isofficial} \\wedge u.\\texttt{percentage} > s.\\texttt{percentage} \\right) \\right\\}\n\\end{array}$$\n:::\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-caution}\nUne autre erreur fréquente consiste à ne lister que les pays où il existe une langue non-officielle  parlée par au moins la moitié de la population:\n\n```{.sql}\nSELECT cl.countrycode\nFROM world.countrylanguage cl\nWHERE cl.percentage > 50 AND NOT c.isofficial ; \n```\n\nIl est très possible que dans un pays, aucune langue ne soit parlée par la moitié de la population, que toutes les langues soient minoritaires, et que la langue la plus parlée ne soit pas officielle. \n:::\n:::\n\n\n1. Liste des pays où aucune ville ne compte plus $3$ millions d'habitants.\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH r AS (  \n    SELECT ci.countrycode, \n           SUM(CAST (ci.population > 3000000 AS INTEGER)) AS nb\n    FROM world.city ci\n    GROUP BY ci.countrycode \n) -- <1>\n\nSELECT co.name_country, co.continent\nFROM world.country co LEFT JOIN \n     r ON (co.countrycode = r.countrycode)   \nWHERE r.nb IS NULL OR r.nb = 0\nORDER BY co.continent, co.name_country;   -- <2>\n```\n1. La requête `r` collecte les codes de pays et pour chaque pays le nombre de villes de plus de $3000000$ d'habitants.\n2. En effectuant la jointure externe entre `country` et `r`, on récupère les territoires sans villes et les territoires où toutes les villes comptent moins de $3000000$ d'habitants.\n\nOn a ajouté  `continent` parmi les colonnes de projection pour rendre plus lisibles les résultats.\n\n:::\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\nAlternative utilisant `EXCEPT` :\n```{.sql}\nWITH cc_no_big_city AS (\n  (SELECT countrycode\n   FROM world.country)\n   EXCEPT\n  (SELECT countrycode\n   FROM world.city\n   WHERE population > 3000000))\n   \nSELECT name_country, continent\nFROM world.country NATURAL JOIN cc_no_big_city\nORDER BY continent, name_country;\n```\n\nCette requête donne le même résultat que la précédente.\n:::\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\nAlternative utilisant `NOT IN` :\n```{.sql}\nSELECT name_country, continent\n  FROM world.country\n WHERE countrycode NOT IN (\n     SELECT countrycode\n       FROM world.city\n      WHERE population > 3000000)\n ORDER BY continent, name_country;\n```\nCette requête donne encore le même résultat que la précédente.\n:::\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution en calcul des tuples\"}\nTraduction quasi-litérale de la question en formule du calcul des tuples:\n$$\\left\\{ t :\\texttt{country}(t)  \\wedge \\left(\\not \\exists s \\quad \\texttt{city}(s) \\wedge   s.\\texttt{countrycode}=t.\\texttt{countrycode} \\wedge s.\\texttt{population} > 3000000 \\right)\\right\\}$$. \nCette formule se traduit presque mécaniquement avec une requête imbriquée\n```{.sql}\nSELECT co.*\nFROM world.country co\nWHERE NOT EXISTS (\n     SELECT *\n     FROM world.city ci\n     WHERE ci.countrycode=co.countrycode AND ci.population > 3000000) ;\n```\non peut aussi réécrire la formule en \n$$\\texttt{country} \\setminus \\left\\{ t : \\texttt{country}(t)  \\wedge \\left( \\exists s \\quad  \\texttt{city}(s) \\wedge   s.\\texttt{countrycode}=t.\\texttt{countrycode} \\wedge s.\\texttt{population} > 3000000 \\right)\\right\\}$$\n:::\n:::\n\n\n6. Liste des *formes de gouvernement* (*governmentform*) pour lesquelles dans tous les pays possédant cette forme de gouvernement, aucune langue n'est officielle.\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH r AS (\n    SELECT DISTINCT cl.countrycode\n    FROM world.countrylanguage cl \n    WHERE cl.isofficial\n), s AS (\n\n    SELECT DISTINCT co.governmentform\n    FROM world.country co \n    WHERE co.countrycode IN (\n    SELECT r.countrycode FROM r)\n)\n\nSELECT DISTINCT co.governmentform\nFROM world.country co \n\nEXCEPT \n\nSELECT s.governmentform\nFROM s  ;\n```\n:::\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\nAlternative utilisant `EXCEPT` :\n```{.sql}\n(SELECT governmentform\n   FROM world.country)\nEXCEPT\n(SELECT governmentform\n   FROM world.country NATURAL JOIN world.countrylanguage\n  WHERE isofficial);\n```\n:::\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\nAlternative avec partition, agrégation\n\n```{.sql}\nSELECT co.governmentform\nFROM world.country  co LEFT join \n     world.countrylanguage cl ON (co.countrycode=cl.countrycode)\nGROUP BY co.governmentform\nHAVING SUM(CAST(cl.isofficial AS INTEGER))=0 OR \n       SUM(CAST(cl.isofficial AS INTEGER)) IS NULL;\n```\n\nSi on oublie la condition `SUM(CAST(cl.isofficial AS INTEGER)) IS NULL`, on ne retrouve pas `Co-administrated` qui concerne des territoires qui ne sont pas mentionnés dans la table `countrylanguage`.\n:::\n:::\n\n7. Donner pour chaque région, le minimum du PIB par habitant (c'est-à-dire le résultat de la division `1000000 * gnp / population_country`, puisque le PIB est donné en millions) dans la région, un des pays (son `countrycode`) de la région où ce minimum est réalisé, le maximum du PIB par habitant et un des pays (son `countrycode`) où ce maximum est réalisé.\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH r AS (\n    SELECT co.region, co.countrycode, co.name_country,\n        1000000*co.gnp/co.population_country AS gnp_per_cap,\n        row_number() OVER w_max AS rang_max,\n        row_number() OVER w_min AS rang_min\n    FROM world.country co\n    WHERE co.population_country IS NOT NULL AND co.population_country >0 AND co.gnp IS NOT NULL\n    WINDOW \n        w_max AS (PARTITION BY co.region ORDER BY co.gnp/co.population_country DESC),\n        w_min AS (PARTITION BY co.region ORDER BY co.gnp/co.population_country) \n), r1 AS (\n    SELECT r.*\n    FROM r\n    WHERE r.rang_max=1\n), r2 AS (\n    SELECT r.*\n    FROM r\n    WHERE r.rang_min=1\n)\n\nSELECT r1.region, r1.countrycode, r1.gnp_per_cap,\n       r2.countrycode, r2.gnp_per_cap\nFROM r1 JOIN r2 ON (r1.region=r2.region)  ;\n```\n:::\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\nAlternative sans fonction fenêtre :\n```{.sql}\nWITH cc_gpc AS (\n  SELECT countrycode, 1000000 * gnp/population_country AS gnp_per_cap\n    FROM world.country\n   WHERE population_country > 0),\nregion_mingpc_maxgpc AS (\n  SELECT region, MIN(gnp_per_cap) AS mingpc, MAX(gnp_per_cap) AS maxgpc\n    FROM world.country NATURAL JOIN cc_gpc\n   GROUP BY region),\nregion_cc_mingpc AS (\n  SELECT region, MIN(c1.countrycode) AS countrycode, c1.gnp_per_cap\n    FROM world.country c NATURAL JOIN region_mingpc_maxgpc r\n         JOIN cc_gpc c1 ON c.countrycode = c1.countrycode\n                           AND r.mingpc = c1.gnp_per_cap\n   GROUP BY region, c1.gnp_per_cap),\nregion_cc_maxgpc AS (\n  SELECT region, MIN(c1.countrycode) AS countrycode, c1.gnp_per_cap\n    FROM world.country c NATURAL JOIN region_mingpc_maxgpc r\n         JOIN cc_gpc c1 ON c.countrycode = c1.countrycode\n                           AND r.maxgpc = c1.gnp_per_cap\n   GROUP BY region, c1.gnp_per_cap)\n\nSELECT *\n  FROM region_cc_mingpc JOIN region_cc_maxgpc\n       USING (region);\n```\n:::\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-caution title=\"Erreur commune\"}\n\nAvec une table `foo`  de schéma `(col1, col2, col3, col4)`, \nla requête suivante n'est pas correcte :\n\n```{.sql}\nSELECT col1, col2, SUM(col4) as bar\nFROM foo\nGROUP BY col1, col3 ;\n```\nLes colonnes qui figurent dans la clause de projection `SELECT ...` doivent \n\n- figurer dans la clause de partitionnement `GROUP BY ...`, ici `col1` et `col3`\n- représenter des agrégations, comme ici `SUM(col4)`\n\nLa colonne `col2` ne peut pas figurer dans la  clause de projection !\n\n:::\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-caution title=\"Erreur commune\"}\n\nDans une clause `WHERE` ou une condition de jointure, lorsqu'on compare deux colonnes, les types des deux colonnes doivent être compatibles (en général identiques). \n\n\nDes conditions comme `language=isofficial` ou `governmentform=countrycode` n'ont pas de sens.\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}