{
  "hash": "a52fd56b1b6d435942539ddac3096ba4",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat:\n  pdf:\n    code-annotations: below\n    keep-tex: false\n    code-fold: false\n    toc: false\n    output-file: cc3-2022-10-21.pdf\n    include-in-header:\n      - text: \"\\\\lhead{{\\\\sf  Base de données (BD5) \\\\\\\\ CC 2022-23: 3}}\"\n  html:\n    standalone: true\n    code-fold: true\n    output-file: cc3-2022-10-21.html\nparams:\n    year: 2023 \n    curriculum: \"L3 MIASHS/Ingémath\"\n    university: \"Université Paris Cité\"\n    homepage: \"https://stephane-v-boucheron.fr/courses/bdd\"\n    moodle: \"https://moodle.u-paris.fr/course/view.php?id=2313\"\n\nengine: knitr\n---\n\n\n\n\n\n\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n\n\n- **L3 MIASHS/Ingémath**\n- **[Université Paris Cité](https://www.u-paris.fr)**\n- Année 2023-2024\n- [Course Homepage](https://stephane-v-boucheron.fr/courses/bdd)  \n- [Moodle](https://moodle.u-paris.fr/course/view.php?id=2313)\n\n::: \n\n::: {#second-column}\n\n![](/images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n\n:::\n\n\n:::\n\n\n::: {.callout-important}\n\nSur le serveur, dans votre schéma personnel (celui dont le nom est votre `username`), créer les fonctions `SQL` et vues correspondant aux cinq questions suivantes.\n\n:::\n\n\n\n\n::: {.callout-note}\n\nCertaines  questions portent sur le schéma `babynames` qui ne contient qu'une seule table `bebes`. Le schéma de `bebes` est le suivant :\n\n```{.sql}\n                     Table \"babynames.bebes\"\n Column |          Type          |  Nullable | \n--------+------------------------+-----------+\n sex    | integer                |  not null | \n name   | character varying(500) |  not null | \n year   | integer                |  not null | \n count  | integer                |           | \nIndexes:\n    \"bebes_pk\" PRIMARY KEY, btree (sex, name, year)\n```\n\n- `sex` représente le sexe des bébés avec le codage suivant :\n  - 1 pour un garçon\n  - 2 pour une fille\n\n- `name` représente un prénom donné. C'est une chaîne de caractères de \nlongueur variable mais inférieure à 500.\n\n- `year` représente l'année, c'est de type entier.\n\n- `count` représsente le nombre de bébés de sexe `sex` nés pendant l'année `year`\nauxquels ont été attribués le prénom `name`.\n\n{{< fa hand-point-right >}} Une ligne de `bébés`  est identifiée par les attributs `year`, `sex`, `name`.\n\nD'autres questions portent sur le [schéma `world`](/schemas/schema-world.qmd).\n\n\n:::\n\n::: {.callout-warning}\n\n\nPour construire les corrections, nous avons développés nos solutions à la main. \n\nMais nous avons aussi transmis le schéma  de `babynames` à un chatbot (`chatgpt 3.5`) et nous lui avons demandé de construire les requêtes correspondant à nos questions posées en langue nturelle.\n\n:::\n\n\n## Popularité\n\n::: {.callout-note}\n\n### Question\n\nÉcrire une fonction `SQL` nommée `top_k_names_by_year` qui prend en argument une année  `yyyy` et un entier `n` et renvoie une table `(name TEXT, sex integer, rank integer)` qui contient, selon la table `babynames.bebes`, les `k` prénoms les plus populaires (attribués) de l'année `yyyy` pour chaque sexe.\n\n:::\n\n::: {.callout-tip  collapse=\"false\"}\n\nRéponse attendue pour `SELECT * FROM top_k_names_by_year(1950, 5);` :\n\n```\n+----+---------+----+\n|F   |MARIE    |   1|\n|F   |MARTINE  |   2|\n|F   |FRANÇOISE|   3|\n|F   |MONIQUE  |   4|\n|F   |NICOLE   |   5|\n|H   |JEAN     |   1|\n|H   |MICHEL   |   2|\n|H   |ALAIN    |   3|\n|H   |GÉRARD   |   4|\n|H   |BERNARD  |   5|\n```\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"Solution\"}\n\nPremière question posée au chatbot :\n\n\n\n\n\n```{.default}\nFor every year and sex, find the 5 most popular names.\n```\n\n\n\n\nRéponse :\n\n\n\n\n\n```{.markdown}\nTo find the 5 most popular names for each year and sex \nin the babynames.bebes table, you can use `ROW_NUMBER()`. \nHere's a query that retrieves the top 5 names \nfor each combination of year and sex:\n```\n\n\n\n\n\n```{.sql}\nWITH RankedNames AS (\n    SELECT\n        name, year, sex, count,\n        ROW_NUMBER() OVER (PARTITION BY year, sex ORDER BY count DESC) AS rank\n    FROM\n        babynames.bebes\n)\n\nSELECT\n    name, year, sex, count\nFROM\n    RankedNames\nWHERE\n    rank <= 5\nORDER BY\n    year, sex, rank;\n```\n\n\n\n\n\n```{.default}\nExplanation:\n\n- The `ROW_NUMBER()` function ranks names \nwithin each `year` and `sex` partition,   \nordered by the `count` of babies in descending order.\n- The `PARTITION BY year, sex` groups the data by each year and sex.\n- The `ORDER BY count DESC` ensures that the most popular names \n(with the highest counts) are ranked first.\n- In the `WHERE` clause, we filter for the top 5 names (`rank <= 5`) \nfor each year and sex.\n\nThis query will return the most popular 5 names \nfor both males and females for each year in the dataset.\n```\n\n\n\n\n:::\n\n::: {.callout-tip title=\"Solution (suite)\"}\n\nPour définir la fonction, on peut demander de l'aide au chatbot:\n\n\n\n\n\n```{.default}\nDesign a sql function that takes as input a year y and an integer k, \nand returns a table wih columns name, sex and rank \ncontaining the k most popular names in year y for each sex\n```\n\n\n\n\nLa réponse est\n\n```{.sql}\nCREATE OR REPLACE FUNCTION top_k_names_by_year(y INT, k INT)\nRETURNS TABLE(name VARCHAR(500), sex INT, rank INT) AS $$\nBEGIN\n    RETURN QUERY\n    WITH RankedNames AS (\n        SELECT\n            name, sex, count,\n            ROW_NUMBER() OVER (PARTITION BY sex ORDER BY count DESC) AS rank\n        FROM\n            babynames.bebes\n        WHERE\n            year = y\n    )\n    SELECT\n        name, sex, rank\n    FROM\n        RankedNames\n    WHERE\n        rank <= k\n    ORDER BY\n        sex, rank;\nEND;\n$$ LANGUAGE plpgsql;\n```\n\n:::\n\n::: {.callout-tip title=\"Solution (suite)\"}\n\nEn insistant pour obtenir une fonction `SQL` on obtient:\n\n\n\n\n\n```{.default}\nSure! If you'd prefer a **pure SQL function** (without using PL/pgSQL), \nhere's how you can implement it. In PostgreSQL, you can create \na function using SQL that performs the required query:\n```\n\n\n\n\n```{.sql}\nCREATE OR REPLACE FUNCTION top_k_names_by_year(y INT, k INT)\nRETURNS TABLE(name VARCHAR(500), sex INT, rank INT) AS $$\n    WITH RankedNames AS (\n        SELECT\n            name, sex, count,\n            ROW_NUMBER() OVER (PARTITION BY sex ORDER BY count DESC) AS rank\n        FROM\n            babynames.bebes\n        WHERE\n            year = y\n    )\n    SELECT\n        name, sex, rank\n    FROM\n        RankedNames\n    WHERE\n        rank <= k\n    ORDER BY\n        sex, rank;\n$$ LANGUAGE sql;\n```\n\n:::\n\n::: {.callout-tip title='Solution (suite)'}\n\n\n\n\n\n\n```{.markdown}\n\nExplanation:\n- **Function Definition:**\n  - The function `top_k_names_by_year` accepts  \n  two parameters: `y` (year) and `k` (number of top names).\n  - It returns a table with three columns:  \n  `name` (name of the baby),  \n  `sex` (gender: 1 for male, 2 for female), and  \n  `rank` (the rank of the name by popularity).\n\n- **WITH Clause:**\n  - The `WITH RankedNames AS` clause ranks names \n  by the count of babies for each sex \n  in the specified year (`y`) using the `ROW_NUMBER()` window function. \n  It partitions by `sex` and orders by `count DESC` to assign ranks \n  starting from the most popular.\n\n- **WHERE Clause:**\n  - The main query filters for names with a rank less \n  than or equal to `k` to get only the top `k` names for each sex.\n\n- **Language:**\n  - The function is written in **pure SQL** (as specified by `LANGUAGE sql`).\n\nThis SQL function will return the top `k` names for each sex in the specified year (`y`).\n```\n\n\n\n\n:::\n\n:::\n\n\n\n## Nombre de naissances/*sex ratio*\n\nDonnées dans le schéma `babynames`.\n\n::: {.callout-note}\n\n### Question \n\nÉcrire une fonction `SQL` nommée `sex_ratio` qui prend en argument une année  `yyyy`  et renvoie le rapport entre le nombre total de naissances féminines et le nombre total de naissances masculines cette année là selon la table `babynames.bebes`.\n\n:::\n\n\n::: {.callout-tip}\n\nRéponse attendue pour `SELECT * FRON sex_ratio(1922);`\n\n```\n+-----------+\n| sex_ratio |\n+-----------+\n|   1.05    |\n```\n\nNB:  précision demandée : 0.1\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"Solution\"}\n\n\n```{.sql}\nWITH R AS (\n   SELECT year, sex, SUM(\"count\") AS n \n   FROM bebes\n   GROUP BY year, sex\n)\n \nSELECT r1.\"year\", \n       (r1.n::float/r2.n::float)::decimal(3,2) AS sex_ratio\nFROM R r1 JOIN R r2 ON (\n     r1.\"year\"=r2.\"year\" AND\n     r1.sex < r2.sex\n) ;\n```\n\nPour calculer une ligne du résultat final, il faut combiner \ndeux lignes concernant la même année mais deux sexes différents de la table intermédiaire `R`.  La jointure réalise en passant une opération de *pivot*.\n\n:::\n\n\n::: {.callout-tip title=\"Solution (suite)\"}\n\n```{.sql}\ncreate or replace function sex_ratio(p_y INT)\n  returns DECIMAL(3,2) as \n$$\nwith R as (\n  select\n    b.sex,\n    SUM(b.\"count\") as n\n  from\n    babynames.bebes as b\n  where\n    b.\"year\" = p_y\n  group by\n    b.sex\n)\n\nselect\n  (r1.n::float / r2.n::float)::decimal(3,1) as sex_ratio\nfrom\n  R r1\njoin R r2 on\n  (r1.sex < r2.sex) ;\n$$ language sql;\n``` \n\n:::\n\n::: {.callout-tip title=\"Solution (suite)\"}\n\nQuestion posée au chatbot :\n\n\n\n\n```{.default}\nCan you design a pure SQL function that takes as input a year y \nand returns the sex ratio for that year ?\n```\n\n\n\n\nRéponse:\n\n\n\n\n\n```{.default}\n\nYes, I can design a pure SQL function to calculate the sex ratio \nfor a given year in the babynames.bebes table. \nThe sex ratio is typically defined as the number of males (sex = 1) \nper 100 females (sex = 2).\n```\n\n\n\n:::\n\n::: {.callout-tip title=\"Solution (suite)\"}\n\n```{.sql}\nCREATE OR REPLACE FUNCTION get_sex_ratio(y INT)\nRETURNS DECIMAL(3,2) AS $$\n    SELECT \n        CASE \n            WHEN SUM(CASE WHEN sex = 2 THEN count ELSE 0 END) = 0 THEN NULL\n            ELSE \n                ((SUM(CASE WHEN sex = 1 THEN count ELSE 0 END))::float /\n                SUM(CASE WHEN sex = 2 THEN count ELSE 0 END)::float)::decimal(3,2)\n        END AS sex_ratio\n    FROM \n        babynames.bebes\n    WHERE \n        year = y;\n$$ LANGUAGE sql;\n```\n\nCette solution évite un `GROUP BY` et une `JOINTURE`. \nL'utilisation de `CASE WHEN ... THEN ... ELSE ...` permet de calculer \nles deux agrégations et de les combiner en une seule passe sur la table filtrée.\n\n:::\n\n:::\n\n\n## Popularité relative et rang de popularité\n\nDonnées dans le schéma `babynames`\n\n::: {.callout-note}\n\n### Question\n\nÉcrire une vue nommée `popularity` de schema\n```\n(sex text, name text, year integer, rank integer, popularity numeric)\n```\nqui donne pour chaque prénom, année, sexe, la popularité  relative (nombre sur nombre total de naissance de ce sexe cette année là) et le rang par popularité décroissante.\n\n:::\n\n\n::: {.callout-tip}\n\nRéponse attendue pour\n```{.sql}\nSELECT *\nFROM popularity\nWHERE name='THÉO' AND\n      sex = 1 AND\n      \"year\" >1999 AND\n      \"year\" < 2005;\n```\n\n```\n+----+------+-----+----+----------+\n|sex |name  | year|rank|popularity|\n+----+------+-----+----+----------+\n|1   |THÉO  | 2000|   6|     0.019|\n|1   |THÉO  | 2001|   6|     0.022|\n|1   |THÉO  | 2002|   5|     0.022|\n|1   |THÉO  | 2003|   5|     0.020|\n|1   |THÉO  | 2004|   7|     0.016|\n```\n\n\nNB:  précision demandée pour la popularité  0.01\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"solution\"}\n\nQuestion posée au chatbot :\n\n\n\n\n\n```{.default}\nCan you define a view with schema \n(sex text, name text, year integer, rank integer, popularity numeric) \nwhere popularity is the proportion of babies with given sex \nwho were named by name during year and rank is the rank of the name \nwhen ordering by decreasing popularity. \n```\n\n\n\n\nRéponse du chatbot :\n\n```{.sql}\nCREATE OR REPLACE VIEW name_popularity_view AS\nWITH TotalBySexYear AS (\n    -- Calculate the total number of babies by sex and year\n    SELECT\n        sex,\n        year,\n        SUM(count) AS total_babies\n    FROM\n        babynames.bebes\n    GROUP BY\n        sex, year\n),\nRankedNames AS (\n    -- Calculate the popularity and rank the names by decreasing popularity\n    SELECT\n        CASE \n            WHEN b.sex = 1 THEN 'Male'\n            WHEN b.sex = 2 THEN 'Female'\n        END AS sex,\n        b.name,\n        b.year,\n        (b.count::numeric / t.total_babies) AS popularity,\n        ROW_NUMBER() OVER (PARTITION BY b.sex, b.year \n                           ORDER BY b.count DESC) AS rank\n    FROM\n        babynames.bebes b\n    JOIN\n        TotalBySexYear t ON b.sex = t.sex AND b.year = t.year\n)\n-- Final selection for the view\nSELECT\n    sex,\n    name,\n    year,\n    rank,\n    popularity\nFROM\n    RankedNames;\n\n```\n:::\n\n:::\n\n\n## Les riches et les pauvres dans `world`\n\nDonnées dans le [schéma `world`](/schemas/schema-world.qmd)\n\n::: {.callout-note}\n\n### Question\n\nÉcrire une vue  nommée `ricchi_e_poveri` de schéma:\n\n```{.sql}\n(region TEXT,\n min_gnp_cap NUMERIC, poorest_country_name TEXT,\n max_gnp_per_cap NUMERIC, richest_country_name TEXT)\n```\n\noù chaque ligne indique pour une région donnée, le minimum du PIB (`gnp`) par habitant, un des pays de la région où ce minimum est réalisé, le maximum du PIB par habitant et un des pays où ce maximum est réalisé.\n\n:::\n\n::: {.callout-tip}\n\n```{.sql}\nSELECT region, richest_country, poorest_country\nFROM ricchi_e_poveri\nWHERE region='Eastern Asia' ;\n```\n\n```\n+------------+---------------+---------------+\n|region      |richest_country|poorest_country|\n+------------+---------------+---------------+\n|Eastern Asia|Japan          |North Korea    |\n```\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"Solution\"}\n\nQuestion posée au chatbot:\n\n\n\n\n```{.default}\nIn the world schema, can you build a view ricchi_e_poveri \nwith schema (region TEXT,\nmin_gnp_cap NUMERIC, poorest_country_name TEXT,\nmax_gnp_per_cap NUMERIC, richest_country_name TEXT) \nwhich,  for each region, contains the minimum gnp per capita, \nthe name of the country in the region \nwith the minimum gnp per capita (poorest country), \nthe maximum gnp per capita in the region, \nthe name of the country with maximum gnp per capita \nin the region (richest country). \n\nCountries with zero or no population should not be considered.  \n```\n\n\n\n\n:::\n\n::: {.callout-tip title=\"Solution (suite)\"}\n\n```{.sql}\nCREATE OR REPLACE VIEW world.ricchi_e_poveri AS\nWITH GnpPerCapita AS (\n    -- Calculate GNP per capita for countries with valid population and GNP\n    SELECT\n        region,\n        name_country,\n        gnp / population_country AS gnp_per_capita\n    FROM\n        world.country\n    WHERE\n        population_country > 0 -- Exclude countries with zero or no population\n        AND gnp IS NOT NULL -- Exclude countries with no GNP data\n)\nSELECT\n    region,\n    MIN(gnp_per_capita) AS min_gnp_cap, -- Minimum GNP per capita for the region\n    (SELECT name_country FROM GnpPerCapita g2 \n     WHERE g2.region = g1.region \n     ORDER BY gnp_per_capita ASC LIMIT 1) AS poorest_country_name, -- Country with minimum GNP per capita\n    MAX(gnp_per_capita) AS max_gnp_per_cap, -- Maximum GNP per capita for the region\n    (SELECT name_country FROM GnpPerCapita g2 \n    WHERE g2.region = g1.region \n    ORDER BY gnp_per_capita DESC LIMIT 1) AS richest_country_name -- Country with maximum GNP per capita\nFROM\n    GnpPerCapita g1\nGROUP BY\n    region;\n```\n:::\n\n\n:::\n\n## Fenêtre glissante  sur les bébés\n\nDonnées dans le schéma `babynames`\n\n::: {.callout-note}\n\n### Question\n\nCréer une vue `sliding_avg_count` de schéma `(name    TEXT, sex TEXT, year INTEGER, avg_count NUMERIC)` qui, pour chaque prénom (name), sexe (sex) et année (year), donne le nombre moyen (average count, `avg_count`) d'attributions du prénom aux enfants du sexe en question durant l'intervalle formé par les deux années qui précèdent et les deux années qui suivent l'année courante (incluses).\n\n:::\n\n`avg_count` est un exemple de *moyenne mobile* ou *glissante*.\n\n::: {.callout-tip collapse=\"true\"}\n\n```{.sql}\nSELECT *\nFROM sliding_avg_count\nWHERE \"name\"  ='PATRICK' AND\n      \"year\" BETWEEN 1955 AND 1960 ;\n```\n\n```\n+-------+----+-----+---------+\n|name   |sex | year|avg_count|     \n+-------+----+-----+---------+\n|PATRICK|F   | 1959|     3.00|\n|PATRICK|H   | 1955| 20381.00|\n|PATRICK|H   | 1956| 20673.80|\n|PATRICK|H   | 1957| 20532.20|\n|PATRICK|H   | 1958| 20173.80|\n|PATRICK|H   | 1959| 19443.20|\n|PATRICK|H   | 1960| 18479.60|\n```\n\n:::\n\nLa manière la plus simple de répondre à cette question 10 est d'utiliser une *fenêtre glissante*. Les fenêtres glissantes étendent les fenêtres définies par `PARTITION BY ... ORDER BY ...`.\n\nLa syntaxe de l'invocation des fonctions fenêtres est décrite dans la documentation [PostgreSQL](https://www.postgresql.org/docs/current/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS).\n\nL'invocation d'une fonction opérant sur une fenêtre suit la forme :\n\n```{.sql}\nfunction_name ([expression [, expression ... ]])\n      [ FILTER ( WHERE filter_clause ) ]\n      OVER ( window_definition )\n\n-- OU\n\nfunction_name ( * )\n      [ FILTER ( WHERE filter_clause ) ]\n      OVER ( window_definition )\n```\n\nNous n'avons pas eu besoin d'utiliser la clause `FILTER (WHERE filter_clause)`\n\nLa définition de la fenêtre  `window definition` est de la forme \n\n```{.sql}\n[ PARTITION BY expression [, ...] ]\n[ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]\n[ frame_clause ]\n```\n\nRappel : une expression entre [] est optionnelle.\n\nLa dernière clause optionnelle `frame_clause`  permet de calculer des fenêtres glissantes et d'autres types de fenêtres. Elle peut se décliner en\n\n```{.sql}\n{ RANGE | ROWS | GROUPS } frame_start [ frame_exclusion ]\n{ RANGE | ROWS | GROUPS } BETWEEN frame_start AND frame_end [ frame_exclusion ]\n```\n\noù `frame_start` (début du cadre/de la fenêtre) peut prendre les formes suivantes :\n\n```{.sql}\nUNBOUNDED PRECEDING  -- ou\noffset PRECEDING  -- ou\nCURRENT ROW   --ou\noffset FOLLOWING  -- ou\nUNBOUNDED FOLLOWING  -- ou\n```\n\n`frame_end`  se définit de la même manière.\n\nSi on veut calculer le nombre cumulé  d'attributions d'un prénom depuis l'origine des temps  on pourra procéder ainsi:\n\n```{.sql}\nWITH R AS (\nSELECT \"name\", sex, \"year\", SUM(\"count\")\n      OVER (PARTITION BY \"name\"  , sex\n            ORDER BY \"year\"\n            RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)\n      as cumule\nFROM babynames.bebes\n)\n\nSELECT * FROM R\nWHERE \"name\"   IN ('PATRICK', 'MICHEL') ;  -- pour limiter la taille du résultat\n```\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"Solution\"}\n\nQuestion posée au chatbot\n\n\n\n\n\n```{.default}\nIn schema babynames, design a view with schema \n(name    TEXT, sex TEXT, year INTEGER, avg_count NUMERIC)  \nwhere `avg_count` represents the moving average of `count` for the given `name` and `sex` where average should be computed from the 2 years preceding and following the current `year`, including the current `year`.\n```\n\n\n\n\n:::\n\n\n::: {.callout-tip title=\"Solution (suite)\"}\n\nRéponse du chatbot :\n\n\n\n\n\n```{.default}\nTo design the view with schema \n`(name TEXT, sex TEXT, year INTEGER, avg_count NUMERIC)`\nthat computes a moving average of `count` for the given `name` and `sex`, including the 2 years preceding and following the current `year` (5-year window), the SQL query would look like this:\n\nSteps:\nDefine the window: The average should be computed over the 2 years before, the current year, and 2 years after (a total of 5 years).\nPartition by name and sex: This ensures that the moving average is calculated independently for each combination of name and sex.\nApply a windowing function: Use AVG() with a window frame of 2 rows preceding and 2 rows following.\n\n```\n\n\n\n\n\n\n:::\n\n\n::: {.callout-tip title=\"Solution (suite)\"}\n\n```{.sql}\nCREATE OR REPLACE VIEW name_avg_count AS\nSELECT\n    name,\n    sex,\n    year,\n    AVG(count) OVER (\n        PARTITION BY name, sex \n        ORDER BY year \n        ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING\n    ) AS avg_count\nFROM\n    babynames;\n```\n\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}