{
  "hash": "b4d011317d0e9fe4498ae9e85da46cb2",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat:\n  pdf:\n    code-annotations: below\n    keep-tex: false\n    code-fold: false\n    toc: false\n    output-file: cc3-2022-10-21.pdf\n    include-in-header:\n      - text: \"\\\\lhead{{\\\\sf  Base de données (BD5) \\\\\\\\ CC 2022-23: 3}}\"\n  html:\n    standalone: true\n    code-fold: true\n    output-file: cc3-2022-10-21.html\nparams:\n    year: 2023 \n    curriculum: \"L3 MIASHS/Ingémath\"\n    university: \"Université Paris Cité\"\n    homepage: \"https://stephane-v-boucheron.fr/courses/bdd\"\n    moodle: \"https://moodle.u-paris.fr/course/view.php?id=2313\"\n---\n\n\n\n\n\n\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n\n\n- **L3 MIASHS/Ingémath**\n- **[Université Paris Cité](https://www.u-paris.fr)**\n- Année 2023-2024\n- [Course Homepage](https://stephane-v-boucheron.fr/courses/bdd)  \n- [Moodle](https://moodle.u-paris.fr/course/view.php?id=2313)\n\n::: \n\n::: {#second-column}\n![](/images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::****\n\n:::\n\nSur le serveur, dans votre schéma personnel (celui dont le nom est votre `username`), créer les fonctions `SQL` et vues correspondant aux cinq questions suivantes.\n\n## Popularité\n\nÉcrire une fonction `SQL` nommée `cc_fonc_6` qui prend en argument une année  `yyyy` et un entier `n` et renvoie une table `(sexe TEXT, prenom TEXT, nombre int4, rang int4)` qui contient, selon la table `babynames.bebes`, les `n` prénoms les plus populaires (attribués) de l'année `yyyy` pour chaque sexe.\n\n::: {.callout-tip  collapse=\"false\"}\n\nRéponse attendue pour `SELECT * FROM cc_fonc_6(1950, 5);` :\n\n```\n+----+---------+------+----+\n|F   |MARIE    | 28093|   1|\n|F   |MARTINE  | 16288|   2|\n|F   |FRANÇOISE| 14735|   3|\n|F   |MONIQUE  | 14647|   4|\n|F   |NICOLE   | 12695|   5|\n|H   |JEAN     | 38353|   1|\n|H   |MICHEL   | 27957|   2|\n|H   |ALAIN    | 24048|   3|\n|H   |GÉRARD   | 18618|   4|\n|H   |BERNARD  | 18355|   5|\n```\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"solution\"}\n\nTODO \n\n:::\n:::\n\n\n\n## Nombre de naissances\n\nDonnées dans le schéma `babynames`.\n\nÉcrire une fonction `SQL` nommée `cc_fonc_7` qui prend en argument une année  `yyyy`  et renvoie le rapport entre le nombre total de naissances féminines et le nombre total de naissances masculines cette année là selon la table `babynames.bebes`.\n\n\n::: {.callout-tip}\n\nRéponse attendue pour `SELECT * FRON cc_fonc_7(1922);`\n\n```\n+---------+\n|cc_fonc_7|\n+---------+\n|     1.05|\n```\n\nNB:  précision demandée : 0.1\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"solution\"}\n\nTODO \n\n:::\n\n:::\n\n\n## Popularité relative et rang de popularité\n\nDonnées dans le schéma `babynames`\n\nÉcrire une vue nommée `cc_vue_8` de schema\n```\n(sexe text, prenom text, annee integer, rang integer, popularite numeric)\n```\nqui donne pour chaque prénom, année, sexe, la popularité  relative (nombre sur nombre total de naissance de ce sexe cette année là) et le rang par popularité décroissante.\n\n\n::: {.callout-tip}\n\nRéponse attendue pour\n\n```\nSELECT *\nFROM cc_vue_8\nWHERE prenom='THÉO' AND\n      sexe = 'H' AND\n      annee >1999 AND\n      annee < 2005;\n```\n\n```\n+----+------+-----+----+----------+\n|sexe|prenom|annee|rang|popularite|\n+----+------+-----+----+----------+\n|H   |THÉO  | 2000|   6|     0.019|\n|H   |THÉO  | 2001|   6|     0.022|\n|H   |THÉO  | 2002|   5|     0.022|\n|H   |THÉO  | 2003|   5|     0.020|\n|H   |THÉO  | 2004|   7|     0.016|\n```\n\n\nNB:  précision demandée pour la popularité  0.01\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"solution\"}\n\nTODO \n\n:::\n\n:::\n\n\n## Requête fenêtre\n\nDonnées dans le schéma `world`\n\nÉcrire une vue  nommée `cc_vue_9` de schéma:\n\n```{.sql}\n(region TEXT,\n min_gnp_cap NUMERIC, poorest_country_name TEXT,\n max_gnp_per_cap NUMERIC, richest_country_name TEXT)\n```\n\noù chaque ligne indique pour une région donnée, le minimum du PIB (`gnp`) par habitant, un des pays de la région où ce minimum est réalisé, le maximum du PIB par habitant et un des pays où ce maximum est réalisé.\n\n\n::: {.callout-tip}\n\n```{.sql}\nSELECT region, richest_country, poorest_country\nFROM cc_vue_9\nWHERE region='Eastern Asia' ;\n```\n\n```\n+------------+---------------+---------------+\n|region      |richest_country|poorest_country|\n+------------+---------------+---------------+\n|Eastern Asia|Japan          |North Korea    |\n```\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"solution\"}\n\nTODO \n\n:::\n\n:::\n\n## Fenêtre glissante\n\nDonnées dans le schéma `babynames`\n\nCréer une vue `cc_vue_10` de schéma `(prenom  TEXT, sexe TEXT, annee INTEGER, moy NUMERIC)` qui, pour chaque prénom, sexe et année, donne le nombre moyen d'attributions du prénom aux enfants du sexe en question durant l'intervalle formé par les deux années qui précèdent et les deux années qui suivent l'année courante (incluse).\n\n\n::: {.callout-tip collapse=\"true\"}\n\n```{.sql}\nSELECT *\nFROM cc_vue_10\nWHERE prenom='PATRICK' AND\n      annee BETWEEN 1955 AND 1960 ;\n```\n\n```\n+-------+----+-----+--------+\n|prenom |sexe|annee|moy     |\n+-------+----+-----+--------+\n|PATRICK|F   | 1959|    3.00|\n|PATRICK|H   | 1955|20381.00|\n|PATRICK|H   | 1956|20673.80|\n|PATRICK|H   | 1957|20532.20|\n|PATRICK|H   | 1958|20173.80|\n|PATRICK|H   | 1959|19443.20|\n|PATRICK|H   | 1960|18479.60|\n```\n\n:::\n\nLa manière la plus simple de répondre à cette question 10 est d'utiliser une *fenêtre glissante*. Les fenêtres glissantes étendent les fenêtres définies par `PARTITION BY ... ORDER BY ...`.\n\nLa syntaxe de l'invocation des fonctions fenêtres est décrite dans la documentation [PostgreSQL](https://www.postgresql.org/docs/current/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS).\n\nL'invocation d'une fonction opérant sur une fenêtre suit la forme :\n\n```{.sql}\nfunction_name ([expression [, expression ... ]])\n      [ FILTER ( WHERE filter_clause ) ]\n      OVER ( window_definition )\n\n-- OU\n\nfunction_name ( * )\n      [ FILTER ( WHERE filter_clause ) ]\n      OVER ( window_definition )\n```\n\nNous n'avons pas eu besoin d'utiliser la clause `FILTER (WHERE filter_clause)`\n\nLa définition de la fenêtre  `window definition` est de la forme \n\n```{.sql}\n[ PARTITION BY expression [, ...] ]\n[ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]\n[ frame_clause ]\n```\n\nRappel : une expression entre [] est optionnelle.\n\nLa dernière clause optionnelle `frame_clause`  permet de calculer des fenêtres glissantes et d'autres types de fenêtres. Elle peut se décliner en\n\n```{.sql}\n{ RANGE | ROWS | GROUPS } frame_start [ frame_exclusion ]\n{ RANGE | ROWS | GROUPS } BETWEEN frame_start AND frame_end [ frame_exclusion ]\n```\n\noù `frame_start` (début du cadre/de la fenêtre) peut prendre les formes suivantes :\n\n```{.sql}\nUNBOUNDED PRECEDING  -- ou\noffset PRECEDING  -- ou\nCURRENT ROW   --ou\noffset FOLLOWING  -- ou\nUNBOUNDED FOLLOWING  -- ou\n```\n\n`frame_end`  se définit de la même manière.\n\nSi on veut calculer le nombre cumulé  d'attributions d'un prénom depuis l'origine des temps  on pourra procéder ainsi:\n\n```{.sql}\nWITH R AS (\nSELECT prenom, sexe, annee, SUM(nombre)\n      OVER (PARTITION BY prenom, sexe\n            ORDER BY annee\n            RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)\n      as cumule\nFROM babynames.bebes\n)\n\nSELECT * FROM R\nWHERE prenom IN ('PATRICK', 'MICHEL') ;  -- pour limiter la taille du résultat\n```\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::: {.callout-tip title=\"solution\"}\n\nTODO \n\n:::\n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}