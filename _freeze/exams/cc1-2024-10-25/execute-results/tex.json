{
  "hash": "dbe20d24c923fb6b84165a950a9b073a",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat:\n  pdf:\n    code-annotations: below\n    code-fold: false\n    toc: false\n    output-file: cc1-2024-10-25.pdf\n    include-in-header:\n      - text: \"\\\\lhead{{\\\\sf  Base de données (BD5) \\\\\\\\ CC 1 2024-10-25  17h00-18h15}}\"\n  html:\n    standalone: true\n    code-fold: true\n    output-file: cc1-2024-10-25.html\nparams:\n    year: 2024 \n    curriculum: \"L3 MIASHS/Ingémath/METIS\"\n    university: \"Université Paris Cité\"\n    homepage: \"https://stephane-v-boucheron.fr/courses/bdd\"\n    moodle: \"https://moodle.u-paris.fr/course/view.php?id=2313\"\n\nengine: knitr\n---\n\n\n\n\n\n\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n\n- **L3 MIASHS/Ingémath/METIS**\n- **[Université Paris Cité](https://www.u-paris.fr)**\n- Année 2024-2025\n- [Course Homepage](https://stephane-v-boucheron.fr/courses/bdd)  \n- [Moodle](https://moodle.u-paris.fr/course/view.php?id=2313)\n\n::: \n\n::: {#second-column}\n![](../images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::\n\n:::\n\n::: {.content-hidden when-profile=\"solution\"}\n::: {.callout-caution}\n\n- Pas de documents autorisés\n- Pas de téléphone portable \n\n:::\n:::\n\n::: {.callout-warning}\n\nToutes les questions portent sur le schéma `pagila` rappelé ci-dessous.\n\nPour chaque question, proposer une requête écrite en algèbre relationnelle *OU* en `SQL`. \n\n:::\n\n![Schéma `pagila`, films](../images/schemas-pagila-film.png){width=12cm}\n\n::: {.content-visible when-format=\"pdf\"}\n\n\\newpage \n\n:::\n\n\n1. Donner pour chaque film au catalogue, le titre et les prénoms des acteurs qui jouent dans ce film. \n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT fi.title, string_agg(DISTINCT a.first_name, ', ') AS casting \nFROM  \n   pagila.film fi  \nJOIN  \n   pagila.film_actor fa ON (fi.film_id=fa.film_id)  \nJOIN \n   pagila.actor a ON (fa.actor_id=a.actor_id) \nGROUP BY fi.film_id;   \n```\n\n\n{{< fa hand-point-right >}} Il n'est pas nécessaire d'effectuer un groupement et une aggrégation, mais c'est une occasion d'illustrer cette possibilité. `string_agg()`  est une fonction proposée par `PostgreSQL`, analogue à `paste()`  ou `stringr::str_c()` en `R`, ou à une invocation de `functools.reduce()` en `Python`: \n\n```{.python}\n>>> reduce(lambda x,y : x + ', ' + y, ['Brad', 'Angelina', 'Romy', 'Ava'])\n'Brad, Angelina, Romy, Ava'\n```\n\nDes fonctions d'aggrégations comme `SUM(), MAX(), COUNT()` sont de cette forme. Des fonctions d'aggrégations comme `AVG()`, `VAR()`, `COUNT(DISTINCT ...)` sont un peu plus compliquées à réaliser mais relève du même genre de calcul.\n\n:::\n:::\n\n\n2. Lister les titres de films qui ne sont disponibles que dans une seule langue\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT fi.title \nFROM \n  pagila.film fi \nGROUP BY fi.title \nHAVING COUNT (DISTINCT fi.language_id)=1 ;\n```\nIl n'est pas indispensable de passer par un groupement/aggrégation. On peut obtenir le résultat en utilisant simplement sélection, projection, jointure, opérations ensemblistes ($∩, ∪, ∖$).\n\n```{.sql}\n(\n SELECT \n    DISTINCT title \n FROM \n    pagila.film\n)\nEXCEPT \n(\n SELECT \n     DISTINCT f1.title\n FROM \n     pagila.film f1 \n JOIN \n     pagila.film f2\n ON (f1.title = f2.title AND f1.language_id < f2.language_id)\n)\n```\n\n:::\n:::\n\n\n\n\n{{< pagebreak >}}\n\n\n\n\n\n\n\n3. Pour chaque langue originale (`original_language_id`), chaque langue de diffusion (`language_id`), compter le nombre de titres tournés dans la langue originale et traduits dans la langue de diffusion  (sans doublons).\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT \n  original_language_id, \n  language_id, \n  count(title) \nFROM \n    pagila.film \nGROUP BY \n    original_language_id,\n    language_id ;\n```\n\n:::\n:::\n\n\n\n\n\n{{< pagebreak >}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n4. Donner pour chaque catégorie (de film), les noms des acteurs qui apparaissent dans le nombre maximal de films de la catégorie. \n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH ActorFilmCount AS (\n    SELECT\n        c.name AS category_name,\n        a.actor_id,\n        a.first_name || ' ' || a.last_name AS actor_name,\n        COUNT(fa.film_id) AS film_count\n    FROM\n        actor a\n    JOIN\n        film_actor fa ON a.actor_id = fa.actor_id\n    JOIN\n        film f ON fa.film_id = f.film_id\n    JOIN\n        film_category fc ON f.film_id = fc.film_id\n    JOIN\n        category c ON fc.category_id = c.category_id\n    GROUP BY\n        c.name, a.actor_id, a.first_name, a.last_name\n),\n\nRankedActors AS (\n    SELECT\n        category_name,\n        actor_name,\n        film_count,\n        DENSE_RANK() OVER (PARTITION BY category_name ORDER BY film_count DESC) AS rank\n    FROM\n        ActorFilmCount\n)\nSELECT\n    category_name,\n    actor_name,\n    film_count\nFROM\n    RankedActors\nWHERE\n    rank = 1\nORDER BY\n    category_name;\n```\n\n:::\n\nOn peut se passer des fonctions fenêtres.\n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH ActorFilmCount AS (\n    SELECT\n        c.name AS category_name,\n        a.actor_id,\n        a.first_name || ' ' || a.last_name AS actor_name,\n        COUNT(fa.film_id) AS film_count\n    FROM\n        actor a\n    JOIN\n        film_actor fa ON a.actor_id = fa.actor_id\n    JOIN\n        film f ON fa.film_id = f.film_id\n    JOIN\n        film_category fc ON f.film_id = fc.film_id\n    JOIN\n        category c ON fc.category_id = c.category_id\n    GROUP BY\n        c.name, a.actor_id, a.first_name, a.last_name\n),\n\n\nMaxPerCat AS (\n    SELECT\n        category_name,\n        MAX(film_count) as m_film_count\n    FROM \n        ActorFilmCount\n    GROUP BY \n        category_name    \n),\n\n\nSELECT \n    ac.category_name,\n    ac.actor_id,\n    ac.actor_name,\n    ac.film_count\nFROM \n    ActorFilmCount  ac\nJOIN\n    MaxPerCat  mpc\nUSING(category_name)\nWHERE \n    ac.film_count=mpc.m_film_count\nORDER BY\n    ac.category_name ;\n\n```\n\n:::\nou encore \n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH ActorFilmCount AS (\n    SELECT\n        c.name AS category_name,\n        a.actor_id,\n        a.first_name || ' ' || a.last_name AS actor_name,\n        COUNT(fa.film_id) AS film_count\n    FROM\n        actor a\n    JOIN\n        film_actor fa ON a.actor_id = fa.actor_id\n    JOIN\n        film f ON fa.film_id = f.film_id\n    JOIN\n        film_category fc ON f.film_id = fc.film_id\n    JOIN\n        category c ON fc.category_id = c.category_id\n    GROUP BY\n        c.name, a.actor_id, a.first_name, a.last_name\n)\n\nSELECT\n    afc.*\nFROM \n    ActorFilmCount afc\nWHERE \n    afc.film_count >= ALL (\n        SELECT \n            a.film_count\n        FROM\n            ActorFilmCount a\n        WHERE \n            a.category_name = afc.category_name\n    ) ;\n```\n:::\n:::\n\n\n\n\n{{< pagebreak >}}\n\n\n\n\n\n\n1. Lister sans doublons les paires d'acteurs qui n'ont jamais joué dans un même film.\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH ActorPairs AS (\n    -- Generate all possible actor pairs (excluding pairing an actor with themselves)\n    SELECT\n        a1.actor_id AS actor1_id,\n        a2.actor_id AS actor2_id,\n        a1.first_name || ' ' || a1.last_name AS actor1_name,\n        a2.first_name || ' ' || a2.last_name AS actor2_name\n    FROM\n        actor a1\n    JOIN\n        actor a2 ON a1.actor_id < a2.actor_id  -- Ensure actor1_id < actor2_id to avoid duplicate pairs\n),\nActorsTogether AS (\n    -- Find all actor pairs who have acted together in at least one film\n    SELECT\n        fa1.actor_id AS actor1_id,\n        fa2.actor_id AS actor2_id\n    FROM\n        film_actor fa1\n    JOIN\n        film_actor fa2 ON fa1.film_id = fa2.film_id\n    WHERE\n        fa1.actor_id < fa2.actor_id  -- Same condition to avoid duplicates\n),\nActorsNotTogether AS (\n    -- Left JOIN all possible pairs with the pairs that acted together\n    SELECT\n        ap.actor1_name,\n        ap.actor2_name\n    FROM\n        ActorPairs ap\n    LEFT JOIN\n        ActorsTogether at ON ap.actor1_id = at.actor1_id AND ap.actor2_id = at.actor2_id\n    WHERE\n        at.actor1_id IS NULL  -- Only return pairs that do not exist in the ActorsTogether result\n)\n-- Final result\nSELECT\n    actor1_name,\n    actor2_name\nFROM\n    ActorsNotTogether\nORDER BY\n    actor1_name, actor2_name;\n\n```\n:::\n:::\n\n\n\n\n{{< pagebreak >}}\n\n\n\n\n\n\n1. Lister les acteurs (prénom, nom) qui ont joué dans des films tournés dans au moins deux langues différentes  (langue de tournage  : `original_language_id`) \n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT\n    a.actor_id,\n    a.first_name || ' ' || a.last_name AS actor_name,\n    STRING_AGG(DISTINCT l.name, ', ') AS languages\nFROM\n    actor a\nJOIN\n    film_actor fa ON a.actor_id = fa.actor_id\nJOIN\n    film f ON fa.film_id = f.film_id\nJOIN\n    language l ON f.original_language_id = l.language_id\nGROUP BY\n    a.actor_id, a.first_name, a.last_name\nHAVING\n    COUNT(DISTINCT f.original_language_id) > 1\nORDER BY\n    actor_name;\n\n```\n\n:::\n:::\n\n\n\n7. Pour chaque magasin (désigné par `store_id`), chaque langue, donnez le nombre de DVDs (physiques) disponibles dans cette langue,\ndans ce magasin. \n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT\n    s.store_id,\n    l.name AS language_name,\n    COUNT(i.inventory_id) AS inventory_count\nFROM\n    store s\nJOIN\n    inventory i ON s.store_id = i.store_id\nJOIN\n    film f ON i.film_id = f.film_id\nJOIN\n    language l ON f.language_id = l.language_id\nWHERE\n    f.language_id IS NOT NULL\nGROUP BY\n    s.store_id, l.name\nORDER BY\n    s.store_id, l.name;\n\n```\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}