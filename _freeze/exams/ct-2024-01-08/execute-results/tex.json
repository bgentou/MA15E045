{
  "hash": "ea8b54d6574708f26e470a43f8dabb78",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat:\n  pdf:\n    code-annotations: below\n    keep-tex: true\n    code-fold: false\n    toc: false\n    output-file: ct-2024-01-08.pdf\n    include-in-header:\n      - text: \"\\\\lhead{{\\\\sf  Base de données \\\\\\\\ CT 2024-01-08 12h-15h}}\"\n  html:\n    standalone: true\n    code-fold: true\n    output-file: ct-2024-01-08.html\nparams:\n    year: 2023 \n    curriculum: \"L3 MIASHS/Ingémath\"\n    university: \"Université Paris Cité\"\n    homepage: \"https://stephane-v-boucheron.fr/courses/bdd\"\n    moodle: \"https://moodle.u-paris.fr/course/view.php?id=2313\"\nengine: knitr\nexecute: \n  eval: true\n  echo: false\n  include: false\n---\n\n\n\n\n::: {layout=\"[80,20]\"} \n\n::: {#first-column}\n\n\n\n- **L3 MIASHS/Ingémath** \n- **[Université Paris Cité](https://www.u-paris.fr)**\n- Année 2023-2024\n- [Course Homepage](https://stephane-v-boucheron.fr/courses/bdd)  \n- [Moodle](https://moodle.u-paris.fr/course/view.php?id=2313)\n\n::: \n\n::: {#second-column}\n\n![](/images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n\n:::\n\n:::\n\n\n\n::: {.content-hidden when-profile=\"solution\"}\n\n::: {.callout-caution}\n\n- Pas de documents autorisés\n- Pas de téléphone portable \n\n:::\n\n:::\n\n::: {.callout-warning}\n\nLes trois exercices (modélisation, normalisation, requêtes) portent sur \nle schéma `nycflights` légèrement nettoyé. \n\n:::\n\n\n![NYCFlights en relationel à pattes de corbeau](../images/nycflights_layout_crop.png){width=\"80%\"}\n\n{{< pagebreak >}}\n\n<!-- {{< include nycflights_layout.qmd >}} -->\n\n\n### Définition du schéma en SQL\n\n\n::: {layout=\"[50,50]\"}\n\n::: {#first-column}\n\n\n```{.sql}\nCREATE TABLE airlines (\n\tcarrier text NOT NULL,\n\t\"name\" text NULL,\n\tCONSTRAINT airlines_pk \n        PRIMARY KEY (carrier),\n\tCONSTRAINT airlines_un \n        UNIQUE (name)\n);\n```\n\n```{.sql}\nCREATE TABLE airports (\n\tfaa text NOT NULL,\n\t\"name\" text NULL,\n\tlat float8 NULL,\n\tlon float8 NULL,\n\talt float8 NULL,\n\ttz float8 NULL,\n\tdst text NULL,\n\ttzone text NULL,\n\tCONSTRAINT airports_pk \n        PRIMARY KEY (faa),\n\tCONSTRAINT airports_un \n        UNIQUE (name),\n\tCONSTRAINT airports_un_ll \n        UNIQUE (lat, lon)\n);\n```\n\n\n\n:::\n\n::: {#second-column}\n\n\n```{.sql}\nCREATE TABLE weather (\n\torigin text NOT NULL,\n\t\"year\" int4 NULL,\n\t\"month\" int4 NULL,\n\t\"day\" int4 NULL,\n\t\"hour\" int4 NULL,\n\t\"temp\" float8 NULL,\n\tdewp float8 NULL,\n\thumid float8 NULL,\n\twind_dir float8 NULL,\n\twind_speed float8 NULL,\n\twind_gust float8 NULL,\n\tprecip float8 NULL,\n\tpressure float8 NULL,\n\tvisib float8 NULL,\n\ttime_hour timestamptz NOT NULL,\n\tCONSTRAINT weather_pk \n        PRIMARY KEY (origin, time_hour)\n);\n```\n\n```{.sql}\nALTER TABLE weather ADD \n    CONSTRAINT weather_fk \n    FOREIGN KEY (origin) \n    REFERENCES airports(faa) \n    ON DELETE CASCADE \n    ON UPDATE CASCADE;\n```\n\n:::\n\n:::\n\n```{.sql}\nCREATE TABLE planes (\n\ttailnum text NOT NULL,\n\t\"year\" int4 NULL,\n\t\"type\" text NULL,\n\tmanufacturer text NULL,\n\tmodel text NULL,\n\tengines int4 NULL,\n\tseats int4 NULL,\n\tspeed int4 NULL,\n\tengine text NULL,\n\tCONSTRAINT planes_pk   PRIMARY KEY (tailnum)\n);\n```\n\n\n::: {layout=\"[50,50]\"}\n\n::: {#first-column}\n\n```{.sql}\nCREATE TABLE flights (\n\t\"year\" int4 NULL,\n\t\"month\" int4 NULL,\n\t\"day\" int4 NULL,\n\tdep_time int4 NULL,\n\tsched_dep_time int4 NULL,\n\tdep_delay float8 NULL,\n\tarr_time int4 NULL,\n\tsched_arr_time int4 NULL,\n\tarr_delay float8 NULL,\n\tcarrier text NULL,\n\tflight int4 NULL,\n\ttailnum text NOT NULL,\n\torigin text NOT NULL,\n\tdest text NULL,\n\tair_time float8 NULL,\n\tdistance float8 NULL,\n\t\"hour\" float8 NULL,\n\t\"minute\" float8 NULL,\n\ttime_hour timestamptz NOT NULL,\n\tCONSTRAINT flights_pk \n        PRIMARY KEY (\n            tailnum, origin, time_hour)\n);\n```\n\n:::\n\n\n\n::: {#second-column}\n\n```{.sql}\nALTER TABLE flights ADD \n    CONSTRAINT flights_fk \n    FOREIGN KEY (carrier) \n    REFERENCES airlines(carrier) \n    ON DELETE SET NULL \n    ON UPDATE CASCADE;\n```\n\n```{.sql}\nALTER TABLE flights ADD \n    CONSTRAINT flights_fk_dest \n    FOREIGN KEY (dest) \n    REFERENCES airports(faa) \n    ON DELETE SET NULL \n    ON UPDATE CASCADE;\n```\n\n```{.sql}\nALTER TABLE flights ADD \n    CONSTRAINT flights_fk_origin \n    FOREIGN KEY (origin) \n    REFERENCES airports(faa) \n    ON DELETE SET NULL \n    ON UPDATE CASCADE;\n```\n\n```{.sql}\nALTER TABLE flights ADD \n    CONSTRAINT flights_fk_planes \n    FOREIGN KEY (tailnum) \n    REFERENCES planes(tailnum) \n    ON DELETE SET NULL \n    ON UPDATE CASCADE;\n```\n\n:::\n\n:::\n\n\n\n\n\nDans le schéma `nycflights`, on a aussi les dépendances fonctionnelles suivantes:\n\nTable `airports`\n\n- `faa`, `name`, et `(lon, lat)` sont des clés. \n\nTable `airlines`\n\n- `carrier` et `name` sont des clés\n\nTable `weather`\n\n- `origin, time_hour` est une clé\n- `time_hour → year, month, day, hour`\n- `year, month, day, hour  → time_hour`\n\nTable `planes`\n\n- `tailnum` est une clé\n- `model → manufacturer, engines, engine, type`\n\nTable `flights`\n\n- `tailnum, time_hour → carrier`\n- `time_hour → sched_dep_time`\n- `sched_dep_time, dep_time → dep_delay`\n- `sched_arr_time, arr_time → arr_delay`\n- `origin, dest, dep_time, arr_time → airtime`\n- `time_hour → year, month, day, hour, minute`\n- `year, month, day, hour, minute → time_hour`\n- `origin, dest → distance`\n- `(tailnum, origin, time_hour)` est une clé\n- `(flight, dest, origin, year, month, day)` est une clé\n\n\n<!-- Pour chaque exercice -->\n{{< pagebreak >}}\n\n::: {.callout-note title=\"Exercice : Modélisation\" icon=\"false\"}\n\n<!-- Énoncé --> \n\nLe schéma entité-association est une tentative de rétro-ingénieurie du schéma \nrelationnel `nycflights`.\n\n![](/images/nycflight_er.png){width=\"70%\" fig-align=\"right\"}\n\n\n:::\n\n\n\n\n\n::: {.callout-note}\n\n### Question\n\n\n\nProposez une variation de la représentation de l'entité `plane` où \non définit une entité `model` (dont les instances seraient par exemple `Airbus A350`, `Boeing 777`, ...), et où chaque avion/aéronef serait considéré comme une réalisation d'une instance de `model`). \n\nPréciser la nature de l'association entre `plane`  et `model` et les cardinalités.\n\nPrécisez la répartition des attributs entre `plane` et `model`.\n\n:::\n\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\nAssociation  `est-un` (`is-a`), avec cardinalité `1:1` côté `plane` et `0:n` côté `model`\n\n`model` a les attributs `model` (à renommer), `engines`, `type`, `manufacturer`, `engine`.\n\n`plane` garde les attributs `year`, `seats`, `tailnum` (identifiant)\n\nSi les instances de `plane`  sont identifiées par `tailnum`, l'association `est-un` n'est pas identifiante. \n\n:::\n:::\n\n<!-- {{< pagebreak >}} -->\n\n<!-- Pour chaque exercice -->\n\n::: {.callout-note title=\"Exercice : Normalisation\" icon=\"false\"}\n\n<!-- Énoncé --> \n\n\n\n:::\n\n\n\n::: {.callout-note}\n\n### Question 1\n\n\n\nPour chaque table, préciser si elle est en FNBC ou non.\n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n- {{< fa check-square >}} `airlines` : en FNBC car deux colonnes\n- {{< fa check-square >}} `airports` : en FNBC \n- {{< fa times >}} `planes` : viole la condition FNBC par toutes les DF `model → ...`\n- {{< fa times >}} `weather` : deux clés `(origin, time_hour)` et `(origin, year, month, day, hour)`, mais les membres gauches des DF `time_hour → year, month, day, hour` et  `year, month, day, hour  → time_hour` violent la condition FNBC.\n- {{< fa times >}} `flights` viole la condition FNBC de plusieurs façons notamment via la DF `origin, dest →  distance`.\n\n:::\n:::\n\n::: {.callout-note}\n\n### Question 2\n\n\n\nSi certaines tables ne sont pas en FNBC, proposer une décomposition en FNBC sans perte d'information. \n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-tip title=\"Solution\"}\n\n- Pour `planes`, la décomposition `(model, manufacturer, engines, engine, type)`, `(tailnum, year, model, seats, speed)` est en FNBC.\n\n- Pour `weather`, supprimer les colonnes `year, month, day, hour` qui peuvent être calculées à partir de `time_hour`.\n\n- Pour `flights`, décomposition \n  - `(origin, dest, distance)`\n  - `(flight, time_hour)`\n  - `(flight, dest, origin, time_hour, dep_time, sched_arr_time, arr_time, tailnum)`\n  - `(tailnum, time_hour, carrier)`\n\n:::\n:::\n\n\n{{< pagebreak >}}\n\n::: {.callout-note title=\"Exercice : Requêtes  (schéma `nycflights`)\" icon=\"false\"}\n\n:::\n\n\n::: {.callout-note}\n\n### Requête 1\n\n\n\n<!-- Énoncé --> \n<!-- jointure + requête imbriquée -->\nFor each airport of departure (denoted by `origin`), for each day of the year, list the codes (`carrier`) of the airlines that have one or more planes taking off from that airport on that day.\n:::\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT DISTINCT f.origin, f.year, f.month, f.day, f.carrier\nFROM nycflights.flights f \nORDER BY f.origin, f.year, f.month, f.day;\n```\n\n{{< fa hand-point-right >}} Il n'est pas nécessaire, ni même utile de procéder à une aggrégation (`GROUP BY`), il suffit \nde projeter sur les attributs qui identifient le jour de l'année `f.year, f.month, f.day`, l'aéroport de décollage (`origin`), et l'identifiant des compagnies aériennes `carrier`, et, bien sûr d'éliminer les doublons avec `DISTINCT`.\n\n{{< fa hand-point-right >}} Si on veut récupérer les noms complets des compagnies aériennes, plutôt que les codes, on \npeut effectuer une jointure naturelle avec `airlines`. \n\n{{< fa hand-point-right >}} Si on veut (finalement) une ligne par aéroport de départ et jour de l'année, on doit alors \neffectuer une aggrégation et utiliser une fonction d'aggrégation de chaine de caractères comme \n`concat()`\n\n```{.sql}\nWITH R AS (\n  SELECT DISTINCT f.origin, f.year, f.month, f.day, f.carrier\n  FROM nycflights.flights f \n)\n\nSELECT R.origin, R.year, R.month, R.day, concat(R.carrier) AS carriers\nFROM R \nGROUP BY R.origin, R.year, R.month, R.day\nORDER BY R.origin, R.year, R.month, R.day ;\n```\n\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Requête 2\n\n\n\n<!-- Énoncé --> \n<!-- Énoncé --> \n<!-- jointure + agregation -->\n\nLister pour chaque aéroport d'origine, chaque jour de l'année, pour chaque compagnie aérienne, le nombre d'avions exploités par la compagnie aérienne  qui décollent de cet aéroport, ce jour là.\n\n\n:::\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT f.origin, f.year, f.month, f.day, f.carrier, COUNT(DISTINCT tailnum)\nFROM nycflights.flights f \nGROUP BY f.origin, f.year, f.month, f.day, f.carrier\nORDER BY f.origin, f.year, f.month, f.day, f.carrier;\n```\n\n{{< fa hand-point-right >}} Il faut bien garder en tête que la clause `GROUP BY` (la clause de partitionnement)\nest définie par une liste de colonnes (ou plus généralement d'expressions) séparées par \ndes virgules, ici `f.origin, f.year, f.month, f.day, f.carrier`. Ces colonnes \nsont évoquées dans *pour chaque aéroport d'origine, chaque jour de l'année, pour chaque compagnie aérienne*. Ces colonnes doivent aussi apparaître dans la clause `SELECT ` (la clause de projection finale).\n\n{{< fa hand-point-right >}} Dans la clause de projection `SELECT ...` ne peuvent figurer que \n- les expressions qui apparaissent dans la clause `GROUP BY ...` \n- les expressions d'aggrégation comme `COUNT(...)`.\n\n\n:::::\n\n:::\n\n\n::: {.callout-note}\n\n### Requête 3\n\n\n\n<!-- deux jointures ou plutôt une requête imbriquée et une jointure  -->\n\nLister pour chaque vol  exploité par la compagnie (`carrier` nommé dans  `airlines`) *Delta Air Lines Inc.* : les conditions météorologiques (`weather`) à l'heure prévue du décollage (`sched_dep_time`). \n\n\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH delta AS (\n    SELECT al.carrier\n    FROM nycflights.airlines al\n    WHERE al.\"name\" = 'Delta Air Lines Inc.'\n),\ndelta_f AS (\n    SELECT f.origin, f.flight, f.year, f.month, f.day, f.hour \n    FROM nycflights.flights f\n    WHERE f.carrier IN (SELECT * FROM delta)\n)\n\nSELECT f.flight, w.*\nFROM  nycflights.weather w NATURAL JOIN delta_f f;\n```\n\n:::::\n\n:::\n\n\n::: {.callout-note}\n\n### Requête 4\n\n\n\n<!-- Énoncé --> \n<!-- agrégation  simple  -->\n\nNombre de vols au décollage par aéoroport d'origine et par compagnie aérienne (`carrier`).\n\n:::\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT f.origin, f.carrier, COUNT(*) AS n\nFROM nycflights.flights f\nGROUP BY f.origin, f.carrier \nORDER BY f.carrier, n DESC;\n```\n\n:::::\n\n:::\n\n\n::: {.callout-note}\n\n### Requête 5\n\n\n\n<!-- Énoncé --> \n<!-- agrégation + filtrage sur agrégation + jointure -->\n\nLister les caractéristiques des avions (`planes`) exploités par au moins deux compagnies aériennes (`carrier`) différentes  dans la base de données. \n\n\n:::\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH for_hire AS (\n    SELECT f.tailnum, COUNT(DISTINCT f.carrier) AS n_carrier\n    FROM nycflights.flights f\n    GROUP BY f.tailnum \n    HAVING COUNT(DISTINCT f.carrier) >=2 \n)\n\nSELECT p.*\nFROM nycflights.planes p NATURAL JOIN for_hire ;\n```\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Requête 6\n\n\n\n<!-- Énoncé --> \n<!-- fonction fenetre  -->\n\nLister pour chaque jour et chaque aéoroport d'origine les dix avions les plus en retard au décollage (`dep_delay`). Ne pas prendre en compte les vols annulés (`dep_time IS NULL`).  \n\n:::\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH f_delayed AS (\n  SELECT f.*, RANK() OVER w AS rnk\n  FROM nycflights.flights f\n  WHERE f.dep_time IS NOT NULL\n  WINDOW w AS (PARTITION BY f.origin, f.year, f.month, f.day ORDER BY f.dep_delay DESC)  \n)\n\nSELECT fd.origin, fd.year, fd.month, fd.day, fd.tailnum\nFROM f_delayed fd\nWHERE fd.rnk <= 10;\n```\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Requête 7\n\n\n\n<!-- Énoncé --> \n<!-- jointure + agrégation + fenetre -->\n\nLister pour chaque modèle d'avion (`model`) le nombre de jours où un \navion de ce modèle a subi le plus grand retard au décollage (`dep_delay`)\nparmi les avions qui ont décollé ce jour là du même aéroport (`origin`). \n\n:::\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH delayed_flight AS (\n  SELECT f.origin, f.year, f.month, f.day, f.tailnum, \n         RANK() OVER w AS rnk\n  FROM nycflights.flights f\n  WINDOW w AS (PARTITION BY f.origin, f.year, f.month, f.day \n               ORDER BY f.dep_delay DESC)\n), plane_of_day  AS (\n  SELECT df.origin, df.year, df.month, df.day, df.tailnum\n  FROM delayed_flight df\n  WHERE df.rnk = 1\n)\n\nSELECT p.model, COUNT(DISTINCT(df.year, df.month, df.day)) AS nb_bad_days\nFROM plane_of_day df  JOIN nycflights.planes p ON \n  (df.tailnum=p.tailnum)\nGROUP BY p.model \nORDER BY nb_bad_days DESC;\n```\n\n{{< fa hand-point-right >}} L'utilisation d'une clause `WITH` (Common Table Expression) plutôt que d'une requête imbriquée rend le code plus lisible. \n\n{{< fa hand-point-right >}} Dans la réponse, nous donnons plus que ce qui était demandé. On aurait pu se contenter de ;\n\n```{.sql}\n...\n\nSELECT p.model\nFROM plane_of_day df  NATURAL JOIN nycflights.planes p \nGROUP BY p.model ;\n```\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Requête 8\n\n\n\n<!-- Énoncé --> \n<!-- division -->\n\nLister les aéroports de destination (`dest`) qui sont desservis au moins une fois à partir de chaque aéroport de départ (`origin`).\n\n:::\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH origins AS (\n  SELECT DISTINCT f.origin  -- les origines\n  FROM nycflights.flights f\n), dests AS (\n  SELECT DISTINCT f.dest  -- les destinations\n  FROM nycflights.flights f\n),\norigin_dest AS (\n  SELECT DISTINCT f.dest, f.origin \n  FROM nycflights.flights f   -- les couples realises\n  ),\norigin_cross_dest AS (\n  SELECT d.dest, o.origin  -- les couples possibles\n  FROM dests d, origins o\n), \nwhitness_orphans AS (\n  SELECT *\n  FROM origin_cross_dest\n\n  EXCEPT\n\n  SELECT *\n  FROM origin_dest  -- couples pas realises\n)\n\nSELECT dest\nFROM dests\n\nEXCEPT\n\nSELECT w.dest\nFROM whitness_orphans w ;\n```\n\n{{< fa hand-point-right >}}  Dans cette réponse, nous n'avons pas utilisé l'agrégation (`GROUP BY ...`). On aurait pu écrire cette requête en algèbre relationnelle. Avec l'agrégation c'est plus simple. \n\n```{.sql}\nWITH R AS (\n  SELECT COUNT(DISTINCT f.origin) as nb_origins\n  FROM nycflights.flights f\n)\n\nSELECT f.dest\nFROM nycflights.flights f\nGROUP BY f.dest \nHAVING COUNT(DISTINCT f.origin) >= ALL (SELECT * FROM R) ;\n```\n\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Requête 9\n\n\n\n<!-- Énoncé --> \n<!-- Division avec fonction fenetre -->\n\nLister les compagnies aériennes (`carrier`) pour lesquelles, chaque jour,\nau moins un avion figure parmi les 10 avions les plus en retard au décollage (`dep_delay`)\nde son aéroport de départ (`origin`). \n\n\n:::\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH delayed_flight AS (\n  SELECT f.origin, f.year, f.month, f.day, f.tailnum, f.carrier,\n         RANK() OVER w AS rnk\n  FROM nycflights.flights f\n  WINDOW w AS (PARTITION BY f.origin, f.year, f.month, f.day \n               ORDER BY f.dep_delay DESC)\n), carriers_of_day  AS (\n  SELECT DISTINCT df.origin, df.year, df.month, df.day, df.carrier\n  FROM delayed_flight df\n  WHERE df.rnk <= 10\n), nb_bad_days_per_carrier AS (\n  SELECT df.origin, \n         df.carrier, \n         COUNT(DISTINCT (df.year, df.month, df.day)) as nb \n  FROM carriers_of_day df  GROUP BY df.origin, df.carrier\n), nb_days AS (\n  SELECT COUNT(DISTINCT (df.year, df.month, df.day)) AS nb\n  FROM carriers_of_day df \n) \n\nSELECT a.origin, a.carrier\nFROM nb_bad_days_per_carrier a \nWHERE a.nb >= ALL (SELECT nb FROM nb_days) ;\n```\n\n{{< fa hand-point-right >}} La complexité de la réponse tient à la complexité de la question : s'il fallait écrire une formule du calcul relationnel des tuples, il faudrait introduire des quantifications  alternées.  Les requêtes de la clause `WITH` correspondent à ses alternances de quantification $\\forall, \\exists$ . `carriers_of_day` liste pour chaque journée répertoriée dans la base,  les transporteurs dont  un avion figure parmi les retardataires du jour pour un aéroport donné. On détermine ensuite le nombre total de journées de la honte pour chaque transporteur, et le nombre total de journées, on sélectionne enfin les transporteurs dont le nombre de journées de la honte coïncide avec le nombre total de journées.\n\n\n\n:::::\n\n:::\n\n::: {.callout-note}\n\n### Requête 10\n\n\n\n<!-- Énoncé --> \n<!-- fenêtres -->\n\nPour chaque couple `(origin, dest)`, lister les dix vols les plus rapides (`airtime` donne le temps de vol, `distance` la distance entre `dest` et `origin`).  \n\n:::\n\n\n\n::: {.content-visible when-profile=\"solution\"}\n\n::::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH R AS (\n  SELECT f.origin, f.dest, f.tailnum, f.flight, RANK() OVER w AS rnk\n  FROM nycflights.flights f\n  WHERE f.airtime IS NOT NULL\n  WINDOW w AS (PARTITION BY f.origin, f.dest ORDER BY f.distance/f.airtime DESC)\n)\n\nSELECT R.*\nFROM R \nWHERE R.rnk <= 10 ;\n```\n\n:::::\n\n:::\n\n::: {.callout-tip}\n\n### Quelques conseils\n\n- Préférez les clauses `WITH` et les jointures aux requêtes imbriquées sauf si la requête imbriquée est très simple. C'est une question de lisibilité et donc souvent de correction.\n\n- Ne mélangez pas les fonctions fenêtres et les clauses `GROUP BY ...`\n\n```{.sql}\nSELECT ..., FOO() OVER w\nFROM R\nWINDOW w AS (PARTITION BY ... ORDER BY ...)\nGROUP BY ... ;  \n```  \n\nest tout simplement incorrect. \n\n- Lorsque vous effectuez un partitionnement par `GROUP BY ...`, la clause `SELECT ...` est sévèrement contrainte, vous n'y trouverez que \n  - les colonnes qui ont servi dans la clause `GROUP BY ...`, normalement elles devraient toutes y figurer\n  - des fonctions d'aggrégation, comme `COUNT(...)`, `SUM(...)`, `VAR(...)`  \n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}