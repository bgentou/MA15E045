{
  "hash": "f89a6f63aa799626689ec3c6433a58f3",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat:\n  pdf:\n    code-annotations: below\n    code-fold: false\n    toc: false\n    output-file: cc3-2024-12-13.pdf\n    include-in-header:\n      - text: \"\\\\lhead{{\\\\sf  Base de données (BD5) \\\\\\\\ CC 3 2024-12-13  17h00-18h15}}\"\n  html:\n    standalone: true\n    code-fold: true\n    output-file: cc3-2024-12-13.html\nparams:\n    year: 2024 \n    curriculum: \"L3 MIASHS/Ingémath/METIS\"\n    university: \"Université Paris Cité\"\n    homepage: \"https://stephane-v-boucheron.fr/courses/bdd\"\n    moodle: \"https://moodle.u-paris.fr/course/view.php?id=2313\"\n\nengine: knitr\n---\n\n\n\n\n\n\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n\n- **L3 MIASHS/Ingémath/METIS**\n- **[Université Paris Cité](https://www.u-paris.fr)**\n- Année 2024-2025\n- [Course Homepage](https://stephane-v-boucheron.fr/courses/bdd)  \n- [Moodle](https://moodle.u-paris.fr/course/view.php?id=2313)\n\n::: \n\n::: {#second-column}\n![](../images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::\n\n:::\n\n::: {.content-hidden when-profile=\"solution\"}\n::: {.callout-caution}\n\n- Pas de documents autorisés\n- Pas de téléphone portable \n- Merci d'écrire vos requêtes en respectant les habitudes  d'indentation et de mise en page suivies en cours et dans les documents.\n\n:::\n:::\n\n\n\nDans une métropole,  un exploitant  de vélos partagés cherche à archiver des informations \nconcernant les vélos et les stations.\n\nChaque vélo est identifié par un numéro. Un vélo possède une date de mise en service, un type (électrique/mécanique). Un vélo possède éventuellement une date de retrait de service. \n\nUne station est identifiée par un numéro. Une station possède un nom. Une station possède une position (lattitude, longitude) et une altitude. Une station possède un nombre de fixe de bornes d'accrochages. \n\nUn trajet est effectué par un vélo entre un instant (`timestamp`) de départ et un instant d'arrivée. Un trajet part d'une station et arrive à une station (pas toujours différente). \n\n\n\n\n::: {.callout-note title=\"Question\"}\n\nProposer un diagrammme entité-association correspondant à cette modélisation.\n\n:::\n\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n\n\n\n```{dot}\n//| label: er1\n//| eval: true\n//| echo: false\ngraph ER {\n\tfontname=\"Helvetica,Arial,sans-serif\"\n\tnode [fontname=\"Helvetica,Arial,sans-serif\"]\n\tedge [fontname=\"Helvetica,Arial,sans-serif\"]\n\tlayout=neato\n\tnode [shape=box]; Velo; Station ; \n\tnode [shape=ellipse]; {node [label=<<u>numero</u>>]  num1; num2;} ;\n    type ; \"date-service\" ; \"date-retrait\" ; \"debut\" ; \"fin\" ;  lattitude ; longitude ; nom ;\n  node [shape=diamond];  \"trajet\"  ;\n  \n\tnum1 -- Velo ;\n  num2 -- Station ; \n  type -- Velo ;\n  \"date-service\" -- Velo ;\n  \"date-retrait\" -- Velo ;\n  \"debut\" --  trajet ;\n  \"fin\" -- trajet ;\n  lattitude -- Station ;\n  longitude -- Station ;\n  nom -- Station ;\n  Velo -- trajet [label=\"0:n\",len=1.00] ;\n  Station -- trajet [label=\"0:n  origine\", len=2.00] ;\n  Station -- trajet [label=\"0:n  destination\", len=2.00] ;\n  \n  \n    //\tlabel = \"\\n\\nEntity Relation Diagram\\ndrawn by NEATO\";\n//\tfontsize=20;\n}\n```\n\n\n\n\n`trajet`  est une association *ternaire* avec des cardinalités `0:n`. C'est une association\n*plusieurs-plusieurs*.  \n\n::: \n\n\n\n\n{{< pagebreak >}}\n\n\n\n\n\n\n:::\n\n\n::: {.callout-note title=\"Question\"}\n\nSi besoin, transformez votre schéme de façon à ce qu'il ne comporte \nplus d'associations d'arité supérieure ou égale à 3, ou d'associations plusieurs-plusieurs \n(0:n pour plusieurs entités participantes).  \n\n:::\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-tip title=\"Solution\"} \n\n\n\n\n```{dot}\n//| label: er2\n//| eval: true\n//| echo: false\ngraph ER {\n\tfontname=\"Helvetica,Arial,sans-serif\"\n\tnode [fontname=\"Helvetica,Arial,sans-serif\"]\n\tedge [fontname=\"Helvetica,Arial,sans-serif\"]\n\tlayout=neato\n\tnode [shape=box]; Velo; Station ; \n\tnode [shape=ellipse]; {node [label=<<u>numero</u>>]  num1; num2;} ;\n    type ; \"date-service\" ; \"date-retrait\" ; {node [label=<<u>debut</u>>] \"debut\" }; \"fin\" ;  lattitude ; longitude ; nom ;\n  node [shape=box, peripheries=2];  \"trajet\"  ;\n  node [shape=diamond, peripheries=2]; \n  {node [label=\"utilise\"] many1};  \n  {node [label=\"origine\"] many2} ;  \n  {node [label=\"destination\"] many3}  ; \n\tnum1 -- Velo ;\n  num2 -- Station ; \n  type -- Velo ;\n  \"date-service\" -- Velo ;\n  \"date-retrait\" -- Velo ;\n  \"debut\" --  trajet ;\n  \"fin\" -- trajet ;\n  lattitude -- Station ;\n  longitude -- Station ;\n  nom -- Station ;\n  \n  Velo -- many1 [label=\"0:n\",len=1.00] ;\n  many1 -- trajet [label=\"1:1\", len=1.00] ;\n  \n  Station -- many2 [label=\"0:n\", len=1.00] ;\n  many2 -- trajet [label=\"1:1\", len=1.00] ;\n\n  Station -- many3 [label=\"0:n\", len=1.00] ;\n  many3 -- trajet [label=\"1:1\", len=1.00] ;\n  \n    //\tlabel = \"\\n\\nEntity Relation Diagram\\ndrawn by NEATO\";\n//\tfontsize=20;\n}\n```\n\n\n\n\n\n\n:::\n\n\n\n\n{{< pagebreak >}}\n\n\n\n\n\n\n:::\n\n::: {.callout-note title=\"Question\"}\n\nProposer une traduction en pattes de corbeau du diagramme EA proposé en réponse   \nà la première question. \n\n:::\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-tip title=\"Solution\"}\n\n\n\n\n```{mermaid}\n%%| label: crow1\n%%| eval: true\n%%| echo: false\n%%| fig-width: 6\nerDiagram\n    TRAJET }o--|| VELO : velo_num \n    TRAJET }o--|| STATION  : origin_num\n    TRAJET }o--|| STATION : dest_num \n\n  VELO {\n    integer num PK\n    text type \n    date mise_service_date\n    date retrait-date  \n  }\n\n  STATION {\n    integer num PK\n    numeric lat\n    numeric long\n    text name\n    integer docks \n  }\n\n  TRAJET {\n    integer velo_num PK, FK\n    integer origin_num PK, FK\n    integer dest_num FK\n    timestamp start PK\n    timestamp end \n  }\n```\n\n\n\n\n::: \n:::\n\n\n::: {.callout-note title=\"Question\"}\n\nExplicitez d'éventuelles contraintes externes (si vous l'avez déjà fait en marge du diagramme entité-association, contentez-vous d'un renvoi).\n\n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n1. La date de retrait de service d'un vélo ne peut pas précéder sa mise en service (`CHECK`)\n2. Un vélo ne peut pas être utilisé pour un trajet s'il nest pas en service (contrainte *multitable*, réalisable avec une fonction qui renvoie l'intervalle pendant lequel un vélo est en service et une contrainte `CHECK` qui vérifie que `(start,end )` est inclus dans l'intervalle de service)\n3. Le début d'un trajet doit précéder sa fin  (`CHECK`)\n4. Un même vélo ne peut pas effectuer deux trajets simultanément  (`EXCLUDE`)\n  \n\n:::\n\n:::\n\n::: {.callout-warning title=\"Attention\"}\n\nDans la suite, vous formulerez les requêtes dans le schéma relationnel défini \npar votre schéma en pattes de corbeau. \n\n:::\n\n::: {.callout-note title=\"Question\"}\n\nPour chaque station, chaque heure de la journée, comptez le nombre de trajets partis de la station. \n\n:::\n\n::: {.callout-tip}\n\nPostgreSQL propose un type `timestamp` (qui permet de représenter les instants à la microseconde près). \nPostgreSQL propose  une fonction fonction  `date_part(text, timestamp)` qui permet d'extraire les \ndifférents composants d'un objet de type `timestamp`. `date_part('month', timestamp)` extrait le mois grégorien (un entier \nde 1 à 12), `date_part('hour', timestamp)` extrait l'heure du jour  (un entier de 0 à 23). \n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT \n  tr.origin_num, date_part('hour', start) AS heure,\n  count(*) AS n_trajet\nFROM \n  trajet tr\nGROUP BY \n  tr.origin_num, date_part('hour', start) ;\n```\n\n::: \n\n:::\n\n::: {.callout-note title=\"Question\"}\n\nPour chaque vélo, comptez le nombre de trajets de plus d'une heure effectués. \n\n:::\n\n::: {.callout-tip}\n\nEn PostgreSQL, la différence de deux objets de type `timestamp` est un objet de type `interval` (durée). Pour \ndéfinir une constante correspondant à une durée d'un jour, d'un mois, d'une heure, vous pouvez utiliser \nla syntaxe `'1 day'::interval`, `'1 month'::interval`, `'1 hour'::interval`. \n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT\n  tr.velo_num,\n  count(*) AS nb_trajets\nFROM \n  trajet tr\nWHERE \n  (tr.end IS NOT NULL AND (tr.start - tr.end) > '1 hour'::interval)   OR\n  (tr.end IS NULL AND (current_timestamp - tr.start) > '1 hour'::interval)\nGROUP BY \n  tr.velo_num ;\n```\n\n::: \n\n:::\n\n::: {.callout-note title=\"Question\"}\n\nPour chaque jour de la semaine,  listez les quatre couples (station de départ, station d'arrivée) utilisés \npar le plus  grand nombre de trajets ce jour de la semaine là.\n\n:::\n\n::: {.callout-tip}\n\nEn PostgreSQL, pour extraire le jour de la semaine d'un objet `ts` de type `timestamp`, vous pouvez utiliser \n`EXTRACT(DOW FROM ts)`. Le résultat est un entier entre 0 et 6, 0 pour dimanche, 1 pour lundi, ..., 7 pour samedi.  \n\n```{.sql}\npostgres=# SELECT \n  current_timestamp as maintenant , \n  EXTRACT(DOW FROM current_timestamp + '1 day'::interval) as dow_demain ;\n\n          maintenant           | dow_demain \n-------------------------------+------------\n 2024-12-08 10:55:05.672936+01 |          1\n```\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH R AS \n(\n   SELECT \n     EXTRACT(DOW FROM tr.start) AS jds, \n     tr.origin_num,  tr.dest_num, \n     COUNT(*) AS nb_trajets\n   FROM \n     trajet tr \n   GROUP BY\n     EXTRACT(DOW FROM tr.start), \n     tr.origin_num, \n     tr.dest_num\n), S AS \n(\n  SELECT \n    R.*, \n    RANK() OVER (PARTITION BY R.jds ORDER BY R.nb_trajets DESC) AS rnk\n  FROM \n    R\n)\n\nSELECT \n  S.*\nFROM \n  S\nWHERE S.rnk <= 4 ;\n```\n\n::: \n\n:::\n\n\n::: {.callout-note title=\"Question\"}\n\nSoit $\\mathcal{A} = \\{\\texttt{A, B, C, D, E, H, S, T}\\}$ un schéma. \n\nSoit Σ = {`{A, E}` $⟶$ `{H}`, `{S, T}` $⟶$ `{C, E}`, `{S}` $⟶$ `{A}`, `{B}` $⟶$ `{T}`}\n\n- Quelle est la fermeture de `{B, S, E}` ?\n- Quelles sont les clés de $\\mathcal{A}, \\Sigma$ ?\n- $\\mathcal{A}, \\Sigma$ est elle forme normale de Boyce-Codd ?\n\n:::\n\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n- $\\texttt{[B, S, E]}_{\\Sigma}^+ = \\{ \\texttt{B, S, E, T, C, A, H}\\} = \\{ \\texttt{A, B, C, E, H, S, T}\\}$\n- Toute clé contient $\\texttt{B, D, S}$ qui est une super-clé $[\\texttt{B, D, S}]^+_\\Sigma = \\{\\texttt{B, D, S, A, T, C, E, H}\\}$. C'est la seule clé.\n- Le schéma n'est pas en FNBC, toutes les DF de Σ ont un déterminant qui n'est pas une super-clé.\n  \n::: \n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}