{
  "hash": "beff144e451feb85d12833349bee010f",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat:\n  pdf:\n    code-annotations: below\n    code-fold: false\n    toc: false\n    output-file: cc3-2024-12-13.pdf\n    include-in-header:\n      - text: \"\\\\lhead{{\\\\sf  Base de données (BD5) \\\\\\\\ CC 3 2024-12-13  17h00-18h15}}\"\n  html:\n    standalone: true\n    code-fold: true\n    output-file: cc3-2024-12-13.html\nparams:\n    year: 2024 \n    curriculum: \"L3 MIASHS/Ingémath/METIS\"\n    university: \"Université Paris Cité\"\n    homepage: \"https://stephane-v-boucheron.fr/courses/bdd\"\n    moodle: \"https://moodle.u-paris.fr/course/view.php?id=2313\"\n\nengine: knitr\n---\n\n\n\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n\n- **L3 MIASHS/Ingémath/METIS**\n- **[Université Paris Cité](https://www.u-paris.fr)**\n- Année 2024-2025\n- [Course Homepage](https://stephane-v-boucheron.fr/courses/bdd)  \n- [Moodle](https://moodle.u-paris.fr/course/view.php?id=2313)\n\n::: \n\n::: {#second-column}\n![](/images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::\n\n:::\n\n::: {.content-hidden when-profile=\"solution\"}\n::: {.callout-caution}\n\n- Pas de documents autorisés\n- Pas de téléphone portable \n- Merci d'écrire vos requêtes en respectant les habitudes  d'indentation et de mise en page suivies en cours et dans les documents.\n\n:::\n:::\n\n\n\nDans une métropole,  un exploitant  de vélos partagés cherche à archiver des informations \nconcernant les vélos et les stations.\n\nChaque vélo est identifié par un numéro. Un vélo possède une date de mise en service, un type (électrique/mécanique). Un vélo possède éventuellement une date de retrait de service. \n\nUne station est identifiée par un numéro. Une station possède un nom. Une station possède une position (lattitude, longitude) et une altitude. Une station possède un nombre de fixe de bornes d'accrochages. \n\nUn trajet est effectué par un vélo entre un instant (`timestamp`) de départ et un instant d'arrivée. Un trajet part d'une station et arrive à une station (pas toujours différente). \n\n\n\n\n::: {.callout-note title=\"Question\"}\n\nProposer un diagrammme entité-association correspondant à cette modélisation.\n\n:::\n\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{dot}\n//| label: er1\n//| eval: true\n//| echo: false\ngraph ER {\n\tfontname=\"Helvetica,Arial,sans-serif\"\n\tnode [fontname=\"Helvetica,Arial,sans-serif\"]\n\tedge [fontname=\"Helvetica,Arial,sans-serif\"]\n\tlayout=neato\n\tnode [shape=box]; Velo; Station ; \n\tnode [shape=ellipse]; {node [label=<<u>numero</u>>]  num1; num2;} ;\n    type ; \"date-service\" ; \"date-retrait\" ; \"debut\" ; \"fin\" ;  lattitude ; longitude ; nom ;\n  node [shape=diamond];  \"trajet\"  ;\n  \n\tnum1 -- Velo ;\n  num2 -- Station ; \n  type -- Velo ;\n  \"date-service\" -- Velo ;\n  \"date-retrait\" -- Velo ;\n  \"debut\" --  trajet ;\n  \"fin\" -- trajet ;\n  lattitude -- Station ;\n  longitude -- Station ;\n  nom -- Station ;\n  Velo -- trajet [label=\"0:n\",len=1.00] ;\n  Station -- trajet [label=\"0:n  origine\", len=2.00] ;\n  Station -- trajet [label=\"0:n  destination\", len=2.00] ;\n  \n  \n    //\tlabel = \"\\n\\nEntity Relation Diagram\\ndrawn by NEATO\";\n//\tfontsize=20;\n}\n```\n\n`trajet`  est une association *ternaire* avec des cardinalités `0:n`. C'est une association\n*plusieurs-plusieurs*.  \n\n::: \n\n::: {.callout-note}\n\n### Remarque(s) \n\nCe schéma ressemble beaucoup à celui des vols dans `nycflights` [voir diapositives](/slides/Modelisation_2.html#/transformation-de-lassociation-quarternaire-en-quatre-associations-binaires-faibles). Dans les deux schémas, une entité (aéroport, station) participe avec deux rôles distincts à une association \n\n\nEn science des données on parle de schéma en étoile (*star schéma*): un vol, une mission, un trajet \nest un *événement* (*event*) auquel participent des objets (vélo, avion, aéroport, station de vélib, etc). L'événement est --à première vue-- une instance d'association. Cette association est  dans les deux cas une association plusieurs-plusieurs et son *arité* est supérieure ou égale à trois.\n\nIl n'est pas utile de définir une entité position munie deux attributs lattitude et longitude. Pour\nlier position et station on est conduit à définir une association avec des cardinalités 1:1 (côté station) et 0:1 (côté position). Ce genre d'association gagne à être représenté par des attributs (rester simple, invoquer le rasoir d'Occam). \n\n:::\n\n{{< pagebreak >}}\n\n:::\n\n\n::: {.callout-note title=\"Question\"}\n\nSi besoin, transformez votre schéme de façon à ce qu'il ne comporte \nplus d'associations d'arité supérieure ou égale à 3, ou d'associations plusieurs-plusieurs \n(0:n pour plusieurs entités participantes).  \n\n:::\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-tip title=\"Solution\"} \n\n```{dot}\n//| label: er2\n//| eval: true\n//| echo: false\ngraph ER {\n\tfontname=\"Helvetica,Arial,sans-serif\"\n\tnode [fontname=\"Helvetica,Arial,sans-serif\"]\n\tedge [fontname=\"Helvetica,Arial,sans-serif\"]\n\tlayout=neato\n\tnode [shape=box]; Velo; Station ; \n\tnode [shape=ellipse]; {node [label=<<u>numero</u>>]  num1; num2;} ;\n    type ; \"date-service\" ; \"date-retrait\" ; {node [label=<<u>debut</u>>] \"debut\" }; \"fin\" ;  lattitude ; longitude ; nom ;\n  node [shape=box, peripheries=2];  \"trajet\"  ;\n  node [shape=diamond, peripheries=2]; \n  {node [label=\"utilise\"] many1};  \n  {node [label=\"origine\"] many2} ;  \n  {node [label=\"destination\"] many3}  ; \n\tnum1 -- Velo ;\n  num2 -- Station ; \n  type -- Velo ;\n  \"date-service\" -- Velo ;\n  \"date-retrait\" -- Velo ;\n  \"debut\" --  trajet ;\n  \"fin\" -- trajet ;\n  lattitude -- Station ;\n  longitude -- Station ;\n  nom -- Station ;\n  \n  Velo -- many1 [label=\"0:n\",len=1.00] ;\n  many1 -- trajet [label=\"1:1\", len=1.00] ;\n  \n  Station -- many2 [label=\"0:n\", len=1.00] ;\n  many2 -- trajet [label=\"1:1\", len=1.00] ;\n\n  Station -- many3 [label=\"0:n\", len=1.00] ;\n  many3 -- trajet [label=\"1:1\", len=1.00] ;\n  \n    //\tlabel = \"\\n\\nEntity Relation Diagram\\ndrawn by NEATO\";\n//\tfontsize=20;\n}\n```\n\n\n::: {.callout-note}\n\n### Remarque\n\nConsidérer `Trajet` comme une entité est assez tentant. Si on le fait d'emblée, il faut se demander ce qui identifie les instances de cette entité. Beaucoup sont tentés d'introduire un \nidentifiant artificiel `trajet_id` (de fait ce genre d'identifiant artificiel est facile à introduire lors de l'implémentation en PostGres, en MySQL, ou autre). On perd de vue que \nce qui identifie un trajet, c'est un vélo, une station de départ et une heure de départ.\nVu comme cela, `Trajet` apparaît comme une association ternaire plusieurs-plusieurs, qu'on se dépêche de transformer en entité faible. L'heure de départ est un identifiant relatif. \n\n\n:::\n:::\n\n{{< pagebreak >}}\n\n:::\n\n::: {.callout-note title=\"Question\"}\n\nProposer une traduction en pattes de corbeau du diagramme EA proposé en réponse   \nà la première question. \n\n:::\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-tip title=\"Solution\"}\n\n```{mermaid}\n%%| label: crow1\n%%| eval: true\n%%| echo: false\n%%| fig-width: 6\nerDiagram\n    TRAJET }o--|| VELO : velo_num \n    TRAJET }o--|| STATION  : origin_num\n    TRAJET }o..|| STATION : dest_num \n\n  VELO {\n    integer num PK\n    text type \n    date mise_service_date\n    date retrait-date  \n  }\n\n  STATION {\n    integer num PK\n    numeric lat\n    numeric long\n    text name\n    integer docks \n  }\n\n  TRAJET {\n    integer velo_num PK, FK\n    integer origin_num PK, FK\n    integer dest_num FK\n    timestamp start PK\n    timestamp end \n  }\n```\n:::\n\n::: {.callout-note}\n\n### Remarque \n\nLe lien qui correspond à la contrainte référentielle entre `TRAJET.dest_num` et `STATION.num`\nn'est pas identifiant.\n\n:::\n:::\n\n\n::: {.callout-note title=\"Question\"}\n\nExplicitez d'éventuelles contraintes externes (si vous l'avez déjà fait en marge du diagramme entité-association, contentez-vous d'un renvoi).\n\n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n1. La date de retrait de service d'un vélo ne peut pas précéder sa mise en service (`CHECK`)\n2. Un vélo ne peut pas être utilisé pour un trajet s'il nest pas en service (contrainte *multitable*, réalisable avec une fonction qui renvoie l'intervalle pendant lequel un vélo est en service et une contrainte `CHECK` qui vérifie que `(start,end )` est inclus dans l'intervalle de service)\n3. Le début d'un trajet doit précéder sa fin  (`CHECK`)\n4. Un même vélo ne peut pas effectuer deux trajets simultanément  (`EXCLUDE`)\n  \n\n:::\n\n::: {.callout-note}\n\n### Remarque\n\nLes contraintes référentielles, les contraintes de clé sont déjà décrites par le diagramme. Il est inutile de les répéter. Ce ne sont pas des contraintes externes.\n:::\n\n:::\n\n::: {.callout-warning title=\"Attention\"}\n\nDans la suite, vous formulerez les requêtes dans le schéma relationnel défini \npar votre schéma en pattes de corbeau. \n\n:::\n\n::: {.callout-note title=\"Question\"}\n\nPour chaque station, chaque heure de la journée, comptez le nombre de trajets partis de la station. \n\n:::\n\n::: {.callout-tip}\n\nPostgreSQL propose un type `timestamp` (qui permet de représenter les instants à la microseconde près). \nPostgreSQL propose  une fonction fonction  `date_part(text, timestamp)` qui permet d'extraire les \ndifférents composants d'un objet de type `timestamp`. `date_part('month', timestamp)` extrait le mois grégorien (un entier \nde 1 à 12), `date_part('hour', timestamp)` extrait l'heure du jour  (un entier de 0 à 23). \n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT \n  tr.origin_num, date_part('hour', start) AS heure,\n  count(*) AS n_trajet\nFROM \n  trajet tr\nGROUP BY \n  tr.origin_num, date_part('hour', start) ;\n```\n\n::: \n\n:::\n\n::: {.callout-note title=\"Question\"}\n\nPour chaque vélo, comptez le nombre de trajets de plus d'une heure effectués. \n\n:::\n\n::: {.callout-tip}\n\nEn PostgreSQL, la différence de deux objets de type `timestamp` est un objet de type `interval` (durée). Pour \ndéfinir une constante correspondant à une durée d'un jour, d'un mois, d'une heure, vous pouvez utiliser \nla syntaxe `'1 day'::interval`, `'1 month'::interval`, `'1 hour'::interval`. \n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT\n  tr.velo_num,\n  count(*) AS nb_trajets\nFROM \n  trajet tr\nWHERE \n  (tr.end IS NOT NULL AND (tr.start - tr.end) > '1 hour'::interval)   OR\n  (tr.end IS NULL AND (current_timestamp - tr.start) > '1 hour'::interval)\nGROUP BY \n  tr.velo_num ;\n```\n\n::: \n\n:::\n\n::: {.callout-note title=\"Question\"}\n\nPour chaque jour de la semaine,  listez les quatre couples (station de départ, station d'arrivée) utilisés \npar le plus  grand nombre de trajets ce jour de la semaine là.\n\n:::\n\n::: {.callout-tip}\n\nEn PostgreSQL, pour extraire le jour de la semaine d'un objet `ts` de type `timestamp`, vous pouvez utiliser \n`EXTRACT(DOW FROM ts)`. Le résultat est un entier entre 0 et 6, 0 pour dimanche, 1 pour lundi, ..., 7 pour samedi.  \n\n```{.sql}\npostgres=# SELECT \n  current_timestamp as maintenant , \n  EXTRACT(DOW FROM current_timestamp + '1 day'::interval) as dow_demain ;\n\n          maintenant           | dow_demain \n-------------------------------+------------\n 2024-12-08 10:55:05.672936+01 |          1\n```\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH R AS \n(\n   SELECT \n     EXTRACT(DOW FROM tr.start) AS jds, \n     tr.origin_num,  tr.dest_num, \n     COUNT(*) AS nb_trajets\n   FROM \n     trajet tr \n   GROUP BY\n     EXTRACT(DOW FROM tr.start), \n     tr.origin_num, \n     tr.dest_num\n), S AS \n(\n  SELECT \n    R.*, \n    RANK() OVER (PARTITION BY R.jds ORDER BY R.nb_trajets DESC) AS rnk\n  FROM \n    R\n)\n\nSELECT \n  S.*\nFROM \n  S\nWHERE S.rnk <= 4 ;\n```\n\n::: \n\n:::\n\n\n::: {.callout-note title=\"Question\"}\n\nSoit $\\mathcal{A} = \\{\\texttt{A, B, C, D, E, H, S, T}\\}$ un schéma. \n\nSoit Σ = {`{A, E}` $⟶$ `{H}`, `{S, T}` $⟶$ `{C, E}`, `{S}` $⟶$ `{A}`, `{B}` $⟶$ `{T}`}\n\n- Quelle est la fermeture de `{B, S, E}` ?\n- Quelles sont les clés de $\\mathcal{A}, \\Sigma$ ?\n- $\\mathcal{A}, \\Sigma$ est elle forme normale de Boyce-Codd ?\n\n:::\n\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n- $\\texttt{[B, S, E]}_{\\Sigma}^+ = \\{ \\texttt{B, S, E, T, C, A, H}\\} = \\{ \\texttt{A, B, C, E, H, S, T}\\}$\n- Toute clé contient $\\texttt{B, D, S}$ qui est une super-clé $[\\texttt{B, D, S}]^+_\\Sigma = \\{\\texttt{B, D, S, A, T, C, E, H}\\}$. C'est la seule clé.\n- Le schéma n'est pas en FNBC, toutes les DF de Σ ont un déterminant qui n'est pas une super-clé.\n  \n::: \n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}