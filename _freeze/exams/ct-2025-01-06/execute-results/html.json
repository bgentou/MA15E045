{
  "hash": "358ba114c95fb1cd8ca2e9db5a85bd1b",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat:\n  pdf:\n    code-annotations: below\n    code-fold: false\n    toc: false\n    output-file: ct-2025-01-06.pdf\n    include-in-header:\n      - text: \"\\\\lhead{{\\\\sf  Base de données (BD5) \\\\\\\\ CT  2025-01-06  13h30-16h30}}\"\n  html:\n    standalone: true\n    code-fold: true\n    output-file: ct-2025-01-06.html\nparams:\n    year: 2024 \n    curriculum: \"L3 MIASHS/Ingémath/METIS\"\n    university: \"Université Paris Cité\"\n    homepage: \"https://stephane-v-boucheron.fr/courses/bdd\"\n    moodle: \"https://moodle.u-paris.fr/course/view.php?id=2313\"\n\nengine: knitr\nexecute: \n  eval: true\n  echo: false\n---\n\n\n\n\n\n\n\n::: {layout=\"[80,20]\"}\n\n::: {#first-column}\n\n\n- **L3 MIASHS/Ingémath/METIS**\n- **[Université Paris Cité](https://www.u-paris.fr)**\n- Année 2024-2025\n- [Course Homepage](https://stephane-v-boucheron.fr/courses/bdd)  \n- [Moodle](https://moodle.u-paris.fr/course/view.php?id=2313)\n\n::: \n\n::: {#second-column}\n![](../images/UniversiteParis_monogramme_couleur_RVB.png){align=\"right\" style=\"size:50px;\" width=75}\n:::\n\n:::\n\n::: {.content-hidden when-profile=\"solution\"}\n::: {.callout-caution}\n\n- Pas de documents autorisés\n- Pas de téléphone portable \n- Merci d'écrire vos requêtes en respectant les habitudes  d'indentation et de mise en page suivies en cours et dans les documents.\n\n:::\n:::\n\n\n\n::: {layout=\"[35,65]\"}\n\n::: {#first-column}\n\n![](/images/taburin_9782070411962_1_75.jpg){width=180px fig-align=\"left\"} \n\n:::\n\n::: {#second-column}\n\n| Raoul Taburin, vélociste (marchand-réparateur de bicyclettes), a décidé de s'équiper d'un système d'information. Il a fait réaliser une analyse par un cabinet de conseil réputé. \n\n<br>\n\n| Le vélociste vend des produits (dérailleurs, jantes, freins, selles, guidons, ...). Chaque  produit est identifié par un numéro de catalogue (`product_id`). Un produit est vendu  par un fabricant connu par son nom (Campagnolo, Shimano, Simplex,...). Un produit possède une description (texte). Un produit relève d'une catégorie identifiée par un numéro (`cat_id`) et munie d'une description (pédalier, freins à | disque, tige de selle télescopique, ...). Un produit relève aussi d'une gamme (Ultegra, 105, Tiagra, ...).    \n\n| Un produit possède un prix unitaire. \n\n<br>\n\n| À chaque produit du catalogue correspond une entrée dans l'inventaire. Dans cette entrée on reporte le numéro du produit, le nombre d'exemplaires en stock (`en_stock`) et le nombre d'exemplaires déjà vendus (`vendus`). \n\n\n:::\n\n:::\n\n\nPour chaque produit, le vélociste est amené à effectuer des réapprovisionnements (commandes). Chaque commande concerne \nun produit, elle est efféctuée à une date notée `date_com`. La commande porte sur une quantité notée `qte`. La commande est livrée au vélociste (si tout se passe bien) à la date `date_liv`. Pour une commande qui n'a pas encore été livrée, `date_liv`  est réputée `NULL`.\n\n\nLe vélociste  possède des fidèles clients. Chaque fidèle client est identifié par un numéro (`client_id`), possède un nom, une adresse (texte), un numéro de téléphone. Sur chaque client, le vélociste possède des renseignements démographiques (année de naissance, sexe, profession, taille).\n\nLorsqu'un fidèle client effectue un achat, le vélociste émet une facture identifiée  par un numéro de facture `fact_id`.\nLa facture comporte le numéro du client, une date et un montant global (`montant`).\n\nUne facture se compose de lignes. Chaque ligne comporte une référence à un produit désigné par son numéro de catalogue, une quantité (`qte`) et un montant (calculé à partir de `qte` et du prix unitaire du produit). Chaque ligne de facture est identifiée par un numéro de ligne `num_ligne` (relativement à la facture).  \n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.callout-note}\n\n### Question 1 (4pts)\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\nProposer un diagrammme entité-association (EA) correspondant à cette modélisation.\n\n:::\n\n::: {.callout-tip title=\"Conseils\"}\n\n- Distinguer entités fortes et faibles\n- Distinguer associations fortes et faibles\n- Pour chaque entité préciser l'identifiant (éventuellement relatif)\n- Préciser les cardinalités pour chaque participation à une association\n\n:::\n\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n\n\n\n```{dot}\n//| label: er1\n//| eval: true\n//| echo: false\n//| include: true\ngraph ER {\n\tfontname=\"Helvetica,Arial,sans-serif\"\n\tnode [fontname=\"Helvetica,Arial,sans-serif\"]\n\tedge [fontname=\"Helvetica,Arial,sans-serif\"]\n\tlayout=neato\n\tnode [shape=box]; \"client\"; \"facture\" ; \"produit\" ; \"catégorie\" ;\n\tnode [shape=ellipse] ; nom ; adresse ; sexe ; profession  ;  prix ; montant  ; \n  \"date_liv\" ; fabricant ; gamme  ;\n  {node [label=\"description\"] desc1 ; desc2 ;}\n  {node [label=\"qté\"] qte1 ; qte2 ;}\n  {node [label=<<u>client_id</u>>] client_id}  ;\n  {node [label=<<u>produit_id</u>>] produit_id}  ;\n  {node [label=<<u>facture_id</u>>] facture_id}  ;\n  {node [label=<<u>num_ligne</u>>] num_ligne} ;\n  {node [label=<<u>cat_id</u>>] cat_id} ;\n  {node [label=<<u>date</u>>] date_reappro} ; \n\n  node [shape=diamond];  \"paye\"  ; \"concerne\" ; \"relève_de\" ;\n  node [shape=box, peripheries=2];  \"inventaire\"  ; \"réappro\" ; \"ligne\" ; \n  node [shape=diamond, peripheries=2];\n  \"demande\" ; \"dans\" ;\n  {node [label=\"\"] \"fictif\"} ;\n  client_id -- client ;\n  adresse -- client ;\n  sexe -- client ;\n  nom -- client ;\n  profession -- client ;\n  produit_id -- produit ;\n  desc1 -- produit ; \n  vendus -- inventaire ;\n  \"qte_en_stock\" -- inventaire ;\n  gamme -- produit ;\n  fabricant -- produit ; \n  facture_id -- facture ;\n  prix -- produit ;\n  num_ligne -- ligne ; \n  montant -- facture ;\n  \"catégorie\" -- cat_id ;\n  \"catégorie\" -- desc2 ;\n  \"réappro\" -- \"date_liv\" ; \n  qte1 -- ligne ;\n  qte2 -- \"réappro\" ;\n\n  \"client\" -- \"paye\" [label=\"0:n\",len=1.00] ;\n  \"paye\" -- \"facture\" [label=\"1:1\", len=1.00] ;\n  \"facture\" -- \"dans\" [label=\"0:n\",len=1.00] ;\n  \"dans\" -- \"ligne\" [label=\"1:1\", len=1.00] ;\n  \"ligne\" -- \"concerne\" [label=\"1:1\"] ;\n  \"concerne\" -- \"produit\" [label=\"0:n\",len=1.00] ; \n  \"inventaire\" -- \"fictif\" [label=\"1:1\", len=1.0] ;\n  \"fictif\" -- \"produit\" [label=\"1:1\", len=2.0] ;\n  \"produit\" -- \"demande\" [label=\"1:n\", len=2.0] ;\n  \"demande\" -- \"réappro\" [label=\"1:1\", len=1.00] ;\n  \"produit\" -- \"relève_de\"  [label=\"1:1\", len=2.00] ;\n  \"relève_de\" -- \"catégorie\" [label=\"0:n\", len=1.00] ;\n  date_reappro -- \"réappro\" ;\n    //\tlabel = \"\\n\\nEntity Relation Diagram\\ndrawn by NEATO\";\n//\tfontsize=20;\n}\n```\n\n\n\n\n\n::: \n\n\n::: {.callout-note}\n\n### Remarque\n\n- Nous n'avons pas décrit tous les attributs, pour ne pas surcharger un schéma déjà chargé.\n- Définir `inventaire`  comme une entité faible subordonnée à l'entité `produit` est un choix discutable.\nComme l'inventaire n'est pas historicisé (c'est l'inventaire à l'instant courant),  on peut aussi bien ajouter à l'entité `produit` les attributs de l'entité `inventaire`.    \n- Un réapprovisionnement est identifié par le produit et la date de commande. Il s'agit d'une entité faible associée à `produit` par une association faible `demande`  \n- `ligne` est une entitée faible identifiée par l'identifiant relatif `num_ligne` et l'identifiant de l'entité forte associée `facture`\n- L'association entre `ligne`  et `produit` n'est pas identifiante.\n \n:::\n\n\n::: {.callout-note}\n\n### Avec Chat-GPT 3.5\n\n> Voici une proposition pour un schéma entité-association (EA) basé sur votre description du système du vélociste :\n\n> La notation des cardinalités n'est pas exactement celle du cours.\n> Les entités et associations faibles ne sont pas mises en évidence, mais \n> le gros, l'essentiel du travail est effectué. \n\n1. **Produit**  \n   - Attributs : `product_id` (PK), `nom_produit`, `description`, `cat_id`, `nom_gamme`, `prix_unitaire`\n   - Association :\n     - Relié à `Inventaire` (1,1) → (`product_id`)\n     - Relié à `Commande` (1,n) → (`product_id`)\n     - Relié à `LigneFacture` (1,n) → (`product_id`)\n\n2. **Catégorie**  \n   - Attributs : `cat_id` (PK), `description`\n\n3. **Inventaire**  \n   - Attributs : `product_id` (FK, PK), `en_stock`, `vendus`\n   - Association : Relié à `Produit` (1,1)\n\n4. **Commande**  \n   - Attributs : `commande_id` (PK), `product_id` (FK), `date_com`, `qte`, `date_liv`\n   - Association : Relié à `Produit` (n,1)\n\n5. **Client**  \n   - Attributs : `client_id` (PK), `nom`, `adresse`, `telephone`, `annee_naissance`, `sexe`, `profession`, `taille`\n   - Association :\n     - Relié à `Facture` (1,n)\n\n6. **Facture**  \n   - Attributs : `fact_id` (PK), `client_id` (FK), `date_fact`, `montant`\n   - Association :\n     - Relié à `Client` (n,1)\n     - Relié à `LigneFacture` (1,n)\n\n7. **LigneFacture**  \n   - Attributs : `fact_id` (FK), `num_ligne` (PK relatif), `product_id` (FK), `qte`, `montant`\n   - Association :\n     - Relié à `Facture` (n,1)\n     - Relié à `Produit` (n,1)\n\n### Associations principales\n\n- Chaque **produit** appartient à une **catégorie**. \n- Un produit a des entrées associées dans l'**inventaire** et des commandes de réapprovisionnement.\n- Les **clients** peuvent avoir plusieurs **factures**, chaque facture pouvant contenir plusieurs lignes relatives à un ou plusieurs produits.\n\n:::\n\n\n\n\n{{< pagebreak >}}\n\n\n\n\n\n\n:::\n\n::: {.content-visible when-profile='solution'} \n\n\n\n\n```{dot}\n//| label: er1-bis\n//| eval: true\n//| echo: false\n//| include: true\ngraph ER {\n\tfontname=\"Helvetica,Arial,sans-serif\"\n\tnode [fontname=\"Helvetica,Arial,sans-serif\"]\n\tedge [fontname=\"Helvetica,Arial,sans-serif\"]\n\tlayout=neato\n\tnode [shape=box]; \"client\"; \"facture\" ; \"produit\" ; \"catégorie\" ;\n\tnode [shape=ellipse] ; nom ; adresse ; sexe ; profession  ;  \n  prix ; montant  ; vendus ; \"qte_en_stock\" ;\n  gamme ; fabricant ;  \"date_liv\" ;\n  {node [label=\"description\"] desc1 ; desc2 ;}\n  {node [label=\"qté\"] qte1 ; qte2 ;}\n  {node [label=<<u>client_id</u>>] client_id}  ;\n  {node [label=<<u>produit_id</u>>] produit_id}  ;\n  {node [label=<<u>facture_id</u>>] facture_id}  ;\n  {node [label=<<u>num_ligne</u>>] num_ligne} ;\n  {node [label=<<u>cat_id</u>>] cat_id} ;\n  {node [label=<<u>date</u>>] date_reappro} ; \n\n  node [shape=diamond];  \"paye\"  ; \"concerne\" ; \"relève_de\" ;\n  node [shape=box, peripheries=2];  \"réappro\" ; \"ligne\" ; \n  node [shape=diamond, peripheries=2]; \"demande\" ; \"dans\" ;\n\n  client_id -- client ;\n  adresse -- client ;\n  sexe -- client ;\n  nom -- client ;\n  profession -- client ;\n  produit_id -- produit ;\n  desc1 -- produit ; \n  vendus -- produit ;\n  \"qte_en_stock\" -- produit ;\n  gamme -- produit ;\n  fabricant -- produit ; \n  facture_id -- facture ;\n  prix -- produit ;\n  qte1 -- ligne ;\n  qte2 -- \"réappro\" ;\n  num_ligne -- ligne ; \n  montant -- facture ;\n  \"catégorie\" -- cat_id ;\n  \"catégorie\" -- desc2 ;\n\n  \"client\" -- \"paye\" [label=\"0:n\",len=1.00] ;\n  \"paye\" -- \"facture\" [label=\"1:1\", len=1.00] ;\n  \"facture\" -- \"dans\" [label=\"0:n\",len=1.00] ;\n  \"dans\" -- \"ligne\" [label=\"1:1\", len=1.00] ;\n  \"ligne\" -- \"concerne\" [label=\"1:1\", len=1.00] ;\n  \"concerne\" -- \"produit\" [label=\"0:n\",len=2.00] ; \n  \"produit\" -- \"demande\" [label=\"1:n\", len=2.0] ;\n  \"demande\" -- \"réappro\" [label=\"1:1\", len=1.00] ;\n  \"produit\" -- \"relève_de\"  [label=\"1:1\", len=2.00] ;\n  \"relève_de\" -- \"catégorie\" [label=\"0:n\", len=1.00] ;\n  date_reappro -- \"réappro\" ;\n  \"réappro\" -- \"date_liv\" ; \n    //\tlabel = \"\\n\\nEntity Relation Diagram\\ndrawn by NEATO\";\n//\tfontsize=20;\n}\n```\n\n\n\n\n\n::: \n\n \n\n::: {.callout-note}\n\n\n### Question 2   (2pts)\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\nSi besoin, transformez votre schéme de façon à ce qu'il ne comporte \nplus d'associations d'arité supérieure ou égale à 3, ou d'associations plusieurs-plusieurs \n(0:n pour plusieurs entités participantes).  \n\n:::\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-note}\n\nNotre schéma ne comporte ni associations plusieurs-plusieurs, ni association\nd'arité supérieure à 2. Il n'y a donc pas de réécriture à effectuer. \nNous pouvons immédiatement proécéder à la traduction en pattes de corbeau.\n\n:::\n\n\n:::\n\n::: {.callout-note}\n\n\n### Question 2   (2pts)\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\nProposer une traduction en pattes de corbeau du diagramme EA proposé en réponse   \nà la première question. \n\n:::\n\n::: {.callout-tip title=\"Conseil\"}\n\nAidez-vous aussi de votre réponse à la deuxième question.\n\nPrécisez \n\n- une clé primaire pour chaque table,\n- les tables dites intermédiaires,\n- pour les liens matérialisant les contraintes référentielles, préciser s'ils sont identifiant ou non.\n\n:::\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-tip title=\"Solution\"}\n\n\n\n\n```{mermaid}\n%%| label: crow1\n%%| eval: true\n%%| include: true\n%%| echo: false\n%%| fig-width: 6\nerDiagram\n    INVENTAIRE ||--|| PRODUIT : produit_id \n    COMMANDE }o--|| PRODUIT  : produit_id\n    PRODUIT }o..|| CATEGORIE : categorie_id \n    FACTURE }o..|| CLIENT :client_id\n    LIGNE }o--|| FACTURE :facture_num\n    LIGNE }o..|| PRODUIT : produit_id \n\n  INVENTAIRE {\n    num produit_id  PK, FK\n    num en_stock  \n    num vendus   \n  }\n\n  CATEGORIE {\n    num categorie_id  PK\n    text nom \n  }\n\n  PRODUIT {\n    num produit_id PK\n    text description \n    num categorie_id FK\n    text gamme \n    text fabricant \n  }\n\n\n  COMMANDE {\n    num produit_id  PK, FK\n    date date_com  PK\n    num qte \n    date date_liv  \n  }\n\n  FACTURE {\n    num facture_num  PK\n    num client_id   FK\n    date date_fac\n    num montant  \n  }\n\n  LIGNE {\n    num facture_num PK, FK\n    num num_lign PK\n    num produit_id  FK\n    num qte \n  }\n\n  CLIENT {\n    num client_id PK\n    text nom\n    text adresse\n    text tel\n    num taille\n    num adn\n    text sexe\n    text profession\n  }\n```\n\n\n\n\n::: \n\n::: {.callout-note}\n\n### Remarque \n\n\n\n\n\n```{mermaid}\n%%| label: crow2\n%%| eval: true\n%%| include: true\n%%| echo: false\n%%| fig-width: 6\nerDiagram\n    %% INVENTAIRE ||--|| PRODUIT : produit_id \n    COMMANDE }o--|| PRODUIT  : produit_id\n    PRODUIT }o..|| CATEGORIE : categorie_id \n    FACTURE }o..|| CLIENT :client_id\n    LIGNE }o--|| FACTURE :facture_num\n    LIGNE }o..|| PRODUIT : produit_id \n\n  %% INVENTAIRE {\n  %%   num produit_id  PK, FK\n  %% }\n\n  CATEGORIE {\n    num categorie_id  PK\n    text nom \n  }\n\n  PRODUIT {\n    num produit_id PK\n    text description \n    num categorie_id FK\n    text gamme \n    text fabricant \n    num en_stock  \n    num vendus   \n\n  }\n\n\n  COMMANDE {\n    num produit_id  PK, FK\n    date date_com  PK\n    num qte \n    date date_liv  \n  }\n\n  FACTURE {\n    num facture_num  PK\n    num client_id   FK\n    date date_fac\n    num montant  \n  }\n\n  LIGNE {\n    num facture_num PK, FK\n    num num_lign PK\n    num produit_id  FK\n    num qte \n  }\n\n  CLIENT {\n    num client_id PK\n    text nom\n    text adresse\n    text tel\n    num taille\n    num adn\n    text sexe\n    text profession\n  }\n```\n\n\n\n\n\n:::\n\n::: {.callout-note}\n\n### Proposition Chat-GPT 3.5\n\nLe lien entre `inventaire`  et `produit` n'est pas décoré correctement, \ncar il n'y a pas d'historicisation. Les liens sont tous présentés\ncomme identifiants. Cela ne devrait pas être le cas. En dehors de cela c'est bon. \n\n\n\n\n```{mermaid}\n%%| label: crow-chatgpt\n%%| eval: true\n%%| include: true\n%%| echo: false\n%%| fig-width: 6\nerDiagram\n    Produit {\n        int product_id PK\n        string nom_produit\n        string description\n        int cat_id FK\n        string nom_gamme\n        float prix_unitaire\n    }\n    Categorie {\n        int cat_id PK\n        string description\n    }\n    Inventaire {\n        int product_id PK, FK\n        int en_stock\n        int vendus\n    }\n    Commande {\n        int commande_id PK\n        int product_id FK\n        date date_com\n        int qte\n        date date_liv\n    }\n    Client {\n        int client_id PK\n        string nom\n        string adresse\n        string telephone\n        int annee_naissance\n        string sexe\n        string profession\n        float taille\n    }\n    Facture {\n        int fact_id PK\n        int client_id FK\n        date date_fact\n        float montant\n    }\n    LigneFacture {\n        int fact_id FK\n        int num_ligne PK\n        int product_id FK\n        int qte\n        float montant\n    }\n\n    Produit ||--o{ Inventaire : \"est référencé dans\"\n    Produit ||--o{ Commande : \"est commandé dans\"\n    Produit ||--o{ LigneFacture : \"est lié à\"\n    Produit }o--|| Categorie : \"appartient à\"\n    Client ||--o{ Facture : \"émet\"\n    Facture ||--o{ LigneFacture : \"contient\"\n\n```\n\n\n\n\n:::\n\n:::\n\nLe vélociste a explicité les contraintes suivantes:\n\n- Pour un même produit, les intervalles de temps `[date_com, date_liv)` correspondant à deux commandes différentes ne peuvent se recouvrir,\n- Une gamme de produits appartient à un seul fabricant (Ultegra est une gamme de Shimano, Campagnolo et autres ne peuvent pas utiliser ce nom),\n- Dans une gamme donnée, un fabricant propose au plus un produit de catégorie donnée. \n\n\n::: {.callout-note}\n\n\n### Question 3   (1pt)\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n- Préciser parmi ces contraintes, celles qui sont des dépendances fonctionnelles\n- Proposer un mécanisme pour mettre en place ces contraintes en SQL (langage de définition de données)  \n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n- La contrainte de recouvrement est une contrainte d'exclusion (`EXCLUDE`). Ce n'est pas un dépendance fonctionnelle.\n\n```{.sql}\nALTER TABLE reappro \n  ADD CONSTRAINT xcl_prod \n  EXCLUDE USING gist (\n    product_id WITH =,\n    (date, date_liv) WITH && \n  ) ;\n```\n- Le fait qu'une  gamme de produits appartient à un seul fabricant, définit une dépendance fonctionnelle `gamme` $\\rightarrow$ `fabricant`. Cette\ncontrainte peut aussi s'exprimer à l'aide d'une contrainte `EXCLUDE`\n\n```{.sql}\nALTER TABLE produit \n  ADD CONSTRAINT xcl_gamme_fabriquant \n  EXCLUDE USING gist (\n    gamme WITH =,\n    fabriquant WITH <> \n  ) ;\n``` \n\n- Le fait que pour une gamme, un fabricant ne propose au plus un produit d'une catégorie donnée définit une contrainte\n`gamme`, `fabricant`, `cat_id` $\\rightarrow$ `produit_id`. Cette contrainte est une dépendance fonctionnelle.\nComme on a par ailleurs `gamme` $\\rightarrow$ `fabricant`, on peut la simplifier en `gamme`, `cat_id` $\\rightarrow$ `produit_id`.\n\nLà encore on peut utiliser la construction \n```{.sql}\nALTER TABLE produit \n  ADD CONSTRAINT xcl_gamme_cat_prod \n  EXCLUDE USING gist (\n    gamme WITH =,\n    cat_id WITH =,\n    produit_id WITH <> \n  ) ;\n```  \n\n:::\n\n:::\n\nOn suppose que le schéma est muni des dépendances fonctionnelles déduites de la question précédente\net de celles qui se déduisent des contraintes de clé primaire. On note cet ensemble de dépendances \nfonctionnelles $\\Sigma$. \n\n\n::: {.callout-note}\n\n### Question 6  (2pts)\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n- Préciser pour chaque table si elle est en FNBC par rapport à $\\Sigma$\n- Si un ou plusieurs tables ne sont pas en FNBC, proposer une décomposition sans perte d'information (SPI)\ntelle que toutes les tables soient en FNBC.  \n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\nLes tables qui ne possèdent pas de DF en dehors de celle impliquées par la donnée de la clé primaire sont en FNBC.\n\nLa table `produit` n'est pas en FNBC: le déterminant de `gamme` $\\rightarrow$ `fabricant` n'est pas une super-clé. \nLes clés de `produit` sont `product_id`, et `gamme, cat_id`. \n\n\n:::\n\n:::\n\n\n::: {.callout-note}\n\n### Question 7  (2pts)\n\nSoit le schéma $\\mathcal{A}$ = `{A, B,C, D, E,  G, H}`.\n\nSoit Σ = {`{D,E}` $⟶$ {F}, `{H}` $⟶$ `{B}`, `{B,C}` $⟶$ `{D}`,   `{C}` $⟶$ `{E}`,     `{D,F}` $⟶$ `{H,A}`} un ensemble de\ndépendances fonctionnelles.\n\nEst-ce que les dépendances fonctionnelles `{B,C}` $⟶$ `{F}`, `{C,H}` $⟶$ `{D}`, `{B,C}` $⟶$ `{G}`  sont impliquées par $Σ$? Autrement dit, a-t-on :\n\n- Σ $⊧$ `{B,C}` $⟶$ `{F}`,\n- Σ $⊧$ `{C,H}` $⟶$ `{D}`,\n- Σ $⊧$ `{B,C}` $⟶$ `{G}` ?\n\n\n:::\n\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\nPour répondre aux trois questions, suffit de vérifier si `F` et/ou `G` appartiennent à $[\\{\\texttt{B,C}\\}]^+_\\Sigma$,\net si $D$ appartient à $[\\{\\texttt{C,H}\\}]^+_\\Sigma$\n\n$$[\\{\\texttt{B,C}\\}]^+_\\Sigma = \\{\\texttt{B, C, D, E, F, H, A}\\}$$\n\n$$[\\{\\texttt{C,H}\\}]^+_\\Sigma = \\{\\texttt{C, H, B, E, D, F, A}\\}$$\n\nLes réponses sont \n\n- Σ $⊧$ `{B,C}` $⟶$ `{F}`,\n- Σ $⊧$ `{C,H}` $⟶$ `{D}`,\n- Σ $\\not\\models$ `{B,C}` $⟶$ `{G}` ?\n\n::: \n:::\n\n\n\n\n\n{{< pagebreak >}}\n\n\n\n\n\n\n\n::: {.callout-warning title=\"Attention\"}\n\nDans la suite, vous formulerez les requêtes dans le schéma relationnel défini \npar votre schéma en pattes de corbeau. \n\n{{< fa graduation-cap >}} : 1 point par requête \n \n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n::: {.callout-note}\n\n### Requête 1 \n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\nLister pour chaque fabricant, chaque gamme,  le nombre de produits proposés au catalogue. \n\n:::\n\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT \n  fabricant, gamme, COUNT(produit_id) AS n_produit \nFROM \n  produit\nGROUP BY \n  fabricant, gamme ;\n```\n::: \n\n:::\n\n::: {.callout-note}\n\n### Requête 4 \n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\nLister pour chaque client, la somme des montants versés par ce client.\n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT \n  client_id, SUM(montant) AS somme_montants\nFROM \n  facture\nWHERE \n  montant IS NOT NULL\nGROUP BY \n  client_id ;\n```\n\n::: \n\n:::\n\n::: {.callout-note}\n\n### Requête 5 \n\n\n\n::: {.cell}\n\n:::\n\n\n\n\nOn cherche à détecter s'il existe des commandes de réapprovisionnement qui concernent un même \nproduit et dont les intervalles de temps  (`[date_com, date_liv)`)  se chevauchent. Écrire une \nrequête qui liste les paire de commandes qui posent problèmes. La requête donnera les numéros de\ncommande, le produit concerné, et les dates de commande.   \n\n:::\n\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT \n  r1.produit_id,\n  r1.date, r1.date_liv,\n  r2.date, r2.date_liv\nFROM \n  reappro r1 JOIN\n  reappro r2 USING(produit_id)\nWHERE \n  r1.date < r2.date     -- les deux commandes r1 et r2 sont distinctes ...\nAND \n  (r1.date, r1.date_liv) OVERLAPS\n  (r2.date, r2.date_liv)\n;\n```\nIl ne faut pas oublier la condition `r1.date < r2.date` \npour \n\n\n::: \n:::\n\n::: {.callout-note}\n\n### Requête 6 \n\n\n\n::: {.cell}\n\n:::\n\n\n\n\nLister les factures pour lesquelles on ne trouve aucune ligne de facture.\n\n:::\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT DISTINCT\n  facture_id\nFROM\n  facture LEFT OUTER JOIN\n  ligne USING (facture_id)\nWHERE\n  num_ligne IS NULL;\n```\n::: \n \n::: {.callout-note}\n\n### Remarque\n\nOn pourrait aussi utiliser `EXCEPT` et  faire la différence entre la projection de `facture` sur \n`facture_id` et la projection de `ligne` sur `facture_id`.\n\nEn revanche \n\n```{.sql}\nSELECT \n  facture_id\nFROM \n  ligne\nGROUP BY \n  facture_id\nHAVING COUNT(num_ligne) == 0 ;\n```\n\nn'est pas une réponse correcte. Cette requête renvoie toujours un résultat vide.\n\n:::\n\n:::\n\n::: {.callout-note}\n\n### Requête 7 \n\n\n\n::: {.cell}\n\n:::\n\n\n\n\nPour chaque mois, lister la catégorie de produits la plus vendue (en nombre d'articles).\n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH R AS (\n  SELECT\n    EXTRACT(MONTH FROM fa.date) AS mois, pr.cat_id,\n    SUM(li.qte) AS qte_mois \n  FROM \n      facture fa\n    JOIN\n      ligne li USING (fact_id) \n    JOIN\n      produit pr USING (produit_id)\n  GROUP BY \n    EXTRACT(MONTH FROM fa.date), pr.cat_id\n)\n\nSELECT \n  r1.mois, r2.cat_id\nFROM \n  R AS r1\nWHERE \n  r1.qte >= ALL (\n    SELECT \n      r2.qte\n    FROM\n      R AS r2\n    WHERE\n      r2.mois = r1.mois\n  )\n;\n\n```\n\n::: \n\n:::\n\n::: {.callout-note}\n\n### Requête 8 \n\n\n\n::: {.cell}\n\n:::\n\n\n\n\nLister les commandes de réapprovisionnement en cours.\n\n:::\n\n\n::: {.content-visible when-profile='solution'}  \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT\n  produit_id, date, qte\nFROM \n  reappro \nWHERE \n  date_liv IS NULL ;\n```\n\n::: \n:::\n\n::: {.callout-note}\n\n### Requête 9 \n\n\n\n::: {.cell}\n\n:::\n\n\n\n\nLister les produits les plus vendus et les moins vendus dans chaque catégorie.\n\n:::\n\n::: {.content-visible when-profile='solution'} \n\n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH R AS (\n  SELECT \n    pr.cat_id, pr.produit_id, SUM(li.qte) as tot_ventes\n  FROM \n      produit pr\n    JOIN\n      ligne li USING (product_id)\n  GROUP BY \n    cat_id, produit_id\n), S AS (\n  SELECT \n    cat_id, MAX(tot_ventes) AS max_ventes, MIN(tot_ventes) AS min_ventes\n  FROM \n    R\n  GROUP BY \n    cat_id\n)\n\nSELECT \n  r1.cat_id, r1.produit_id, r1.tot_ventes\nFROM \n  R r1\nWHERE \n  EXISTS (\n    SELECT \n      *\n    FROM\n      S s1\n    WHERE \n      s1.cat_id = r1.cat_id AND \n      r1.tot_ventes IN (s1.max_ventes, s1.min_ventes)\n  )\nORDER BY r1.cat_id ;\n```\n\n::: \n \n:::\n\n\n::: {.callout-note}\n\n### Requête 10 \n\n\n\n::: {.cell}\n\n:::\n\n\n\n\nLister les paires de clients qui habitent la même adresse. \n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nSELECT \n  c1.client_id, c2.client_id, c1.adresse\nFROM \n    client c1 \n  JOIN\n    client c2 ON (c1.client_id < c2.client_id AND c1,adresse=c2.adresse)\n;\n```\n::: \n:::\n\n::: {.callout-note}\n\n### Requête 11 \n\n\n\n::: {.cell}\n\n:::\n\n\n\n\nLister pour chaque fabricant, les cinq produits les vendus.\n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH R AS (\n  SELECT \n    pr.produit_id, pr.fabricant, \n    RANK() OVER (PARTITION BY pr.fabricant ORDER BY SUM(li.qte) DESC) AS rnk\n  FROM\n    produit pr\n  JOIN \n    ligne li USING (produit_id)\n)\n\nSELECT \n  fabriquant, produit_id, rnk\nFROM \n  R\nWHERE \n  rnk <=5\nORDER BY fabricant  ;\n```\n::: \n:::\n\n::: {.callout-note}\n\n### Requête 12 \n\n\n\n::: {.cell}\n\n:::\n\n\n\n\nLister pour chaque mois, les dix clients qui ont le plus dépensé. \n\n:::\n\n::: {.content-visible when-profile='solution'} \n \n::: {.callout-tip title=\"Solution\"}\n\n```{.sql}\nWITH R AS (\n  SELECT\n    client_id,\n    EXTRACT(MONTH FROM fa.date) AS mois,\n    RANK() OVER (PARTITION BY EXTRACT(MONTH FROM fa.date), fa.client_id \n                 ORDER BY SUM(fa.montant) DESC)  AS rnk\n  FROM\n    facture fa\n)\n\nSELECT \n  R.mois, \n  R.client_id,\n  R.rnk\nFROM \n  R\nWHERE \n  R.rnk <= 10\nORDER BY \n  R.mois, R.rnk\n;\n```\n::: \n\n::: {.callout-tip title=\"Solution\"}\n\nLa réponse proposée au dessus est tordue. La suivante est plus pertinente.\n\n```{.sql}\nWITH R AS (\n  SELECT\n    client_id,\n    DATE_TRUNC('MONTH', fa.date) AS mois,\n    RANK() OVER (PARTITION BY DATE_TRUNC('MONTH', fa.date), fa.client_id \n                 ORDER BY SUM(fa.montant) DESC)  AS rnk\n  FROM\n    facture fa\n)\n\nSELECT \n  R.mois, \n  R.client_id,\n  R.rnk\nFROM \n  R\nWHERE \n  R.rnk <= 10\nORDER BY \n  R.mois, R.rnk\n;\n```\n::: \n\n:::\n\n\n\n\n{{< pagebreak >}}\n\n\n\n\n\n\n::: {.callout-tip}\n\nEn PostgreSQL, pour définir un intervalle à l'aide de deux dates `debut`  et `fin`, il suffit d'écrire `(début, fin)`.\nL'intervalle ne contient pas la date de fin. \n\nPour tester l'intersection/le recouvrement de deux intervalles, on utilise l'opérateur `OVERLAPS` \n\n```{.sql}\nbd_2023-24=# SELECT \n  ('2025-01-03'::date, '2025-01-10'::date) OVERLAPS \n  ('2025-01-10'::date, '2025-01-15'::date)  ; \n overlaps \n----------\n false\n(1 row)\n\nbd_2023-24=# SELECT \n  ('2025-01-03'::date, '2025-01-10'::date) OVERLAPS \n  ('2025-01-09'::date, '2025-01-15'::date)  ; \n overlaps \n----------\n true\n(1 row)\n\n```\n\n:::\n\n\n\n::: {.callout-tip}\n\nEn PostgreSQL, pour extraire le mois d'un objet `dd` de type `date`, vous pouvez utiliser \n`EXTRACT(MONTH FROM dd)`. Le résultat est un entier entre 1 et 12, 1 pour janvier, ...  \n\n```{.sql}\npostgres=# SELECT \n  current_timestamp::date AS la_date, \n  EXTRACT( MONTH FROM current_timestamp::date) AS le_mois ;\n\n  la_date   | le_mois \n------------+---------\n 2025-01-03 |       1\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}