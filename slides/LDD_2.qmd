---
title: "BD VII: gestion avancée des contraintes"
subtitle: "Définition de données: Contraintes"
date: "2025-10-24"


format: 
  revealjs:
    header: ""
---

  


# Revisiter le schéma world  {background-color="#1c191c"}



## Schema de world


![Modèle relationnel du schéma World](/images/modelisation/MRD_world2.svg)




## Conraintes sur la table `country`

- Un pays est identifié par son `countrycode`, 

- Deux pays ne devraient pas avoir le même nom,

- Une région ne devrait appartenir qu'à un seul continent, 

- La capitale d'un pays devrait être une ville connue dans `city`,

- La capitale d'un pays devrait être une ville de ce pays,

- Les capitales de deux pays différents devraient être des villes différentes,

- ...


{{< fa hand-point-right >}} Ce ne sont pas les seules contraintes possibles 



## Mise en œuvre des contraintes

- Un pays est identifié par son `countrycode` : `PRIMARY KEY`

- Deux pays ne devraient pas avoir le même nom : `UNIQUE`

- **Une région ne devrait appartenir qu'à un seul continent** : ??? -> `EXCLUDE`

- La capitale d'un pays devrait être une ville connue dans `city` : `REFERENCES`

- **La capitale d'un pays devrait être une ville de ce pays** : ??? -> trigger

- Les capitales de deux pays différents devraient être des villes différentes : `UNIQUE`

- Deux pays différents ne peuvent avoir le même `code2` : `UNIQUE`



## Examen du schema de `country`   



```{.sql}
+--------------------+---------------+-----------+
| Column             | Type          | Modifiers | 
|--------------------+---------------+-----------+-
| countrycode        | character(3)  |  not null | 
| name_country       | text          |  not null | 
| continent          | text          |  not null | 
| region             | text          |  not null |
| surfacearea        | real          |  not null |
| indepyear          | smallint      |           | 
| population_country | integer       |  not null | 
| lifeexpectancy     | real          |           | 
| gnp                | numeric(10,2) |           | 
| gnpold             | numeric(10,2) |           | 
| localname          | text          |  not null | 
| governmentform     | text          |  not null | 
| headofstate        | text          |           | 
| capital            | integer       |           | 
| code2              | character(2)  |  not null | 
+--------------------+---------------+-----------+
```

{{< fa hand-point-right >}} Un schéma de table ne se réduit pas à la données des noms et domaines  des colonnes.


##  suite   


```{.sql}
Indexes:
    "country_pkey" PRIMARY KEY, btree (countrycode)
Check constraints:
    "country_continent_check" CHECK (continent = 'Asia'::text OR 
                                     continent = 'Europe'::text OR 
                                     continent = 'North America'::text OR 
                                     continent = 'Africa'::text OR
                                     continent = 'Oceania'::text OR
                                     continent = 'Antarctica'::text OR
                                     continent = 'South America'::text),
Foreign-key constraints:
    "country_capital_fkey" FOREIGN KEY (capital) REFERENCES city(id)
```


## DDL pour `country`  


```{.sql}
CREATE TABLE world.country (
	countrycode bpchar(3) NOT NULL,
	name_country text NOT NULL,
	continent text NOT NULL,
	region text NOT NULL,
	surfacearea float4 NOT NULL,
	indepyear int2 NULL,
	population_country int4 NOT NULL,
	lifeexpectancy float4 NULL,
	gnp numeric(10, 2) NULL,
	gnpold numeric(10, 2) NULL,
	localname text NOT NULL,
	governmentform text NOT NULL,
	headofstate text NULL,
	capital int4 NULL,
	code2 bpchar(2) NOT NULL,
	CONSTRAINT country_continent_check CHECK (((continent = 'Asia'::text) 
    OR (continent = 'Europe'::text) 
    OR (continent = 'North America'::text) 
    OR (continent = 'Africa'::text) 
    OR (continent = 'Oceania'::text)
    OR (continent = 'Antarctica'::text) 
    OR (continent = 'South America'::text))),
	CONSTRAINT country_pkey PRIMARY KEY (countrycode)
);
```


## Ajout de contraintes référentielles

- Une contrainte d'intégrité référentielle impose l'inclusion de l'ensemble des valeurs d'une colonne (la colone qui référence) à l'ensemble des valeurs d'une autre colonne (la colonne référencée). 

. . .

- La colonne référencée est quasiment toujours la clé primaire d'une autre table. On peut alors définir la contrainte en n'indiquant que la table référencée (car la clé primaire est unique) :

```{.sql}
ALTER TABLE world.country ADD CONSTRAINT 
  country_capital_fkey FOREIGN KEY (capital) REFERENCES world.city;
```

. . .

- Si la colonne référencée n'est pas une clé primaire, elle doit vérifier une **contrainte d'unicité**. Il faut alors préciser le nom de la table et le nom de la colonne référencée avec cette syntaxe : `REFERENCES nom_table(nom_colonne)`
  


## Gestion de la mise à jour ou de la suppression d'un attribut référencé

::: {.callout-important}

Après la définition de la contrainte `country_capital_fkey`, la mise à jour ou la suppression d'une valeur de l'attribut `city.id` référencée dans l'attribut `country.capital` est bloquée par le SGBD.

:::

. . .

On peut définir différentes actions pour les rendre possibles : 

- `CASCADE` : supprime ou met à jour en cascade les lignes qui référencent la valeur supprimée ou mise à jour.

. . .

- `SET NULL` : met à `NULL` la ou les colonnes des lignes qui référencent la valeur supprimée ou mise à jour.

. . .

- `SET DEFAULT` : met à leur valeur par défaut la ou les colonnes des lignes qui référencent la valeur supprimée ou mise à jour.



## Utilisation de l'action `CASCADE`

```{.sql}
ALTER TABLE world.city 
  ADD CONSTRAINT city_countrycode_fkey 
    FOREIGN KEY (countrycode) 
    REFERENCES world.country
    ON DELETE CASCADE
    ON UPDATE CASCADE;
```

- Si un `countrycode` est suprrimé dans la table `country`, toutes les lignes de la table `city` où ce code est présent seront supprimées, et si ces lignes sont référencées dans un autre table, les lignes qui les référencent seront elles-mêmes supprimées et ainsi de suite "en cascade".

. . .

- Si un `countrycode` est mis à jour dans la table `country`, toutes les lignes de la table `city` où ce code est présent seront mises à jour, et si ces mises à jour sont référencées dans un autre table, les lignes qui les référencent seront elles-mêmes mises à jour et ainsi de suite "en cascade".

## Utilisation de l'action `SET NULL`

```{.sql}
ALTER TABLE world.city 
  ADD CONSTRAINT country_capital_fkey 
    FOREIGN KEY (capital) 
    REFERENCES world.city(id)
    ON DELETE SET NULL
    ON UPDATE CASCADE;
```
- Si un `id` est suprrimé dans la table `city`, les lignes de la table `country` où ce code est présent ne seront pas supprimées, la colonne `capital` sera mise à `NULL`. Cette action est possible car la valeur `NULL` est autorisée pour la colonne `capital`.





# Contraintes d'exclusion   {background-color="#1c191c"}

## Une région n'appartient qu'à un seul continent

Cette contrainte signifie que le résultat de la requête suivante est vide :

```{.sql}
SELECT *
FROM 
  world.country c1 
JOIN 
  world.country c2 ON (c1.continent<> c2.continent AND c1.region=c2.region);
```

. . .

On *exclut* l'existence de deux lignes qui coïncideraient sur `region` mais pas sur `continent`

Nous postulons l'existence d'une **dépendance fonctionnelle**

$$\texttt{region} \longrightarrow \texttt{continent}$$

## Deux attitudes 

Dans sa forme actuelle, la table `country` de `world` contient des informations *redondantes*:
on répète plusieurs fois que la région `Western Europe` est située dans le continent `Europe`.

Ces redondances représentent un gaspillage de mémoire (très modeste ici) et un risque pour le maintien de la cohérence de la base : chaque insertion, mise-à-jour est susceptible de mettre en défaut la dépendance fonctionnelle.

On peut considérer qu'il s'agit d'une *anomalie* de schéma et **normaliser** le schéma. 

La normalisation suppose une révision du schéma. Si le schéma est muni de vues et de fonctions,
il faudra éventuellement réécrire ces vues et ces fonctions. 


## Autre possibilité avec une contrainte d'exclusion

Avec une contrainte d'exclusion (`EXCLUDE`), on ne touchera pas au schéma, les vues et les fonctions resteront utilisables.

La contrainte d'exclusion  permettra de maintenir la dépendance fonctionnelle.



## Les contraintes d'exclusion

::: {.callout-note}

### Objectifs

- Mise en place de dépendances fonctionnelles,
- Mise en place de contraintes de non-recouvrement (données spatiales ou temporelles),
- Mise en place de contraintes très diverses. 

:::


<!--[Documentation](https://www.postgresql.org/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-EXCLUSION){target="_blank"}
-->

## Clause EXCLUDE

Une clause `EXCLUDE` empêche que *deux* lignes vérifient toutes les comparaisons sur les colonnes spécifiées en utilisant les opérateurs indiqués par le mot clé `WITH`.

```{.sql}
ALTER TABLE country
   ADD CONSTRAINT xcl_country_region_continent 
      EXCLUDE USING GIST
      (
         region WITH =, 
         continent WITH <>
      );
```

Cette contrainte d'exclusion empèche que deux lignes de la table `country` aient la colonne `region` égale et la colonne `continent` différente.


::: {.callout-note}

La clause `USING` définit le type d'index utilisé pour vérifier la contrainte d'exclusion.

En pratique, le type d'index sera toujours `GiST` ou `SP-GiST` (`GIST` est l'acronyme de *Generalized Search Tree*). 
:::


<!--
## Détails syntaxiques

```{.sql}
EXCLUDE 
  [ USING index_method ] 
  ( exclude_element WITH operator [, ... ] ) 
  index_parameters 
  [ WHERE ( predicate ) ] 
```



## Remarques 

Si tous les opérateurs spécifiés testent une égalité, ceci est équivalent à une contrainte UNIQUE bien qu'une contrainte unique ordinaire sera plus rapide. 

Néanmoins, ces contraintes d'exclusion peuvent spécifier des contraintes qui sont plus générales qu'une simple égalité. 

Vous pouvez spécifier qu'il n'y a pas deux lignes dans la table contenant des cercles de surcharge en utilisant l'opérateur &&. 

{{< fa hand-point-right >}} Le(s) opérateur(s) doivent être commutatif(s).


## Mise en œuvre 

Les contraintes d'exclusion sont implantées en utilisant un *index* qui a le même nom que la contrainte, donc chaque opérateur précisé doit être associé avec une classe d'opérateurs appropriée  pour la méthode d'accès par index, nommée `méthode_index`. 

Chaque `élément_exclusion` définit une colonne de l'`index`, donc il peut spécifier en option une *collation*, une classe d'opérateur, des paramètres pour la classe d'opérateurs, et/ou des options de tri 

En pratique, la méthode d'accès sera toujours `GiST` ou `SP-GiST` (`GIST` est un acronyme qui renvoie 
à *Generalized Search Tree*). 


## Zoologie des index  `B-tree`, `hash`, `GIN`

Une stratégie d'indexation permet de gérer efficacement des conditions de la forme 

```{.sql}
<colonne indexée> <opérateur> <valeur de comparaison>
```

Les index de type `B-tree` sont appropriés pour les types ordonnés et les opérateurs `=`, `<=`, `=>`

Les index de type `B-tree` sont souvent utilisés pour réaliser les équi-jointures.  

## Méthodes d'accès (Index) `GiST`

GiST: une infrastructure qui permet la mise en  œuvre de différentes stratégies d'indexation. 

Les opérateurs susceptibles d'utiliser un index  GiST peuvent varier selon la stratégie d'indexation.

. . .

La distribution standard de PostgreSQL comprend des classes d'opérateurs GiST pour plusieurs types de données géométriques (bidimensionnelles), qui permettent d'effectuer des requêtes indexées à l'aide de ces opérateurs 

```{.sql}
<<   &<   &>   >>   <<|   &<|   |&>   |>>   @>   <@   ~=   &&
```
-->




<!--
## Contraintes ajoutées

```{.sql}
-- world.country foreign keys

ALTER TABLE world.country ADD CONSTRAINT 
  country_capital_fkey FOREIGN KEY (capital) REFERENCES world.city(id);

ALTER TABLE world.country ADD CONSTRAINT 
  country_fk FOREIGN KEY (continent) REFERENCES world.code_continent(continent);
```

{{< fa hand-point-right >}} La contrainte `country_fk` sur `continent` remplit la même fonction que la 
contrainte `country_continent_check`

. . .

{{< fa lightbulb >}} **Conseil:** 

- Si le domaine est de grande cardinalité, utiliser une table pour représenter le domaine, 
et une contrainte référentielle
- Si le domaine est de petite cardinalité, une contrainte `CHECK` est aussi pratique (et sans doute plus efficace)

. . .

{{< fa brain >}} Comment procéder pour mettre en œuvre une contrainte de domaine sur `region` ? 
-->

<!--
# Normalisation de $\texttt{country}$   {background-color="#1c191c"}


## 


La normalisation des bases de données relationnelles est une activité en soi, guidée par des principes 
codifiés et des algorithmes établis (voir [Normalisation I](/slides/DF_norm_1.qmd), [Normalisation II](/slides/DF_norm_3.qmd))

Ici, nous profitons de la simplicité du schéma `world` pour normaliser `country` à la main. 

## Éclatement de la table `country`

- Mise en place d'une table `region_continent(region, continent)`

- Émission d'une contrainte référentielle de `country` vers `region_continent`



## Préparation

```{.sql}
CREATE SCHEMA monde AUTHORIZATION superdupont ;

GRANT ALL ON SCHEMA monde TO superdupont ;

CREATE TABLE monde.code_continent AS 
       TABLE world.code_continent ;

ALTER TABLE monde.code_continent ADD CONSTRAINT 
  code_continent_pk PRIMARY KEY (codecontinent);
ALTER TABLE monde.code_continent ADD CONSTRAINT 
  code_continent_un UNIQUE (continent);
```



## Création de `region_continent`

```{.sql}
CREATE TABLE monde.region_continent AS 
  SELECT DISTINCT 
    region, continent 
  FROM 
    world.country c ;
```


La requête suivante renvoie une table vide:

```{.sql}
SELECT * 
FROM 
  monde.region_continent rc1 
JOIN 
  monde.region_continent rc2 
ON (
	rc1.region=rc2.region AND 
  rc1.continent<> rc2.continent
) ;
```



```{.sql}
ALTER TABLE monde.region_continent ADD CONSTRAINT 
	region_continent_pk PRIMARY KEY (region);

ALTER TABLE mode.region_continent ADD CONSTRAINT 
  region_continent_fk FOREIGN KEY (continent) 
  REFERENCES monde.code_continent(continent);
```


## Création de la table `monde.country`

```{.sql}
CREATE TABLE monde.country AS  
  SELECT  
    countrycode, name_country, region, surfacearea, 
    indepyear, population_country, 
    lifeexpectancy, gnp, gnpold, localname,
    governmentform, headofstate, capital,  code2            
  FROM 
    world.country ;
```

{{< fa hand-point-right >}} sans colonne `continent`



## Mise en place des contraintes sur `monde.country`


```{.sql}
ALTER TABLE monde.country ADD CONSTRAINT 
  country_pk PRIMARY KEY (countrycode);

ALTER TABLE monde.country ADD CONSTRAINT 
  country_un_name UNIQUE (name_country);

ALTER TABLE monde.country ADD CONSTRAINT 
  country_un_code2 UNIQUE (code2);

ALTER TABLE monde.country ADD CONSTRAINT 
  country_un_capital UNIQUE (capital);
```

. . .

```{.sql}
ALTER TABLE monde.country ADD CONSTRAINT country_fk 
  FOREIGN KEY (region) REFERENCES monde.region_continent(region) 
  ON DELETE SET NULL 
  ON UPDATE CASCADE;
```




## Copie de `city`

```{.sql}
CREATE TABLE monde.city AS 
  TABLE world.city;
```

{{< fa hand-point-right >}} On a copié le schéma a minima (sans les contraintes)


## Dans un pays plusieurs villes peuvent elles porter le même nom ?



```{.sql}
SELECT *
FROM 
  monde.city c 
JOIN 
  monde.city c2 
ON (c.name = c2.name AND 
    c.countrycode = c2.countrycode  AND 
    c.id <> c2.id) ;
```

renvoie 48 lignes 

. . .

```{.sql}
SELECT *
FROM 
  monde.city c 
JOIN 
  monde.city c2 
ON (c.name = c2.name AND 
    c.countrycode = c2.countrycode  AND
    c.district = c2.district  AND
    c.id <> c2.id) ;
```

renvoie 2 lignes 




## Existe-t-il un pays dont la capitale est dans un autre pays ?

```{.sql}
SELECT c. countrycode, c.name_country, cc.name, cc.countrycode
FROM 
  world.country c 
JOIN 
  world.city cc 
ON (c.capital = cc.id  AND 
    cc.countrycode <> c.countrycode) ;
```

renvoie 0 lignes {{< fa champagne-glasses >}}


##  {{< fa triangle-exclamation >}}  Blocages possibles

Si 

- `city` emet une contrainte référentielle sur `country` (`countrycode`)
- `country` emet une contrainte référentielle sur `city` (`capital` $\rightarrow$ `id`)

Risque de blocage : qui précède la capitale ou le pays ? 




## Émission de la contrainte de `city` vers `country`

```{.sql}
ALTER TABLE monde.city 
  ADD CONSTRAINT city_fk FOREIGN KEY (countrycode) 
      REFERENCES monde.country(countrycode) 
  ON DELETE SET NULL ON UPDATE CASCADE;
```



## Table `countrylanguage` 

```{.sql}
CREATE TABLE monde.countrylanguage  AS 
  TABLE world.countrylanguage ;
```

. . .


```{.sql}
ALTER TABLE monde.countrylanguage 
  ADD CONSTRAINT countrylanguage_fk 
	    FOREIGN KEY (countrycode) REFERENCES monde.country(countrycode) 
	    ON DELETE CASCADE 
      ON UPDATE CASCADE;

ALTER TABLE monde.countrylanguage 
  ADD CONSTRAINT countrylanguage_pk 
	PRIMARY KEY ("language",countrycode);

ALTER TABLE monde.countrylanguage 
  ADD CONSTRAINT countrylanguage_check 
	CHECK (percentage <= 100.0 AND percentage >=0.0 );
```

-->


<!-- ![](/images//bd_2023-monde.png) -->


<!--
# Les vues {background-color="#1c191c"}



## Synthèse régionale 

```{.sql}
CREATE OR REPLACE VIEW regionale AS (
SELECT C.region, 
       SUM(c.population_country) AS population_region,
       SUM(COALESCE(c.surfacearea, 0)) AS surfacearea_region,
       SUM(c.gnp) AS gnp_region,
       SUM(c.gnpold) AS gnpold_region
FROM country c 
GROUP BY c.region ) ;
```



## Synthèse continentale

```{.sql}
SELECT r.* 
FROM 
  regionale r 
JOIN 
  region_continent rc 
ON (r.region=rc.region AND rc.continent='Europe') ;
```

. . .

```{.sql}
SELECT r.* 
FROM 
  regionale r 
WHERE 
  r.region IN (
    SELECT 
      region
    FROM 
      monde.region_continent
    WHERE 
      continent='Europe'
  ) ;
```

. . .

```
+----------------+-----------------+------------------+----------+-------------+
|region          |population_region|surfacearea_region|gnp_region|gnpold_region|
+----------------+-----------------+------------------+----------+-------------+
|Western Europe  |        183247600|         1108456.5|4673272.00|   4578420.00|
|Southern Europe |        144674200|         1316392.4|2012289.00|   1944737.00|
|Baltic Countries|          7561900|          175117.0|  22418.00|     18595.00|
|Nordic Countries|         24166400|         1321901.0| 676655.00|    677698.00|
|British Islands |         63398500|          313173.0|1454251.00|   1369962.00|
|Eastern Europe  |        307026000|          18814094| 659980.00|    792589.00|
```


## Synthèse continentale

```{.sql}
CREATE OR REPLACE VIEW monde.continentale AS (
SELECT rc.continent, 
       SUM(r.population_region) AS population,
       SUM(r.surfacearea_region) AS surfacearea,
       SUM(r.gnp_region) AS gcp,
       SUM(r.gnpold_region) AS gcpold
FROM monde.regionale r JOIN monde.region_continent rc 
     ON (r.region=rc.region) 
GROUP BY rc.continent;) ;
```

. . .

```
+-------------+----------+-----------+----------+----------+
|continent    |population|surfacearea|gcp       |gcpold    |
+-------------+----------+-----------+----------+----------+
|South America| 345780000|   17864926|1511874.00|1520641.00|
|North America| 482993000|   24214472|9688627.20|9288175.00|
|Oceania      |  30401150|  8564294.0| 419774.70| 469058.00|
|Antarctica   |         0|   13132101|      0.00|          |
|Africa       | 784475000|   30250376| 580375.00| 553264.00|
|Europe       | 730074600|   23049132|9498865.00|9382001.00|
|Asia         |3705025700|   31881006|7655392.00|8251969.00|
```
-->

# Fin  {background-color="#1c191c"}