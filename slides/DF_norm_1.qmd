---
title: "Normalisation I"
subtitle: "Dépendances Fonctionnelles, Clés, Fermetures, Couvertures irredondantes."
date: "2025-12-01"

format: 
  revealjs:
    header: "Dépendances Fonctionnelles, Clés, Fermetures, Couvertures irredondantes."

engine: knitr
---


# Introduction  {background-color="#1c191c"}


## Conception du modèle relationnel

Une première approche pour concevoir un modèle relationnel (l'ensemble des schémas de tables d'une bd) consiste à :

- Identifier les attributs d'intérêt

- Répartir les attributs dans plusieurs relations

. . .

- Comment savoir si le modèle relationnel est *bon* ?

. . .

- Si ce n'est pas le cas : y a-t-il des techniques pour le transformer en un *bon* modèle?





## Qualité d'un schéma  {.smaller}

Quelles sont de *bonnes propriétés* d'un schéma ?


**Exemple**

Attributs relatifs à des *vendeurs*, *produits* et *livraisons*

| Attribut |  Usage |
|:--------:|:----------------|
| **`V#`** | numéro du vendeur   |
| `Vnom`   | nom du vendeur  |
| `Vville` |ville du vendeur   |
| **`P#`** | numéro du produit  |
|`Pnom`    |nom du produit  |
|`Pville`  |ville où le produit est stocké  |
|`Qte`     |quantité de produit livrée au vendeur |



## Qualité d'un schéma

Un schéma relationnel possible : une seule relation `R` avec tous les attributs

```
R(V#, Vnom, Vville, P#, Pnom, Pville, Qte)
```

. . .


- {{< fa face-frown >}} C'est une mauvaise modélisation.

- {{< fa brain >}} Pourquoi ?




## Qualité d'un schéma relationnel

::: {.callout-caution}

### Redondance

| V# |  Vnom |  Vville |  P# |  Pnom |  Pville |  Qte |
|---:|:-----:|:-------:|----:|:-----:|:-------:|----: |
|3 | MagicV | Paris | ... | ... | ... | ... |
|3 | MagicV | Paris | ... | ... | ... | ... |
|2 | IdealB | Lyon | ... | ... | ... | ... |
|2 | IdealB | Lyon | ... | ... | ... | ... |



`Vnom` et `Vville` sont déterminés par` V#` :

si deux livraisons ont le même `V#`, elles ont aussi le même `Vville` et le même `Vnom`

:::


## {{< fa face-frown >}}


- **Anomalies de mise à jour**

`Vnom` ou `Vville` pourrait être mis à jour dans une livraison et pas dans une autre, ce qui donnerait une incohérence. Les mesures pour éviter cela rendent la mise à jour est coûteuse

. . .

- **Anomalies d'insertion**

On ne peut pas enregistrer un vendeur s'il ne reçoit pas de livraison


. . .

- **Anomalies de suppression**

Si on supprime toutes les livraisons à un vendeur, on perd toute l'information sur ce vendeur


---

## Qualité d'un schéma relationnel

- Un *bon* schéma

```{verbatim}
Vendeur(V#, Vnom, Vville)    Clef : V#
Produit(P#, Pnom, Pville)    Clef : P#
Livraison(V#, P#, Qte)       Clef : (V#,P#)
```

- Plus d'anomalie ! Comment y arriver?

. . .

La théorie de la *normalisation* des BD relationnelles fournit

- la notion de **forme normale** : propriétés d'un schéma qui garantissent l'absence de redondance et des anomalies qui en dérivent. Ces propriétés sont définies par rapport à un ensemble de *contraintes*

- des *techniques de normalisation* : passage d'un schéma arbitraire (mauvais) à un schéma en forme normale (obtenu typiquement par décomposition)





# Dépendances fonctionnelles  {background-color="#1c191c"}

## Exemple

`R(V#, Vnom, Vville, P#, Pnom, Pville, Qte)`

Un ensemble de dépendances fonctionnelles qu'on peut raisonnablement supposer :

```{verbatim}
V# ⟶ Vnom Vville
P# ⟶ Pnom Pville
V# P# ⟶ Qte
```

- Cela signifie que l'on ne considère que des relations R qui satisfont :
- si 2 tuples de `R` ont la même valeur de `V#` alors ils ont la même valeur de `Vnom` et `Vville`
- si 2 tuples de `R` ont la même valeur de `P#` alors ils ont la même valeur de `Pnom` et `Pville`
- ...



## DF exemple (suite) {.smaller}


| V# |  Vnom |  Vville |  P# |  Pnom |  Pville |  Qte  |
|---:|:-----:|:-------:|----:|:-----:|:-------:|:-----:|
|3 | MagicV | Paris | 322 | manteau | Lille | 2 |
|1 | StarV | Rome | 546 | veste | Rome | 1 |
|3 | MagicV | Paris | 322 | manteau | Lille | 5 |
|2 | IdealB | Lyon | 145 | jupe | Paris | 7 |
|2 | IdealB | Lyon | 234 | jupe | Lille | 1 |

. . .

- `R` satisfait `V#` ⟶ `Vnom Vville` et `P#` ⟶ `Pnom Pville`

- `R` ne respecte pas `V# P#` ⟶ `Qte`



## Autre Exemple   {.smaller}

Schéma `Films(titre, année, durée, genre, producteur, acteur)`

| titre |  année |  durée |  genre |  producteur |  acteur |
|:------|:---------:|----------:|:----------|:---------------|:-----------|
|Star Wars | 1977 | 124 | SciFi | Fox | Carrie Fisher |
|Star Wars | 1977 | 124 | SciFi | Fox | Mark Hamill |
| Star Wars | 1977 | 124 | SciFi | Fox | Harrison Ford |
|Gone With The Wind | 1939 | 231 | drame | MGM | Vivien Leigh|
|Wayne's World | 1992 | 95 | comédie | Paramount | Dana Carvey|
|Wayne's World | 1992 | 95 | comédie | Paramount | Mike Meyers|
| ... | | | | | |

---

- On sait qu'il n'y a pas 2 films de même nom qui sortent la même année. On a donc la dépendance suivante

`titre, année ⟶ durée, genre, producteur`

- La DF `titre, année ⟶ acteur`

est certainement fausse puisqu'un film fait intervenir en général plusieurs acteurs

- A-t-on la DF `titre, acteur ⟶ année, durée, genre, producteur` ?



## Définition d'une dépendance fonctionnelle

::: {.callout-important}

### Définition : Dépendance fonctionnelle 

Soit $\mathcal{A}$ un schéma de relation ($\mathcal{A}$ est un ensemble d'attributs)

Une *dépendance fonctionnelle* sur $\mathcal{A}$ est une expression de la forme

$$X \to Y$$

où $X \subseteq \mathcal{A}$ et $Y \subseteq \mathcal{A}$

Une relation $R$ de schéma $\mathcal{A}$ satisfait $X \to Y$ si pour tous tuples $s,t ∈ R$ on a

$$\bigl(∀ A∈ X\ s.A=t.A\bigr) ⟹ \bigl(\forall A∈ Y\ s.A=t.A\bigr)$$

(si $s$ et $t$ coïncident sur $X$ alors $s$ et $t$ coïncident sur $Y$)

Une relation $R$, de schéma $\mathcal{A}$, satisfait un ensemble $\Sigma$ de DF si $R$ satisfait chaque DF de $\Sigma$

:::



## Exemples

Dans la base **Pagila**, relation `Actor` :

- `Actor_id ⟶ last_name`, `first_name`

- car `Actor_id` est une clé...


## Dépendance fonctionnelle élémentaire

::: {.callout-important}

### Définition : dépendance élémentaire

$A_1,...,A_p \to Y$ est une dépendance *élémentaire* si
pour tout $j\leqslant p$ :  $A_1,...,A_{j-1}, A_{j+1},..., A_p\not\to Y$

:::

. . .

- `No_insee ⟶ sexe, mois_naiss, jour_naiss` est  élémentaire.

- `No_insee, jour_naiss ⟶ sexe, mois_naiss, ville_naiss` n'est pas élémentaire ...


::: {.callout-note}

`No_insee` suffit

:::






## Dépendance fonctionnelle triviale

Une DF triviale est une DF satisfaite par toute relation.


::: {.callout-important}

### Définition (dépendance triviale)

Soient $X,Y⊂ \mathcal{A}$

$X\to Y$ est une dépendance triviale si $Y \subset X$

:::

. . .

::: {.callout-note}

### Exemple

`No_insee ` $\to$ `No_insee` est  triviale


:::




## Implication entre  DF

::: {.callout-important}

### Définition

Un ensemble $\Sigma$ de DF *implique* une autre DF $X\to Y$ si
toute relation qui satisfait $\Sigma$ satisfait également $X\to Y$.

Notation pour $\Sigma$ implique $X\to Y$ : $\quad \quad\Sigma \models X \to Y$

:::

::: {.callout-note}

### Exemple I
$A\to B$ et $B\to C$ impliquent $A\to C$.
:::

. . .

::: {.callout-note}

### Exemple II
$A\to C$, $BC\to D$, $AD\to E$ impliquent $AB\to E$.
:::


## Règles d'inférence

Les règles d'inférence permettent de calculer toutes les DF impliquées par un ensemble donné de DF.

::: {.callout-important}

### Règles d'Armstrong

- *Transitivité* : $\{ X\to Y, Y\to Z\} \models X\to Z$

- *Augmentation* : $X\to Y \models \{X,Z\} \to \{Y,Z\}$

- *Réflexivité* : $\varnothing \models \{X,Y\}\to X$  (DF triviale)

:::

## Vérification de la transitivité

On se rammène à vérifier une règle du calcul propositionnel :  
si p ⇒ q et q ⇒ r alors p ⇒ r 

Soit une instance $\mathcal{R}$ telle que :  
$$\forall s,t \in \mathcal{R} \qquad 
  \begin{cases}  \text{si } s.X =t.X & \text{alors } s.Y= t.Y \\
   \text{si } s.Y =t.Y &  \text{alors } s.Z= t.Z
\end{cases}
$$
On a alors aussi 
$\forall s,t \in \mathcal{R}$, si $s.X =t.X$ alors $s.Z= t.Z$




## Calcul sur les DF  

::: {.callout-important}

### Théorème

$\Sigma \models X\to Y$

si et seulement si

$X\to Y$ peut-être dérivée de $\Sigma$ par applications successives des trois règles d'Armstrong.

:::

::: {.callout-note}
Des 3 règles d'Armstrong, on déduit d'autres règles :

- *Union* : $\{X\to Y, X\to Z\} \models X\to \{Y,Z\}$
- *Séparation* : $X\to \{Y,Z\} \models X\to Y$

- ...
:::


## Exemple

Soient $\mathcal{A}$ un schéma de relation ( $\mathcal{A}$ est un ensemble d'attributs) 

On considère l'ensemble de DF $\Sigma=\{A\to B, B\to C\}$

- $\Sigma$ implique $A\to B$, $B\to C$, $A\to C$, $AB\to C$, ...
- mais aussi les DF triviales $A\to A$, $AB\to A$, ...



## Ensembles de DF équivalents


::: {.callout-important}
### Définition

Soit $\Sigma$ et $\Sigma'$ deux ensemble de DF sur un schéma $\mathcal{A}$


$\Sigma$ est *équivalent* à $\Sigma'$

ssi

$\Sigma\models\Sigma'$ et $\Sigma'\models\Sigma$

:::


. . .

Exemples simples :

- $\{X\to A_1,...,A_n\}$ est équivalent à $\{X\to A_1, ..., X\to A_n\}$

- $XY\to YZ$ est équivalent à $XY\to Z$





# Clés et sur-clés {background-color="#1c191c"}

## Définitions

Soit $\mathcal{A}$ un schéma et $\Sigma$ une ensemble de DF sur $\mathcal{A}$

::: {.callout-important}

### Définition : sur-clé

Un ensemble d'attributs $X$ est une **sur-clé** (ou super-clé) si $\Sigma \models X \to \mathcal{A}$

c-à-d si $X$ détermine tous les attributs de $\mathcal{A}$.

:::

. . .

::: {.callout-important}

### Définition : clé

Un ensemble d'attributs $X$ est une **clé** si $X$ est une sur-clé et si
tout sous-ensemble $Y\subset X$ tel que $Y\not=X$ n'est pas une sur-clé.

Autrement dit, $X$ est une clé si $X$ est une sur-clé minimale au sens de l’inclusion.
:::


## Exemple


$R(A,B,C) \qquad \Sigma = \{A\to B, B\to C\}$

Sur-clé : $A$, $AB$, $AC$, $ABC$

Clé : $A$ (la seule)




# Fermeture d'un ensemble d'attributs  {background-color="#1c191c"}



## Question principale

- Comment vérifier si un ensemble $\Sigma$ de DF implique une DF $X\to Y$ ?

. . . 

- Par les équivalences présentées précédemment, la question se ramène à :

Comment vérifier si un ensemble $\Sigma$ de DF implique une DF $X\to A$
où $A$ est un attribut ?


## Fermeture d'un ensemble d'attributs

Soit $X \subset\mathcal{A}$ un sous-ensemble d'attributs et $\Sigma$ un ensemble de DF sur $\mathcal{A}$


::: {.callout-important}

### Définition

La fermeture de $X$ par rapport à $\Sigma$ est

$$X^+=\{ A\in\mathcal{A} \mid \Sigma\models X\to A \}$$

:::

::: {.aside}

Autrement dit $X^+$ est l'ensemble des attributs déterminés par $X$

:::


##  Exemple de fermeture

- $R(ABCDE)$
- $\Sigma=\{AB\to C, C\to D, E\to D\}$
- $\{A,B\}^+=\{A,B,C,D\}$


## Algorithme de calcul d'une fermeture

L'algorithme retourne $X^+$ relativement à un ensemble de DF $\Sigma$.

```{=html}
<pre style="background-color: #f0f0ffff;font-family:'Lucida Console','Courier New',monospace; color: #15093aff;font-size:1em;padding:10px;border:1px solid #220f61ff;">
fonction fermeture(X, Σ)
   X⁺ :=  X
   while (exists Y → Z in Σ with Y ⊂ X⁺ and Z ⊄ X⁺)
      X⁺ := X⁺ ⋃ Z
   return X⁺
</pre>
```


## Exemple de calcul de fermeture

$\mathcal{A}=\{ABCDEF\}$, $\Sigma=\{A\to C, BC\to D, AD\to E\}$, $X=\{A,B\}$

- $X_c=\{A,B\}$

- $A\to C$ donc on obtient $X_c=\{A,B,C\}$

- $BC\to D$ donc on obtient $X_c=\{A,B,C,D\}$

- $AD\to E$ donc on obtient $X_c=\{A,B,C,D, E\}$

- On obtient $X^+=\{A,B,C,D, E\}$




## Terminaison de l'algorithme

{{< fa hand-point-right >}} $X^c$ grandit à chaque itération

Comme $\mathcal{A}$ est fini, l'algorithme se termine en au plus $|\mathcal{A}|$ itérations


## Correction de l'algorithme de fermeture  {{< fa person-chalkboard >}}

- L'algorithme calcule uniquement des attributs dans la fermeture car
on a toujours $X^c \subset X^+$ (récurrence sur le nombre d'itérations de la boucle `while`).

- L'algorithme calcule tous les attributs dans la fermeture:  $X_c=X^+$ quand l'algorithme se termine.

::: {.aside}

Le dernier point est le plus délicat. Que peut signifier le fait qu'il existe au moins un attribut $Y\in X^+$ qui n'appartienne pas à la valeur terminale de $X^c$ ?  
:::


## Calcul de la fermeture transitive : exemple

::::: {.columns}

::: {.column width="75%"}

Soit $R$ d'ensemble d'attributs

$\mathcal{A} =\{A,B,C,D,E,F,G\}$

Soit $X=\{B,D\} \subset \mathcal{A}$

Et $\Sigma$ l'ensemble de dépendances fonctionnelles ci-contre

:::



::: {.column width="25%"}

$A,B \to C$ 
$C \to A$ 
$B,C \to D$ 
$A,C,D \to B$ 
$F\to A,C$
$D \to E,G$ 
$B,E \to C$ 
$C,G \to B,D$ 
$C,E \to A,G$ 

:::

:::::

. . . 

Montrer que  $X^+=\{A,B,C,D,E,G\}$

Donner une clé de $R$ : par exemple $\{A,B,F\}$, $\{E,F\}$, $\{F,G\}$. Il n'y a pas unicité.



## Fermetures et clés

::: {.callout-important}

### Propriété 

Soit $\mathcal{A}$ un schéma, $X \subset \mathcal{A}$ est une clé de $\mathcal{A}$ si et seulement si 

- $X^+ = \mathcal{A}$, 
- $\forall \ Y \subsetneqq X$, $\quad Y^+ \subsetneqq X$

où $\subsetneqq$ signifie "strictement inclus".

:::

## Fermetures et implications de DF

::: {.callout-important}

### Propriété 

Soit $\mathcal{A}$ un schéma, X,Y des parties de $\mathcal{A}$, $\Sigma$ un ensemble de DF sur $\mathcal{A}$.

- $\Sigma \models X\to Y \quad$  ssi $\quad Y \subset X^+$

:::



## Fermetures et équivalences de DF

::: {.callout-important}

### Propriété 

Soit $\mathcal{A}$ un schéma, $\Sigma_1$ et $\Sigma_2$ deux ensembles de DF sur $\mathcal{A}$.

**$\Sigma_1$ et $\Sigma_2$ sont équivalents** si et seulement si $\quad \forall\ X \subset \mathcal{A},\ \ X^+_{\Sigma_1} = X^+_{\Sigma_2}$.

où $X^+_{\Sigma_1}$ et $X^+_{\Sigma_2}$ sont les fermetures transitives de $X$ respectivement selon $\Sigma_1$ et $\Sigma_2$.

:::

::: {.callout-note}

### justification 

Cette propriété dit que $\Sigma_1$ et $\Sigma_2$ sont équivalents si, pour tout ensemble d'attributs $X$ , les ensembles $X^+$ de tous les attributs déterminés par $X$ sont identiques selon $\Sigma_1$ et selon $\Sigma_2$.

:::




# Couverture irredondante d'un ensemble de DF {background-color="#1c191c"}



## Définition de la couverture irredondante d'un ensemble de DFs

::: {.callout-important}
### Définition

Soit  $\Sigma$ un ensemble de DF, une *couverture irredondante* (ou minimale) de  $\Sigma$ est un ensemble de DF $\Sigma'$ qui vérifie :

- Chaque DF de $\Sigma'$ est de la forme $X → a$, où $a$ est un attribut,

- Chaque DF de $\Sigma'$ est élémentaire, c.a.d. $\quad ∀ (X → a) ∈ Σ',\ \ ∀ Y ⫋ X,\ \ Σ' ⊭ Y → a $. 

- $\Sigma'$ et $\Sigma$ sont équivalents

- Aucun sous-ensemble strict de $\Sigma'$ n'implique $\Sigma$.
:::

::: {.callout-note}

Dans une couverture irredondante, toutes des DFs sont nécessaires, chaque DF est élémentaire et une DF avec plusieurs attributs à droite est décomposée en autant de DF avec un seul attribut à droite.

- **pas d'unicité**.
- minimise la compléxité des algorithmes.
- utile pour la décomposition FN3.
:::

 
## Algorithme de construction d'une couverture irredondante  {.scrollable}

```{=html}
<pre style="background-color: #f0f0ffff;font-family:'Lucida Console','Courier New',monospace; color: #15093aff;font-size:0.8em;padding:10px;border:1px solid #220f61ff;">
fonction min_cover(Σ)
   Σ' := ∅ 
   for (X → Y) ∈ Σ    // sélection des DF non redondantes
      for y ∈ Y
         if not (Σ' ⊨ X → y)
            Σ':= Σ' ⋃ {X → y}
   go = True
   while go       // élimination d'attributs, obtenir des DF élémentaires 
      go := False
      for (X → y) ∈ Σ'
         for x ∈ X
            if Σ' ⊨ (X\{x}) → y
               Σ' := (Σ'\{X → y}) ⋃ {(X\{x}) → y}
               go := True
               break
   return Σ'
</pre>
```




# Fin   {background-color="#1c191c"}
