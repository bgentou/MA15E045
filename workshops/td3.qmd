---
title: "TD 3 : SQL"
subtitle: "SQL Interrogation de données, requêtes complexes"
categories: [pagila, world, SQL, VIEW, FUNCTION, requêtes imbriquées]
date: "2025-10-10"


format:
  pdf:
    code-annotations: below
    keep-tex: false
    code-fold: false
    toc: false
    output-file: td3.pdf
    include-in-header:
      - text: "\\lhead{{\\sf  Base de données \\\\ TD 3}}"
  html:
    embed-resources: true
    code-fold: true
    output-file: td3.html

engine: knitr
---



{{< include _preamble.qmd >}}


## Objectifs

- requêtes imbriquées, 
- jointures externes,
- vues, 
- fonctions SQL.



<!--
Sous `psql` ou `pgli`, vous pouvez aussi inspecter les tables comme d'habitude avec

```{.sql}
bd_2023-24> \d pagila.film
bd_2023-24> \d pagila.actor
```
-->

## Prérequis

- schéma [`world`](/schemas/schema-world.qmd){target="_blank"},
- schéma [`pagila`](/schemas/schema-pagila.qmd){target="_blank"},

- cours [Algèbre relationnelle](https://bgentou.github.io/MA15E045/slides/SQL_0.html){target="_blank"},
- cours [Requêtes simples](https://bgentou.github.io/MA15E045/slides/SQL_1.html){target="_blank"},
- cours [Requêtes imbriquées, CTEs](https://bgentou.github.io/MA15E045/slides/SQL_2.html){target="_blank"}.

::: {.callout-tip}

Quand on travaille sur plusieurs schémas (ici `world`, `pagila` et votre schéma personnel), il est bon 

- d'ajuster `search_path` : `set search_path to world, pagila, ... ;` (remplacer `...`par votre identifiant)
- de qualifier les noms de table pour indiquer le schéma d'origine : `world.country` versus `pagila.country`

:::


<!--
## [Requêtes imbriquées](/slides/SQL_2.html)

Les requêtes imbriquées permettent d'utiliser le résultat d'une requête dans la clause `WHERE`.

On utilisera essentiellement les opérateurs suivants: `IN, EXISTS, ALL, ANY`.

`IN` permet de tester la présence d'une valeur dans le résultat d'une requête. 

`EXISTS` renvoie `True` si la requête donnée est non-vide et `False` sinon. On peut les combiner avec `NOT` pour inverser leur comportement: `NOT IN` et `NOT EXISTS`. Par exemple, pour connaître les régions sans monarchie, on pourra écrire:



```{.sql}
SELECT DISTINCT region 
FROM world.country
WHERE region NOT IN (
  SELECT region
  FROM world.country
  WHERE governmentform like '%Monarchy%'
);
```

Pour connaître les régions qui ont au moins une langue officielle, on pourra écrire:


```{.sql}
SELECT DISTINCT region 
FROM world.country AS co
WHERE EXISTS (
  SELECT *
  FROM world.countrylanguage AS cl
  WHERE co.countrycode = cl.countrycode AND 
    cl.isofficial
);
```

Remarquez que dans ce dernier exemple, la sous-requête fait intervenir des attributs de la requête principale, c'est pourquoi on parle de requêtes imbriquées.

`ANY` et `ALL` sont deux autres opérateurs. Par exemple

```{.sql}
SELECT * 
FROM table 
WHERE col < ALL(
  requete
)
```

sélectionnera les lignes de `table` telles que la valeur de `col` est plus petite que toutes les valeurs retournées par la requête `requete`. Ainsi, la requête

```{.sql}
SELECT * 
FROM world.country
WHERE population_country >= ALL(
  SELECT population_country 
  FROM world.country
);
```

retournera la liste des pays les plus peuplés.

```{.sql}
SELECT * 
FROM table 
WHERE col < ANY(
  requete
)
```

sélectionnera les lignes de `table` telles que la valeur de `col` est strictement plus petite qu'au moins une des valeurs retournées par la requête `requete`.

Pour connaître les régions où l'on ne trouve qu'une seule forme de gouvernement, on pourra écrire:

```{.sql}
SELECT DISTINCT region 
FROM world.country as c1
WHERE c1.governmentform = ALL(
  SELECT c2.governmentform 
  FROM world.country as c2
  WHERE c2.countrycode!=c1.countrycode AND 
    c2.region=c1.region
);
```

::: {.callout-note}

On remarque que dans `EXISTS` ou `IN` on peut utiliser des attributs de notre requête globale, ce qui les rend plus *puissants* que 

```{.sql}
WITH ... AS (
  ...
)
```

:::


## [Jointure externe](/slides/SQL_1.html)

La jointure externe est une jointure un peu particulière. On a vu la semaine dernière que lorsqu'on faisait une jointure, les lignes de la table de droit étaient recollées aux lignes de la table de gauche. Si une ligne a gauche ne pouvaient pas être recollée, elle disparaissait de la jointure. La jointure extérieure permet de garder ces lignes-là malgré tout.

On utilisera `LEFT JOIN` et `RIGHT JOIN`. Par exemple, la requête suivante renvoie la liste des pays et leur langages. Les pays qui ne se trouvent pas dans la table `countrylanguage` (il y en a, l'Antarctique par exemple) seront listés quand même et les informations manquantes seront remplies avec des valeurs `NULL`.



```{.sql}
SELECT * 
FROM world.country AS p LEFT JOIN 
  world.countrylanguage AS l ON 
  p.countrycode = l.countrycode;
```

On peut utiliser cette requête pour trouver les pays qui n'ont pas de langue officielle par exemple:


```{.sql}
SELECT * 
FROM world.country as p LEFT JOIN 
  world.countrylanguage AS l ON 
  p.countrycode = l.countrycode AND l.isofficial
WHERE l.countrycode IS NULL;
```
-->

## Questions


@. Quels sont les langues qui ne sont officielles dans aucun pays ? (355 lignes)

   Écrivez une version avec `EXCEPT`, une avec `NOT IN` et une autre avec `LEFT JOIN`.


::::: {.content-visible when-profile="solution"}

::: {.callout-tip title="Solution"}

```{.sql}
(
  SELECT DISTINCT language 
  FROM  world.countrylanguage
)

EXCEPT 

(
  SELECT language 
  FROM world.countrylanguage 
  WHERE isofficial
);
```

:::

:::::


::: {.content-visible when-profile="solution"}

Première  version

::: {.callout-tip title="Solution"}




```{.sql}
SELECT DISTINCT language 
FROM world.countrylanguage
WHERE language NOT IN
      (SELECT language 
       FROM world.countrylanguage 
       WHERE isofficial);
```

:::

Deuxième version:


::: {.callout-tip title="Solution"}

```{.sql}
SELECT DISTINCT l1.language 
FROM world.countrylanguage AS l1
     LEFT JOIN world.countrylanguage AS l
     ON (l1.language = l.language AND l.isofficial)
WHERE l.language IS NULL;
```

:::


Troisième version:

::: {.callout-tip title="Solution"}


```{.sql}
SELECT DISTINCT cl.language 
FROM world.countrylanguage cl
WHERE  NOT EXISTS (
  SELECT cl1.language 
  FROM world.countrylanguage cl1
  WHERE cl1.language=cl.language AND
  cl1.isofficial
);
```

:::
<!--
::: {.callout-note}

En calcul relationnel


\begin{align*}
\Big\{l.\texttt{language} :  & \texttt{countrylanguage}(l) \wedge \\
& \neg \big( \exists t \quad \texttt{countrylanguage}(t)  \wedge\\
&\phantom{\neg\big(}l.\texttt{language}=t.\texttt{language}\wedge t.\texttt{isofficial}\big)\Big\}
\end{align*}


:::
-->
:::

@. Quelles sont les régions où au moins deux pays ont la même forme de gouvernement ? (21 lignes)


::: {.content-visible when-profile="solution"}

::: {.callout-tip title="Solution"}

```{.sql}
SELECT DISTINCT region 
FROM world.country AS c1
WHERE c1.governmentform = ANY(
  SELECT c2.governmentform
  FROM world.country AS c2 
  WHERE c2.countrycode!=c1.countrycode AND c2.region=c1.region
);
```

:::

:::

::: {.content-visible when-profile="solution"}

::: {.callout-tip title="Solution"}

```{.sql}
SELECT DISTINCT c1.region 
FROM world.country AS c1 JOIN world.country AS c2
  ON c1.region=c2.region AND 
    c1.countrycode!=c2.countrycode AND 
    c1.governmentform=c2.governmentform;
```

:::

:::


@. Quels sont les films qui n'ont jamais été loués ? (42 lignes)




::::: {.content-visible when-profile="solution"}

::: {.callout-tip title="Solution"}



Là encore, plusieurs possibilités. Avec ce que l'on sait déjà  :

```{.sql}
WITH DejaLoue AS (
  SELECT film_id 
  FROM rental JOIN inventory USING (inventory_id)
), NonLoue AS (
  SELECT film_id 
  FROM film 
  EXCEPT 
  SELECT * 
  FROM DejaLoue
)

SELECT title 
FROM film NATURAL JOIN NonLoue;
```

Avec les requêtes imbriquées :


```{.sql}
SELECT title,film_id FROM film
                     WHERE film_id NOT IN (
                      SELECT film_id 
                      FROM rental JOIN inventory USING (inventory_id)
);
```

:::

:::::


<!--::: {.callout-note }

En calcul relationnel


\begin{align*}
\Big\{ f.\texttt{title} : & \texttt{film}(f) \wedge \\
& \neg \big( \exists t, t_1  \quad \texttt{inventory}(t)  \wedge  \exists t_1  \quad \texttt{rental}(t_1)  \wedge\\
&\phantom{\neg\big(} f.\texttt{film\_id}=t.\texttt{film\_id}\wedge t.\texttt{inventory\_id}=t_1.\texttt{inventory\_id}\big)\Big\}
\end{align*}


:::-->

::: {.callout-note}

Cette question est exactement du même type que la précédente. On y répond de la même manière :
pour trouver les objets d'un certain type  qui ne possèdent pas une propriété, on cherche
dans la base tous les objets de ce type et on fait la différence avec l'ensemble des objets de ce type qui possèdent la propriété dans la base.

:::


@. Quels sont les acteurs qui ont joué dans toutes les catégories de film ? (11 lignes)

::::: {.content-visible when-profile="solution"}

::: {.callout-tip title="Solution"}

```{.sql}
WITH ActCat AS (SELECT actor_id, category_id FROM film_actor fa
                 JOIN film_category fc ON (fa.film_id=fc.film_id)),
ActNot AS (SELECT actor_id FROM actor,category
    WHERE (actor_id,category_id) NOT IN (SELECT * FROM ActCat)),
ActId AS (SELECT actor_id FROM actor
    EXCEPT SELECT * FROM ActNot)

SELECT first_name,last_name FROM actor NATURAL JOIN ActId  ;
```

:::

:::::


::: {.callout-important}

Cette requête réalise une opération sophistiquée de l'algèbre relationnelle [la *division* ou  $\div$](/slides/SQL_0.html#/division).
Il ne s'agit pas d'une opération primitive comme  $\sigma,\pi, \times$.


$$\pi_{\texttt{actor\_id},\texttt{category\_id}} \left(\texttt{film\_actor} \bowtie \texttt{film\_category}\right)  \div \pi_{\texttt{category}} (\texttt{film\_category})$$

:::

::: {.content-visible when-profile="solution"}

::: {.callout-tip title="Solution"}

La version suivante  calcule le même résultat,  et
suit fidèlement le plan d'exécution le plus élémentaire pour réaliser la division.


```{.sql}
WITH 
  ActCat AS (
    SELECT actor_id, category_id 
    FROM film_actor fa JOIN film_category fc ON (fa.film_id=fc.film_id)),
  ActCrosCat AS (
    SELECT  actor_id, category_id 
    FROM  actor, category),
  ActNotCat AS (
    SELECT * 
    FROM ActCrosCat
    EXCEPT 
    SELECT *
    FROM ActCat),
  ActId AS (
    SELECT actor_id 
    FROM actor 
    EXCEPT
    SELECT actor_id 
    FROM ActNotCat)

SELECT first_name,last_name 
FROM actor NATURAL JOIN ActId  ;
```


En comptant le nombre $n$ de catégories de films dans une première requête, on peut aussi sélectionner les acteurs qui apparaissent dans au moins $n$ catégories de film.

:::

:::

@. Existe-t-il des acteurs qui ne jouent avec aucun autre acteur ? (0 ligne)


::: {.content-visible when-profile="solution"}

::: {.callout-tip title="Solution"}

Avec une jointure externe

```{.sql}
WITH copain AS
  (SELECT DISTINCT
    R1.actor_id 
   FROM 
    film_actor as R1
  JOIN 
    film_actor as R2
  ON 
    (R1.film_id = R2.film_id AND 
     R1.actor_id != R2.actor_id)
)
SELECT 
  actor_id 
FROM 
  actor LEFT JOIN copain USING(actor_id)
WHERE 
  actor_id IS NULL;
```

Avec une sous-requête ou une CTE :


```{.sql}
WITH copain AS
  (SELECT 
    R1.actor_id 
   FROM 
    film_actor as R1
  JOIN 
    film_actor as R2
  ON 
    (R1.film_id = R2.film_id AND 
     R1.actor_id != R2.actor_id)
)
SELECT 
  actor_id 
FROM 
  actor
WHERE 
  actor_id NOT IN (
    SELECT * 
    FROM copain
);
```

ou avec `NOT EXISTS`


```{.sql}
SELECT actor_id 
FROM 
  actor a
WHERE 
  NOT EXISTS (
    SELECT fa2.actor_id
    FROM 
      film_actor fa1 
    JOIN 
      film_actor fa2
    ON
     (fa1.actor_id=a.actor_id AND
      fa2.actor_id<> a.actor_id AND
      fa1.film_id=fa2.film_id)
)
```

:::

:::




::: {.content-visible when-profile='solution'} 
 
::: {.callout-tip title="Solution"}
ChatGPT *fecit* (ça marche mais ça n'est pas très beau)
```{.sql}
WITH ActorFilmCounts AS (
    -- Pour chaque acteur, chaque film, nombre de co-acteurs dans le film
    SELECT 
        fa1.actor_id,
        fa1.film_id,
        COUNT(fa2.actor_id) AS other_actors_count
    FROM 
        film_actor fa1
    LEFT JOIN 
        film_actor fa2 
    ON 
        fa1.film_id = fa2.film_id 
        AND fa1.actor_id <> fa2.actor_id
    GROUP BY 
        fa1.actor_id, fa1.film_id
)
SELECT 
    a.actor_id,
    a.first_name,
    a.last_name
FROM 
    ActorFilmCounts afc
JOIN 
    actor a 
ON 
    afc.actor_id = a.actor_id
GROUP BY 
    a.actor_id, a.first_name, a.last_name
HAVING 
    -- garder les acteurs qui n'ont pas de co-acteurs
    SUM(afc.other_actors_count) = 0;
```

::: 
:::

::: {.content-visible when-profile='solution'} 
 
::: {.callout-caution title="Une erreur"}

{{< fa radiation >}} La requête suivante ne répond pas à la question posée:
```{.sql}
SELECT 
    fa.actor_id 
FROM 
    film_actor fa
LEFT JOIN 
    film_actor fa2 
ON 
  (fa.film_id = fa2.film_id AND fa.actor_id<>fa2.actor_id)
WHERE 
  fa2.actor_id IS NULL;
```
Elle liste les identifiants d'acteurs qui ont joué au moins une fois dans un film ne comportant qu'un seul acteur, alors qu'on ne cherche les acteurs qui n'ont joué que dans des films ne comportant qu'un seul acteur. 

Cette requête renvoie 31 lignes. 
::: 
 
:::


@. Nom, prénom  des clients  installés dans des villes sans magasin ? (599 lignes)



::: {.content-visible when-profile="solution"}

::: {.callout-tip title="Solution"}

Avec une jointure externe :

```{.sql}
WITH 
  CustomerCity AS (
    SELECT 
      cu.first_name, 
      cu.last_name,
      cu.customer_id, 
      ad.city_id
    FROM 
      customer cu 
    JOIN 
      address ad 
    ON 
      (cu.address_id=ad.address_id)),
  StoreCity AS (
    SELECT 
      ad.city_id 
    FROM 
      store st 
    JOIN address ad 
    ON 
      (st.address_id= ad.address_id)
)
SELECT 
  first_name,
  last_name 
FROM 
  CustomerCity cc LEFT JOIN StoreCity sc USING(city_id)
WHERE 
  sc.city_id IS null;
```

Avec une requête imbriquée :

```{.sql}
WITH 
  CustomerCity AS (
    SELECT 
      cu.first_name, 
      cu.last_name,
      cu.customer_id, 
      ad.city_id
    FROM 
      customer cu 
    JOIN 
      address ad 
    ON 
      (cu.address_id=ad.address_id)),
  StoreCity AS (
    SELECT 
      ad.city_id 
    FROM 
      store st 
    JOIN address ad 
    ON 
      (st.address_id= ad.address_id)
)

SELECT 
  first_name,
  last_name 
FROM 
  CustomerCity
WHERE 
  city_id NOT IN (
      SELECT * FROM StoreCity
  );
```

:::

:::


@. Lister les pays pour lesquels toutes les villes ont au moins un magasin. (1 ligne)

::: {.content-visible when-profile="solution"}

::: {.callout-tip title="Solution"}

Sans requête imbriquée, seulement avec des jointures :

```{.sql}
with co_with_ci_without_store as
(
	select distinct * 
	from country co join city ci using (country_id)
	    left join (address join store using (address_id)) ad_st
	    	using (city_id)
	where ad_st.store_id is null
)
select co.country 
from country co left join co_with_ci_without_store cw on co.country_id = cw.country_id
where cw.country_id is null;
```

Avec des requêtes imbriquées

```{.sql}
SELECT co.country 
from country co 
WHERE NOT EXISTS (
  SELECT * 
  FROM city ci 
  WHERE co.country_id=ci.country_id AND ci.city_id NOT IN 
  	(
	   SELECT address.city_id 
	   FROM store JOIN address USING (address_id)
    )
);
```

:::

:::

@. Déterminer la liste des films disponibles dans toutes les langues.

::: {.content-visible when-profile="solution"}

::: {.callout-tip title="Solution"}

*Comme pour les acteurs "toutes catégories"*, il s'agit d'une *division*. Dans la base installée, le
résultat est vide.  

:::

:::

@. Un même *dvd* (`inventory_id`) peut bien sûr être loué plusieurs fois, mais pas simultanément. Proposer une requête qui  vérifie que les dates de location d'un *dvd* donné sont compatibles.


::: {.content-visible when-profile="solution"}

::: {.callout-tip title="Solution"}

`SQL` en général et `PostGres` en particulier proposent beaucoup de types et d'opérations sophistiquées pour représenter et manipuler les données temporelles.
Plusieurs types de données permettent de représenter les instants (timestamp), les dates, les intervalles de temps, les durées, et de calculer sur le temps (ajouter une durée à une date, extraire une information calendaire d'une date ou d'un instant, ...). Même si l'API varie d'un cadre à l'autre, on retrouve ces types et ces opérations dans tous les environnements de sciences des données : {{< fa brands python >}}, {{< fa brands r-project >}} 

:::

:::




## Vues

Les *vues* permettent de donner un nom à une requête afin de pouvoir l'appeler plus tard sans la réécrire à chaque fois. Une vue s'enregistre dans un schéma.
Par exemple, dans le schéma `World`, on pourrait créer une vue `VillesRepublic`  qui contient toutes les villes de la table `city` qui sont dans une république.

On crée une vue avec `CREATE VIEW nom AS requete`. Étant donné que vous ne pouvez écrire que dans votre schéma personnel, il faudra nommer vos vues `entid.nom` où `entid` est votre identifiant en salle de TP. Ainsi


```{.sql}
CREATE VIEW entid.VillesRepublic AS
  SELECT 
    B.* 
  FROM 
	  world.country as A 
  NATURAL JOIN 
	  world.city as B
  WHERE 
	  A.governmentform like '%Republic%';
```

crée une vue dans votre schéma personnel. Désormais, si on veut sélectionner les villes qui sont dans une république et dont la population est supérieure à $1000000$, on pourra simplement écrire :

```{.sql}
SELECT * 
FROM 
	entid.VillesRepublic 
WHERE 
	population>=1000000;
```


::: {.callout-note}

Remarquez la différence entre `WITH` et une vue. `WITH` nomme une requête temporairement, seulement à l'échelle de la requête courante tandis qu'une vue est enregistrée de façon permanente. Cependant, chaque fois que vous appelez votre vue, elle est réévaluée par le système de base de données.

:::

Notez aussi que SQL n'est pas sensible à la casse. La vue `entid.VillesRepublic`
peut être aussi désignée par `entid.villesrepublic`.

Pour supprimer une vue existante on utilise la commande `DROP VIEW` suivie du nom de la vue à supprimer. Par exemple l'instruction

```{.sql}
DROP VIEW entid.VillesRepublic ;
```

supprime la vue créée précédemment.

Dans votre schéma personnel `entid` (il faut remplacer `entid` par votre nom de login), écrire une vue `film_id_horror` qui renvoie la liste des films de catégorie 'Horror'.



::: {.content-visible when-profile="solution"}
::: {.callout-tip title="Solution"}

```{.sql}
CREATE VIEW entid.film_id_horror
AS
( 
  SELECT film_id 
  FROM film_category JOIN 	category USING(category_id) 
  WHERE category.name='Horror'
) ;
```

:::
:::




## Fonctions SQL

Dans votre schéma personnel `entid` (il faut remplacer `entid` par votre nom de login), écrire une fonction SQL `film_id_cat` qui prend en paramètre une chaîne de caractère `s` et renvoie la liste des films de catégorie `s`. La syntaxe est :



```{.sql}
CREATE OR REPLACE FUNCTION entid.film_id_cat(s TEXT)
RETURNS TABLE(film_id INTEGER)
LANGUAGE 'sql' AS
$$
requete
$$
```

et l'usage 

```{.sql}
CREATE OR REPLACE FUNCTION 
  entid.film_id_cat(s text)
RETURNS TABLE(film_id smallint) AS 
$$
	SELECT fc.film_id 
	FROM 
		film_category fc
  JOIN 
		category ca
  ON (fc.category_id=ca.category_id)
	WHERE 
    ca.name=s ;
$$ LANGUAGE sql ;
```

## Questions

Utilisez votre fonction pour écrire les requêtes suivantes :


@. Quels sont les acteurs qui ont déjà joué dans un film d'horreur (catégorie 'Horror') ?


::: {.content-visible when-profile="solution"}

::: {.callout-tip title="Solution"}

Les solutions sont données en utilisant la fonction suivante


```{.sql}
CREATE OR REPLACE FUNCTION 
  entid.film_id_cat(s category.name%TYPE)
RETURNS TABLE(film_id film.film_id%TYPE) 
AS $$
SELECT fc.film_id 
FROM 
	film_category fc 
JOIN 
	category ca
ON (fc.category_id=ca.category_id)
WHERE 
  ca.name=s ;
$$ LANGUAGE sql;
```

:::

:::


::: {.content-visible when-profile="solution"}

::: {.callout-tip title="Solution"}

Solution uniquement avec des jointures :
 
```{.sql}
SELECT DISTINCT ac.*
FROM 
  actor ac 
JOIN
  film_actor fa  USING (actor_id)
JOIN
  film_id_cat('Horror') USING (film_id);
```
(156 tuples renvoyés).


Solution avec une ETC :

```{.sql}
with actor_with_horror as
( 
	select fa.actor_id
	from film_actor fa
	where fa.film_id in (
		select *
		from film_id_cat('Horror')
	)
)
select distinct ac.*
from actor ac join actor_with_horror using (actor_id);
```

:::

:::

@. Quels sont les acteurs qui n'ont jamais joué dans une comédie (`Comedy`) ? (53 lignes)

::: {.callout-caution}

### {{< fa radiation >}} Attention !  Cette requête ne répond pas à la question :

```{.sql}
SELECT DISTINCT ac.*
FROM actor ac NATURAL JOIN
     (SELECT * FROM film_actor
      WHERE film_id NOT IN
        (SELECT * FROM film_id_cat('Comedy') )
      ) as X;
```

Elle répond à la question : *Quels sont les acteurs qui ont  joué dans un film qui n'est pas une comédie ?*

:::



::: {.content-visible when-profile="solution"}

::: {.callout-tip title="Solution"}

Réponse avec une jointure externe :

```{.sql}
with actor_with_comedy as
(
	select distinct actor_id
	from film_actor fa 
	join film_category fc using (film_id) 
	join category c using (category_id)
	where c.name='Comedy'
)
select distinct last_name, first_name
from actor a left join actor_with_comedy ac using (actor_id)
where ac.actor_id is null
```

Une autre solution avec `EXCEPT`
```{.sql}
with actor_without_comedy as 
(
	(
		select distinct actor_id
		from actor
	)
	except
	(
		select distinct actor_id
		from film_actor
		join film_category using (film_id) 
		join category using (category_id)
	  	WHERE name='Comedy'
	)
)
select last_name, first_name
from actor join actor_without_comedy using (actor_id);
```

Une autre réponse avec une sous-requête est

```{.sql}
SELECT DISTINCT last_name, first_name
FROM 
  actor a1 
WHERE 
  NOT EXISTS 
  (SELECT * 
  FROM 
    film_actor a2
    JOIN film_category using (film_id)
    JOIN category using (category_id) 
  WHERE 
	  a1.actor_id = a2.actor_id 
	  AND name='Comedy' 
  );
```

:::

:::

::: {.content-visible when-profile="solution"}

ou encore (qu'en pensez-vous ?) :

::: {.callout-tip title="Solution"}

```{.sql}
SELECT 
  DISTINCT ac.last_name, ac_first_name
FROM 
  actor ac
WHERE NOT EXISTS
  (SELECT * 
   FROM 
    film_actor fa
   WHERE film_id IN
     (SELECT * 
      FROM 
        entid.film_id_cat('Comedy')
     ) AND 
    fa.actor_id = ac.actor_id
  )  ;
```

:::

:::

::: {.callout-note}
<!--
En calcul relationnel, en considérant  `film_id_cat('Comedy')` comme une relation (ce qui
est cohérent avec la définition de la fonction) cette requête s'exprime


\begin{align*}
  \left\{ a.\texttt{last\_name,}  \right. & a.\texttt{first\_name}
  :
  \texttt{actor}(a) \wedge \\
  & \neg
  \left(\exists \mathrm{fa}\quad \texttt{film\_actor}(\mathrm{fa}) \right.  \wedge  \mathrm{fa}.\texttt{actor\_id}=a.\texttt{actor\_id}  \\
& \left. \left.   \wedge \texttt{film\_id\_cat}(\mathrm{'Comedy'})(\mathrm{fa}.\texttt{film\_id}) \right) \right\}
\end{align*}


Le calcul relationnel traduit presque littéralement la démarche que nous suivons lorsqu'il faut construire le résultat à la main : pour trouver les `actor_id` des acteurs qui n'ont jamais joué dans une comédie,
nous examinons toutes les  valeurs $a$ de `actor_id` présentes dans la table `actor` (ou `film_actor`), et pour chacune de ces valeurs, nous verifions qu'il n'existe pas de tuple de la table `film_actor` où  l'attribut `actor_id` soit égal à $a$ et où l'attribut `film_id` désigne un film qui apparaît dans le résultat de `film_id_cat('Comedy')`.

Nous *décrivons/explicitons* ainsi les propriétés du résultat de la requête *Quels sont les acteurs qui n'ont jamais joué dans une comédie ('Comedy') ?*.

-->

Nous pouvons par exemple d'abord calculer la liste des
`actor_id`  des acteurs qui ont joué dans au  moins une comédie, puis calculer la liste des
`actor_id` des acteurs présents dans la base et faire la différence

<!-- A corriger

, en algèbre relationnelle, cela se résume à 

$$\pi_{\texttt{actor\_id}}\left(\texttt{film\_actor}\right) \setminus \pi_{\texttt{actor\_id}} \left( \texttt{film\_actor} \bowtie\texttt{film\_id\_cat}(\texttt{'Comedy'}) \right)$$
-->
:::


@. Quels sont les acteurs qui ont joué dans un film d'horreur ('Horror') et dans un film pour enfant ('Children')? (129 lignes)

::: {.callout-caution}

Ici l'erreur la plus fréquente consiste à  écrire


```{.sql}
SELECT 
  actor_id 
FROM 
  film_actor AS fa
WHERE 
  fa.film_id IN (
    SELECT * 
    FROM entid.film_id_cat('Children')
  ) AND 
  fa.film_id IN (
    SELECT * 
    FROM entid.film_id_cat('Horror')
  );
```

Le résultat est vide et la requête ne correspond pas à la question posée. 

Elle calcule les `actor_id` des acteurs qui ont dans au moins un film qui relève simultanément des catégories `Horror` et `Children` (ce genre de film est assez rare).

Pour calculer un résultat correct, il faut pour chaque valeur $a$  de `actor_id`
rechercher deux tuples (pas nécessairement distincts) de  `film_actor`, où
l'attribut `actor_id` vaut $a$, et tel que,  dans un cas, `film_id`  désigne
un film pour enfants et, dans l'autre, un film d'horreur. 

<!--
En calcul relationnel, cela donne


\begin{align*}
  \left\{ a.\texttt{last\_name,}  \right. & a.\texttt{first\_name}
  :
  \texttt{actor}(a) \wedge \\
  &
  \left(\exists \mathrm{fa}\quad \texttt{film\_actor}(\mathrm{fa}) \right.  \wedge  \mathrm{fa}.\texttt{actor\_id}=a.\texttt{actor\_id}  \\
& \left.   \wedge \texttt{film\_id\_cat}(\mathrm{'Children'})(\mathrm{fa}.\texttt{film\_id}) \right) \\
&  \left(\exists \mathrm{fa}\quad \texttt{film\_actor}(\mathrm{fa}) \right.  \wedge  \mathrm{fa}.\texttt{actor\_id}=a.\texttt{actor\_id}  \\
& \left. \left.   \wedge \texttt{film\_id\_cat}(\mathrm{'Horror'})(\mathrm{fa}.\texttt{film\_id}) \right)\right\}
\end{align*}
-->

En algèbre relationnelle, cela donne par exemple : 


\begin{align*}
\pi_{\texttt{last\_name,}\texttt{first\_name}} \bigg( &  \texttt{actor} \bowtie  \\
	 & \Big(\pi_{\texttt{actor\_id}} \left( \texttt{film\_actor} \bowtie
	                             \texttt{film\_id\_cat}(\texttt{'Children'}) \right) \bigcap\\
	 & \; \pi_{\texttt{actor\_id}} \left( \texttt{film\_actor} \bowtie
	                             \texttt{film\_id\_cat}(\texttt{'Horror'}) \right) \Big)
	                             \bigg)
\end{align*}


:::

::: {.content-visible when-profile="solution"}

::: {.callout-tip title="Solution"}

En SQL, cela peut s'écrire uniquement avec des jointures :

```{.sql}
SELECT DISTINCT a.first_name, a.last_name
FROM film_id_cat('Horror') fc1
	 JOIN film_actor fa1 USING(film_id)
     JOIN actor a USING(actor_id)
     JOIN film_actor fa2 ON a.actor_id = fa2.actor_id
     JOIN film_id_cat('Children') fc2 ON fa2.film_id = fc2.film_id;
```

Ou bien avec des sous-requêtes :

```{.sql}
SELECT DISTINCT a.first_name, a.last_name  
FROM actor a
WHERE EXISTS (SELECT film_id
              FROM film_actor AS fa1 NATURAL JOIN
                   entid.film_id_cat('Children')
              WHERE  fa1.actor_id = a.actor_id
      ) 
      AND
      EXISTS (SELECT film_id
              FROM film_actor AS fa2 NATURAL JOIN
                   entid.film_id_cat('Horror')
              WHERE  fa2.actor_id = a.actor_id
      ) ;
```

:::

:::


