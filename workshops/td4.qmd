---
title: "TD 4 : SQL"
subtitle: "Aggrégations, Partitions, Fenêtres"
categories: [world, SQL, Aggregation, Fenêtres]
date: "2025-10-17"

format:
  pdf:
    output-file: td4.pdf
    include-in-header:
      - text: "\\lhead{{\\sf  Base de données \\\\ TD 4}}"
  html:
    output-file: td4.html

engine: knitr
---


{{< include _preamble.qmd >}}

[Documentation Postgres](https://www.postgresql.org/docs/current/index.html){target="_blank"}

[Documentation Postgres en Français](https://docs.postgresql.fr){target="_blank"}


@. Écrire une requête qui compte le nombre de langues parlées dans chaque pays.


::: {.content-visible when-profile="solution"}
::: {.callout-tip title="Solution"}
```{.sql}
SELECT 
  countrycode, COUNT(language)
FROM 
  world.countrylanguage
GROUP BY 
  countrycode;
```
:::
:::



@. Écrire une requête qui compte le nombre de langues parlées dans le monde.


::: {.content-visible when-profile="solution"}
::: {.callout-tip title="Solution"}
```{.sql}

SELECT 
  COUNT(DISTINCT language)
FROM 
  world.countrylanguage;
```
:::
:::


@. Écrire une requête qui compte le nombre de langues officielles par pays.


::: {.content-visible when-profile="solution"}
::: {.callout-tip title="Solution"}
Une solution presque bonne :

```{.sql}
SELECT countrycode, COUNT(language) AS nb_lg_official
FROM world.countrylanguage
WHERE isofficial 
GROUP BY countrycode
ORDER BY nb_lg_official, countrycode;
```

Cependant, on perd les pays qui ne possèdent  pas de langue officielle. On va utiliser une jointure extérieure pour les conserver:

```{.sql}
SELECT c.countrycode, c.name_country, COUNT(cl.language) AS nb_lg_official
FROM world.country c LEFT JOIN world.countrylanguage cl
	  ON (c.countrycode = cl.countrycode AND cl.isofficial)
GROUP BY c.countrycode, c.name_country
ORDER BY nb_lg_official, c.countrycode;
```

*NB* : `L.isofficial` doit être dans la condition de jointure et pas dans un `WHERE`pour ne pas perdre les pays qui n'ont pas de langue officielle.
:::
:::




@. Écrire une requête qui renvoie le nombre de langues officielles par pays en utilisant la fonction `SUM`.


::: {.content-visible when-profile="solution"}
::: {.callout-tip title="Solution"}
Presque correct :
```{.sql}
WITH s AS(
    SELECT L.countrycode, sum(CAST (isofficial AS INTEGER)) AS nb_lg_official
    FROM  world.countrylanguage as L
    GROUP BY L.countrycode)
SELECT s.*, c.name_country
FROM world.country c JOIN s USING (countrycode)
ORDER BY s.nb_lg_official, s.countrycode;
```

Mais on a perdu les pays qui n'apparaissent pas dans la table `countrylanguage`. Pour y remédier, il faut faire une jointure gauche et faire un `CASE WHEN` pour gérer les valeurs `NULL`. Ici, les valeurs `NULL` entrent dans le cas par défaut `ELSE`.

```{.sql}
SELECT c.countrycode, c.name_country, SUM(CASE WHEN cl.isofficial THEN 1 ELSE 0 END) AS nb_lg_official
FROM world.country c LEFT JOIN world.countrylanguage cl USING (countrycode)
GROUP BY c.countrycode, c.name_country
ORDER BY nb_lg_official, c.countrycode;
```

Au final, compter en faisant une somme n'est pas la meilleure idée.
:::
:::


@. Écrire une requête qui renvoie la surface de chaque région.



::: {.content-visible when-profile="solution"}
::: {.callout-tip title="Solution"}
```{.sql}
SELECT region, SUM(surfacearea)
FROM world.country
GROUP BY region;
```
:::
:::


@. Écrire une requête qui compte le nombre de francophones dans le monde.


::: {.content-visible when-profile="solution"}
::: {.callout-tip title="Solution"}

```{.sql}
SELECT ROUND(SUM((percentage/100)*population_country))
FROM world.country JOIN world.countrylanguage USING (countrycode)
WHERE language = 'French';
```

:::
:::


@. Combien de personnes vivent dans une capitale européenne ?

::: {.content-visible when-profile="solution"}
::: {.callout-tip title="Solution"}
```{.sql}
SELECT SUM(ci.population)
FROM world.country co 
JOIN world.city ci ON co.capital=ci.id
WHERE co.continent='Europe';
```

:::
:::


@. Quelle est la capitale européenne la moins peuplée ?


::: {.content-visible when-profile="solution"}
::: {.callout-tip title="Solution"}
```{.sql}
WITH r AS (
   SELECT min(population) AS min
   FROM world.country co 
      JOIN world.city ci ON co.capital=ci.id
   WHERE co.continent='Europe' 
)
SELECT ci.name, ci.population 
FROM city ci join r ON ci.population = r.min;
```
:::
:::


@. Quelle est la langue la plus parlée dans le monde ?


::: {.content-visible when-profile="solution"}
::: {.callout-tip title="Solution"}
```{.sql}
WITH r AS 
(
   SELECT language, ROUND(SUM((percentage/100)*population_country)) AS sum
   FROM world.country JOIN world.countrylanguage USING (countrycode)
   GROUP BY language
),
s AS
(
   SELECT MAX(sum) AS max
   FROM r
)
SELECT language, r.sum AS nb_speaker 
FROM r JOIN s ON r.sum = s.max;
```

On peut aussi utiliser un ordre descendant sur le nombre de locuteurs en faisant attention à bien gérer les valeurs nulles possibles. Car celles-ci fausses l'ordre.

Ici, pas de souci car les valeurs nulles sont interdites pour les attributs `country.population_country` et `countrylanguage.percentage`.

```{.sql}
SELECT 
   cl.language, ROUND(SUM((percentage/100)*population_country)) as nb_speaker
FROM 
   world.country co JOIN world.countrylanguage cl USING(countrycode)
GROUP BY cl.language
ORDER BY nb_speaker DESC
LIMIT 1 ;
``` 
:::
:::



@. Écrire une requête qui renvoie le nombre de pays par régime.

::: {.content-visible when-profile="solution"}
::: {.callout-tip title="Solution"}
```{.sql}
SELECT governmentform AS regime, COUNT(countrycode) AS nb
FROM  world.country
GROUP BY governmentform
ORDER BY governmentform ;
```
:::
:::


@. Écrire une requête calculant le nombre de personnes vivant dans des villes de plus d'un million d'habitants.



::: {.content-visible when-profile="solution"}
::: {.callout-tip title="Solution"}
```{.sql}
SELECT 
  SUM(population) AS pop
FROM 
  world.city
WHERE 
  population >= 1000000 ;
```
:::
:::


@. Écrire une requête qui calcule le nombre total de personnes dans le monde qui n'habitent pas une ville listée dans la table `city`.
   Réponse :  (4,649,189,566)

::: {.content-visible when-profile="solution"}
::: {.callout-tip title="Solution"}

```{.sql}
WITH 
  pop_villes AS 
  (
    SELECT 
      SUM(population) AS pop
    FROM 
      world.city
  ),
  pop_totale AS 
  (
    SELECT 
      SUM(population_country) AS pop
    FROM 
      world.country
  )
SELECT 
  (pop_totale.pop - pop_villes.pop) as non_urban_population
FROM 
  pop_totale, pop_villes ;
```
:::
:::


@. Écrire une requête qui compte le nombre moyen de langues parlées par pays dans chaque région.

::: {.content-visible when-profile="solution"}
::: {.callout-tip title="Solution"}
Avec la fonction `AVG()` :
```{.sql}
WITH nb_langues_parlees AS (
   SELECT 
    countrycode, COUNT(language) nb
   FROM  
    world.countrylanguage
   GROUP BY countrycode
)
SELECT 
  co.region, AVG(nb)
FROM 
  world.country co JOIN nb_langues_parlees USING(countrycode)
GROUP BY co.region
ORDER BY co.region;
```

Sinon on faisant le calcul de moyenne "à la main" : 

```{.sql}
WITH nb_langues_parlees AS (
	SELECT 
    countrycode, COUNT(language) nb
	FROM  
    world.countrylanguage
	GROUP BY countrycode
)
SELECT 
  region, SUM(nb)/COUNT(DISTINCT countrycode)
FROM 
  world.country co JOIN nb_langues_parlees USING(countrycode)
GROUP BY region ;
```
Le `DISTINCT` dans `COUNT(DISTINCT countrycode)` est utile en général pour faire un calcul correct de moyenne. Cependant, ici, il est inutile car nous avons fait une jointure sur `countrycode` qui est à valeur unique dans les deux tables jointes.

:::
:::


@. Écrire une requête qui donne la liste des pays ayant deux langues officielles parlées chacune par plus du quart de la population.

   {{< fa hand-point-right >}} Pas besoin d'agrégation à cet endroit là.

::: {.content-visible when-profile='solution'} 
 
::: {.callout-note title="Solution"}

```{.sql}
SELECT 
  cl1.countrycode, cl1.language, cl2.language
FROM 
  countrylanguage AS cl1 
JOIN 
  countrylanguage AS cl2 ON (
    cl1.countrycode=cl2.countrycode AND 
    cl1.language < cl2.language AND
    cl1.isofficial AND cl2.isofficial
  ) 
WHERE cl1.percentage > 25 AND cl2.percentage > 25;
```

::: 
:::


@. Écrire une fonction `plus_peuplee(p_countrycode text)` qui, étant donné le code d'un pays, renvoie le nom de la ville la plus peuplée de ce pays.


::: {.content-visible when-profile='solution'} 
 
::: {.callout-tip title="Solution"}

En remplaçant `monschema` par votre nom de schéma personnel :
```{.sql}
CREATE OR REPLACE monschema.plus_peuplee(p_countrycode text)
RETURNS text 
LANGUAGE sql AS $$
WITH  m AS (
  SELECT 
    MAX(population) AS m_pop
  FROM
    world.city ci
  WHERE 
    ci.countrycode = p_countrycode
)
SELECT 
  ci.name   
FROM 
  world.city ci, m  
WHERE ci.countrycode = p_countrycode
  AND ci.population = m_pop;
$$ ;
-- Utilisation de la fonction
SELECT monschema.plus_peuplee('FRA');
SELECT monschema.plus_peuplee('USA');
```
::: 
:::


@. Écrire une fonction `langues_region(p_continent text)` qui étant donné le nom d'un continent, renvoie le nombre moyen de langues parlées par pays dans chaque région. L'entête de cette fonction doit être : 


```{.sql}
FUNCTION langues_region(p_continent TEXT) 
RETURNS TABLE(region TEXT, nbmoy NUMERIC)
```

::: {.content-visible when-profile='solution'}  
::: {.callout-tip title="Solution"}
En remplaçant `monschema` par votre nom de schéma personnel :

```{.sql}
CREATE OR REPLACE FUNCTION monschema.langues_region(p_continent TEXT)
RETURNS TABLE(region TEXT, nbmoy NUMERIC)
LANGUAGE SQL AS $$
WITH S AS (
  SELECT 
    R.region, cl.countrycode, COUNT(cl.language) AS n_l
  FROM 
    (
      SELECT 
        co.region, co.countrycode
      FROM
        world.country co
      WHERE 
        co.continent = p_continent
    ) AS R
  JOIN 
    world.countrylanguage cl USING (countrycode)
  GROUP BY 
    R.region, cl.countrycode
)
SELECT 
  region, AVG(n_l) AS nbmoy
FROM 
  S
GROUP BY 
  region ;
$$ ;
SELECT * FROM monschema.langues_region('Europe');
SELECT * FROM monschema.langues_region('Asia');
```
::: 
:::


@. Écrire une requête qui liste trois attributs, pour chaque pays où on parle français, ordonné par population croissante :

  - `name_country`,
  - `cumul_loc` qui donne le nombre cumulé de locuteurs du français dans les pays où on parle français, dans l'ordre croissant des populations des pays,
  - `cum_pop` qui donne la population cumulée des pays où on parle français, dans l'ordre croissant des populations des pays. 
    
::: {.callout-tip}

Utilisez une fonction fenêtre (`WINDOW`) sans partition. 

:::

::: {.callout-caution}

Pour trouver les pays où on parle français, utilisez l'expression `language like '%French%'`. Vous remarquerez que dans certains pays, il existe plusieurs variétés de 'French'. Veillez à compter les locuteurs de toutes les formes du Français. 

Que se passe-t-il si un locuteur parle plusieurs formes de Français ?   

:::


::: {.content-visible when-profile="solution"}
::: {.callout-tip title="Solution"}

```{.sql}
WITH f AS (
  SELECT 
    cl.countrycode, SUM(cl.percentage) AS percentage
  FROM 
    world.countrylanguage cl
  WHERE 
    cl.language LIKE '%French%'
   GROUP BY 
    cl.countrycode
)
SELECT 
  co.name_country, 
  SUM(ROUND(f.percentage * co.population_country/100)) OVER w AS cumul_loc,
  SUM(co.population_country) OVER w AS cum_pop
FROM  
  f JOIN world.country co USING(countrycode)
WINDOW w AS (
  ORDER BY co.population_country 
);
```
**Problème** : si une même personne parle plusieurs formes de Français, elle est comptabilisée autant de fois comme locuteur du Français. Mais aucune information dans la table ne permet de distinguer ce cas de figure.


:::
:::


<!--
@. Ecrire une fonction `actor_category(p_nom text, p_prenom text)` qui prend en argument le nom et le prénom d'un acteur (d'une actrice) et renvoie la liste des noms des catégories de films dans lesquels il/elle a joué (schéma : `pagila`).


::: {.content-visible when-profile='solution'} 
::: {.callout-tip title="Solution"}

```{.sql}
CREATE FUNCTION public.actor_category(p_nom text, p_prenom text)
RETURNS text 
LANGUAGE SQL AS 
$$
SELECT 
  string_agg(DISTINCT pc.name, ', ')
FROM 
  (SELECT 
    actor_id
  FROM
    pagila.actor 
  WHERE 
    last_name = p_nom AND 
    first_name = p_prenom
  ) as pa 
JOIN 
  pagila.film_actor as pfa USING(actor_id)
JOIN 
  pagila.film_category as pfc USING(film_id)
JOIN 
  pagila.category as pc USING(category_id) ;
$$ ;
```

```{.sql}
bd_2023-24=# SElECT public.actor_category('LOLLOBRIGIDA', 'JOHNNY') ;
                                               actor_category                                               
------------------------------------------------------------------------------------------------------------
 Action, Animation, Children, Comedy, Documentary, Drama, Games, Horror, Music, New, Sci-Fi, Sports, Travel
(1 row)
```
::: 
:::

::: {.callout-note title="Question"}
  
@. Ecrire une fonction `co_actors(p_nom text, p_prenom text)` qui renvoie les noms et prénoms des acteurs qui jouent dans un film où apparaît un acteur ou une actrice dont le nom et le prénom sont donnés en argument (schéma : `pagila`).

:::

::: {.content-visible when-profile='solution'} 

::: {.callout-tip title="Solution"}

```{.sql}
CREATE OR REPLACE FUNCTION public.co_actors(p_nom text, p_prenom text)
RETURNS TABLE(nom text, prenom text) 
LANGUAGE SQL AS 
$$
SELECT 
  DISTINCT pa2.last_name as nom, pa2.first_name as prenom
FROM 
  (SELECT 
    actor_id
  FROM
    pagila.actor 
  WHERE 
    last_name = p_nom AND 
    first_name = p_prenom
  ) as pa 
JOIN 
  pagila.film_actor as pfa1 USING(actor_id)
JOIN 
  pagila.film_actor as pfa2 ON (
    pfa1.film_id=pfa2.film_id AND 
    pfa1.actor_id<>pfa2.actor_id 
    )
JOIN 
  pagila.actor as pa2 ON (pa2.actor_id=pfa2.actor_id) 
ORDER BY nom, prenom;
$$ ;
```
::: 
 
:::


-->


<!--
# Fonctions d'agrégation

Les fonctions d'*agrégation* permettent d'effectuer des opérations avancées sur les solutions d'une requête (sur une table) comme : compter les lignes, sélectionner le maximum dans une colonne, etc. 

Une des opérations les plus courantes est de compter. `COUNT(col)` permet de compter les résultats d'une requête. 

## Count

Pour compter les pays en Europe, on écrira :

```{.sql}
SELECT COUNT(countrycode)
FROM world.country
WHERE continent='Europe';
```

Cette requête renvoie une table ayant *une* ligne et *une* colonne contenant le nombre de lignes dans le résultat de la requête. 

# GROUP BY

Admettons qu'on veuille compter les pays par continent. On doit alors utiliser la clause `GROUP BY` :

```{.sql}
SELECT 
  continent, COUNT(countrycode)
FROM 
  world.country
GROUP BY 
  continent;
```

Cette requête regroupe les lignes de la table `country` par valeur de la colonne `continent` et pour chaque groupe, compte le nombre de `countrycode` y apparaissant. Lorsque plusieurs lignes sont susceptibles d'avoir la même valeur, on peut compter seulement le nombre d'occurences distinctes avec `COUNT(DISTINCT col)`.

-->

<!--

## Sum, Max, Min, Avg

Une autre fonction importante est la fonction `SUM(col)` qui effectue la somme des valeurs (numériques) d'une colonne :

```{.sql}
SELECT SUM(population_country)
FROM world.country;
```

renvoie la population mondiale. 

On peut de même utiliser `GROUP BY` pour faire des paquets :

```{.sql}
SELECT 
  continent, SUM(population_country)
FROM 
  world.country
GROUP BY continent;
```

renvoie la population de chaque continent. 

On peut même faire des opérations sur la colonne à l'intérieur de `SUM`. Par exemple: `SUM(percentage/100)`.
-->

<!--
# Having

Parfois, on veut filtrer les requêtes en fonction du résultat d'une fonction d'agrégation. 

Par exemple, pour connaître les langues officielles dans plus de 10 pays, on serait tenté d'écrire :

```{.sql}
SELECT 
  language 
FROM 
  world.countrylanguage
WHERE 
  COUNT(countrycode) > 10 AND isofficial 
GROUP BY language;
```


::: {.callout-caution}

Cela ne fonctionne pas. `WHERE` applique une condition sur chaque ligne de la table pour les filtrer, par exemple, garder seulement les langues officielles. Ici, on veut  *ensuite* sélectionner les lignes après avoir regroupé par langue et compté. 

:::

On utilisera alors `HAVING`, après la clause  `GROUP BY`:

```{.sql}
SELECT 
  language -- <5>
FROM 
  world.countrylanguage  -- <1>
WHERE 
  isofficial            -- <2>
GROUP BY language           -- <3>
HAVING 
  COUNT(countrycode) > 10; -- <4>
```
1. La requête concerne la table `world.countrylanguage`,
2. On filtre les lignes qui correspondent à des langues officielles,
3. On groupe/partitionne la table filtrée selon la langue,
4. On ne garde que les groupes comportant au moins 10 tuples,
5. On projette le résultat sur la colonne `language`.
-->